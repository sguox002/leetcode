## leetcode solution

leetcode contest contents
## contest 220
Reformat Phone Number3
Maximum Erasure Value4
Jump Game VI5
Checking Existence of Edge Length Limited Paths6

## contest 219
Count of Matches in Tournament3
Partitioning Into Minimum Number Of Deci-Binary Numbers4
Stone Game VII5
Maximum Height by Stacking Cuboids

## biweek 41
Count the Number of Consistent Strings3
Sum of Absolute Differences in a Sorted Array4
Stone Game VI5
Delivering Boxes from Storage to Ports

## contest 218
Goal Parser Interpretation3
Max Number of K-Sum Pairs4
Concatenation of Consecutive Binary Numbers5
Minimum Incompatibility

#contest 217
Richest Customer Wealth3
Find the Most Competitive Subsequence4
Minimum Moves to Make Array Complementary6
Minimize Deviation in Array

## biweek 40
Maximum Repeating Substring3
Merge In Between Linked Lists4
Design Front Middle Back Queue5
Minimum Number of Removals to Make Mountain Array

## contest 216
Check If Two String Arrays are Equivalent3
Smallest String With A Given Numeric Value4
Ways to Make a Fair Array5
Minimum Initial Energy to Finish Tasks

## contest 215
Design an Ordered Stream3
Determine if Two Strings Are Close4
Minimum Operations to Reduce X to Zero5
Maximize Grid Happiness

## biweek 39
Defuse the Bomb3
Minimum Deletions to Make String Balanced4
Minimum Jumps to Reach Home5
Distribute Repeating Integers

## contest 214
Get Maximum in Generated Array3
Minimum Deletions to Make Character Frequencies Unique4
Sell Diminishing-Valued Colored Balls5
Create Sorted Array through Instructions

## contest 213
Check Array Formation Through Concatenation3
Count Sorted Vowel Strings4
Furthest Building You Can Reach5
Kth Smallest Instructions

## biweek 38
Sort Array by Increasing Frequency3
Widest Vertical Area Between Two Points Containing No Points4
Count Substrings That Differ by One Character5
Number of Ways to Form a Target String Given a Dictionary

## contest 212
Slowest Key3
Arithmetic Subarrays4
Path With Minimum Effort5
Rank Transform of a Matrix

## contest 211
Largest Substring Between Two Equal Characters3
Lexicographically Smallest String After Applying Operations4
Best Team With No Conflicts5
Graph Connectivity With Threshold

## biweek 37
Mean of Array After Removing Some Elements3
Coordinate With Maximum Network Quality4
Number of Sets of K Non-Overlapping Line Segments5
Fancy Sequence

## contest 210
Maximum Nesting Depth of the Parentheses3
Maximal Network Rank4
Split Two Strings to Make Palindrome5
Count Subtrees With Max Distance Between Cities

## contest 209
Special Array With X Elements Greater Than or Equal X3
Even Odd Tree4
Maximum Number of Visible Points5
Minimum One Bit Operations to Make Integers Zero

## biweek 36
Design Parking System3
Alert Using Same Key-Card Three or More Times in a One Hour Period4
Find Valid Matrix Given Row and Column Sums6
Find Servers That Handled Most Number of Requests

## contest 208
Crawler Log Folder3
Maximum Profit of Operating a Centennial Wheel4
Throne Inheritance5
Maximum Number of Achievable Transfer Requests

## contest 207
Rearrange Spaces Between Words3
Split a String Into the Max Number of Unique Substrings4
Maximum Non Negative Product in a Matrix5
Minimum Cost to Connect Two Groups of Points

## biweek 35
Sum of All Odd Length Subarrays3
Maximum Sum Obtained of Any Permutation5
Make Sum Divisible by P5
Strange Printer II

## contest 206
Special Positions in a Binary Matrix3
Count Unhappy Friends4
Min Cost to Connect All Points5
Check If String Is Transformable With Substring Sort Operations

## contest 205
Replace All ?'s to Avoid Consecutive Repeating Characters3
Number of Ways Where Square of Number Is Equal to Product of Two Numbers5
Minimum Deletion Cost to Avoid Repeating Letters5
Remove Max Number of Edges to Keep Graph Fully Traversable

## biweek 34
Matrix Diagonal Sum3
Number of Ways to Split a String4
Shortest Subarray to be Removed to Make Array Sorted5
Count All Possible Routes

## contest 204
1566. Detect Pattern of Length M Repeated K or More Times
one pass using two pointer

1567. Maximum Length of Subarray With Positive Product
using prefix xor and hashmap similar count.

1568. Minimum Number of Days to Disconnect Island
find the critical cell or the bottom right cell (0,1,2)

1569. Number of Ways to Reorder Array to Get Same BST
combinations and dfs. large combination using pascal triangle.

## contest 203

1560. Most visited sector in a circular track
middle rounds has no effect

1561. Max number of coins you can get
you can only choose the 2nd max piles, sort and greedy.

1562. Find latest group of size Max
union-find and hashmap.

1563. Stone game V
dp

## biweek 33
1556. Thousands separater
simple, check remaining

1557. Minimum Number of Vertices to Reach All Nodes
source nodes count

1558. Minimum Numbers of Function Calls to Make Target Array
equivalent to reduce n to 1, odd -1, even /2

1559. Detect Cycles in 2D Grid
dfs avoid go back to parent.

## contest 202
Three Consecutive Odds (array, *)

Minimum Operations to Make Array Equal (greedy, math, **)

Magnetic Force Between Two Balls (binary search, **)

Minimum Number of Days to Eat N Oranges (dp+greedy, bfs ***)

## contest 201
Make The String Great (stack, **)

Find Kth Bit in Nth Binary String (recursive, divide and conquer, ***)

Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (hashmap,interval ***)

Minimum Cost to Cut a Stick (dp, dp[i,j]=min(dp[i,j],dp[i,k]+cost(k,j)) ***)

## biweek 32
Kth Missing Positive Number3
Can Convert String in K Moves4
Minimum Insertions to Balance a Parentheses String5
Find Longest Awesome Substring


## contest 200
1534. Count Good Triplets (array, brutal force **)

1535. Find the Winner of an Array Game (array, greedy, swap the bigger to cur position, ***)

1536. Minimum Swaps to Arrange a Binary Grid (greedy, bubble sort, reduce to 1d, ***)

1537. Get the Maximum Score (greedy, math, choose a or b. ***)

## contest 199
1528 Shuffle string (array, straightforward *)

1529. Bulb Switcher IV	(odd, even, **)

1530 Number of good leaf node pairs (postorder, ***)

1531. String Compression II (dp, compress on the fly, greedy, connect two parts ****)

## biweek 31
Count Odd Numbers in an Interval Range3
Number of Sub-arrays With Odd Sum4
Number of Good Ways to Split a String5
Minimum Number of Increments on Subarrays to Form a Target Array

## contest 198
1518. Water Bottles (simulate, math, **)

1519. Number of Nodes in the Sub-Tree With the Same Label (postorder, ***)

1520. Maximum Number of Non-Overlapping Substrings (greedy, interval merging, ****)

1521. Find a Value of a Mysterious Function Closest to Target (bit and a range. hashset ***)

## contest 197
1512. Number of Good Pairs (array, hashmap, **)

1513. Number of Substrings With Only 1s (ending with current 1, **)

1514. Path with Maximum Probability (from start to end, dp, dijkstra, ****)

1515. Best Position for a Service Centre (numeric algorithm, ***)

## biweek 30
Reformat Date3
Range Sum of Sorted Subarray Sums4
Minimum Difference Between Largest and Smallest Value in Three Moves5
Stone Game IV


## contest 196

1502. Can Make Arithmetic Progression From Sequence (straightfoward, *)

1503. Last Moment Before All Ants Fall Out of a Plank (greedy, **)

1504. Count Submatrices With All Ones (dp, count left, and right ****)
this is directly from count rectangle, count triangles, and count rectangles with invalid cells.

1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (greedy, bubble sort, ***)

## contest 195

1496. Path Crossing (hashmap, **)

1497. Check If Array Pairs Are Divisible by k (hashmap,**)

1498. Number of Subsequences That Satisfy the Given Sum Condition (sort, and 2^l, math, ***)

1499. Max Value of Equation (heap, ****).

## biweek 29

Average Salary Excluding the Minimum and Maximum Salary3
The kth Factor of n4
Longest Subarray of 1's After Deleting One Element5
Parallel Courses II

## contest 194

1486. XOR Operation in an Array (straightforward *)

1487. Making File Names Unique (hashmap, ***)

1488. Avoid Flood in The City (binary search, hash ***)

1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (MST, greedy, ***)

## contest 193
1480. Running sum pf 1d array (prefix sum, *)

1481. Least Number of Unique Integers after K Removals (hashmap,**)

1482. Minimum Number of Days to Make m Bouquets (binary search ***)

1483. Kth Ancestor of a Tree Node (dp, binary lifting, binary represenation ****)

## biweek 28
Final Prices With a Special Discount in a Shop3
Subrectangle Queries4
Find Two Non-overlapping Sub-arrays Each With Target Sum5
Allocate Mailboxes

## contest 192
1470. Shuffle the Array(array, *)

1471. The k Strongest Values in an Array (sort, customize, or two pointer, **)

1472. Design Browser History (array, ***)

1473. Paint House III (top down dp, ****)

## contest 191
1464. Maximum Product of Two Elements in an Array (find max and 2nd max, **)

1465. Max area of a piece of cake after horizontal and vertical cuts (math, interval, **)

1466. Reorder Routes to Make All Paths Lead to the City Zero (dfs, tree traversal ***)

1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (backtrack, ***)

## biweek 27
Make Two Arrays Equal by Reversing Sub-arrays3
Check If a String Contains All Binary Codes of Size K4
Course Schedule IV5
Cherry Pickup II

## contest 190

1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence
array, string match, straightforward, *

1456. Maximum Number of Vowels in a Substring of Given Length
sliding window fixed size, **

1457. Pseudo-Palindromic Paths in a Binary Tree
root to leaf: permutation of the path is palindrome. dfs. **

1458. Max Dot Product of Two Subsequences
dp, two dimensional grid path. ***

## contest 189

1450. Number of Students Doing Homework at a Given Time
intervals or brutal force searching **

1451. Rearrange Words in a Sentence
stable sort, **

1452. People Whose List of Favorite Companies Is Not a Subset of Another List
using bitmask, hashmap **

1453. Maximum Number of Darts Inside of a Circular Dartboard
math, use two point line on the circle to see number of points inside it. ***

## biweek 26
Consecutive Characters3
Simplified Fractions4
Count Good Nodes in Binary Tree5
Form Largest Integer With Digits That Add up to Target

## contest 188

1441. Build an Array With Stack Operations
simulate the stack *

1442. Count Triplets That Can Form Two Arrays of Equal XOR
xor property, hashmap, ****

1443. Minimum Time to Collect All Apples in a Tree
tree traversal, postorder. ***

1444. Number of Ways of Cutting a Pizza
dp, precaluclate the suffix sum. top down or bottom up. ***


## contest 187

1436. Destination City
one income one outgoing, **

1437. Check If All 1's Are at Least Length K Places Away
check cur and previous 1's position difference or sliding window counting **

1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
max and min using stack. ****

1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows
prioriy_queue, dijkstra similar, *****

## biweek 25
Kids With the Greatest Number of Candies3
Max Difference You Can Get From Changing an Integer4
Check If a String Can Break Another String5
Number of Ways to Wear Different Hats to Each Other

## contest 186

1422. Maximum Score After Splitting a String
left 0s and right 1s, two pointer. **

1423. Maximum Points You Can Obtain from Cards	
equiv sliding window minimum. ***

1424. Diagonal Traverse II
hashmap sort by r+c. ***
bfs: layer=r+c.

1425. Constrained Subsequence Sum
heap + dp, (sliding window max) ****

# solutions

## biweek 1

1064. Fixed Point
<em>
Given an array A of distinct integers sorted in ascending order, return the smallest index i that satisfies A[i] == i.  Return -1 if no such i exists.
</em>

- O(N) straightforward
- binary search O(logn)

```cpp
    int fixedPoint(vector<int>& A) {
        int l=0,r=A.size()-1;
        while(l<=r){
            int m=l+(r-l)/2;
            if(A[m]-m==0)  return m;
            if(A[m]<m) l=m+1;
            else r=m-1;
        }
        return -1;
    }
```

1065. Index Pairs of a String
<em>
Given a text string and words (a list of strings), return all index pairs [i, j] so that the substring text[i]...text[j] is in the list of words.	
</em>

brutal force using hashmap

```cpp
    struct comp{
      bool operator()(vector<int> a,vector<int> b) {
          return a[0]<b[0] || (a[0]==b[0] && a[1]<b[1]);
      }
    };
    vector<vector<int>> indexPairs(string text, vector<string>& words) {
        vector<vector<int>> ans;
        unordered_set<string> ms(words.begin(),words.end());
        for(int i=0;i<text.size();i++){
            for(int j=i;j<text.size();j++){
                if(ms.count(text.substr(i,j-i+1)))
                    ans.push_back({i,j});
            }
        }
        sort(ans.begin(),ans.end(),comp());
        return ans;
    }
```

1066. Campus Bikes II
<em>
On a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid.

We assign one unique bike to each worker so that the sum of the Manhattan distances between each worker and their assigned bike is minimized.

The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.

Return the minimum possible sum of Manhattan distances between each worker and their assigned bike.
</em>

bitmask dp.
```cpp
    int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
        int m=workers.size(),n=bikes.size();
        vector<vector<int>> dist(m,vector<int>(n));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++)
                dist[i][j]=abs(workers[i][0]-bikes[j][0])+abs(workers[i][1]-bikes[j][1]);
        }
        //seeking a min path sum in the matrix
        vector<vector<int>> dp(m+1,vector<int>(1<<n,INT_MAX));
        dp[0][0]=0;
        int ans=INT_MAX;
        for(int i=1;i<=m;i++){
            for(int s=1;s<(1<<n);s++){
                for(int j=0;j<n;j++){
                    if(s&(1<<j)==0) continue;
                    int prev=s^(1<<j);
                    if(dp[i-1][prev]<INT_MAX)
                        dp[i][s]=min(dp[i][s],dp[i-1][prev]+dist[i-1][j]);
                    if(i==m && nbits(s)==m) ans=min(ans,dp[i][s]);
                }
            }
        }
        return ans;
    }
    int nbits(int n){
        int ans=0;
        while(n){
            ans+=n&1;
            n>>=1;
        }
        return ans;
    }
```

1067. Digit Count in Range
<em>
Given an integer d between 0 and 9, and two positive integers low and high as lower and upper bounds, respectively. Return the number of times that d occurs as a digit in all integers between low and high, including the bounds low and high.
 

Example 1:

Input: d = 1, low = 1, high = 13
Output: 6
Explanation: 
The digit d=1 occurs 6 times in 1,10,11,12,13. Note that the digit d=1 occurs twice in the number 11.
Example 2:

Input: d = 3, low = 100, high = 250
Output: 35
Explanation: 
The digit d=3 occurs 35 times in 103,113,123,130,131,...,238,239,243.
 

Note:

0 <= d <= 9
1 <= low <= high <= 2×10^8
</em>

- equivalent to count(d, high)-count(d,low-1)
- count(d,n) based on 233. Number of Digit One (logN)


```cpp
    int digitsCount(int d, int low, int high) {
        return count(d, high) - count(d, low - 1);
    }

	int count(int digit, int n) {
		int cnt = 0;
		if(digit != 0)
		{
			for(int num = 1; num <= n; num *= 10)
			{
				int divisor = num * 10;
				cnt += (n / divisor) * num;
				cnt += min(max(n % divisor - digit * num + 1, 0), num);
			}
		}
		else
		{
			for(int num = 1; num <= n; num *= 10)
			{
				int divisor = num * 10;
				cnt += (n / divisor) * num;
				if(n / divisor > 0)
				{
					cnt -= num;
					cnt += min(n % divisor + 1, num);
				}
			}
		}
		return cnt;
	}
```	
	

	
## biweek 2.
### 1085. Sum of Digits in the Minimum Number (*)
trivial

### 1086. high five
<em>Given a list of scores of different students, return the average score of each student's top five scores in the order of each student's id.

Each entry items[i] has items[i][0] the student's id, and items[i][1] the student's score.  The average score is calculated using integer division.
</em>
- less than 5 scores 
- same scores
can use multiset or pq.
map<int,pq<int>>

```cpp
	vector<vector<int>> highFive(vector<vector<int>>& items) {	
		vector<vector<int>> ans;
		map<int,priority_queue<int>> mp;
		for(auto t: items){
			mp[t[0]].push(t[1]);
		}
		for(auto t: mp){
			int sum=0,cnt=0;
			while(t.second.size() && cnt<5){
				sum+=t.second.top();
				t.second.pop();
                cnt++;
			}
			ans.push_back({t.first,sum/cnt});
		}
		return ans;
	}
```

### 1087. Brace Expansion
<em>A string S represents a list of words.

Each letter in the word has 1 or more options.  If there is one option, the letter is represented as is.  If there is more than one option, then curly braces delimit the options.  For example, "{a,b,c}" represents options ["a", "b", "c"].

For example, "{a,b,c}d{e,f}" represents the list ["ade", "adf", "bde", "bdf", "cde", "cdf"].

Return all words that can be formed in this manner, in lexicographical order.

Example 1:

Input: "{a,b}c{d,e}f"
Output: ["acdf","acef","bcdf","bcef"]
Example 2:

Input: "abcd"
Output: ["abcd"]
</em>

Intuition: backtracking.
- build the adjacent matrix from the string.
- backtracking or dfs.

```cpp
    vector<string> permute(string S) {
        vector<vector<char>> adj;
        vector<char> t;
        bool inbrack=0;
        for(char c: S){
            if(c!='{' && c!='}') {
                if(!inbrack) adj.push_back({c});
                else if(c!=',') t.push_back(c);
            }
            else if(c=='{'){
                inbrack=1;
            }
            else{
                if(!t.empty()) adj.push_back(t);
                t.clear();
                inbrack=0;
            }
        }
        vector<string> ans;
        dfs(adj,0,"",ans);
        sort(ans.begin(),ans.end());
        return ans;
    }
    
    void dfs(vector<vector<char>>& adj,int start,string t,vector<string>& ans){
        if(start==adj.size()) {ans.push_back(t);return;}

		for(int j=0;j<adj[start].size();j++)
		{
			dfs(adj,start+1,t+adj[start][j],ans);
		}
    }
```	

### 1088. Confusing Number II
<em>We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid.

A confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid.(Note that the rotated number can be greater than the original number.)

Given a positive integer N, return the number of confusing numbers between 1 and N inclusive.

Example 1:

Input: 20
Output: 6
Explanation: 
The confusing numbers are [6,9,10,16,18,19].
6 converts to 9.
9 converts to 6.
10 converts to 01 which is just 1.
16 converts to 91.
18 converts to 81.
19 converts to 61.
</em>

Intuition: 

0-0, 1-1, 8-8, 9-6, 6-9 and final form need reverse.
we can check all combination of 01689, each digit can appear 0 to m times at different locations. O(n2^m)
backtracking solution:
```cpp
    int confusingNumberII(int N) {
        int total=0;
        dfs(N,0,0,0,0,total);
        return total;
    }   
    void dfs(int n,int start,int j,long t,long rt,int &ans){
        vector<int> digits={0,1,6,8,9},rdigits={0,1,9,8,6};
        if(t>n) return;
        if(t<=n && t!=rt) {ans++;}
        for(int i=0;i<5;i++){ //can choose multiple times
            if(j==0 && i==0) continue;
            dfs(n,i,j+1,t*10+digits[i],rt+rdigits[i]*pow(10,j),ans);
        }
    }
```
this will try a lot of invalid combinations. and the complexity is high.

Optimization:
we can use the fact that:
all numbers consist of 01689 only minus those symmetric numbers (strobogrammatric numbers)
so it reduces to two other questions:
- find the total number of 01689 only numbers (this is a combination problem)
for example 123: 
0xx: 5x5
10x: 5
11x: 5
total 25+10-1=34
- find the total number of strobogrammatic numbers (this is much easier, can use backtrack.)
## biweek 3
### 1099. Two sum less than K (***)
<em>Given an array A of integers and integer K, return the maximum S such that there exists i < j with A[i] + A[j] = S and S < K. If no i, j exist satisfying this equation, return -1.</em>
idea:

using hashmap with binary search
```cpp
    int twoSumLessThanK(vector<int>& A, int K) {
        set<int> ms;
        
        int ans=INT_MIN;
        for(int i: A){
            auto it=ms.lower_bound(K-i);
            if(it!=ms.begin()) ans=max(ans,i+*(--it));
            ms.insert(i);
        }
        return ans==INT_MIN?-1:ans;
    }
```	
### 1100. Find k-length substrings with no repeated characters
Given a string S, return the number of substrings of length K with no repeated characters.
idea:

sliding window with hashmap
```cpp
    int numKLenSubstrNoRepeats(string S, int K) {
        //sliding window with hashmap
        unordered_map<char,int> mp;
        int ans=0;
        for(int i=0;i<S.size();i++){
            if(i<K) mp[S[i]]++;
            else{
                mp[S[i]]++;
                mp[S[i-K]]--;
                if(mp[S[i-K]]==0) mp.erase(S[i-K]);
           }
            if(mp.size()==K) ans++;
        }
        return ans;
    }
```


### 1101. The earliest moment when everyone become friends (**)
simple: union-find and get the time when the number of union is 1.

### 1102. Path with max min value.
<em>Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].

The score of a path is the minimum value in that path.  For example, the value of the path 8 →  4 →  5 →  9 is 4.

A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south).</em>

Idea:
convert to binary search problem. set all <mid value to be non-passable and find the value (last connection).
using bfs to check if connected.

```cpp
    int maximumMinimumPath(vector<vector<int>>& A) {
        int mn=INT_MAX,mx=INT_MIN;
        for(auto t: A){
            for(int i: t) mn=min(i,mn),mx=max(mx,i);
        }
        //binary search to see if it connects
        int l=mn,r=mx*2;
        while(l+1<r){
            int mid=l+(r-l)/2;
            if(connected(A,mid)) l=mid;
            else r=mid;
            //cout<<l<<" "<<r<<endl;
        }
        return l;
    }
    bool connected(vector<vector<int>>& A,int v){
        int m=A.size(),n=A[0].size();
        if(v>min(A[0][0],A[m-1][n-1])) return 0;
        queue<int> q;
        vector<vector<bool>> visited(m,vector<bool>(n));
        q.push(0);visited[0][0]=1;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        while(q.size()){
            int sz=q.size();
            while(sz--){
                int t=q.front();
                q.pop();
                int x=t/n,y=t%n;
                if(x==m-1 && y==n-1) return 1;
                for(int i=0;i<4;i++){
                    int x0=x+dir[i][0],y0=y+dir[i][1];
                    if(x0<0||y0<0||x0>=m||y0>=n||visited[x0][y0]||A[x0][y0]<v) continue;
                    visited[x0][y0]=1;
                    q.push(x0*n+y0);
                }
            }
        }
        return 0;
    }
```	
## biweek 4
### 1118. Number of Days in a Month (**)
simply check if it is a lunar year

a lunar year: divisible by 4, and if divisible by 100 and 400

### 1119. Remove Vowels from a String (*)
simple

### 1120. Maximum Average Subtree (***)
idea: the average of a subtree requires the sum and num of nodes. traversal and get the two, calculate the average and max average on the fly.
```cpp
    double maximumAverageSubtree(TreeNode* root) {
        double ans=0;
        int num=0;
        dfs(root,num,ans);
        return ans;
    }
    pair<int,int> dfs(TreeNode* root,int num,double& ans){
        if(!root) return {0,0};
        auto left=dfs(root->left,num,ans);
        auto right=dfs(root->right,num,ans);
        num=1+left.second+right.second;
        int sum=(left.first+right.first+root->val);
        double leftavg=left.first*1.0/left.second;
        double rightavg=right.first*1.0/right.second;
        double curr=sum*1.0/num;
        ans=max({ans,leftavg,rightavg,curr});
        return {sum,num};
    }
```	

### 1121. Divide Array Into Increasing Sequences (***)
<em>Problem: 

Given a non-decreasing array of positive integers nums and an integer K, find out if this array can be divided into one or more disjoint increasing subsequences of length at least K.
</em>
Idea:

hashmap to get the histogram. The most frequent one determines at least how many groups we will have.
- maxfreq*K<n no solution
- maxfreq=1 only one
- greedy: we need use the max freq and reduce by 1, stop when all same maxfreq is reduced and cnt>=k.
- using a pq to reduce the maxfreq by 1 and then put back
```cpp
    struct comp{
        bool operator()(pair<int,int> a,pair<int,int> b){
            return a.second<b.second || (a.second==b.second && a.first<b.first);
        }
    };
    bool canDivideIntoSubsequences(vector<int>& nums, int K) {
        int n=nums.size();
        map<int,int> mp;
        int maxdup=0;
        for(int i: nums) {mp[i]++;maxdup=max(maxdup,mp[i]);}
        if(maxdup*K>n) return 0;
        if(maxdup==1) return 1;
        //we need to divide the array into at least maxdup parts
        //we first need to take one from the most frequent one until the top
        priority_queue<pair<int,int>,vector<pair<int,int>>,comp> pq(mp.begin(),mp.end());
        while(pq.size()){
            auto p=pq.top();
            int maxfreq=p.second;
            int cnt=0;
            vector<pair<int,int>> vp;
            while(pq.size() && (cnt<K || pq.top().second==maxfreq)){ //same freq shall be used all
                if(pq.top().second>1)
                    vp.push_back({pq.top().first,pq.top().second-1});
                //cout<<pq.top().first<<" ";
                cnt++;
                pq.pop();
            }
            if(cnt<K) return 0;
            for(auto t: vp) pq.push(t);
        }
        return 1;
    }
```	
## biweek 5
### 1133. Largest Unique Number (*)
heap map..

### 1134. Armstrong number (*)
sum(digit^k)=N

### 1135. connecting cities with min cost (***)
min spanning tree combining union find and greedy
```cpp
    vector<int> parent;
    int sz;
    int minimumCost(int N, vector<vector<int>>& connections) {
        //min spanning tree greedy or union-find
        //first need make sure they are in one set.
        parent.resize(N);
        sz=N;
        for(int i=0;i<N;i++) parent[i]=i;
        sort(connections.begin(),connections.end(),[](vector<int>& a,vector<int>& b){
            return a[2]<b[2];
        });
        int ans=0;
        for(auto t: connections){
            int pi=findp(t[0]-1),pj=findp(t[1]-1);
            if(pi!=pj){
                ans+=t[2];
                parent[pi]=pj;
                sz--;
            }
        }
        return sz==1?ans:-1;
    }
    int findp(int i){
        while(i!=parent[i]){
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
```

### 1136. Parallel courses (***)
bfs source nodes in a graph. (source nodes has no incoming edges).

```cpp
    int minimumSemesters(int N, vector<vector<int>>& relations) {
        vector<unordered_set<int>> adj(N);
        for(auto r: relations){
            adj[r[1]-1].insert(r[0]-1); //incoming edges
        }
        queue<int> q;
        vector<bool> v(N);
        add_source(adj,q,v);
        int step=0;
        while(q.size()){
            int sz=q.size();
            unordered_set<int> nodes;
            while(sz--){
                int t=q.front();
                q.pop();
                for(auto& vn: adj){
                    if(vn.count(t)) vn.erase(t);
                }
            }
            add_source(adj,q,v);
            step++;
        }
        int res=accumulate(v.begin(),v.end(),0);
        
        return res==N?step:-1;
    }
    void add_source(vector<unordered_set<int>>& adj,queue<int>& q,vector<bool>& v){
        for(int i=0;i<adj.size();i++){
            if(adj[i].size()==0 && !v[i]) {
                q.push(i);
                v[i]=1;
            }
        }
    }
```
## biweek 7
### 1165. Single-Row Keyboard
<em>Problem:

There is a special keyboard with all keys in a single row.

Given a string keyboard of length 26 indicating the layout of the keyboard (indexed from 0 to 25), initially your finger is at index 0. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index i to index j is |i - j|.

You want to type a string word. Write a function to calculate how much time it takes to type it with one finger.

Example 1:

Input: keyboard = "abcdefghijklmnopqrstuvwxyz", word = "cba"
Output: 4
Explanation: The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.
Total time = 2 + 1 + 1 = 4. </em>
idea: straightforward.

### 1166. Design File System
<em>Problem:

You are asked to design a file system which provides two functions:

createPath(path, value): Creates a new path and associates a value to it if possible and returns True. Returns False if the path already exists or its parent path doesn't exist.
get(path): Returns the value associated with a path or returns -1 if the path doesn't exist.
The format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters. For example, /leetcode and /leetcode/problems are valid paths while an empty string and / are not.

Implement the two functions.

Please refer to the examples for clarifications.</em>
Idea:

File system is tree structure, we can use hashmap for it.
```cpp
    unordered_map<string,int> mp;
    FileSystem() {
        
    }
    
    bool create(string path, int value) {
        if(mp.count(path)) return 0;
        int ind=1,next;
        while((next=path.find_first_of('/',ind))!=string::npos){
            if(mp.count(path.substr(0,next))==0) return 0;
            ind=next+1;
        }
        mp[path]=value;
        return 1;
    }
    
    int get(string path) {
        if(mp.count(path)) return mp[path];
        return -1;
    }
```
- note using stringstream to analyze the path need be careful. we need reconstruct the path.

### 1167. Minimum Cost to Connect Sticks
<em>
You have some sticks with positive integer lengths.

You can connect any two sticks of lengths X and Y into one stick by paying a cost of X + Y.  You perform this action until there is one stick remaining.

Return the minimum cost of connecting all the given sticks into one stick in this way.

Example 1:

Input: sticks = [2,4,3]
Output: 14	
</em>

this problem is very similar to huffman algorithm the worker split problem.
the idea: sort the input and arrange as the tree leaf, and combine to a parent (x+y) and parent combine with next leaf.
[1,8,3,5]==>[1,3,5,8]--> 4+9+17=30

     17
     /\
    9  \
   /\   \
  4  \   \
 /\   \   \
1  3   5   8
```cpp
    int connectSticks(vector<int>& sticks) {
        //previous is added again into sum
        //greedy: always add the two min
        priority_queue<int,vector<int>,greater<int>> pq(sticks.begin(),sticks.end());
        int ans=0;
        while(pq.size()>1){
            int i=pq.top();
            pq.pop();
            int j=pq.top();
            pq.pop();
            pq.push(i+j);
            ans+=i+j;
        }
        return ans;
    }
```

### 1168. Optimize Water Distribution in a Village
<em>Problem:

There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.

For each house i, we can either build a well inside it directly with cost wells[i], or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes, where each pipes[i] = [house1, house2, cost] represents the cost to connect house1 and house2 together using a pipe. Connections are bidirectional.

Find the minimum total cost to supply water to all houses.	
</em>
Idea: consider drilling wells a cost to a common node. and then problem is simplified.
from the edges find the connected graph--> minimum spanning tree.
we can use union-find and greedy to get the MST.
greedy: try the shortest edge first.
```cpp
    vector<int> parent;
    struct comp{
        bool operator()(vector<int>& a,vector<int>& b){
            return a[2]<b[2];
        }
    };
    int minCostToSupplyWater(int n, vector<int>& wells, vector<vector<int>>& pipes) {
        //union find
        parent.resize(n+1);
        for(int i=0;i<=n;i++) parent[i]=i;
        for(int i=0;i<n;i++) pipes.push_back({0,i+1,wells[i]});
        sort(pipes.begin(),pipes.end(),comp()); //sort by cost
        //now the problem is to get the min sum visiting all nodes
        //greedy: use the smallest pipe to connect two unions
        int ans=0;
        for(int i=0;n>0;i++){
            int pi=find_parent(pipes[i][0]),pj=find_parent(pipes[i][1]);
            if(pi!=pj) //two different set
            {
                ans+=pipes[i][2];
                if(pi<pj) parent[pj]=pi;
                else parent[pi]=pj;
                n--; //reduce 1 set;
            }
        }
        return ans;
    }
    int find_parent(int i){
        while(i!=parent[i]) i=parent[i];
        return i;
    }
```
	

## biweek 8
### 1180. Count Substrings with Only One Distinct Letter (***)
<em>Problem: Given a string S, return the number of substrings that have only one distinct letter.</em>
idea: find the same char region i,j and the number of subarray is len*(len+1) len=j-i;
two pointers.
### 1181. Before and After Puzzle (***)
<em>Problem:

Given a list of phrases, generate a list of Before and After puzzles.

A phrase is a string that consists of lowercase English letters and spaces only. No space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase.

Before and After puzzles are phrases that are formed by merging two phrases where the last word of the first phrase is the same as the first word of the second phrase.

Return the Before and After puzzles that can be formed by every two phrases phrases[i] and phrases[j] where i != j. Note that the order of matching two phrases matters, we want to consider both orders.

You should return a list of distinct strings sorted lexicographically.
</em>
idea:

brutal force:
- check phase[i] and phase[j] to see if they match the condition.
- using stringstream
- store in a set or sort.

### 1182. Shortest Distance to Target Color (***)
<em>Problem:

You are given an array colors, in which there are three colors: 1, 2 and 3.

You are also given some queries. Each query consists of two integers i and c, return the shortest distance between the given index i and the target color c. If there is no solution return -1.


Example 1:

Input: colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]
Output: [3,0,3]
Explanation: 
The nearest 3 from index 1 is at index 4 (3 steps away).
The nearest 2 from index 2 is at index 2 itself (0 steps away).
The nearest 1 from index 6 is at index 3 (3 steps away).
</em>
idea:
1: [0,1,3]
2: [2,5,6]
3: [4,7,8]
given index and color: binary search the closest in the target color array for the given index.
find the upper_bound and then we get [idx-1,idx] to check which is closer.

### 1183. Maximum Number of Ones (****)
<em>Problem:

Consider a matrix M with dimensions width * height, such that every cell has value 0 or 1, and any square sub-matrix of M of size sideLength * sideLength has at most maxOnes ones.

Return the maximum possible number of ones that the matrix M can have.
</em>

idea:
greedy approach: fill the squares with 1s. the out boundary squares shall not fill if possible.

If we create the first square matrix, the big matrix will just be the copies of this one. (translation copies)
The value of each location in the square matrix will appear at multiple locations in the big matrix, count them.
Then assign the ones in the square matrix with more occurances with 1.

```cpp
    int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {
        //greedy: calculate the number of show times of each point in square
        vector<int> cnt;
        for(int i=0;i<sideLength;i++){
            for(int j=0;j<sideLength;j++){
                int cx=(width-i-1)/sideLength+1;
                int cy=(height-j-1)/sideLength+1;
                cnt.push_back(cx*cy);
            }
        }
        sort(cnt.begin(),cnt.end(),greater<int>());
        int ans=0;
        for(int i=0;i<maxOnes;i++) ans+=cnt[i];
        return ans;
    }
```	
- it basically calculate number of appearance of the points in the square shown in the rectangle.
for example [0,0] can be translated horizontally or veritcally.
we sort it according to its number and fill them first.
- we can also use a min heap to pop non-needed elements.
see other O(1) solutions in discussion on the site.
## biweek 9
### 1196. How Many Apples Can You Put into the Basket (*)
<em>Problem:

You have some apples, where arr[i] is the weight of the i-th apple.  You also have a basket that can carry up to 5000 units of weight.

Return the maximum number of apples you can put in the basket.
</em>
idea:

greedy, from light to heavy, prefix sum.

### 1197. Minimum Knight Moves (****)
<em>Problem:

In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].

A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.

Return the minimum number of steps needed to move the knight to the square [x, y].  It is guaranteed the answer exists.
|x|+|y|<300.
</em>

Approach:
- intuition is bfs for shortest move.
- any position can be limited in first quarter.
- bfs will grow substantially if layer number is large.
The critical point for this problem is limit the coordinate in 1st quarter.
```cpp
    int minKnightMoves(int tx, int ty)
    {
        tx = abs(tx), ty = abs(ty);
        int n = 400;
        vector<vector<int>> mat(n, vector<int>(n,-1));

        int dx[] = {-2, -2, -1, -1,  1, 1,  2, 2};
        int dy[] = {-1,  1, -2,  2, -2, 2, -1, 1};

        int row = 0, col = 0, x, y;

        queue<pair<int, int>> q;

        mat[row][col] = 0;
        q.push(make_pair(row,col));

        while(!q.empty())
        {
            if(mat[tx][ty] != -1)
                return mat[tx][ty];

            row = q.front().first;
            col = q.front().second;
            q.pop();

            for(int i = 0; i < 8; i++)
            {
                int x = abs(row + dx[i]);//limit it in 1st quarter.
                int y = abs(col + dy[i]);

                if(x >= 0 and y >= 0 and x < n and y < n and mat[x][y] == -1)
                {
                    mat[x][y] = 1 + mat[row][col];
                    q.push(make_pair(x,y));
                }
            }
        } 
        return mat[tx][ty];
    }
```	

### 1198. Find Smallest Common Element in All Rows (**)
<em>Problem:

Given a matrix mat where every row is sorted in increasing order, return the smallest common element in all rows.

If there is no common element, return -1.
</em>
idea:

- this is so similar to sorted list merge using k pointers with PQ. O(mn)
- using first row number and binary search in other rows. O(mnlog(m))
- count using hashmap.

### 1199. Minimum Time to Build Blocks
<em>Problem:

You are given a list of blocks, where blocks[i] = t means that the i-th block needs t units of time to be built. A block can only be built by exactly one worker.

A worker can either split into two workers (number of workers increases by one) or build a block then go home. Both decisions cost some time.

The time cost of spliting one worker into two workers is given as an integer split. Note that if two workers split at the same time, they split in parallel so the cost would be split.

Output the minimum time needed to build all blocks.

Initially, there is only one worker.
blocks = [1,2,3], split = 1
Split 1 worker into 2, then assign the first worker to the last block and split the second worker into 2.
Then, use the two unassigned workers to build the first two blocks.
The cost is 1 + max(3, 1 + max(1, 2)) = 4.

</em>
Analysis:

- n jobs need split n workers, and one worker can split into two workers.
- parallel work: the time is the max.
- assign worker to block matters to the total time.
- apparently, worker split and assign the longest job, the other guy split and assign him the longest job. seems a greedy approach works. above observation is incorrect, each guy has option to do work or split again, this makes it a binary tree. The leaf node is the time. each branch is the time to finish the job. and the answer is the max of all the branches.
- We can model this entire question as a binary tree that we need to construct with a minimum max depth cost. Each of the blocks is a leaf node, with a cost of its face value. And then each inner node will be of cost split. nodes that are sitting at the same level represent work that is done in parallel. We know there will be len(blocks) - 1 of these inner nodes, so the question now is how can we construct the tree such that it has the minimum depth.
- Huffman is used to build a tree with minimum total weighted path. we can choose either split or not split. This is the same as choosing 0 or 1 in Huffman code. Initially, the optimal tree can be built by using a huffman coding way. Then combine the least two nodes. After that, rebuild the huffman tree.
- thus we get the algorithm: build a min heap and pop the top 2 and add split to the larger one, and put it back until there is one left. This is called Huffman algorithm.
- this is reverse thinking: look each num in blocks as leaf, and merge these leaves with cost "split" until get one root.
for example [1,2,3] with split=1
first leaf [1,2,3]
the [1,2] merge with split, got max 3
3 merge with 3 with split, got 4.

```cpp
    int minBuildTime(vector<int>& blocks, int split) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for(int num: blocks) {
            pq.push(num);
        }
        while (pq.size() > 1) {
            int a = pq.top(); pq.pop();
            int b = pq.top(); pq.pop();
            pq.push(b+split);
        }
        return pq.top();
    }
```
## biweek 10
### 1213. Intersection of Three Sorted Arrays (***)
*Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays.*

idea: this can be expanded to a matrix. using k pointers. just like merge sort.
```cpp
    vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) {
        int i=0,j=0,k=0;
        vector<int> ans;
        while(i<arr1.size()&&j<arr2.size()&&k<arr3.size()){
            if(arr1[i]==arr2[j] && arr2[j]==arr3[k])
                ans.push_back(arr1[i]),i++,j++,k++;
            else if(arr1[i]<arr2[j]) i++;
            else if(arr2[j]<arr3[k]) j++;
            else k++;
        }
        return ans;
    }
```	
### 1214. Two Sum BSTs (**)
*Problem: Given two binary search trees, return True if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer target.*

idea: traverse bst1 and store in hashset, and then traverse tree 2 and do the find.

### 1215. Stepping Numbers (***)
* Problem: A Stepping Number is an integer such that all of its adjacent digits have an absolute difference of exactly 1. For example, 321 is a Stepping Number while 421 is not.

Given two integers low and high, find and return a sorted list of all the Stepping Numbers in the range [low, high] inclusive.*

idea: typical backtracking, but need make sure 0 is exception for leading 0. Also when we add a digit, int will overflow so use long.
```cpp
    vector<int> countSteppingNumbers(int low, int high) {
        vector<int> res;
        if(low == 0) res.push_back(0);
        for(int i = 1; i < 10; i++){
            helper(low, high, i, res);
        }
        sort(res.begin(), res.end());
        return res;
    }
    /* We use long int so that we do not have to use overflow check for cur value*/
    void helper(int low, int high, long int cur, vector<int> &res){
        if(cur > high) return;
        if(cur >= low) res.push_back(cur);
        
        int last = cur%10;
        long int next = cur*10+last+1;
        long int prev = cur*10+last-1;
        
        if(last != 0) helper(low, high, prev, res);
        if(last != 9) helper(low, high, next, res);
    }
```
- use long for intermediate
- deal with 0
	
### 1216. Valid Palindrome III
*Problem: Given a string s and an integer k, find out if the given string is a K-Palindrome or not.

A string is K-Palindrome if it can be transformed into a palindrome by removing at most k characters from it.*

idea: equiv to longest common subsequence of s and reversed s. That's the critical point.

```cpp
    bool isValidPalindrome(string s, int k) {
        //bfs? edit distance? dp?
        //find longest palidrome subsequences, dp
        string rs=s;
        reverse(rs.begin(),rs.end());
        int n=s.size();
        vector<vector<int>> dp(n+1,vector<int>(n+1));
         for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(s[i-1]==rs[j-1])
                    dp[i][j]=dp[i-1][j-1]+1;
                else
                    dp[i][j]=max({dp[i-1][j],dp[i][j-1]});
            }
        } 
        return dp[n][n]+k>=n;
    }
```	
## biweek contest 14
### 1271. Hexspeak
convert to hex if it only contains 1,0 ABCDEF
simple
### 1272. Remove Interval	(***)
O(N) one pass scan
- interval non-overlap
- interval overlap with the given interval.

```cpp
    vector<vector<int>> removeInterval(vector<vector<int>>& intervals, vector<int>& toBeRemoved) {
        vector<vector<int>> res;
        auto start = toBeRemoved[0], end = toBeRemoved[1];
        for (auto &v : intervals) {
            if (v[1] <= start || v[0] >= end) res.push_back(v);
            else {
                if (v[0] < start) res.push_back({v[0], start});
                if (v[1] > end) res.push_back({end, v[1]});
            }
        }
        return res;
    }
```	
	
### 1273. Delete Tree Nodes(****)
delete the subtree with sum of zero. return the number of nodes left.
the tree relation is given by parent and array.
approach: find the root and build the tree relation in data structure
postorder traversal and remove the subtree if sum=0. We need to get the sum and number of nodes at the same time.

```cpp
    int deleteTreeNodes(int nodes, vector<int>& parent, vector<int>& value) {
        int n=parent.size();
        vector<unordered_set<int>> tree(n);
        int root=0;
        for(int i=0;i<n;i++){
            if(parent[i]==-1) {root=i;continue;}
            tree[parent[i]].insert(i);
        }
        
        return dfs(root,tree,value)[0];
    }
    vector<int> dfs(int root,vector<unordered_set<int>>& tree,vector<int>& v){
        vector<int> res(2);
        for(int t: tree[root]){
            auto p=dfs(t,tree,v);
            res[0]+=p[0];
            res[1]+=p[1];
        }
        res[1]+=v[root];
        if(res[1]==0) res[0]=0;else res[0]++;
        return res;
    }
```	
### 1274. Number of Ships in a Rectangle(****)
this is similar to a quadtree problem. 
divide into subgrid if there are ships
make sure the division is non-overlapped.

```cpp
    int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {
        int ans=0;
        if(topRight[0]<bottomLeft[0] || topRight[1]<bottomLeft[1]) return 0;
        if(sea.hasShips(topRight,bottomLeft)){
            if(topRight==bottomLeft) return 1;
            vector<int> mid={(topRight[0]+bottomLeft[0])/2,(topRight[1]+bottomLeft[1])/2};
            ans+=countShips(sea,mid,bottomLeft)+
                countShips(sea,{topRight[0],mid[1]},{mid[0]+1,bottomLeft[1]})+
                countShips(sea,{mid[0],topRight[1]},{bottomLeft[0],mid[1]+1})+
                countShips(sea,topRight,{mid[0]+1,mid[1]+1});
        }
        return ans;
    }
```
base condition: 
bottom left, top right not forming a legal rectangle--->0
rectangle reduces to a point  ---> hasships


## biweek 12
### 1243. Array Transformation (**)
just check if we have operations

### 1244. Design A Leaderboard (**)
using a hashmap to record the scores and reset
using a pq to get the k highest score

### 1245. Tree Diameter (*****)
this is not a easy tree problem.
several points to know:
- a tree has n-1 edges and n nodes.
- using any node as the root does not change the diameter
- n-ary tree depth problem: the diameter is the max depth + 2nd max depth
```cpp
    int treeDiameter(vector<vector<int>>& edges) {
        //a tree has n-1 edges
        int n=edges.size();
        vector<vector<int>> adj(n+1);
        vector<bool> v(n+1);
        for(auto e: edges){
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        //using any node as root is equivalent
        int ans=0; //max diameter, n-ary tree, get the depth for each subtree
        dfs(0,0,adj,v,ans);
        return ans;
    }
    int dfs(int root,int depth,vector<vector<int>>& adj,vector<bool>& v,int& ans){
        if(v[root]) return 0; //visited
        v[root]=1;
        //get the max and 2nd max and ans=max+2ndmax
        int max1=0,max2=0;
        for(int node: adj[root]){
            int d=dfs(node,depth+1,adj,v,ans);
            if(d>max1){
                max2=max1;
                max1=d;
            }
            else if(d>max2) max2=d;
        }
        ans=max(ans,max1+max2);
        return 1+max1;
    }
```
attention:
- we need return maxdepth for each node to get the max and 2nd max
- max1 and max2 cannot set to int_min but has to set as 0
- it allows max1==max2 so need use d>max1.
- if visited return 0 (it just prevent going back, and we shall use min so that we do not mess up the max and 2nd max)

### 1246. Palindrome Removal (*****)
Given an integer array arr, in one move you can select a palindromic subarray arr[i], arr[i+1], ..., arr[j] where i <= j, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal.

Return the minimum number of moves needed to remove all numbers from the array.

this is a hard dp problem.
a string can have multiple palindrome substr, we can remove one of it and leaves a smaller size subproblem. But this is generally not a correct way since it involves changing of the array.

dp[i,j] represents the min removal for substr[i,j]
basecase: length=1, length=2

this forms a upper-triangle matrix.
dp[i,j]=min(dp[i,j],dp[i,k]+dp[k,j]) 
k as a separator to split the string into two half and remove separately.

```cpp
    int minimumMoves(vector<int>& arr) {
        //dp: subproblem dp[l,r] and remove a substr which is pal
        int n = arr.size();
        // dp[left][right] = the min move for arr[left]...arr[right] (both included).
        vector<vector<int>> dp(n, vector<int>(n, n));
        for(int i = 0; i < n; i++) { dp[i][i] = 1; }
        for(int i = 0; i < n - 1; i++) { dp[i][i + 1] = arr[i] == arr[i + 1] ? 1 : 2; }
        
        for(int size = 3; size <= n; size++) {
            for(int left = 0, right = left + size - 1; right < n; left++, right++) {
                if(arr[left] == arr[right]) {
                    dp[left][right] = dp[left + 1][right - 1];
                }
                for(int mid = left; mid < right; mid++) {
                    dp[left][right] = min(dp[left][right], dp[left][mid] + dp[mid + 1][right]);
                }
            }
        }
        return dp[0][n - 1];        
    }
```
	
## Biweek 13 --pretty hard one
### 1256. Encode number (***)
0->"" (binary 0)
1->"0" (binary 1)
2->"1" (binary 10)
3->"00" (binary 11)
4->"01" (binary 100)
5->"10" (binary 101)
6->"11" (binary 110)
7->"000" (binary 111)
how can we deduce the converting function ?
binary of n+1:
0: 1
1: 10
2: 11
3: 100
4: 101
5: 110
6: 111
7: 1000
remove the first char

### 1257. Smallest Common Region (***)
a group of names, the first contains all others.
seems union find problem and find the lowest common ancestor
no need union actually. just build the structure and find the parent

```cpp
    string findSmallestRegion(vector<vector<string>>& regions, string region1, string region2) {
		unordered_map<string,string> parent;
		for(auto v: regions){
			string& par=v[0];
			for(int i=1;i<v.size();i++){
				parent[v[i]]=par; //do not overwrite 
			}
		}
		unordered_set<string> parent1;
		while(region1.size()){
			parent1.insert(region1);
			region1=parent[region1];
		}
		while(region2.size()){
		if(parent1.count(region2)) return region2;
			region2=parent[region2];
		}
		return "";
    }
```	

### 1258. Synonymous Sentences (****)
Given a list of pairs of equivalent words synonyms and a sentence text, Return all possible synonymous sentences sorted lexicographically.
idea: union find to merge the same set of synonyms. and then each set is sorted and then dfs/backtracking to get all combinations
it is not easy to design the right data structure.

```cpp
class Solution {
public:
	unordered_map<string,string> parent;
    vector<string> generateSentences(vector<vector<string>>& synonyms, string text) {
		vector<string> vtext;
		stringstream ss(text);
		string w;
		while(ss>>w) {
			vtext.push_back(w);
		}
		for(auto v: synonyms){
			if(!parent.count(v[0])) parent[v[0]]=v[0];
			if(!parent.count(v[1])) parent[v[1]]=v[1];
			merge(v[0],v[1]);
		}
		//assemble each disjoint set into sorted array or set.
		unordered_map<string,set<string>> sets;
		for(auto v: synonyms){
			string par=find_parent(v[0]);
			sets[par].insert(v[0]);
			sets[par].insert(v[1]);
		}
		//now do dfs to form the vector
		vector<string> ans;
		backtrack(sets,0,{},vtext,ans);
		return ans;
    }
	void backtrack(unordered_map<string,set<string>>& sets,int start,
		vector<string> t,vector<string>& vtext,vector<string>& ans){
		if(start==vtext.size()){
			string str;
			for(string s: t) str+=s+" ";
			str.pop_back();
			ans.push_back(str);
			return;
		}
		string w=vtext[start];
		string parent=find_parent(w);
		if(parent.size()){
			for(string s: sets[parent]){
				t.push_back(s);
				backtrack(sets,start+1,t,vtext,ans);
				t.pop_back();
			}
		}
		else{
            t.push_back(w);
			backtrack(sets,start+1,t,vtext,ans);
		}
	}
	string find_parent(string& a){
		if(!parent.count(a)) return ""; //not in the group
		while(a!=parent[a]) a=parent[a];
		return a;
	}
	void merge(string& a,string& b){
		string pa=find_parent(a),pb=find_parent(b);
		parent[pb]=pa;
	}
};
```	

### 1259. Handshakes That Don't Cross (*****)
even number of people in a circle, return number of ways that do not cross.
typical dp problem:
if person i and person j shake hands, then it divide into two groups:
assuming i<j:
(i+1)%n to (j-1+n)%n.-->dp(m1)
(j+1)%n to (i-1+n)%n.-->dp(m2) m1+m2=n-2
to avoid non-cross, each set shall have even number of people
for convenice we use pair.
for n pairs of people, we can divide into:
{0, n-1},{1,n-2},....{k,n-k-1}....{n-1,0} pairs

```cpp
    int numberOfWays(int n) {
        vector<long> dp(n/2+1);
		int mod=1e9+7;
		dp[0]=1;
		for(int k=1;k<=n/2;k++){
			for(int i=0;i<k;i++){
				dp[k]=(dp[k]+dp[i]*dp[k-1-i])%mod;
			}
		}
		return dp[n/2];
    }
```	


## biweek contest 15
### 1287. Element Appearing More Than 25% In Sorted Array (***)
in a sorted array, the >25% element will appear at 1/4, 2/4, 3/4 position
```cpp
    int findSpecialInteger(vector<int>& arr) {
        //element appear at 1/4,2/4,3/4
        int n=arr.size();
        int bound=(n+3)/4;
        if(num_elem(arr,arr[n/4])>bound) return arr[n/4] ;
        if(num_elem(arr,arr[n/2])>bound) return arr[n/2] ;
        return arr[n*3/4];
    }
    int num_elem(vector<int>& arr,int num){
        auto t=equal_range(arr.begin(),arr.end(),num);
        return distance(t.first,t.second);
    }
```
### 1288. Remove Covered Intervals (***)
sort the intervals according to the start. then we using the right max to remove covered intervals	
```cpp
    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        //sorting with beginning
        int n=intervals.size();
        sort(intervals.begin(),intervals.end());
        int ans=0;
        int cur_end=intervals[0][1];
        for(int i=1;i<n;i++){
            if(intervals[i][1]>cur_end)
                cur_end=intervals[i][1];
            else ans++;
        }
        return n-ans;
    }
```
### 1286. Iterator for Combination	(**)
using backtracking to get all the combinations
```cpp
    string s;
    int cl;
    vector<string> vs;
    int ind;
    CombinationIterator(string characters, int combinationLength) {
        s=characters;
        cl=combinationLength;
        backtrack(s,0,"",vs);
        ind=0;
    }
    
    void backtrack(string& s,int start,string t,vector<string>& vs){
        if(t.length()==cl){
            vs.push_back(t);
            return;
        }
        for(int i=start;i<s.size();i++){
            t+=s[i];
            backtrack(s,i+1,t,vs);
            t.pop_back();
        }
    }
    string next() {
        return vs[ind++];  
    }
    
    bool hasNext() {
        return ind<vs.size();
    }
```
we can also get the iterator directly.

### 1289. Minimum Falling Path Sum II	(***)
the dp relation is apparent. It only involves with previous row's min and second min.
There is a O(N) method to find the min and 2nd min.
```cpp
    int minFallingPathSum(vector<vector<int>>& arr) {
        int m=arr.size(),n=arr[0].size();
        for(int i=1;i<m;i++){
            vector<int> min2=findmin2(arr[i-1]);
            //print(arr[i-1]);
            //print(min2);
            for(int j=0;j<n;j++){
                arr[i][j]+=(arr[i-1][j]==min2[0]?min2[1]:min2[0]);
            }
        }
        return *min_element(arr[m-1].begin(),arr[m-1].end());
    }
    vector<int> findmin2(vector<int>& num){
        int a=INT_MAX,b=INT_MAX;
        for(int t: num){
            if(t<a){
                b=a;
                a=t;
            }
            else if(t<b) b=t;
        }
        return {a,b};
    }
```
## biweek contest 16
### 1299. Replace elemets with greatest element on right side (**)
simple, just do it from right to left and find the max and add to answer

### 1300. sum of mutated array closest to target (****)
first we can sort the array to make calculate the sum more efficient. (but not necessary)
second, it is a binary search problem.
we are actually looking for a value between 0 and max_element so that the sum==target.
when sum>=target, r=mid, else l=mid+1
This is pretty similar to find target in a sorted array using binary search. (the target could or not in the array)
(the abs(sum-target) is a v-shape curve, without abs, it is monotonic shape).

```cpp
    int findBestValue(vector<int>& arr, int target) {
        int l=0,r=*max_element(arr.begin(),arr.end());
        int sum=accumulate(arr.begin(),arr.end(),0);
        if(sum<=target) return r; //cannot change 
        //find a value for sum==target
        while(l<r){
            int m=l+(r-l)/2;
            sum=0;
            for(int t: arr) sum+=t<m?t:m;
            if(sum>=target) r=m;
            else l=m+1;
        }
        //now we find l, check if it shall be l-1 or l
        //note binary search l shall be the one for sum>=target
        //note the sum is not for l
        int s1=0,s2=0;
        for(int t: arr) {
            s1+=t<l-1?t:l-1;
            s2+=t<l?t:l;
        }
        //cout<<sum<<endl;
        return abs(s2-target)<abs(s1-target)?l:l-1;
    }
```
	
### 1302. Deepest leaves sum. (***)
It is simple to use two pass traversal. first pass to get the max depth, second pass to get the sum.
```cpp
    int deepestLeavesSum(TreeNode* root) {
        int d=depth(root);
        //cout<<d;
        int ans=0;
        dfs(root,1,d,ans);
        return ans;
    }
    
    void dfs(TreeNode* root,int d,int md,int& ans){
        if(!root) return;
        if(d==md) ans+=root->val;
        dfs(root->left,d+1,md,ans);
        dfs(root->right,d+1,md,ans);
    }
    
    int depth(TreeNode* root){
        if(!root) return 0;
        return 1+max(depth(root->left),depth(root->right));
    }
```
one pass solution:
we need find the max depth and do the sum in one pass, a little bit tricky though
when current depth>max depth, we need update sum and depth
when current depth==max_depth, we need add the node to the sum.

```cpp
    int dh,sum;
    int deepestLeavesSum(TreeNode* root) {
        dh = sum = 0;
        dfs(root, 0);
        return sum;
    }
    void dfs(TreeNode* root, int d) {
        if(!root) return;
        if(d > dh) {
	    sum = root -> val;
            dh=d;
	}
	else if(d == dh) {
	    sum += root -> val;
	}
        dfs(root -> left, d + 1);
        dfs(root -> right, d + 1);
    }
```	
other approach: level order traversal using bfs

### 1301. number of paths with max score (***)
two dp problems:
one is max score from top left to bottom right
second is number of max sum paths (note it asks number of path with the max score)

some observations:
- it is easy to see that from bottom right to top left is equivalent to from top left to bottom right
- we can replace the top left and bottom right cell with 0 score cell to simplify
- dp0[i,j] represent the max score for [i-1,j-1]
- dp1[i,j] represent the number of max sum path for [i-1,j-1]
- score:
  *. current cell must be a number
  *. shall have one or more paths from left, top, topleft cell
- base condition: we can set dp1[0,0] or dp[0,1] or dp[1,0] to 1, which means we only have one path entering to board[0,0]
```cpp
    vector<int> pathsWithMaxScore(vector<string>& board) {
        //dp
        vector<int> ans={0,0};
        int mod=1e9+7;
        if(board.empty()) return ans;
        int m=board.size(),n=board[0].size();
        vector<vector<int>> dp0(m+1,vector<int>(n+1)),dp1(m+1,vector<int>(n+1)); //dp0: max, dp1 number of path for max
        dp1[0][0]=1; //diagonal can go to E
        board[0][0]=board[m-1][n-1]='0';
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]!='X'){
                    dp0[i+1][j+1]=max({dp0[i+1][j],dp0[i][j+1],dp0[i][j]});//+board[i][j]-'0';
                    if(dp0[i+1][j+1]==dp0[i+1][j]) dp1[i+1][j+1]+=dp1[i+1][j];
                    if(dp0[i+1][j+1]==dp0[i][j+1]) dp1[i+1][j+1]+=dp1[i][j+1];
                    if(dp0[i+1][j+1]==dp0[i][j]) dp1[i+1][j+1]+=dp1[i][j];
                    dp1[i+1][j+1]%=mod;
                    if(dp1[i+1][j+1]) dp0[i+1][j+1]+=board[i][j]-'0';//only when there is path we can add
                }
            }
        }
        return {dp0[m][n],dp1[m][n]};
    }
```	### 1313. Decompress Run-Length Encoded List (*)
problem description is not very clear, however very simple:
```cpp
    vector<int> decompressRLElist(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i+=2){
            int a=nums[i],b=nums[i+1];
            while(a--) ans.push_back(b);
        }
        return ans;
    }
```

### 1314. Matrix Block Sum (*)
brutal force is fine. however we can use dp to get the prefix sum and then get block matrix sum
```cpp
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {
        if(mat.empty()) return {};
        int m=mat.size(),n=mat[0].size();
        vector<vector<int>> ans(m,vector<int>(n));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                for(int k=-K;k<=K;k++){
                    for(int l=-K;l<=K;l++){
                        if(i+k<0||i+k>=m||j+l<0||j+l>=n) continue;
                        ans[i][j]+=mat[i+k][j+l];
                    }
                }
            }
        }
        return ans;
    }
```

### 1315. Sum of Nodes with Even-Valued Grandparent (*)
preorder traversal, simple
```cpp
    int sumEvenGrandparent(TreeNode* root) {
        //preorder
        int ans=0;
        preorder(root,0,0,ans);
        return ans;
    }
    void preorder(TreeNode* root,TreeNode* p,TreeNode* pp,int& ans){
        if(!root) return;
        if(pp && pp->val%2==0) ans+=root->val;
        preorder(root->left,root,p,ans);
        preorder(root->right,root,p,ans);
    }
```

### 1316. Distinct Echo Substrings (**)
problem is not well described. It asks for substring which is AA format.
sliding window is fine 
but rolling hash is another option.
```cpp
    int distinctEchoSubstrings(string text) {
        //substring which is repeat.
        //we can use a window to see
        //rolling hash?
        //problem is not clear, it means two identical parts
        unordered_set<string> ms;
        for(int i=0;i<text.size();i++){
            for(int j=i;2*j+1-i<text.size();j++){
                //check substr(i,j-i+1)
                if(text[i]!=text[j+1]) continue;
                if(text.substr(i,j-i+1)==text.substr(j+1,j-i+1))
                    ms.insert(text.substr(i,j-i+1));
            }
        }
        return ms.size();
    }
```
- note if do not check the first char will get TLE since it avoids the substr construction work.
This contest is simple, but problem is not clear in Q1 and Q4.



## biweek 18
### 1331. Rank transform of an array
<em>Problem:

Given an array of integers arr, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:

Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.</em>

n up to 1e5.
intuition: cannot use O(N^2) algorithm. 
Approach: sort with index and then assign the id.

```cpp
    vector<int> arrayRankTransform(vector<int>& arr) {
        vector<vector<int>> vdata;
        for(int i=0;i<arr.size();i++){
            vdata.push_back({arr[i],i});
        }
        sort(vdata.begin(),vdata.end());
        vector<int> ans(arr.size());
        int id=0,prev=INT_MIN;
        for(auto t: vdata){
            if(t[0]!=prev){
                ans[t[1]]=++id;
                prev=t[0];
            }
            else ans[t[1]]=id;
        }
        return ans;
    }
```

### 1328. Break a Palindrome
<em>Problem:

Given a palindromic string palindrome, replace exactly one character by any lowercase English letter so that the string becomes the lexicographically smallest possible string that isn't a palindrome.

After doing so, return the final string.  If there is no way to do so, return the empty string.
</em>

Intuition:
- go only the half (avoid the mid element)
- find the first not a and replace it with a.
- otherwise replace the last one with b.
```cpp
    string breakPalindrome(string S) {
        int n = S.size();
        for (int i = 0; i < n / 2; ++i) {
            if (S[i] != 'a') {
                S[i] = 'a';
                return S;
            }
        }
        S[n - 1] = 'b';
        return n < 2 ? "" : S;
    }
```

### 1329. Sort the Matrix Diagonally	
<em>Problem:

Given a m * n matrix mat of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.
</em>

Intuition: sort using map to put each diagonal with key i*n+j (with i or j to be 0)
```cpp
    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
        //diagnonal: dx=dy
        unordered_map<int,multiset<int>> mp;
        int m=mat.size(),n=mat[0].size();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                int x=i-min(i,j),y=j-min(i,j);
                mp[x*n+y].insert(mat[i][j]);
            }
        }
        for(auto t: mp){
            int ind=0;
            int x=t.first/n,y=t.first%n;
            for(int i: t.second) mat[x][y]=i,x++,y++;
        }
        return mat;
    }
```

### 1330. Reverse Subarray To Maximize Array Value
<em>Problem:

You are given an integer array nums. The value of this array is defined as the sum of |nums[i]-nums[i+1]| for all 0 <= i < nums.length-1.

You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.

Find maximum possible value of the final array.
</em>

n up to 3e4.
Intuition: O(N^2) may not pass the test.
Brutal force will TLE:
```cpp
    int maxValueAfterReverse(vector<int>& num) {
        //reverse a subarray only change the two end difference
        //assuming reverse [i,j], the orginal diff is sum(abs(A[i]-A[i-1]))
        //now 0,1,....i-1,j....i,j+1....
        //abs(A[j]-A[i-1])+abs(A[j+1]-A[i])-abs(A[i]-A[i-1])-abs(A[j+1]-A[j])
        //we are maxmizing this sum
        int sum=0,n=num.size();
        for(int i=1;i<num.size();i++){
            sum+=abs(num[i]-num[i-1]);
        }
        int maxdiff=0;
        for(int i=0;i<num.size();i++){
            for(int j=i+1;j<num.size();j++){
                maxdiff=max(maxdiff,(i?abs(num[j]-num[i-1]):0)
                            +(j+1<n?abs(num[j+1]-num[i]):0)
                            -(i?abs(num[i]-num[i-1]):0)
                            -(j+1<n?abs(num[j+1]-num[j]):0));
            }
        }
        return sum+maxdiff;
    }
```

We need improve this algorithm into O(N)
- now we know the changes are obtained using above solution.
- if we want to O(N) we can only process neigboring elements. then we need to know how to accumulate to get the reverse [i,j].
- to make it simple, we let a=num[i-1],b=num[i],c=num[j],d=num[j+1]. the minus part only involves with i or j. max(|c-a|+|d-b|-|b-a|-|d-c|)
- to maximize it, we need minimize |b-a|+|d-c| and maximize |c-a|+|d-b|.
- remove abs operator by using abs(a)=max(a,-a).
max(|c-a|+|d-b|)=max(max(c-a,a-c)+max(d-b,b-d))=max(max(c-a+d-b,c-a+b-d,a-c+b-d,a-c+d-b))
min(|b-a|+|d-c|)=min(max(b-a,a-b)+max(d-c,c-d))=min(max(b-a+d-c,b-a+c-d,a-b+d-c,a-b+c-d))
reorganize to make them clearer:
max(max(-a-b+c+d,-a+b+c-d,a+b-c-d,a-b-c+d))
min(max(-a+b-c+d,-a+b+c-d,a-b-c+d,a-b+c-d))

if we want to do O(N) then we need group a and b together, and c and d together.
there are only a+b, a-b two combinations.
need get max(a+b),max(-a-b),max(-a+b),max(a-b), save them as previous max pairs.
- there are 3 cases: reverse the prefix, reverse the suffix, reverse the mid subarray
```cpp
    int maxValueAfterReverse(vector<int>& num) {
		int ans=0;//accumulate(num.begin(),num.end(),0);
		int n=num.size();
		int maxpre=INT_MIN,maxpost=INT_MIN,maxmid=INT_MIN,minmid=INT_MAX;
		int mx0=INT_MIN,mx1=INT_MIN,mx2=INT_MIN,mx3=INT_MIN;
		for(int i=0;i<n-1;i++){
			int a=num[i],b=num[i+1];
            ans+=abs(a-b);
			maxpre=max(maxpre,abs(num[0] - b) - abs(a - b));
			maxpost=max(maxpost,abs(num[n - 1] - a) - abs(a - b));
			if(mx0>INT_MIN){
                maxmid=max(maxmid,max({mx1+a+b,mx2+a-b,mx0-a-b,mx3-a+b}));
			    minmid=min(minmid,max({mx2-a+b,mx2+a-b,mx3-a+b,mx3+a-b}));
            }
			mx0=max(mx0,a+b);
			mx1=max(mx1,-a-b);
			mx2=max(mx2,-a+b);
			mx3=max(mx3,a-b);
		}
        cout<<maxpre<<" "<<maxpost<<" "<<maxmid<<" "<<minmid<<endl;
		return ans+max({maxpre,maxpost,maxmid-minmid});
	}
```
Above code gives wrong results.
actually NO. You cannot separate them as min and max. we need to 		
max(|c-a|+|d-b|-|b-a|-|d-c|)
- max(c-a+d-b-|b-a|-|d-c|) equiv to (-a-b+c+d-|b-a|-|d-c|) for c>a and d>b
- max(c-a+b-d-|b-a|-|d-c|) equiv to (-a+b+c-d-|b-a|-|d-c|) for c>a and d<b
- max(a-c+d-b-|b-a|-|d-c|) equiv to (a-b-c+d-|b-a|-|d-c|) for c<a and d>b.
- max(a-c+b-d-|b-a|-|d-c|) equiv to (a+b-c+d-|b-a|-|d-c|) for c<a and d<b.
we separate (a,b) and (c,d)
there are four cases:
- max(-a-b-|b-a|+c+d-|d-c|)
- max(-a+b-|b-a|+c-d-|d-c|)
- max(a-b-|b-a|-c+d-|d-c|)
- max(a+b-|b-a|-c-d-|d-c|)
the key part is when we separate choosing the max, we cannot guarantee choosing same set.
thus we may over count it.
The following code passes the tests with O(N)

```cpp
    int maxValueAfterReverse(vector<int>& num) {
		int ans=0;//accumulate(num.begin(),num.end(),0);
		int n=num.size();
		int maxpre,maxpost,maxmid;
		int mx0,mx1,mx2,mx3;
		maxpre=maxpost=maxmid=INT_MIN;
		mx0=mx1=mx2=mx3=INT_MIN;
		for(int i=0;i<n-1;i++){
			int a=num[i],b=num[i+1];
			int diff=abs(a-b);
            ans+=diff;
			maxpre=max(maxpre,abs(num[0] - b) - diff);
			maxpost=max(maxpost,abs(num[n - 1] - a) - diff);
			if(mx0>INT_MIN){
                maxmid=max(maxmid,max(
				{mx3+a+b-diff,
				mx2+a-b-diff,
				mx1-a+b-diff,
				mx0-a-b-diff}));
            }
			mx0=max(mx0,a+b-diff);
			mx1=max(mx1,a-b-diff);
			mx2=max(mx2,-a+b-diff);
			mx3=max(mx3,-a-b-diff);
		}
		return ans+max({maxpre,maxpost,maxmid});
	}
```
	
Lee's solution on this:

total calculate the total sum of |A[i] - A[j]|.
res record the value the we can improve.

Assume the current pair is (a,b) = (A[i], A[i+1]).

If we reverse all element from A[0] to A[i],
we will improve abs(A[0] - b) - abs(a - b)

If we reverse all element from A[i+1] to A[n-1],
we will improve abs(A[n - 1] - a) - abs(a - b)

As we iterate the whole array,
We also record the maximum pair and the minimum pair.
We can break these two pair and reverse all element in the middle.
This will improve (max2 - min2) * 2


```cpp
    int maxValueAfterReverse(vector<int>& A) {
        int total = 0, res = 0, min2 = 123456, max2 = -123456, n = A.size();
        for (int i = 0; i < n - 1; ++i) {
            int a = A[i], b = A[i + 1];
            total += abs(a - b);
            res = max(res, abs(A[0] - b) - abs(a - b));
            res = max(res, abs(A[n - 1] - a) - abs(a - b));
            min2 = min(min2, max(a, b));
            max2 = max(max2, min(a, b));
        }
        return total + max(res, (max2 - min2) * 2);
    }
```
	

## biweek 19

### 1342. Number of Steps to Reduce a Number to Zero
<em>
Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.</em>

Really simple:
```cpp
    int numberOfSteps (int num) {
        int ans=0;
        while(num){
            if(num%2==0) num/=2;
            else num--;
            ans++;
        }
        return ans;
    }
```

### 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
<em>
Given an array of integers arr and two integers k and threshold.

Return the number of sub-arrays of size k and average greater than or equal to threshold.
</em>

classical sliding window:
```cpp
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int target=k*threshold;
        //moving average
        int i=0,sum=0,ans=0;
        while(i<arr.size()){
            sum+=arr[i];
            if(i>=k){
                sum-=arr[i-k];
            }
            if(i>=k-1 && sum>=target) ans++;
            i++;
        }
        return ans;
    }
```

### 1344. Angle Between Hands of a Clock
<em>
Given two numbers, hour and minutes. Return the smaller angle (in sexagesimal units) formed between the hour and the minute hand.
</em>
Simple: get the min and hr angle position and get the difference.
if <0 we add 360. then check if it >180, choose the other one.

```cpp
    double angleClock(int hour, int minutes) {
        //a min 360/60 degree, a hr: 360/12=
        int min_angle=minutes*6;
        double hr_angle=hour*30+minutes/60.0*30;
        double ans=hr_angle-min_angle;
        if(ans<0)  ans+=360;
        if(ans>180) ans=360-ans;
        return ans;
    }
```

### 1345. Jump Game IV
<em>
Given an array of integers arr, you are initially positioned at the first index of the array.

In one step you can jump from index i to index:

i + 1 where: i + 1 < arr.length.
i - 1 where: i - 1 >= 0.
j where: arr[i] == arr[j] and i != j.
Return the minimum number of steps to reach the last index of the array.

Notice that you can not jump outside of the array at any time.
</em>

typical bfs problem with hashmap

```cpp
    int minJumps(vector<int>& arr) {
        //bfs
        unordered_map<int,vector<int>> mp;
        for(int i=arr.size()-1;i>=0;i--) mp[arr[i]].push_back(i);
        int n=arr.size();
       
        queue<int> q;
        vector<bool> v(n);
        q.push(0),v[0]=1;
        int step=0;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                int cur=q.front();
                q.pop();
                if(cur==n-1) return step;
                if(cur+1<n && !v[cur+1]){
                    q.push(cur+1),v[cur+1]=1;
                }
                if(cur-1>=0 && !v[cur-1]){
                    q.push(cur-1),v[cur-1]=1;
                }
                for(int i: mp[arr[cur]]){ //this could be very lengthy and will cause TLE
                    if(i==cur || v[i]) continue;
                    q.push(i),v[i]=1;
                }
                mp.erase(arr[cur]);
            }
            step++;
        }
        return -1;
    }
```

- the key for the problem is the mp.erase(arr[cur]) otherwise it will have to repeatedly check and will cause TLE.

	
## biweek 20
this contest is simple

### 1356. Sort Integers by The Number of 1 Bits
sort by bits

```cpp
    vector<int> sortByBits(vector<int>& arr) {
        vector<vector<int>> v;
        for(int i: arr){
            int t=bitset<16>(i).count();
            v.push_back({i,t});
        }
        sort(begin(v),end(v),[](vector<int>& a,vector<int>& b){
            return a[1]<b[1] || (a[1]==b[1] && a[0]<b[0]);
        });
        vector<int> ans;
        for(auto t: v) ans.push_back(t[0]);
        return ans;
    }
```

### 1357 Apply discount
simple math. using hashmap

```cpp
    int cnt;
    unordered_map<int,int> mp;
    int discount;
    int n;
    Cashier(int n, int discount, vector<int>& products, vector<int>& prices) {
        cnt=0;
        for(int i=0;i<products.size();i++) mp[products[i]]=prices[i];
        this->discount=discount;
        this->n=n;
    }
    
    double getBill(vector<int> product, vector<int> amount) {
        cnt++;
        double ans=0;
        for(int i=0;i<product.size();i++){
            ans+=mp[product[i]]*amount[i];
        }
        if(cnt==n){
            ans*=(100-discount)/100.0;
            cnt=0;
        }
        return ans;
    }
```

### 1358. Number of Substrings Containing All Three Characters	
simple sliding window
important: all prefix is the substring,, we only need to keep the smallest substring.
```cpp
    int numberOfSubstrings(string s) {
        //mvoing window
        int ans=0;
        int cnt[3]={0};
        int i=0,j=0;
        //the min window which contains the abc
        while(j<s.size()){
            cnt[s[j]-'a']++;
            while(cnt[0] && cnt[1] && cnt[2]){
                cnt[s[i]-'a']--;
                i++;
            }
            ans+=i;
            j++;
        }
        return ans;
    }
```

### 1359. Count All Valid Pickup and Delivery Options
simple dp:
we have n options for the first position. then reduces to n-1 subproblem. D can be put in 2n-1 positions
the total dp[n]=n*(2n-1)*dp[n-1]
can be O(1) space

```cpp
    int countOrders(int n) {
        int mod=1e9+7;
        //permutation problem:
        //0: has n options, 1, has 2n-1 options,.... 2n has n options
        //once we fixed the first postion Pi, the reduces to similar problem, with Di can be inserted in it anywhere
        //dp[n]=n*[(2*n-1)*dp(n-1)]
        vector<long> dp(n+1);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            dp[i]=(long)i*(2*i-1)*dp[i-1];
            dp[i]%=mod;
        }
        return dp[n];
    }
```

- be sure to use long to avoid overflow.
	
## biweek 21
### 1370. Increasing Decreasing String
<em>
Given a string s. You should re-order the string using the following algorithm:

Pick the smallest character from s and append it to the result.
Pick the smallest character from s which is greater than the last appended character to the result and append it.
Repeat step 2 until you cannot pick more characters.
Pick the largest character from s and append it to the result.
Pick the largest character from s which is smaller than the last appended character to the result and append it.
Repeat step 5 until you cannot pick more characters.
Repeat the steps from 1 to 6 until you pick all characters from s.
In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.

Return the result string after sorting s with this algorithm.
</em>

Approach:

use a hashmap and do the simulation

```cpp
    string sortString(string s) {
        vector<int> cnt(26);
        for(char c: s) cnt[c-'a']++;
        string res;
        while(res.size()!=s.size()){
            for(int i=0;i<26;i++){
                if(cnt[i]) res+='a'+i,cnt[i]--;
            }
            for(int i=25;i>=0;i--){
                if(cnt[i]) res+='a'+i,cnt[i]--;
            }
        }
        return res;        
    }
```

### 1371. Find the Longest Substring Containing Vowels in Even Counts
<em>
Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.
</em>

Approach:
- the exact count does not matter. use xor to get 0
- sliding window will not make O(N)
- we can use bit operations, aeiou corresponds to bit 0 to bit 4.
	- we can record the status in hashmap. 
	- keep the smallest index with the same status. and then we can get the longest substring.
	- only has 32 status, so we can use vector to speed up.

```cpp
	int findTheLongestSubstring(string s) {
		unordered_map<int,int> mp; //status vs smallest index
		int cnt=0,ans=0;
		mp[0]=-1; 
		for(int i=0;i<s.size();i++){
			char c=s[i];
			if(c=='a') cnt^=1;
			else if(c=='e') cnt^=2;
			else if(c=='i') cnt^=4;
			else if(c=='o') cnt^=8;
			else if(c=='u') cnt^=16;
			if(mp.count(cnt)) ans=max(ans,i-mp[cnt]);
			else mp[cnt]=i;
		}
		return ans;
	}
```

### 1372. Longest ZigZag Path in a Binary Tree
<em>
Given a binary tree root, a ZigZag path for a binary tree is defined as follow:

Choose any node in the binary tree and a direction (right or left).
If the current direction is right then move to the right child of the current node otherwise move to the left child.
Change the direction from right to left or right to left.
Repeat the second and third step until you can't move in the tree.
Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).

Return the longest ZigZag path contained in that tree.
</em>

Approach:

post order traversal
- it could be in the left or right subtree or connect the root itself.

```cpp
    int longestZigZag(TreeNode* root) {
        //post order and update the max path
        int ans=0;
        auto t=helper(root,ans);
        return ans;
    }
    vector<int> helper(TreeNode* root,int& ans){
        if(!root) return {0,0};
        auto left=helper(root->left,ans);
        auto right=helper(root->right,ans);
        ans=max({ans,left[1],right[0]}); //update the ans
        return {1+left[1],1+right[0]};//include the root
    }
```
	
### 1373. Maximum Sum BST in Binary Tree
<em>
Given a binary tree root, the task is to return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
</em>

Approach:
- post order traversal
- left and right shall be BST, get the lmax,rmin, sum

```cpp
    int maxSumBST(TreeNode* root) {
        //postorder get the sum, lmax,rmin
        //BST: lmax<root<rmin
        int ans=0;
        //int lmax=-1e5,rmin=1e5;
        helper(root,ans);
        return ans;
    }
    //return sum and if it is a bst
    vector<int> helper(TreeNode* root,int& ans){
        if(!root) return {1,0,-100000,100000}; //it is a bst
        int sum=0,lmax=-100000,rmin=100000;
        auto left=helper(root->left,ans);
        auto right=helper(root->right,ans);
        bool isbst=left[0] && right[0] && root->val>left[2] && root->val<right[3];
        if(isbst){
            sum=root->val+left[1]+right[1];
            ans=max(ans,sum);
            lmax=max(root->val,lmax);
            rmin=min(root->val,rmin);
        }
        return {isbst,sum,lmax,rmin};
    }
```
	
## biweek 22

### 1385. Find the Distance Value Between Two Arrays
<em>
Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.
</em>

brutal force O(N^2)
```cpp
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        int ans=0;
        for(int i: arr1){
            bool valid=1;
            for(int j: arr2){
                if(abs(i-j)<=d) {valid=0;break;}
            }
            ans+=valid;
        }
        return ans;
    }
```
O(nlogn) sort the array first. and then search for a[i]+d and a[i]-d

### 1386. Cinema Seat Allocation
<em>
A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.

Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i]=[3,8] means the seat located in row 3 and labelled with 8 is already reserved. 

Return the maximum number of four-person families you can allocate on the cinema seats. A four-person family occupies fours seats in one row, that are next to each other. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be next to each other, however, It is permissible for the four-person family to be separated by an aisle, but in that case, exactly two people have to sit on each side of the aisle.
</em>

Approach: bit manipulation: 
- note we can process row by row.
- need to have as many as possible families. so we have 0,1,2 possible.
```cpp
int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats)
{
    int ans = n*2;
    
    unordered_map<int, char> m;
    
    for (auto r : reservedSeats)
        if (r[1] > 1 && r[1] < 10)
            m[r[0]] |= 1<<(r[1]-2);
    
    for (auto seats : m)
    {  
        bool p1 = !(seats.second & 0b11110000);
        bool p2 = !(seats.second & 0b00111100);
        bool p3 = !(seats.second & 0b00001111);
        
        if (p1 && p3)
            continue;
        else if (p1 || p2 || p3)
            ans-=1;
        else
            ans-=2;
    }
    
    return ans;
}
```

### 1387. Sort Integers by The Power Value
<em>
The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:

if x is even then x = x / 2
if x is odd then x = 3 * x + 1
For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).

Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order.

Return the k-th integer in the range [lo, hi] sorted by the power value.

Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in 32 bit signed integer.
</em>

direct approach using hashmap similar to memoization or dp.
also, if the size is very large, we can use heap to maintain k elements only.

```cpp
    unordered_map<int,int> mp;
    int getKth(int lo, int hi, int k) {
        vector<vector<int>> vp;
        for(int i=lo;i<=hi;i++){
            vp.push_back({get_power(i),i});
        }
        sort(begin(vp),end(vp));
        return vp[k-1][1];
    }
    int get_power(int n){
        if(n==1) return 0;
        if(mp.count(n)) return mp[n];
        if(n%2){
            return mp[n]=1+get_power(3*n+1);
        }
        return mp[n]=1+get_power(n/2);
    }
```	

### 1388. Pizza With 3n Slices
<em>
There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:

You will pick any pizza slice.
Your friend Alice will pick next slice in anti clockwise direction of your pick. 
Your friend Bob will pick next slice in clockwise direction of your pick.
Repeat until there are no more slices of pizzas.
Sizes of Pizza slices is represented by circular array slices in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.
</em>

This problem is similar to 213. House Robber II
- You cannot pick 0 and n-1 at the same time.
- once you choose i, you cannot choose i-1 and i+1.
- the difference is you have to choose n/3 slices (the constrains), which makes it a 2d dp problem.

```cpp
    int maxSizeSlices(vector<int>& slices) {
        //same as 213. convert to two linear problems
        int n=slices.size();
        return max(dp(slices,0,n-2,n/3),dp(slices,1,n-1,n/3));
    }
    int dp(vector<int>& slices,int l,int r,int k){
        //choose i or not choose i
        int n=slices.size();
        vector<vector<int>> dp0(n+2,vector<int>(k+1));
        //choose i: dp0[i]=dp0[i-2]+slices[i]
        //not choose i: dp0[i]=dp0[i-1]
        for(int i=l;i<=r;i++){ //i is the index
            for(int j=1;j<=k;j++){
                dp0[i+2][j]=max(dp0[i][j-1]+slices[i],dp0[i+1][j]);
            }
        }
        return dp0[r+2][k];
    }
```
	

	
## biweek 23, 4/4/2020

### 1399. Count Largest Group
<em>
Given an integer n. Each number from 1 to n is grouped according to the sum of its digits. 

Return how many groups have the largest size.
</em>

straightforward:

```cpp
    int countLargestGroup(int n) {
        unordered_map<int,int> mp;
        for(int j=1;j<=n;j++){
            int sum=0;
            int i=j;
            while(i){
                sum+=i%10;
                i/=10;
            }
            mp[sum]++;
        }
        int ans=0,mx=0; //number of max group
        for(auto t: mp) {
            if(t.second>mx){
                mx=t.second;
                ans=1;
            }
            else if(t.second==mx){
                ans++;
            }
        }
        return ans;
    }
```


### 1400. Construct K Palindrome Strings
<em>
Given a string s and an integer k. You should construct k non-empty palindrome strings using all the characters in s.

Return True if you can use all the characters in s to construct k palindrome strings or False otherwise.
</em>

Observation:
- odd characters <=k
- string size >=k

```cpp
    bool canConstruct(string s, int k) {
        //k pal, each string shall at least contain 1 char
        if(s.size()<k) return 0;
        //num types of char <k, we are ok to build
        vector<int> cnt(26);
        for(char c: s) cnt[c-'a']++;
        int nchar=0,nodd=0;
        for(int i: cnt) {
            nchar+=(i>0);
            nodd+=(i%2);
        }
        if(nchar<=k) return 1;
        //number of odd chars
        if(nodd>k) return 0;
        return 1;
    }
```

lee's solution:
```cpp
    bool canConstruct(string s, int k) {
        bitset<26> odd;
        for (char& c : s)
            odd.flip(c - 'a');
        return odd.count() <= k && k <= s.length();
    }
```

### 1401. Circle and Rectangle Overlapping
<em>
Given a circle represented as (radius, x_center, y_center) and an axis-aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle.

Return True if the circle and rectangle are overlapped otherwise return False.

In other words, check if there are any point (xi, yi) such that belongs to the circle and the rectangle at the same time.
</em>

- check if rectangle boundary point <radius
- check if circle inside rectangle
```cpp
    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {
        //check all points on the rectangle distance to the center to see if any distance <=r
        
        for(int x=x1;x<=x2;x++){
            int d1=(x-x_center)*(x-x_center)+(y1-y_center)*(y1-y_center);
            int d2=(x-x_center)*(x-x_center)+(y2-y_center)*(y2-y_center);
            if(min(d1,d2)<=radius*radius) return 1;
        }
        for(int y=y1;y<=y2;y++){
            int d1=(x1-x_center)*(x1-x_center)+(y-y_center)*(y-y_center);
            int d2=(x2-x_center)*(x2-x_center)+(y-y_center)*(y-y_center);
            if(min(d1,d2)<=radius*radius) return 1;
        }
        //also circle is inside rect.
        if(x_center-radius>=x1 && x_center+radius<=x2 && y_center-radius>=y1 && y_center+radius<=y2) return 1;
        return 0;
    }
```

### 1402. Reducing Dishes
<em>
A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.

Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level  i.e.  time[i]*satisfaction[i]

Return the maximum sum of Like-time coefficient that the chef can obtain after dishes preparation.

Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.
</em>

- greedy: since initial order does not matter, so we need sort it. put the larger satisfaction value in the behind
- dp: O(N^2) 

```cpp
    int maxSatisfaction(vector<int>& satisfaction) {
        //sum(A[i]*(i+1))
        //dp: each dish can be discarded or not
        //dp[i][j]=max(dp[i-1][j-1]+s[i]*j,dp[i-1][j])
        sort(begin(satisfaction),end(satisfaction));
        int n=satisfaction.size();
        vector<vector<int>> dp(n+1,vector<int>(n+1,INT_MIN));
        int ans=0;
        for(int i=1;i<=n;i++){ //number of dishes
            for(int j=1;j<=i;j++){ //number of dishes cooked
                dp[i][j]=max((dp[i-1][j-1]==INT_MIN?0:dp[i-1][j-1])+satisfaction[i-1]*j,dp[i-1][j]);
                ans=max(ans,dp[i][j]);
            }
        }
        return ans;
    }
```	
Note: initialize as 0 is incorrect since it will give incorrect results for negative values.

	
## biweek 24

### 1413. Minimum Value to Get Positive Step by Step Sum
<em>
Given an array of integers nums, you start with an initial positive value startValue.

In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).

Return the minimum positive value of startValue such that the step by step sum is never less than 1.
</em>

simple math and prefix sum
```cpp
    int minStartValue(vector<int>& nums) {
        int prefix=0;
        int ans=0;
        for(int i: nums){
            prefix+=i;
            ans=min(ans,prefix);
        }
        return max(1-ans,1);
    }
```

### 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K
<em>
Given the number k, return the minimum number of Fibonacci numbers whose sum is equal to k, whether a Fibonacci number could be used multiple times.

The Fibonacci numbers are defined as:

F1 = 1
F2 = 1
Fn = Fn-1 + Fn-2 , for n > 2.
It is guaranteed that for the given constraints we can always find such fibonacci numbers that sum k.
1 <= k <= 10^9
</em>

Intuition: greedy approach
always pick the largest one<=n and then reduce to a smaller subproblem

approach 1: precalculate the fib series (since k<1e9, this will not be long) and then find the largest one <=n

approach 2: recursive
```cpp
int findMinFibonacciNumbers(int k) {
    int f1 = 0, f2 = 1;
    while (f2 <= k) {
        swap(f1, f2);
        f2 += f1;
    }
    return 1 + (k == f1 ? 0 : findMinFibonacciNumbers(k - f1));
}
```

### 1415. The k-th Lexicographical String of All Happy Strings of Length n
<em>
A happy string is a string that:

consists only of letters of the set ['a', 'b', 'c'].
s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).
For example, strings "abc", "ac", "b" and "abcbabcbcb" are all happy strings and strings "aa", "baa" and "ababbc" are not happy strings.

Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.

Return the kth string of this list or return an empty string if there are less than k happy strings of length n.
</em>

backtrack approach:

```cpp
    string getHappyString(int n, int k) {
        //backtrack
        string ans;
        backtrack(n,k,"",ans);
        return ans;
    }
    void backtrack(int n,int& k,string t,string& ans){
        if(t.size()==n){
            if(--k==0) {ans=t;}
            return;
        }
        for(char c='a';c<='c';c++){
            if(t.size() && c==t.back()) continue;
            t+=c;
            backtrack(n,k,t,ans);
            t.pop_back();
        }
    }
```

### 1416. Restore The Array
<em>
A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.

Given the string s and the integer k. There can be multiple ways to restore the array.

Return the number of possible array that can be printed as a string s using the mentioned program.

The number of ways could be very large so return it modulo 10^9 + 7
</em>
Intuition: dp problem, each number can attach to previous or start a new number.
```cpp
    int numberOfArrays(string s, int k) {
        //dp, current digit can be attached to previous or not
        int n=s.size();
        int mod=1e9+7;
        string sk=to_string(k);
        vector<long> dp(n+1);
        dp[0]=1;//empty string
        for(int i=1;i<=n;i++){ //length
            for(int j=i-1;j>=0 && i-j<=9;j--){ //attach to previous, j is th index
                if(j && s[j]=='0') continue; //cannot use it as leading char
                
                long num=stol(s.substr(j,i-j));
                if(num<=k) //add one combination, and it is same as previous
                    dp[i]+=dp[j],dp[i]%=mod;
                else break;
            }
        }
        return dp[n]%mod;
    }
```	


	
## biweek 25
### 1431. Kids With the Greatest Number of Candies
<em>
Given the array candies and the integer extraCandies, where candies[i] represents the number of candies that the ith kid has.

For each kid check if there is a way to distribute extraCandies among the kids such that he or she can have the greatest number of candies among them. Notice that multiple kids can have the greatest number of candies.
</em>

straightforward: give the extra to himself and see if it is >=max.

```cpp
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
        int mx=*max_element(begin(candies),end(candies));
        vector<bool> ans;
        for(int i: candies)
            ans.push_back(i>=mx-extraCandies);
        return ans;
    }
```

### 1432. Max Difference You Can Get From Changing an Integer
<em>
You are given an integer num. You will apply the following steps exactly two times:

Pick a digit x (0 <= x <= 9).
Pick another digit y (0 <= y <= 9). The digit y can be equal to x.
Replace all the occurrences of x in the decimal representation of num by y.
The new integer cannot have any leading zeros, also the new integer cannot be 0.
Let a and b be the results of applying the operations to num the first and second times, respectively.

Return the max difference between a and b.
</em>

greedy: 
to get the max number, replace the first seen number <9 to 9.
to get the min number, 
- if the first number >1, replace it to 1
- else replace the first seen number >1 to 0

```cpp
    int maxDiff(int num) {
        //replace to make one largest and one smallest
        //to make it larger, replace the first one <9 to 9
        string s=to_string(num);
        char rep=-1;
        for(char& c: s){
            if(rep<0 && c<'9') {
                rep=c;
                c='9';
            }
            if(c==rep) c='9'; 
        }
        int a=stoi(s);
        s=to_string(num);
        //find the first one >0 and change it to 0, except the first one
        rep=-1;
        int b;
        char nc,minc='0';
        if(num<9) b=1; //cannot be 0
        else{
           if(s[0]>'1') {
               rep=s[0];
               s[0]=nc='1';
           }else{//this '1' cannot be the new char
               minc='1';
           }
            
           for(int i=1;i<s.size();i++){
               if(s[i]==rep){
                   s[i]=nc;
               }
               if(rep<0 && s[i]>minc){
                   rep=s[i];
                   s[i]=nc='0';
               }
           }
        }
        b=stoi(s);
        return a-b;
    }
```
This code is too long, we can use a function:

```cpp
    int maxDiff(int num) {
        string s = to_string(num);
        
		// Replace all occurrences of the first char that is NOT included in `chs` with `ch`.
        auto f = [](string str, string chs, char ch) {
            auto pos = str.find_first_not_of(chs);
            if (pos != string::npos) {
                char a = str[pos];
                replace(begin(str), end(str), a, ch);
            }
            return stoi(str);
        };
        
		// Replacing all occurrences of the first non-'9' with '9' gives the maximum.
        int mx = f(s, "9", '9');
		
		// To get the minimum, there are two cases:
		// a) s[0] == '1': Replace all occurrences of the first char that is neither '0' nor '1' with '0'.
		// b) s[0] != '1' (or s[0] > '1'): Replace all occurrences of s[0] with '1'.
        int mn = s[0] == '1' ? f(s, "01", '0') : f(s, "1", '1');
		
        return mx - mn;
    }
```

### 1433. Check If a String Can Break Another String
<em>
Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa (in other words s2 can break s1).

A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.
</em>

equivalent: if sorted, the suffix string is consistently >= or <=

```cpp
    bool checkIfCanBreak(string s1, string s2) {
        sort(begin(s1),end(s1));
        sort(begin(s2),end(s2));
        if(s1>s2) swap(s1,s2);
        for(int i=0;i<s1.size();i++){
            if(s1[i]>s2[i]) return 0;
        }
        return 1;
    }
```
O(nlogn)

O(N) approach:
we can use bucket sort to reduce the complexity of sort. That's basically the hashmap
then we compare character by character:
note the one left shall bring forward
for example
s1: 3a2b
s2: 2a3b
then s1 has one a to go forward, leaving finally 1a vs 1b
aaabb
aabbb

```cpp
    bool checkIfCanBreak(string s1, string s2) {
		vector<int> cnt1(26),cnt2(26);
		for(char c: s1) cnt1[c-'a']++;
		for(char c: s2) cnt2[c-'a']++;
		//using prefix sum and compare
        int a=0,b=0,dir=0;
        for(int i=0;i<26;i++){
            a+=cnt1[i];
            b+=cnt2[i];
            if(dir==1 && a<b) return false;
            if(dir==2 && a>b) return false;
            if(a>b && dir==0) dir=1;
            else if(a<b && dir==0) dir=2;
        }
        return true;		
	}
```
	
### 1434. Number of Ways to Wear Different Hats to Each Other
<em>
There are n people and 40 types of hats labeled from 1 to 40.

Given a list of list of integers hats, where hats[i] is a list of all hats preferred by the i-th person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo 10^9 + 7.
</em>

Apparently this is a dp problem.
Since the bottom up relation is not that straightforward, let's start from the backtracking recursive approach first.

```cpp
    int mod=1e9+7;
	int numberWays(vector<vector<int>>& hats) {
		int n=hats.size(); //num of people
		vector<bool> v(41); //1 to 40
		return backtrack(hats,0,v);
    }
	
	long backtrack(vector<vector<int>>& hats,int start,vector<bool>& v){
		if(start>=hats.size()) return 1; //reach the end
		int ans=0;
		for(int h: hats[start]){
			if(v[h]) continue;
			v[h]=1;
			ans+=backtrack(hats,start+1,v);
			ans%=mod;
			v[h]=0;
		}
		return ans%mod;
	}
```

The approach is correct and could be verified using some example tests.
However, the complexity would be 40^n. (each person can have up to 40 choices)

Memoization approach:
memoization of above backtracking is not straightforward since it involves start and v.
v is a combination of 40 hats.
It is naturally to use bit for the v, so we need:
dp[n][1<<40], this is too much storage.

In this case, we need convert the problem equivalently to [40][1<<n] since n<10.

let's do the recursive approach first:
```cpp
    int mod=1e9+7;
	int numberWays(vector<vector<int>>& hats) {
		int n=hats.size(); //num of people
		//convert hats to people
		vector<vector<int>> h2p(41);
		for(int i=0;i<hats.size();i++){
			for(int j: hats[i]) h2p[j].push_back(i);
		}
		//now equivalent problem: with hats to differnent people, can we arrange all? 
		//if we get all bits set 1, we get one combination.
		//vector<bool> v(n); //now for n people, better using bits
		
		return backtrack(h2p,1,0,n);//start from hat 1 and state=0
    }
	
	long backtrack(vector<vector<int>>& h2p,int start,int state,int n){
		if(state==(1<<n)-1) return 1; //reach the end
        if(start>40) return 0; //tried all hats

        int ans=backtrack(h2p,start+1,state,n);//do not wear this hat.
		for(int p: h2p[start]){
			if(state&(1<<p)) continue;//if person is set.
			ans+=backtrack(h2p,start+1,state+(1<<p),n);
			ans%=mod;
		}
		return ans%mod;
	}
```
complexity would be 2^40*2^n.
- note for hats, it has two options, to be used or not used. This is similar to knapsack.

Now we can add memoization:
```cpp
    int mod=1e9+7;
	int numberWays(vector<vector<int>>& hats) {
		int n=hats.size(); //num of people
		//convert hats to people
		vector<vector<int>> h2p(41);
		for(int i=0;i<hats.size();i++){
			for(int j: hats[i]) h2p[j].push_back(i);
		}
		//now equivalent problem: with hats to differnent people, can we arrange all? 
		//if we get all bits set 1, we get one combination.
		//vector<bool> v(n); //now for n people, better using bits
		int m=1<<n;
		vector<vector<long>> dp(41,vector<int>(m,-1));
		return backtrack(h2p,1,0,n);//start from hat 1 and state=0
    }
	
	long backtrack(vector<vector<int>>& h2p,int start,int state,int n){
		if(state==(1<<n)-1) return 1; //reach the end
        if(start>40) return 0; //tried all hats
		if(dp[start][state]>=0) return dp[start][state];
        int ans=backtrack(h2p,start+1,state,n);//do not wear this hat.
		for(int p: h2p[start]){
			if(state&(1<<p)) continue;//if person is set.
			ans+=backtrack(h2p,start+1,state+(1<<p),n);
			ans%=mod;
		}
		return dp[start][state]=ans%mod;
	}
```
now the complexity is O(40*2^n)

Based on the memoization, bottom up approach can be easily obtained.	
	
## biweek 26
### 1446. Consecutive Characters
<em>
Given a string s, the power of the string is the maximum length of a non-empty substring that contains only one unique character.

Return the power of the string.
</em>

Approach: straightforward
compare with previous
```cpp
    int maxPower(string s) {
        int ans=0,cnt=0;
        char prev=s[0];
        for(char c: s){
            if(c==prev) cnt++;
            else{
                ans=max(ans,cnt);
                cnt=1;
            }
            prev=c;
            ans=max(ans,cnt);
        }
        return ans;
    }
```


### 1447. Simplified Fractions
<em>
Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. The fractions can be in any order.
</em>

brutal force:
```cpp
    vector<string> simplifiedFractions(int n) {
        //must be gcd=1
        vector<string> ans;
        for(int i=2;i<=n;i++){
            for(int j=1;j<i;j++){
                if(__gcd(j,i)==1) ans.push_back(to_string(j)+"/"+to_string(i));
            }
        }
        return ans;
    }
```

### 1448. Count Good Nodes in Binary Tree
<em>
Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.

Return the number of good nodes in the binary tree.	
</em>

Approach: preorder dfs, prev is previous max.
```cpp
    int goodNodes(TreeNode* root) {
        return helper(root,INT_MIN);
    }
    int helper(TreeNode* root,int prev){
        if(!root) return 0;
        int ans=0;
        if(root->val>=prev) ans++;
        prev=max(prev,root->val);
        ans+=helper(root->left,prev)+helper(root->right,prev);
        return ans;
        
    }
```

### 1449. Form Largest Integer With Digits That Add up to Target
<em>
Given an array of integers cost and an integer target. Return the maximum integer you can paint under the following rules:

The cost of painting a digit (i+1) is given by cost[i] (0 indexed).
The total cost used must be equal to target.
Integer does not have digits 0.
Since the answer may be too large, return it as string.

If there is no way to paint any integer given the condition, return "0".
</em>

A very good problem, and I like it.

first intuition: knapsack with repetition but with more complexity (longest and largest)
2nd intution: backtracking with memoization

- backtracking
```cpp
    string largestNumber(vector<int>& cost, int target) {
        //we shall have more digits
        //if number of digits is fixed, then we need have the largest digit first.
        //first get the longest subsequence adds to target
        //then find the lex largest longest subsequence, each one can be used multiple times
        //shall use dp. backtracking to get the 
        string ans;
        int n=cost.size();
        vector<vector<string>> dp(n,vector<string>(target+1));
        //memset(dp,-1,5000*9*sizeof(int));
        backtrack(cost,0,target,"",ans,dp);
        
        return ans.empty()?"0":ans;
    }
    string backtrack(vector<int>& cost,int ind,int val,string t,string& ans,vector<vector<string>>& dp){
        if(val==0) {
            reverse(t.begin(),t.end());
            if(t.size()>ans.size()) ans=t;
            if(t.size()==ans.size()) ans=max(ans,t);
            return t;
        }

        if(ind>=cost.size() || val<0) return "";
        //if(dp[ind][val].size()) return dp[ind][val]; //disable memo.
        //we can use 0 to val/cost[ind] times
        string ts=backtrack(cost,ind+1,val,t,ans,dp);
        for(int i=1;i<=val/cost[ind];i++){
            t+='1'+ind;
            ts=max(ts,backtrack(cost,ind+1,val-i*cost[ind],t,ans,dp));
        }
        return dp[ind][val]=ts;
    }
	```
Note above memoization will not work, but backtrack gives all correct answer.
It is a good start though.
- note val==0 must be checked before the 2nd check
- in the loop we cannot update val using val-=cost[ind] since we use it also in the loop condition

let's get the memo correct. What is the problem with above code?
[5,4,4,5,5,5,5,5,5]
29
backtracking: 9333333
memo: 4333333

- if we did not get a solution for ind and val, we set it empty, this disables the memoization. 
we can set it as "0"
- two if are incorrect and we shall use if.. else for val==0 case.
- apparently it is due to this statement: if(dp[ind][val].size()) return dp[ind][val];


After struggling for quite a time, I found the memoization is incorrect, since we define the dp incorrectly.
dp[ind][v] shall be the solution for the subproblem, but actually we return the whole answer.
In this case, we can eliminate the ind dimension.
If we want to use the 2d dp, we need strictly keep the subproblem definition, where the dp shall save the subproblem solution only.

The dp actually does not depend on the index, and is a 1d dp problem.
we choose one element and then leave a smaller target with the same array. That's the knapsack with repetition.

```cpp
string dp[5001] = {};
string largestNumber(vector<int>& cost, int t) {
    if (t <= 0)
        return t == 0 ? "" : "0";
    if (dp[t].empty()) {
        dp[t] = "0";
        for (int n = 1; n <= 9; ++n) {
            auto res = largestNumber(cost, t - cost[n - 1]);
            if (res != "0" && res.size() + 1 >= dp[t].size())
                dp[t] = to_string(n) + res;
        }
    }
    return dp[t];
}
```
## biweek 27

### 1460. Make Two Arrays Equal by Reversing Sub-array

<em>
Given two integer arrays of equal length target and arr.

In one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps.

Return True if you can make arr equal to target, or False otherwise.
</em>
- brtual force
loop from left to right, find the element in the other array and reverse to the correct position.

- hashmap: the other array need to be a permutation of the array
```cpp
    bool canBeEqual(vector<int>& target, vector<int>& arr) {
        unordered_map<int,int> mp;
        for(int i: target) mp[i]++;
        for(int i: arr) mp[i]--;
        for(auto t: mp) if(t.second) return 0;
		return 1;
	}
```	

### 1461. Check If a String Contains All Binary Codes of Size K
<em>
iven a binary string s and an integer k.

Return True if all binary codes of length k is a substring of s. Otherwise, return False.
</em>

sliding window and bool array
```cpp
    bool hasAllCodes(string s, int k) {
        int n=s.size(),m=1<<k;
        vector<bool> flag(m);
        //sliding window
        int num=0,i=0;
        while(i<n){
            num=num*2+(s[i]-'0');
            if(i>=k) num-=(s[i-k]-'0')*(1<<k);
            if(i>=k-1) flag[num]=1;
            //cout<<i<<" "<<num<<endl;
            i++;
        }
        return accumulate(begin(flag),end(flag),0)==m;
    }
```

### 1462. Course Schedule IV
<em>
There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have direct prerequisites, for example, to take course 0 you have first to take course 1, which is expressed as a pair: [1,0]

Given the total number of courses n, a list of direct prerequisite pairs and a list of queries pairs.

You should answer for each queries[i] whether the course queries[i][0] is a prerequisite of the course queries[i][1] or not.

Return a list of boolean, the answers to the given queries.

Please note that if course a is a prerequisite of course b and course b is a prerequisite of course c, then, course a is a prerequisite of course c.
</em>

- do dfs to check if we can from a to b, but it will takes too long.
- post order traversal on each node and save the parent-relation in a hashmap, query can be performed on the hashmap
```cpp
    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        vector<vector<int>> adj(n);
        for(auto p: prerequisites){
            adj[p[0]].push_back(p[1]);
        }
        //we can precalculate all ij pairs and all other false
        vector<bool> v(n);
        unordered_map<int,unordered_set<int>> mp;
        for(int i=0;i<n;i++){
            if(!v[i]) dfs(adj,i,-1,mp,v);
        }
        vector<bool> ans;
        
        for(auto q: queries){
            if(mp[q[0]].count(q[1])) ans.push_back(1);
            else ans.push_back(0);
        }
        return ans;
    }
    void dfs(vector<vector<int>>& adj,int root,int parent,unordered_map<int,unordered_set<int>>& mp,vector<bool>& v){
        //shall use postorder parent - all child
        for(int ch: adj[root]){
            dfs(adj,ch,root,mp,v);
        }
        v[root]=1;
        if(parent>=0) {
            for(auto t: mp[root])
            mp[parent].insert(t);
            mp[parent].insert(root);
        }
    }

```

we performed dfs on all nodes, so the complexity would be O(N^2), and it will TLE for large test cases.
- each node may have multiple parents and multiple children. that's why we do not use v in the dfs. but the in the main function, we use it if is alreaady visited.
- N is small up to 100, but why will it TLE?

optimization: 
in the dfs, when a node is visited, we just add the results into the hashmap.

```cpp
    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        vector<vector<int>> adj(n);
        for(auto p: prerequisites){
            adj[p[0]].push_back(p[1]);
        }
        //we can precalculate all ij pairs and all other false
        vector<bool> v(n);
        unordered_map<int,unordered_set<int>> mp;
        for(int i=0;i<n;i++){
            if(!v[i]) dfs(adj,i,-1,mp,v);
        }
        //print(mp);
        vector<bool> ans;
        
        for(auto q: queries){
            if(mp[q[0]].count(q[1])) ans.push_back(1);
            else ans.push_back(0);
        }
        return ans;
    }
    void dfs(vector<vector<int>>& adj,int root,int parent,unordered_map<int,unordered_set<int>>& mp,vector<bool>& v){
        //shall use postorder parent - all child
        //cout<<root<<endl;
        for(int ch: adj[root]){
            if(!v[ch]) dfs(adj,ch,root,mp,v);
            else{
                for(auto t: mp[ch]) mp[root].insert(t);
                mp[root].insert(ch);
            }
        }
        v[root]=1;
        if(parent>=0) {
            for(auto t: mp[root])
            mp[parent].insert(t);
            mp[parent].insert(root);
        }
    }
```

or we can build a matrix to record the connection. O(N^3).

### 1463. Cherry Pickup II

<em>
Given a rows x cols matrix grid representing a field of cherries. Each cell in grid represents the number of cherries that you can collect.

You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.

Return the maximum number of cherries collection using both robots  by following the rules below:

From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).
When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).
When both robots stay on the same cell, only one of them takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in the grid.
</em>

this is very similar to cherry pickup I where two branches start from the top left corner.
difference：
- robot can only move downward diagonal.
- for m rows, both robot walks m-1 steps.
- each row we can pick up to two cells only.
- if they step into the same cell, only one is picked.

robot 1 position (i, j1)
robot 2 position (i, j2)
at each position each robot has up to 2 choices: left or right.
4 combination
nums[i,j1]+nums[i,j2], j1 starts from 0, and j2 starts from n-1.
i+1,j1+1,j2+1
i+1,j1+1,j2-1
i+1,j1-1, j2+1
i+1,j1-1, j2-1
dp[i,j0,j1]
base case one row: 

We will try top down first:
```cpp
    int dp[70][70][70] = {};
    int cherryPickup(vector<vector<int>>& grid) {
        memset(dp, -1, sizeof(dp));
        int m = grid.size(), n = grid[0].size();
        return dfs(grid, m, n, 0, 0, n - 1);
    }
    int dfs(vector<vector<int>>& grid, int m, int n, int r, int c1, int c2) {
        if (r == m) return 0; // Reach to bottom row
        if (dp[r][c1][c2] != -1) return dp[r][c1][c2];
        int ans = 0;
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                int nc1 = c1 + i, nc2 = c2 + j;
                if (nc1 >= 0 && nc1 < n && nc2 >= 0 && nc2 < n) {
                    ans = max(ans, dfs(grid, m, n, r + 1, nc1, nc2));
                }
            }
        }
		int cherries = c1 == c2 ? grid[r][c1] : grid[r][c1] + grid[r][c2];
        return dp[r][c1][c2] = ans + cherries;
    }
```
	


```cpp
	int dp[70][70][70]={0};
    int cherryPickup(vector<vector<int>>& grid) {
		int m=grid.size(),n=grid[0].size();
        memset(dp,0,70*70*70*sizeof(int));
        if(n>1)	dp[0][0][n-1]=grid[0][n-1]+grid[0][0];
        else dp[0][0][n-1]=grid[0][0]; //only one.
		int ans=dp[0][0][n-1];
		for(int i=1;i<m;i++){
			for(int j0=0;j0<n;j0++){
				for(int j1=0;j1<n;j1++){
					int mx=0;
					for(int k=-1;k<=1;k++) { //+1 0 -1
						for(int l=-1;l<=1;l++){
                            if(j0+k<0 || j0+k>=n || j1+l<0 || j1+l>=n) continue;
							mx=max(mx,dp[i-1][j0+k][j1+l]);
						}
					}
					if(j0==j1) dp[i][j0][j1]=grid[i][j0]+mx;
					else dp[i][j0][j1]=grid[i][j0]+grid[i][j1]+mx;
                    if(i==m-1) ans=max(ans,dp[i][j0][j1]);
				}
			}
		}
		return ans;
	}
	
```	
note:
it also calculated those not reachable cells which shall be excluded.
the robot one can only reach to m-1 max. 
the robot one can reach n-1-(m-1) max.

finally the correct code:

```cpp
	int dp[70][70][70]={0};
    int cherryPickup(vector<vector<int>>& grid) {
		int m=grid.size(),n=grid[0].size();
        memset(dp,-1,70*70*70*sizeof(int));
        if(n>1)	dp[0][0][n-1]=grid[0][n-1]+grid[0][0];
        else dp[0][0][n-1]=grid[0][0]; //only one.
		int ans=dp[0][0][n-1];
		for(int i=1;i<m;i++){
			for(int j0=0;j0<min(i+1,n);j0++){
				for(int j1=max(n-1-i,0);j1<n;j1++){
                    //cout<<i<<" "<<j0<<" "<<j1<<endl;
					int mx=0;
					for(int k=-1;k<=1;k++) { //+1 0 -1
						for(int l=-1;l<=1;l++){
                            if(j0+k<0 || j0+k>=n || j1+l<0 || j1+l>=n && dp[i-1][j0+k][j1+l]<0) continue;
							mx=max(mx,dp[i-1][j0+k][j1+l]);
						}
					}
					if(j0==j1) dp[i][j0][j1]=grid[i][j0]+mx;
					else dp[i][j0][j1]=grid[i][j0]+grid[i][j1]+mx;
                    if(i==m-1) ans=max(ans,dp[i][j0][j1]);
				}
			}
		}
		return ans;
	}
```	

- using -1 to indicate not visited and not reachable
- use the fact that robot 1 can only reach to i th column and robot 2 can only reach to n-1-i th column to save a bit computation






	
## biweek 28-1475
### 1475. Final Prices With a Special Discount in a Shop

Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i], otherwise, you will not receive any discount at all.

Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount.

- brutal force O(N^2)
- stack: find next smaller- O(N)

```cpp

    vector<int> finalPrices(vector<int>& A) {
        vector<int> stack;
        for (int i = 0; i < A.size(); ++i) {
            while (stack.size() && A[stack.back()] >= A[i]) {
                A[stack.back()] -= A[i];
                stack.pop_back();
            }
            stack.push_back(i);
        }
        return A;
    }
	
	```
	
### 1476. Subrectangle Queries

mplement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:

1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)

Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
2. getValue(int row, int col)

Returns the current value of the coordinate (row,col) from the rectangle

- brutal force:
```cpp
    vector<vector<int>> rect;
    SubrectangleQueries(vector<vector<int>>& rectangle) {
        rect=rectangle;
    }
    
    void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1;i<=row2;i++){
            for(int j=col1;j<=col2;j++)
                rect[i][j]=newValue;
        }
    }
    
    int getValue(int row, int col) {
        return rect[row][col];
    }
```
or we can record the updates and then start from newest to oldest updates and see what region is in.

### 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum

Given an array of integers arr and an integer target.

You have to find two non-overlapping sub-arrays of arr each with sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.

Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays

this is two subproblem: find subarray sum=target sum and two non-overlapped region with sum of length minimized.

we start from left to right and get the left min length satisfying subarray sum==target
then get the right to left the right min length satisfying subarray sum==target.

subarray sum==target using hashmap to record the latest index.
a little bit similar to dp.

```cpp
    int minSumOfLengths(vector<int>& arr, int target) {
        unordered_map<int,int> mp0,mp1; //prefix sum vs index, suffix sum and then meet
        int n=arr.size();
        mp0[0]=-1;
        mp1[0]=n;
        
        int pre=0,post=0,i=0,j=n-1;
        int ans=INT_MAX;
        vector<int> left(n,INT_MAX),right(n,INT_MAX);//min length
        int lmin=INT_MAX,rmin=INT_MAX;
        for(int i=0;i<n;i++){
            pre+=arr[i];
            if(mp0.count(pre-target)){
                lmin=min(lmin,i-mp0[pre-target]);
            }
            mp0[pre]=i;
            left[i]=lmin;            
        }
        mp0.clear();
        mp0[0]=n;
        pre=0;
        for(int i=n-1;i>0;i--){
            pre+=arr[i];
            if(mp0.count(pre-target)){
                rmin=min(rmin,mp0[pre-target]-i);
            }
            mp0[pre]=i;
            if(rmin<INT_MAX && left[i-1]<INT_MAX) ans=min(ans,rmin+left[i-1]);
        }
        return ans<INT_MAX?ans:-1;
	}		
```


### 1478. Allocate Mailboxes

Given the array houses and an integer k. where houses[i] is the location of the ith house along a street, your task is to allocate k mailboxes in the street.

Return the minimum total distance between each house and its nearest mailbox.

The answer is guaranteed to fit in a 32-bit signed integer.	

dp: dp[i,k] for i houses with k mailboxes
k=1 is the base case
current house can combine up to k-1 to i for an additional group
however the base case is hard to get the min.

The base: given a array and 1 mailbox, what is the min distance?
brutal force: try all possible position in the house range, that would be too large O(N^2)

if two houses: any place from i to j can be OK since the distance is the same
if three houses: the median would be the best place, because lleft and right gives the same sum anywhere, but the mid will have 0 if we put on median.

```cpp
    int minDistance(vector<int>& houses, int k) {
        //divide into k groups and the sum of distance is minimized
        //dp? dp[i,k] represent to min sum for i houses and k mailbox
        int n=houses.size();
        sort(begin(houses),end(houses));
        vector<vector<long>> dp(n+1,vector<long>(k+1,INT_MAX));
        dp[0][0]=0;
        //when mailbox>=houses
        for(int g=1;g<=k;g++) {
            for(int i=0;i<=g;i++) dp[i][g]=0;
        }
        
        for(int g=1;g<=k;g++){ //mailbox, always keep i>g
            for(int i=g+1;i<=n;i++){ //number of houses
                dp[i][g]=dp[i-1][g-1]; //use it as a new segment
                for(int j=i-1;j>=g;j--){ //number of groups, need keep g-1 houses 
                    dp[i][g]=min({dp[i][g],dp[j-1][g-1]+mindist(houses,j-1,i-1)});
                }
            }
        }
        return dp[n][k]==INT_MAX?-1:dp[n][k];
    }
    int mindist(vector<int>& houses,int i,int j){
        int ans=0;
        while(i<j) ans+=houses[j--]-houses[i++];
        return ans;
    }
```

- I struggled for a long time due to the following details
- always keep the i,j >=g satisfied since other are basecases
- use long to avoid the int-max problem
- base case k=1, the answer is the accumulation of pair difference 

## biweek 29

### 1491. Average Salary Excluding the Minimum and Maximum Salary

simple
rating: *
```cpp
    double average(vector<int>& salary) {
        sort(begin(salary),end(salary));
        long sum=accumulate(begin(salary)+1,end(salary)-1,0ll);
        return double(sum)/(salary.size()-2);
    }
```
without sort, we can find min and max, but need only minus once.

### 1492. The kth Factor of n
<em>
Given two positive integers n and k.

A factor of an integer n is defined as an integer i where n % i == 0.

Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.
</em>
simple and brutal force
rating: **
```cpp
    int kthFactor(int n, int k) {
        int ans=-1;
        vector<int> f;
        f.push_back(1);
        f.push_back(n);
        for(int i=2;i*i<=n;i++){
            if(n%i==0) {
                f.push_back(i);
                if(i*i!=n) f.push_back(n/i);
            }
        }
        if(f.size()<k) return -1;
        sort(begin(f),end(f));
        return f[k-1];
    }
```

### 1493. Longest Subarray of 1's After Deleting One Element
<em>
Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array.

Return 0 if there is no such subarray.
</em>

equivalent: find the longest window containing at most one zero.
sliding window: when more than one zero is seen, start a new window.
rating: ***
```cpp
    int longestSubarray(vector<int>& nums) {
        //sliding window with one zero
        //longest window with at most one zero
        int n=nums.size();
        int ans=0;
        int i=0,j=0,pre=-1;
        while(j<n){
            if(nums[j]==0) {
                if(pre>=0){
                    i=pre+1;
                }
                pre=j;
            }
            ans=max(ans,j-i);
            //cout<<i<<" "<<j<<endl;
            j++;
        }
        return ans;
    }
```

### 1494. Parallel Courses II
<em>
Given the integer n representing the number of courses at some university labeled from 1 to n, and the array dependencies where dependencies[i] = [xi, yi]  represents a prerequisite relationship, that is, the course xi must be taken before the course yi.  Also, you are given the integer k.

In one semester you can take at most k courses as long as you have taken all the prerequisites for the courses you are taking.

Return the minimum number of semesters to take all courses. It is guaranteed that you can take all courses in some way.
</em>

- first, we need to recognize this is a dp problem.
- choosing which k courses or how many will affect further choices, indicating this is bitmask dp problem.
- top down approach
rating: *****

```cpp
    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {
        //bfs: source nodes first. (no incoming edge)
        vector<int> adj(n);//using bits
        for(auto t: dependencies)
            adj[t[1]-1]|=1<<(t[0]-1);//incoming
        //bitset dp, how do we track the status change?
        int mx=n+1;
        int m=1<<n;
        vector<int> dp(m,mx),cnt(m);//cnt: number of bits set.
        for(int i=1;i<m;i++) cnt[i]=cnt[i/2]+(i&1);
        dp[0]=0; //there is no course
        for(int state=0;state<m;state++) {
            //find all courses without pre
            //if(dp[state]<=n){
                int nstate=0;
                for(int i=0;i<n;i++){ //each course
                    if(state & (1<<i)) continue; //if course i is taken
                    if( (adj[i]&state)==adj[i]){ //all pre are taken
                        nstate|=1<<i;
                    }
                }
            //these courses can be taken in this semester or next semester
            //suppose we have l courses and at most k courses per semester.
                for(int j=nstate;j>0;j=((j-1) & nstate)){
                    if(cnt[j]<=k) dp[state|j]=min(dp[state|j],dp[state]+1);
                }
            //}
        }
        return dp[m-1];
    }
```	
## biweek 30

### 1507. reformat date
<em>
Given a date string in the form Day Month Year, where:

Day is in the set {"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}.
Month is in the set {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}.
Year is in the range [1900, 2100].
Convert the date string to the format YYYY-MM-DD, where:

YYYY denotes the 4 digit year.
MM denotes the 2 digit month.
DD denotes the 2 digit day.
</em>

```cpp
    string reformatDate(string date) {
        string day,mon,year;
        stringstream ss(date);
        unordered_map<string,string> mp={{"Jan","01"}, {"Feb","02"},{"Mar","03"}, {"Apr","04"}, {"May","05"}, {"Jun","06"}, {"Jul","07"},
                                         {"Aug","08"}, {"Sep","09"}, {"Oct","10"}, {"Nov","11"}, {"Dec","12"}};
        ss>>day>>mon>>year;
        string nday;
        for(char c: day) if(isdigit(c)) nday+=c;
        if(nday.size()<2) nday="0"+nday;
        return year+"-"+mp[mon]+"-"+nday;
    }
```
	
### 1508. Range Sum of Sorted Subarray Sums
<em>
Given the array nums consisting of n positive integers. You computed the sum of all non-empty continous subarrays from the array and then sort them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.

Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7.
</em>

brutal force:

```cpp
    int rangeSum(vector<int>& nums, int n, int left, int right) {
        int mod=1e9+7;
        vector<int> prefix(1);
        for(int i: nums) prefix.push_back((prefix.back()+i));
        vector<int> sum;
        for(int i=0;i<prefix.size();i++){
            for(int j=i+1;j<prefix.size();j++)
                sum.push_back((prefix[j]-prefix[i]));
        }
        //for(int i: sum) cout<<i<<" ";
        sort(begin(sum),end(sum));
        int ans=0;
        for(int i=left-1;i<right;i++) 
            ans+=sum[i],ans%=mod;
        return ans;
    }
```
this uses O(N^2) space and O(N^2logN) time complexity.

priority_queue: 	
- sort on the fly
- pop when size > right. (not a significant optimization)

### 1509. Minimum Difference Between Largest and Smallest Value in Three Moves
<em>
Given an array nums, you are allowed to choose one element of nums and change it by any value in one move.

Return the minimum difference between the largest and smallest value of nums after perfoming at most 3 moves.
</em>

equivalent: choose 3 elements and discard them.
approach: sort the array, and use n-3 as the window and get the max-min and find the min.

```cpp
    int minDifference(vector<int>& nums) {
        //at most 3 moves
        //greedy: assume we change an element to x (it shall be inside the max and min, maybe the median)
        //equivalent: we discard at most three numbers, and get the min difference
        if(nums.size()<4) return 0;
        sort(begin(nums),end(nums));
        //for(int i: nums) cout<<i<<" ";
        int ans=INT_MAX;
        int w=nums.size()-3;//sliding window
        for(int i=0;i+w<=nums.size();i++){
            ans=min(ans,nums[i+w-1]-nums[i]);
        }
        return ans;
    }
```

### 1510. Stone Game IV
<em>
Alice and Bob take turns playing a game, with Alice starting first.

Initially, there are n stones in a pile.  On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.

Also, if a player cannot make a move, he/she loses the game.

Given a positive integer n. Return True if and only if Alice wins the game otherwise return False, assuming both players play optimally.
</em>

dp: dp[i]=1 if dp[i-j*j]=0 (opponent lose)
```cpp
    bool winnerSquareGame(int n) {
        //dp[n]-- dp[n-j*j], check if any will give win result
        vector<bool> dp(n+1);
        if(n<2) return 1;
        dp[1]=1;//leave 1 stone for other play, we will lose
        
        for(int i=2;i<=n;i++){
            for(int j=1;j*j<=i;j++){
                if(dp[i-j*j]==0){
                    dp[i]=1;
                    break;
                }
            }
        }
        return dp[n];
    }
```
	
## biweek 31

### 1523. Count odd numbers in an interval range
given range [L,R], count how many odd numbers
idea: reduce to neighboring distance to 1.
```cpp
    int countOdds(int low, int high) {
        return (high+1)/2-low/2;
    }
```

Note: low side: left biased, high side: right biased.

### 1524. Number of Sub-arrays With Odd Sum
<em>
Given an array of integers arr. Return the number of sub-arrays with odd sum.

As the answer may grow large, the answer must be computed modulo 10^9 + 7.
</em>

dp approach:
odd[i] is the number of odd subarrays ending with element i.
and our final answer is the sum of all odd[i].

- if current number is odd, then odd[i]=1+even[i-1]
- if current number is even then eve[i]=1+odd[i-1]

```cpp
    int numOfSubarrays(vector<int>& arr) {
        int mod=1e9+7;
        //ending with a[i]
        int n=arr.size();
        vector<int> odd(n+1),even(n+1);//number of odd/even with length n
        even[0]=0;
        int ans=0;
        for(int i=1;i<=n;i++){
            if(arr[i-1]%2){ //current is odd, attached to previous even
                odd[i]=1+even[i-1];//itself is an odd
                even[i]=odd[i-1];
            }
            else { //even
                odd[i]=odd[i-1];
                even[i]=1+even[i-1];//itself is an even
            }
            ans+=odd[i];
            ans%=mod;
        }
        return ans;
    }
```

### 1525. Number of Good Ways to Split a String
<em>
You are given a string s, a split is called good if you can split s into 2 non-empty strings p and q where its concatenation is equal to s and the number of distinct letters in p and q are the same.

Return the number of good splits you can make in s.
</em>

sliding window: possible cut from 0 to n-2.

```cpp
    int numSplits(string s) {
        //sliding window
        vector<int> cnt(26),v(26);
        for(char c: s) cnt[c-'a']++;
        int ans=0;
        for(int i=0;i<s.size()-1;i++){
            char c=s[i];
            v[c-'a']++;
            ans+=valid(v,cnt);
            //cout<<i<<" "<<ans<<endl;
        }
        return ans;
    }
    bool valid(vector<int>& a, vector<int>& b){
        int suma=0,sumb=0;
        for(int i=0;i<26;i++){
            suma+=a[i]>0;
            sumb+=(b[i]-a[i])>0;
        }
        return suma==sumb;
    }
```

### 1526. Minimum Number of Increments on Subarrays to Form a Target Array
</em>
Given an array of positive integers target and an array initial of same size with all zeros.

Return the minimum number of operations to form a target array from initial if you are allowed to do the following operation:

Choose any subarray from initial and increment each value by one.
The answer is guaranteed to fit within the range of a 32-bit signed integer.
</em>
equivalent from 0 to target or from target to 0.
for example [1,2,3,2,1]
first reduce the min to 0. [0,1,2,1,0]
then reduce the next min [0,0,1,0,0]
total 3 steps.
[3,1,5,4,2]->
[2,0,4,3,1]->
[1,0,4,3,1]->
[0,0,4,3,1]->
[0,0,3,2,0]->
[0,0,2,1,0]->
[0,0,1,0,0]->
[0,0,0,0,0]

we can do like this:
it seems a monotonic stack problem. The local max determines the number of steps.
for example: [3,1,5,4,2], we need 3 steps first to bring 3 to 0
then we see 5, need 4 steps (not 2).

this hints us to accumulate the difference.

```cpp
    int minNumberOperations(vector<int>& A) {
        int res = A[0];
        for (int i = 1; i < A.size(); ++i)
            res += max(A[i] - A[i - 1], 0);
        return res;
    }
```
explanation:

We encounter a number less than a[0] (a[1] < a[0]): In this case we can simply reuse the same operations that we did for a[0]. i.e If array was (3, 2), we can first perform 3 operations and then use 2 of the same operations in next term. However, going forward, we will only have a[1] operations available for reuse.

We encounter a number greater than a[0] (a[1] > a[0]): In this case we can simply reuse the same operations that we did for a[0]. And additionally, we will perform a[1] - a[0] more operation to reach a[1]. Again, going forward, we will have a[1] operations available for reuse.	


 
	
	
 
## biweek 32

### 1539. kth missing positive numbers
- approach 1: linear
we can start 1, if less than curr, add 1
one important: A[i]-(i+1) is the number of missed.
- approach 2: binary search.
using above A[i]-(i+1) is the missing numbers. 
if A[m]-(m+1)<k, then it is on right side. 
else >=k, 

```cpp
    int findKthPositive(vector<int>& A, int k) {
        int l = 0, r = A.size(), m;
        while (l < r) {
            m = (l + r + 1) / 2;
            if (m == 0 || A[m - 1] - m < k)
                l = m;
            else
                r = m - 1;
        }
        return l + k;
    }
```
tag: array, search
rating: ***

### 1540. Can Convert String in K Moves
<em>
Given two strings s and t, your goal is to convert s into t in k moves or less.

During the ith (1 <= i <= k) move you can:

Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.
Do nothing.
Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times.

Remember that any index j can be picked at most once.

Return true if it's possible to convert s into t in no more than k moves, otherwise return false.

 

Example 1:

Input: s = "input", t = "ouput", k = 9
Output: true
Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.
</em>

idea:

using hashmap to record the shift required. 
for example if we have two different chars with both 2 shifts, then the first one would be 2, second shall be 2+28.
Thus we just need check if the (cnt-1)*26+shift <=k.

```cpp
    bool canConvertString(string s, string t, int k) {
		if(s.size()!=t.size()) return 0;
		vector<int> cnt(26);
		for(int i=0;i<s.size();i++){
			if(s[i]!=t[i]){
				int shift=(t[i]-s[i]+26)%26;
				if(cnt[shift]*26+shift>k) return 0;
				cnt[shift]++;
			}
		}
		return 1;
	}
```
tag: hashmap
rating: ***

### 1541. Minimum Insertions to Balance a Parentheses String
<em>
Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:

Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.
Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.
For example, "())", "())(())))" and "(())())))" are balanced, ")()", "()))" and "(()))" are not balanced.

You can insert the characters '(' and ')' at any position of the string to balance it if needed.

Return the minimum number of insertions needed to make s balanced.
</em>

idea:
- left parenthesis add 2, right parenthesis subtract 1.
- anytime the prefix shall be >=0
- anytime we see a left parenthesis, the prefix shall be even

```cpp
    int minInsertions(string s) {
        int cnt=0;
        int ans=0;
        for(char c: s){
            if(c=='(') {
                if(cnt%2) ans++,cnt--;
                cnt+=2;
            }
            else cnt--;
            if(cnt<0) ans++,cnt+=2; //add a (
            //if(cnt%2) ans++,cnt--;//add a )
        }
        ans+=cnt; //add right
        return ans;
    }
```
tag: array, prefix sum
rating: **

### 1542. Find Longest Awesome Substring
<em>
Given a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it palindrome.

Return the length of the maximum length awesome substring of s.

 

Example 1:

Input: s = "3242415"
Output: 5
Explanation: "24241" is the longest awesome substring, we can form the palindrome "24142" with some swaps.
Example 2:

Input: s = "12345678"
Output: 1
Example 3:

Input: s = "213123"
Output: 6
Explanation: "213123" is the longest awesome substring, we can form the palindrome "231132" with some swaps.

</em>

since s up to 10^5, O(N^2) approach surely TLE, but it is still a good start though.

idea:
- binary search will not work since if we can find len=m pal-subregion, but we may not find len<m pal-subregion.
- a palindrome: at most have a character which appears odd times.
- it is naturally to use vector<int>(10) to record the char's occurrance.
- but we do not need really know the actual occurrence, we only need to know odd/even, which can be expressed as binary.

```cpp
    int longestAwesome(string s) {
        if(s.empty()) return 0;
        int ans=1; //at least we have 1. binary search does not meet invariant.
        int n=s.size();
        int mask=0;
        //using bit to indicate odd even
        vector<int> dp(n+1);//stores the cnt for each digit
        for(int i=0;i<s.size();i++){
            mask^=1<<(s[i]-'0');
            dp[i+1]=mask;
            for(int j=0;j<=i;j++){ //[i,j]
                if(valid(dp[i+1],dp[j])) {
                    ans=max(ans,i-j+1);break;
                }
            }
        }
        return ans;
    }
    bool valid(int a,int b){ //use bit to indicate the digit's odd or even
        return (bitset<10>(a^b).count())<=1;
    }
```	
this will TLE for the last test case.
we need optimize to O(nlogn) or O(N)

this is actually 2d dp, with bitmask. we may consider the other dimension.
using dp[1024], we only need to find the one with at most 1 bit difference.
dp[mask] stores the mask with the index.
```cpp
int longestAwesome(string s) {
    vector<int> dp(1024, s.size()); //set them as max.
    int res = 0, mask = 0;
    dp[0] = -1;
    for (auto i = 0; i < s.size(); ++i) {
        mask ^= 1 << (s[i] - '0');
        res = max(res, i - dp[mask]); //same mask
        for (auto j = 0; j <= 9; ++j) //mask with 1 bit difference.
            res = max(res, i - dp[mask ^ (1 << j)]);
        dp[mask] = min(dp[mask], i);
    }
    return res;
}
```
	
tag: dp, bitmask
rating: ****
	

## biweek 33
1556. Thousands separater
1557. Minimum Number of Vertices to Reach All Nodes
1558. Minimum Numbers of Function Calls to Make Target Array
1559. Detect Cycles in 2D Grid
### 1556. Thousands separater
one pass. remaining digits is 3 multiples, add '.'
```cpp
    string thousandSeparator(int n) {
        string s=to_string(n);
        int m=s.size();
        string ans;
        for(int i=0;i<m;i++){
            ans+=s[i];
            if((m-i-1)%3==0) ans+='.';
        }
        if(ans.back()=='.') ans.pop_back();
        return ans;
    }
```	

### 1557. Minimum Number of Vertices to Reach All Nodes
<em>
Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.

Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.

Notice that you can return the vertices in any order.
</em>

greedy: only source nodes are not reachable. 

```cpp
    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
        vector<int> ans;
        //all souce nodes shall be included.
        vector<vector<int>> adj(n);
        for(auto e: edges){
            adj[e[1]].push_back(e[0]);
        }
        for(int i=0;i<n;i++){
            if(adj[i].empty()) ans.push_back(i);
        }
        return ans;
    }
```

### 1558. Minimum Numbers of Function Calls to Make Target Array
equiv: you can -1 or /2 if it is even.
O(nlogn):
if it is odd, add 1.
if mx>0 we /2.

```cpp
    int minOperations(vector<int>& nums) {
        int ans=0;
        int mx=INT_MIN;
        while(mx){
            mx=INT_MIN;
            for(int& i: nums){
                ans+=i%2; //current is odd, dec it by 1
                i/=2;
                mx=max(mx,i);
            }
            ans+=mx>0;
        }
        return ans;
    }
```	
	
### 1559. Detect Cycles in 2D Grid
<em>
Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.

A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.

Also, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.

Return true if any cycle of the same value exists in grid, otherwise, return false.
 </em>

The critical point is to avoid visit parent again.
```cpp
    bool containsCycle(vector<vector<char>>& grid) {
        //dfs if there is a cycle, any cell on it can detect the cycle
        int m=grid.size(),n=grid[0].size();
        vector<int> v(m*n);
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(v[i*n+j]==0 && dfs(grid,i,j,-1,-1,grid[i][j],v)) return 1;
            }
        }
        return 0;
    }
    bool dfs(vector<vector<char>>& g,int i,int j,int pi,int pj,char c,vector<int>& v){
        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]!=c) return 0;
        int np=i*g[0].size()+j; //current node as new parent
        if(v[np]) return 1; 
        v[np]=1;//in explore
        //return dfs(g,i-1,j,i,j,c,v)||dfs(g,i+1,j,i,j,c,v)||dfs(g,i,j-1,i,j,c,v)||dfs(g,i,j+1,i,j,c,v);
        
        int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(auto d:dir){
          int ni=i+d[0], nj=j+d[1];
          if(ni==pi && nj==pj) continue; // need to ensure we don't go back to the parent
          if(dfs(g,ni,nj,i,j,c,v)) return 1;
        }
        return 0;
    }
```

I had a bug which I wasted a lot of time by using the code:
```cpp
    bool containsCycle(vector<vector<char>>& grid) {
        //dfs if there is a cycle, any cell on it can detect the cycle
        int m=grid.size(),n=grid[0].size();
        vector<int> v(m*n);
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(v[i*n+j]==0 && dfs(grid,i,j,-1,-1,grid[i][j],v)) return 1;
            }
        }
        return 0;
    }
    bool dfs(vector<vector<char>>& g,int i,int j,int pi,int pj,char c,vector<int>& v){
        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]!=c || (pi==i && pj==j)) return 0;
        int np=i*g[0].size()+j; //current node as new parent
        if(v[np]) return 1; 
        v[np]=1;//in explore
        return dfs(g,i-1,j,i,j,c,v)||dfs(g,i+1,j,i,j,c,v)||dfs(g,i,j-1,i,j,c,v)||dfs(g,i,j+1,i,j,c,v);
    }
```	
according to above code:
(i,j)->(i-1,j)  ->(i-2,j) <br/>
   	|->(i+1,j) |->(i,j) cannot avoid this since now parent is (i-1,j)<br/>
	  |->(i,j-1) |->(i-1,j-1)<br/>
	  |->(i,j+1) |->(i-1,j+1)<br/>
to avoid parent information lost, we shall use the parent information before calling recursive.
In above example, (i,j) is actually the current node's parent parent and that's why immdidate parent does not work. 
Check before calling, then we use the mid node for previous and next step.
## biweek 34

1575	Count All Possible Routes    		59.3%	Hard	
1574	Shortest Subarray to be Removed to Make Array Sorted    		24.1%	Medium	
1573	Number of Ways to Split a String    		27.8%	Medium	
1572	Matrix Diagonal Sum    		77.5%	Easy	

### 1572. Matrix diagnonal sum
simple, diagonal i=j, 2nd diagonal i+j=n-1

```cpp
    int diagonalSum(vector<vector<int>>& mat) {
        int ans=0,n=mat.size();
        for(int i=0;i<mat.size();i++)
            ans+=mat[i][i]+(i!=n-i-1?mat[i][n-i-1]:0);
        return ans;
        
    }
```

### 1573. Number of Ways to Split a String
<em>
Given a binary string s (a string consisting only of '0's and '1's), we can split s into 3 non-empty strings s1, s2, s3 (s1+ s2+ s3 = s).

Return the number of ways s can be split such that the number of characters '1' is the same in s1, s2, and s3.

Since the answer may be too large, return it modulo 10^9 + 7.

</em>

idea:
- check number of 1 is 3 multiples
- no 1s, equivalent to put 2 separaters in 1 to n-1 C(n-1,2)
- count the left parts trailing zeros, and mid parts trailing zero (or right part leading zeros)

```cpp
    int numWays(string s) {
        int ans=0,mod=1e9+7;
        int cnt1=0,n=s.size();
        for(char c: s) cnt1+=c-'0';
        if(cnt1%3) return 0;
        if(cnt1==0) return ((long)(n-1)*(n-2)/2)%mod;
        int target=cnt1/3;
        int i=0,j=s.size()-1;
        cnt1=0;
        while(cnt1<target) cnt1+=s[i++]-'0'; //left boundary
        int l=0,r=0;
        while(i<j-1 && s[i]=='0') l++,i++;
        cnt1=0;
        while(cnt1<target) cnt1+=s[j--]-'0'; //right boundary
        while(i<j && s[j]=='0') r++,j--;
        return (long)(l+1)*(r+1)%mod;
    }
```
do not forget to convert to long.

### 1574. Shortest Subarray to be Removed to Make Array Sorted
<em>
Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.

A subarray is a contiguous subsequence of the array.

Return the length of the shortest subarray to remove.
</em>

binary search: O(nlogn)
```cpp
    int findLengthOfShortestSubarray(vector<int>& arr) {
        int l=0,n=arr.size(),r=n-1;
        while(l<r){
            int m=l+(r-l)/2;
            bool t=valid(arr,m);
            if(t) r=m;
            else l=m+1;
        }
        return l;
    }
    bool valid(vector<int>& arr,int m){
        //sliding window to remove a subarray 
        int n=arr.size();
        vector<int> rmin(n+1,-1);
        rmin[n]=INT_MAX;
        rmin[n-1]=arr[n-1];
        int r=1;
        for(int i=n-2;i>=0 && arr[i]<=arr[i+1];i--) rmin[i]=min(rmin[i+1],arr[i]),r++;
        if(r>=n-m) return 1;
        int lmax=0;
        for(int i=0;i<n-m && (i==0 || arr[i-1]<=arr[i]);i++){ 
            lmax=max(lmax,arr[i]);
            if(lmax<=rmin[i+m+1] || i+1>=n-m) return 1;
        }
        return 0;
    }
```	
note:
- it could be the left only, right only
- it could be the left + right.

O(N) approach:
we have 3 options:
- delete the left parts
- delete the right parts
- delete the mid parts.
choose the longest among the three.
connect left and right using two pointer approach. for i, we advance j until a[j]>=a[i] get the length
and then advance i by 1 and get j and length.

### 1575. Count All Possible Routes
<em>
You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.

At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.

Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).

Return the count of all possible routes from start to finish.

Since the answer may be too large, return it modulo 10^9 + 7.

 </em>
 
- intuition: dfs with memoization. or dp.
dp[start,fuel] is the status.

```cpp
    long dp[101][201] = {}, mod = 1e9+7, finish;
    int dist(vector<int> &A, int a, int b) {
        return abs(A[a] - A[b]);
    }
    int dfs(vector<int> &A, int start, int fuel) {
        if (dp[start][fuel]) return dp[start][fuel];
        long ans = 0;
        if (start == finish) ans++;
        for (int i = 0; i < A.size(); ++i) {
            if (i == start || dist(A, start, i) + dist(A, i, finish) > fuel) continue;
            ans = (ans + dfs(A, i, fuel - dist(A, i, start))) % mod;
        }
        return dp[start][fuel] = ans;
    }
public:
    int countRoutes(vector<int>& A, int start, int finish, int fuel) {
        this->finish = finish;
        return dfs(A, start, fuel);
    }
```

	


 


	

 
## biweek 35

### 1588. Sum of All Odd Length Subarrays
<em>Given an array of positive integers arr, calculate the sum of all possible odd-length subarrays.

A subarray is a contiguous subsequence of the array.

Return the sum of all odd-length subarrays of arr.</em>

approach 1: brutal force with each element as the end.
O(N^3)
```cpp
    int sumOddLengthSubarrays(vector<int>& arr) {
        int ans=0,n=arr.size();
        for(int i=0;i<arr.size();i++){
            for(int j=i;j>=0 && (j-i)%2==0;j-=2){
                for(int k=j;k<=i;k++) ans+=arr[k];
            }
        }
        return ans;
    }
```

optimization:
[1,4,2,5,3] length=5
[1]
[4]
[2]
[1,4,2]
[5]
[4,2,5]
[3]
[2,5,3]
[1,4,2,5,3]
1 appears 3 times
4 appears 4 times
2 appears 5 times
5 appears 3 times
3 appears 3 times

subarrays containing A[i]:
left has 0,1,2,...i, total i+1 choices
right has i,i+1...n-1 total n-i choices
total subarrays containing A[i]: (i+1)*(n-i)
total subarrays containing A[i] with odd length: ((i+1)*(n-i)+1)/2
O(N)

```cpp
    int sumOddLengthSubarrays(vector<int>& A) {
        int res = 0, n = A.size();
        for (int i = 0; i < n; ++i) {
            res += ((i + 1) * (n - i) + 1) / 2 * A[i];
        }
        return res;
    }
```

### 1589. Maximum Sum Obtained of Any Permutation
<em>
We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.

Return the maximum total sum of all requests among all permutations of nums.

Since the answer may be too large, return it modulo 109 + 7.
</em>

idea: get the histogram of all query ranges and greedily assign the larger value to the one with higher frequency

```cpp
    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {
        int mod=1e9+7;
        //greedy: the highest freq components need to be bigger
        sort(begin(nums),end(nums));
        map<int,int> mp;
        for(auto r: requests){
            mp[r[0]]++;
            mp[r[1]+1]--;
        }
        int pre=0;
        vector<int> freq(nums.size());
        int i=0;
        for(auto t: mp){
            pre+=t.second;
            for(;i<t.first;i++) freq[i]=pre-t.second;
        }
        //sort according to the freq
        sort(begin(freq),end(freq));
        long ans=0,n=nums.size();
        for(int i=0;i<n;i++){
            ans+=(long)freq[i]*nums[i]%mod;
            ans%=mod;
        }
        return ans;
    }
```	

### 1590. Make Sum Divisible by P
<em>
Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.

Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.

A subarray is defined as a contiguous block of elements in the array
</em>

idea:
the total sum %p=tsum, equivalently find the min subarray with sum%p=tsum.
so this is a hashmap problem similar to 2 sum

```cpp
    int minSubarray(vector<int>& nums, int p) {
        //tsum%p and find smallest subarray with psum%p==tsum%p
        int ans=nums.size();
        int tsum=0;
        for(int i: nums) tsum+=i,tsum%=p;
        if(tsum==0) return 0;
        int pre=0;
        unordered_map<int,int> mp; //prefix sum vs index
        mp[0]=-1;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%p==tsum) return 1;
            pre+=nums[i],pre%=p;
            if(mp.count(pre-tsum)) ans=min(ans,i-mp[pre-tsum]);
            if(mp.count(pre+p-tsum)) ans=min(ans,i-mp[pre-tsum+p]);
            mp[pre]=i;
        }
        return ans==nums.size()?-1:ans;
    }
```

actually we do not need pre-tsum and pre+p-tsum but using (pre+p-tsum)%p equivalently.

### 1591. Strange Printer II
<em>
There is a strange printer with the following two special requirements:

On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.
Once the printer has used a color for the above operation, the same color cannot be used again.
You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.

Return true if it is possible to print the matrix targetGrid, otherwise, return false.
</em>

This is actually straightforward.
we calculate each element's rectangle and print one by one and replace them with 0.
The sequence is we shall print the subrect containing only the element and 0.

```cpp
    bool isPrintable(vector<vector<int>>& targetGrid) {
        //the one with single element shall be printed first.
        //reverse and return to all 0.
        unordered_map<int,vector<int>> mp;
        int m=targetGrid.size(),n=targetGrid[0].size();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                mp[targetGrid[i][j]].push_back(i*n+j);
            }
        }
        return valid(mp,targetGrid);
    }
    //we will eliminate one valid prints in one round
    bool valid(unordered_map<int,vector<int>>& mp,vector<vector<int>>& targetGrid){
        //start from smallest rect.
        //top left and bottom right
        int m=targetGrid.size(),n=targetGrid[0].size();
        bool ans=0;
        while(mp.size()){
            //print(targetGrid);
            int sz=mp.size();
            for(auto t: mp){
                bool found=1;
                int xmin=m,xmax=0,ymin=n,ymax=0;
                for(auto j: t.second){
                    int r=j/n,c=j%n;
                    xmin=min(xmin,r),xmax=max(xmax,r);
                    ymin=min(ymin,c),ymax=max(ymax,c);
                }
                for(int i=xmin;i<=xmax && found;i++){
                    for(int j=ymin;j<=ymax;j++){
                        if(targetGrid[i][j] && targetGrid[i][j]!=t.first) {
                            found=0;
                            break;
                        }   
                    }
                }
            
                if(found){
                    for(int i=xmin;i<=xmax;i++){
                        for(int j=ymin;j<=ymax;j++){
                            targetGrid[i][j]=0;
                        }
                    }
                    mp.erase(t.first);
                    break;
                }
            }
            if(mp.size()==sz) break;
        }
        return mp.empty();
    }
```	

	

	
## biweek 36

1603. Design Parking System.
<em>
Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.

Implement the ParkingSystem class:

ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.
bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.
</em>

very simple:

```cpp
    vector<int> cap;
    ParkingSystem(int big, int medium, int small) {
        cap.push_back(big);
        cap.push_back(medium);
        cap.push_back(small);
    }
    
    bool addCar(int carType) {
        if(cap[carType-1]>0) {
            cap[carType-1]--;
            return 1;
        }
        return 0;
    }
```

1604. Alert Using Same Key-Card Three or More Times in a One Hour Period

<em>
LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an alert if any worker uses the key-card three or more times in a one-hour period.

You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.

Access times are given in the 24-hour time format "HH:MM", such as "23:51" and "09:49".

Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.

Notice that "10:00" - "11:00" is considered to be within a one-hour period, while "22:51" - "23:52" is not considered to be within a one-hour period.
</em>

approach: using hashmap and sliding window
need sort in time and sort in name.
sliding window either using dq or two pointer.

```cpp
    vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {
        set<string> ans;
        unordered_map<string,set<int>> mp;
        for(int i=0;i<keyName.size();i++){
            int t=stoi(keyTime[i].substr(0,2))*60+stoi(keyTime[i].substr(3));
            mp[keyName[i]].insert(t);
        }
        for(auto t: mp){
            deque<int> dq;
            for(int i: t.second){
                while(dq.size()>=2 && dq.front()+60<i) dq.pop_front();
                dq.push_back(i);
                if(dq.size()>=3) ans.insert(t.first);
            }
        }
        return {begin(ans),end(ans)};
    }
```	

1605. Find Valid Matrix Given Row and Column Sums
<em>

You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.

Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.

Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.
</em>

math problem:
- A[i,j] is bound by the min(row[i],col[j]) (all non-negative)
- greedy choose the max =min(row[i],col[j]) will not break the validness.
sum(rsum)=sum(csum)
when choose min(rsum[i],csum[j]) 
sum(rsum)-min(rsum[i],csum[j]) =sum(csum)-min(rsum[i],csum[j]) 

```cpp
    vector<vector<int>> restoreMatrix(vector<int>& row, vector<int>& col) {
        int m = row.size(), n = col.size();
        vector<vector<int>> A(m, vector<int>(n, 0));
        for (int i = 0; i < m; ++i) {
            for (int j = 0 ; j < n; ++j) {
                A[i][j] = min(row[i], col[j]);
                row[i] -= A[i][j];
                col[j] -= A[i][j];
            }
        }
        return A;
    }
```

1606. Find Servers That Handled Most Number of Requests
<em>
You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:

The ith (0-indexed) request arrives.
If all servers are busy, the request is dropped (not handled at all).
If the (i % k)th server is available, assign the request to that server.
Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.
You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another array load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.

Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.
k<=10^5

</em>

brutal force O(N^2) will TLE:

```cpp
    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
        vector<int> nextTime(k);
        vector<int> cnt(k),ans;
        int mx=0;
        for(int i=0;i<arrival.size();i++){
            int start=i%k;
            for(int j=start;j<start+k;j++){
                if(nextTime[j%k]<=arrival[i]){
                    cnt[j%k]++;
                    nextTime[j%k]=arrival[i]+load[i];
                    mx=max(mx,cnt[j%k]);
                    break;
                }
            }
        }
        for(int i=0;i<k;i++){
            if(cnt[i]==mx) ans.push_back(i);
        }
        return ans;
    }
```	

We need optimize it to O(N) or O(nlogn).
We shall be able to find the next free server using O(logn) time.
The difficulty is after the start sever, there are servers which cannot satisfy the time requirement. 

can we use priority_queue for this?
- start,....start+k-1, we need update all the server id after start.
- expand the server list and unwrap the circular so we can do lower_bound.
- use time,id pair as the pq element. we need time<arrival and id>start.
- min heap

approach: sort the time in the pq, sort the free servers.
this will save some time and will pass the time requirement.

```cpp
    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {
        set<int> free;
        int n = arr.size();
        for (int i = 0; i < 2*k - 1; i ++)
            free.insert(i);
        vector<int> cnt(k, 0);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (int i = 0; i < n; i ++)
        {
            int at = arr[i];
            int load = lo[i];
            while (!pq.empty() and pq.top().first <= at)
            {
                auto tt = pq.top();
                int server = tt.second;
                pq.pop();
                free.insert(server);
                free.insert(server + k);
            }
            if (!free.empty()) {
                int server = (*free.lower_bound(i % k)) % k;
                free.erase(server % k);
                free.erase(server % k + k);

                cnt[server] ++;
                pq.push({at + load, server});
            }
        }
        int mv = -1;
        vector<int> res;
        for (int i = 0; i < k; i ++)
        {
            if (cnt[i] > mv)
            {
                mv = cnt[i];
                res = {i};
            }
            else if (cnt[i] == mv)
                res.push_back(i);
        }
        return res;
    }
```	

## biweek 37

### 1619. Mean of Array After Removing Some Elements
<em>
Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.

Answers within 10-5 of the actual answer will be considered accepted.
</em>

straightforward, sort and average. 
```cpp
    double trimMean(vector<int>& arr) {
        double ans=0;
        int n=arr.size();
        sort(begin(arr),end(arr));
        int mx=arr.back();
        
        int nrm=n*0.05;
        int i=nrm,j=n-1-nrm;
        int m=j-i+1;
        int sum=0;
        for(;i<=j;i++) sum+=arr[i];
        return sum*1.0/m;
    }
```
	
Note it is not removing 5% of the max.

### 1620. Coordinate With Maximum Network Quality
<em>
You are given an array of network towers towers and an integer radius, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. All the coordinates are integral coordinates on the X-Y plane, and the distance between two coordinates is the Euclidean distance.

The integer radius denotes the maximum distance in which the tower is reachable. The tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable.

The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula ⌊qi / (1 + d)⌋, where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.

Return the integral coordinate where the network quality is maximum. If there are multiple coordinates with the same network quality, return the lexicographically minimum coordinate.

Note:

A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either x1 < x2 or x1 == x2 and y1 < y2.
⌊val⌋ is the greatest integer less than or equal to val (the floor function).
</em>

idea: 
- find the minx maxx,miny,maxy and the rectangle shall all evaulated
- do not need to store all the results, but find the max.
- use min customized compare

hashmap: will be able to avoid many no-need calculate grids
will have to use x*256+y as the key to avoid string combination of x and y (which is slower)

```cpp
    vector<int> bestCoordinate(vector<vector<int>>& towers, int radius) {
		int minx=INT_MAX,maxx=INT_MIN,miny=INT_MAX,maxy=INT_MIN;
		for(auto t: towers){
			minx=min(minx,t[0]-radius),maxx=max(maxx,t[0]+radius);
			miny=min(miny,t[1]-radius),maxy=max(maxy,t[1]+radius);
		}
		vector<int> ans={0,INT_MAX,INT_MAX};
	
		
		for(int i=minx;i<=maxx;i++){
			for(int j=miny;j<=maxy;j++){
				int q=0;
				for(auto t: towers){
					int dx=t[0]-i,dy=t[1]-j;
					int d2=dx*dx+dy*dy;
					if(d2>radius*radius) continue;
					q+=t[2]/(1+sqrt(d2));
				}
				ans=min(ans,{q,i,j},[](const vector<int>& a,const vector<int>& b){
					return a[0]>b[0] || (a[0]==b[0] && (a[1]<b[1] || (a[1]==b[1] && a[2]<b[2])));
				});
			}
		}
		return {begin(ans)+1,end(ans)};
    }
```

O(N^3) will TLE.
	
One optimization: 
when searching for minx/maxx, miny/maxy we do not need add radius (outside will be smaller)
1100ms

using hashmap to reduce unnecessary computation
```cpp
    vector<int> bestCoordinate(vector<vector<int>>& towers, int radius) {
        int minx=50,miny=50,maxx=0,maxy=0;
        unordered_map<int,int> ms;
        for(auto t: towers){
            int x0=t[0],y0=t[1],q0=t[2];
            for(int x=-radius;x<=radius;x++){
                for(int y=-radius;y<=radius;y++){
                    int d2=x*x+y*y;
                    if(d2>radius*radius || (q0-1)*(q0-1)<d2) continue;
                    double d=sqrt((double)x*x+y*y);
                   
                    ms[(x+x0)*256+(y+y0)]+=int(q0/(1+d));
                }
            }
        }
        pair<int,int> mn=*ms.begin();
        for(const pair<int,int>& t: ms) mn=min(mn,t,[](const pair<int,int>& a,const pair<int,int>& b){
            int x1=a.first/256,y1=a.first%256,x2=b.first/256,y2=b.first%256;
            return a.second>b.second || (a.second==b.second && (x1<x2 || (x1==x2 && y1<y2)));
        });
        
        vector<int> ans={mn.first/256,mn.first%256};

        return ans;
    }
```	
- we can use minx/maxx, miny/maxy to reduce more computations.
- avoid using string it will be much slower.
- find min only, do not sort!
- min need both parameters to be const T&.
- 400ms

### 1621. Number of Sets of K Non-Overlapping Line Segments
<em>
Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at x = i, find the number of ways we can draw exactly k non-overlapping line segments such that each segment covers two or more points. The endpoints of each segment must have integral coordinates. The k line segments do not have to cover all n points, and they are allowed to share endpoints.

Return the number of ways we can draw k non-overlapping line segments. Since this number can be huge, return it modulo 109 + 7.
</em>

observation:
- <2 point will give 0
- k=1, just one line, we have C(n,2) choices.
dp approach: 
current point can be appended to ith segment. dp[i,j]=dp[i-1,j]
current point [k,i] can be the ith segment: dp[i,j]+=dp[i-1][j-k]

```cpp
    int numberOfSets(int n, int k) {
        //dp
        int mod=1e9+7;
        vector<vector<long>> dp(k+1,vector<long>(n+1)); //solution for n points, k segment
        //base case for all k<n we have 
        //k=0: 0 choices
        //k=1, for all n>=2 get 1, C(n,2)
        for(int j=2;j<=n;j++) dp[1][j]=j*(j-1)/2;
        
        for(int i=2;i<=k;i++){
            for(int j=2;j<=n;j++){
                //add one more point: append to previous and start a new line.
                dp[i][j]=dp[i][j-1]; //append to ith segment
                for(int k=1;k<=j;k++){ //append to 
                    dp[i][j]+=dp[i-1][j-k];
                    dp[i][j]%=mod;
                }
            }
        }
        //print(dp);
        return dp[k][n];        
        
    }
```	

this will TLE since its complexity is O(kn^2)
the inner loop can be simplified using prefix sum:

```cpp
    int numberOfSets(int n, int k) {
        //dp
        int mod=1e9+7;
        vector<vector<long>> dp(k+1,vector<long>(n+1)); //solution for n points, k segment
        //base case for all k<n we have 
        //k=0: 0 choices
        //k=1, for all n>=2 get 1, C(n,2)
        for(int j=2;j<=n;j++) dp[1][j]=j*(j-1)/2;
        
        for(int i=2;i<=k;i++){
            long pre=0;
            for(int j=2;j<=n;j++){
                //add one more point: append to previous and start a new line.
                dp[i][j]=dp[i][j-1]; //append to ith segment
                pre+=dp[i-1][j-1];
                pre%=mod;
                dp[i][j]+=pre;
                dp[i][j]%=mod;
                /*
                for(int k=1;k<=j;k++){ //append to 
                    dp[i][j]+=dp[i-1][j-k]; //accumulate 0...j-1
                    dp[i][j]%=mod;
                }*/
            }
        }
        //print(dp);
        return dp[k][n];        
        
    }
```
Lee215's approachL
case 1: given n points, take k segments, allowing sharing endpoints
case 2: given n+k-1 points, take k segments, not allowing sharing endpoints
the two cases are equivalent. 
answer is C(n+k-1,2k), choosing 2k points. 

### 1622. Fancy Sequence
<em>
Write an API that generates fancy sequences using the append, addAll, and multAll operations.

Implement the Fancy class:

Fancy() Initializes the object with an empty sequence.
void append(val) Appends an integer val to the end of the sequence.
void addAll(inc) Increments all existing values in the sequence by an integer inc.
void multAll(m) Multiplies all existing values in the sequence by an integer m.
int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1.
 length up to 10^5, and calls up to 10^5
 </em>
 
 intuition:
 - cannot brutal force, will need lazy evaluation (save operations and evaluate once)
 - need to save all the numbers.
 lazy evaluation:
 ((x+a)*b+c)*d=x*b*d+a*b*d+c*d
-->the number itself and the inc value shall multiplies the mult the same time and then added together.

- how to get the mod of ((x+a)*b+c)*d?
- we cannot save the lazy operations for each element. and this is the critical point:
we use the same for all elements and undo the addition and mult for those elements which do not have it.
newval-=inc, newval/=mult, newval%=mod

using Fermat little theorem: a^(m-1)=1 (mod m, m is a prime)
newval *=modInv(mult);

```cpp
    int mod97 = 1000000007;

    unsigned long seq[100001];
    unsigned int length = 0;
    unsigned long increment = 0;
    unsigned long mult = 1;
    Fancy() {
    }
    
    void append(int val) {
        seq[length++] = (((mod97 + val - increment)%mod97) * modPow(mult, mod97-2))%mod97;
    }
    void addAll(int inc) {
        increment = (increment+ inc%mod97)%mod97;
    }
    
    void multAll(int m) {
        mult = (mult* m%mod97)%mod97;
        increment = (increment* m%mod97)%mod97;
    }
    
    int getIndex(int idx) {
        
        if (idx >= length){
            return -1;
        }else{
            return ((seq[idx] * mult)%mod97+increment)%mod97;
        }
    }
    /**
    Calculates multiplicative inverse
    */
    unsigned long modPow(unsigned long x, int y) {
        unsigned long tot = 1, p = x;
        for (; y; y >>= 1) {
            if (y & 1)
                tot = (tot * p) % mod97;
            p = (p * p) % mod97;
        }
        return tot;
    }
```	

lee215's approach:
store original seq
store prefix sum of add, prefix mult of mult.
need using big integer since it will overflow easily
then use lazy evaluation.

```python:
class Fancy(object):

    def __init__(self):
        self.A = []
        self.add = [0]
        self.mul = [1]

    def append(self, a):
        self.A.append(a)
        self.add.append(self.add[-1])
        self.mul.append(self.mul[-1])

    def addAll(self, inc):
        self.add[-1] += inc

    def multAll(self, m):
        self.add[-1] *= m
        self.mul[-1] *= m

    def getIndex(self, i):
        if i >= len(self.A): return -1
        m = self.mul[-1] / self.mul[i]
        inc = self.add[-1] - self.add[i] * m
        return (self.A[i] * m + inc) % (10 ** 9 + 7)
```
		




 



## biweek 38

### 1636. Sort Array by Increasing Frequency

<em>
Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.

Return the sorted array.
</em>

good practice using lambda sort

```cpp
    vector<int> frequencySort(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i: nums) mp[i]++;
        sort(begin(nums),end(nums),[&](int a,int b){
            return mp[a]<mp[b] || (mp[a]==mp[b] && a>b);
        });
        return nums;
    }
```

### 1637. Widest Vertical Area Between Two Points Containing No Points
<em>
Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.
</em>

y coordinate does not matter.
just sort and calculate the neigboring distance.

approach 1: store x into a set (eliminate all duplicates)
approach 2: sort it.

```cpp
    int maxWidthOfVerticalArea(vector<vector<int>>& points) {
        sort(begin(points),end(points));
        int ans=0;
        for(int i=1;i<points.size();i++){
            ans=max(ans,points[i][0]-points[i-1][0]);
        }
        return ans;
    }
```

### 1638. Count Substrings That Differ by One Character
<em>
Given two strings s and t, find the number of ways you can choose a non-empty substring of s and replace a single character by a different character such that the resulting substring is a substring of t. In other words, find the number of substrings in s that differ from some substring in t by exactly one character.

For example, the underlined substrings in "computer" and "computation" only differ by the 'e'/'a', so this is a valid way.

Return the number of substrings that satisfy the condition above.

A substring is a contiguous sequence of characters within a string.	
</em>

brutal force: try all substrings
loop all substr from length 1 to n.
O(N^4)

```cpp
    int countSubstrings(string s, string t) {
        //from length 1 to size(t) we can try one by one
        int n=t.size();
        int ans=0;
        for(int i=1;i<=n;i++){
            ans+=numstr(s,t,i);
        }
        return ans;
    }
    int numstr(string& s,string& t,int len){
        int m=s.size(),n=t.size();
        int ans=0;
        for(int i=0;i<=m-len;i++){
            for(int j=0;j<=n-len;j++){
                ans+=valid(s,i,t,j,len);
            }
        }
        return ans;
    }
    bool valid(string& s,int i,string& t,int j,int len){
        int ans=0;
        while(len--){
            ans+=s[i++]!=t[j++];
            if(ans>1) return 0;
        }
        return ans==1;
    }
```

O(N^3): starting at s[i] and t[j] and tries all length. break if difference>1.

```cpp
int countSubstrings(string &s, string &t) {
    int res = 0;
    for (int i = 0; i < s.size(); ++i) {
        for (int j = 0; j < t.size(); ++j) {
            int miss = 0;
            for (int pos = 0; i + pos < s.size() && j + pos < t.size(); ++pos) {
                if (s[i + pos] != t[j + pos] && ++miss > 1)
                    break;
                res += miss;
            }
        }
    }
    return res;
}
```
note when miss=1, we need continue until miss>1

also we can use s[i] as the mismatch and extend to find the left and right.
l*r is the answer for i.

O(N^2)
use DP to precompute sizes of a matching substring ending at position [i][j] (dpl), and starting from position [i][j] (dpr).

```cpp
int countSubstrings(string &s, string &t) {
    int res = 0;
    int dpl[101][101] = {}, dpr[101][101] = {};
    for (int i = 1; i <= s.size(); ++i)
        for (int j = 1; j <= t.size(); ++j)
            if (s[i - 1] == t[j - 1])
                dpl[i][j] = 1 + dpl[i - 1][j - 1];
    for (int i = s.size(); i > 0; --i)
        for (int j = t.size(); j > 0; --j)
            if (s[i - 1] == t[j - 1])
                dpr[i - 1][j - 1] = 1 + dpr[i][j];
    for (int i = 0; i < s.size(); ++i)
        for (int j = 0; j < t.size(); ++j)
            if (s[i] != t[j])
                res += (dpl[i][j] + 1) * (dpr[i + 1][j + 1] + 1);
    return res;
}
```

### 1639. Number of Ways to Form a Target String Given a Dictionary
<em>
You are given a list of strings of the same length words and a string target.

Your task is to form target using the given words under the following rules:

target should be formed from left to right.
To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].
Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.
Repeat the process until you form the string target.
Notice that you can use multiple characters from the same string in words provided the conditions above are met.

Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.
</em>

idea: dp.

- precalculate the histogram for each index.
- dp: use current col, or not use current col.

```cpp
    int numWays(vector<string>& words, string target) {
        int mod=1e9+7;
        
        int n=words[0].size();
        vector<vector<int>> cnt(n,vector<int>(26));
        for(auto w:words){
            for(int i=0;i<n;i++) cnt[i][w[i]-'a']++;
        }
        //dp: ith character, and choose jth char, 
        int m=target.size();
        vector<vector<long>> dp(m+1,vector<long>(n+1));
        //base case: m=0, 
        for(int i=0;i<=n;i++) dp[0][i]=1;
        
        for(int i=1;i<=m;i++){ //target len
            char c=target[i-1];
            for(int j=i;j<=n;j++){ //used len j>=i
                int t=cnt[j-1][c-'a'];
                dp[i][j]=dp[i][j-1]+t*dp[i-1][j-1]; //do not use current col
                dp[i][j]%=mod;
            }
        }
        //print(dp);
        return dp[m][n];
    }
```	

## biweek 39

### 1652. Defuse the Bomb
<em>
You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

If k > 0, replace the ith number with the sum of the next k numbers.
If k < 0, replace the ith number with the sum of the previous k numbers.
If k == 0, replace the ith number with 0.
As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].

Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!
</em>

straightforward

```cpp
    vector<int> decrypt(vector<int>& code, int k) {
                //k>0 next k 
        vector<int> ans(code.size());
        if(k==0) return ans;
        int dir=1,n=code.size();
        if(k<0) dir=-1,k*=-1;
        for(int i=0;i<code.size();i++){
            int sum=0;
            for(int j=1;j<=k;j++){
                sum+=code[(i+dir*j+n)%n];
            }
            ans[i]=sum;
        }
        return ans;
    }
```

### 1653. Minimum Deletions to Make String Balanced
<em>
You are given a string s consisting only of characters 'a' and 'b'​​​​.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.
Constraints:

1 <= s.length <= 105
s[i] is 'a' or 'b'
 </em>

equivalent: long non-decreasing subsequence
using dp, it will be O(N^2) and will TLE.
O(nlogn) will be OK. see 300. longest increasing subsequence
https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/

here we needs non-increasing subsequence by using upper_bound.
```cpp
    int minimumDeletions(string s) {
        //delete to make string sorted.
        //when not sorted we need either delete the first or the second
        //longest increasing subsequence using binary search

        string res;
        for(int i=0; i<s.size(); i++) {
            auto it = std::upper_bound(res.begin(), res.end(), s[i]); //find the >=
            if(it==res.end()) res.push_back(s[i]);
            else *it = s[i];
        }
        return s.size()-res.size();
    }
```
res is the tail array storing the smallest tail of all increasing subsequence with length i+1 for tail[i].
Each time we only do one of the two:

(1) if x is larger than all tails, append it, increase the size by 1
(2) if tails[i-1] < x <= tails[i], update tails[i]
Doing so will maintain the tails invariant. The the final answer is just the size.

O(N) solution using stack (greedy approach):
we are counting number of ba pairs. each pair needs to remove one char.

```cpp
    //Idea is to traverse from right to left & use stack to keep track if 'b' comes before 'a' in string
    //then we need to pop & need to delete that character
    int minimumDeletions(string s) {
        stack<char> st;
        int n =s.size();
        int res = 0;
        
        for(int i = n-1; i >=0; i--){
            char c = s[i];
            if(!st.empty() && st.top() < c){
                res++;
                st.pop();
            }else{
                st.push(c);
            }
        }
        
        return res;
    }
```
note: we count the reversed pairs, and does not add the char into stack.

greedy: the final sorted shall be axxxxbbbb...b. so we only need to count the left a and right b and then get the max sum.
and then delete all right a and left b (the split spot).

### 1654. Minimum Jumps to Reach Home
<em>
A certain bug's home is on the x-axis at position x. Help them get there from position 0.

The bug jumps according to the following rules:

It can jump exactly a positions forward (to the right).
It can jump exactly b positions backward (to the left).
It cannot jump backward twice in a row.
It cannot jump to any forbidden positions.
The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.

Given an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], and integers a, b, and x, return the minimum number of jumps needed for the bug to reach its home. If there is no possible sequence of jumps that lands the bug on position x, return -1.
</em>

2d state bfs:
a position can be jumped from left side or from right side.

```cpp
	int minimumJumps(vector<int>& forbidden, int a, int b, int x) {
		unordered_set<int> forbi(forbidden.begin(), forbidden.end());
		vector<vector<int>> visited(2,vector<int>(5000));
		// visited array has two states:
		// visited[0][i] means the ith cell was reached from its left hand side jumping forward, 
		// visited[1][i] means the ith cell was reached from its right hand side jumping backward. 
		queue<pair<int,bool>> qu; 
		// true means your last jump was backward jumping, you cannot jump backward in current step.
		// false, otherwise.
		qu.push({0,false});
		visited[0][0] = 1;
		visited[1][0] = 1;
		int ans = 0;
		while(!qu.empty()) {
			int len = qu.size();
			while(len > 0) {
				len--;
				int cur = qu.front().first;
				bool flag = qu.front().second;
				if(cur == x) {
					return ans;
				}
				qu.pop();
				int forward = cur + a;
				int backward = cur - b;
				if(forward < 5000 && visited[0][forward] == 0 && !forbi.count(forward)) {
					qu.push({forward,false});
					visited[0][forward] = 1;
				}
				if(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {
					qu.push({backward,true});
					visited[1][backward] = 1;
				}
			}
			ans++;
		}
		return -1;
	}
```	
	
### 1655. Distribute Repeating Integers
<em>
You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that:

The ith customer gets exactly quantity[i] integers,
The integers the ith customer gets are all equal, and
Every customer is satisfied.
Return true if it is possible to distribute nums according to the above conditions
</em>

backtracking

```cpp
    bool canDistribute(vector<int>& nums, vector<int>& quantity) {
        //you can have multiple choices to fulfill the orders
        unordered_map<int,int> mp; //up to 50 values
        for(int i: nums) mp[i]++;
        //dp approach: we have to satisfy every one
        vector<int> v;
        for(auto t: mp) v.push_back(t.second);
        sort(rbegin(quantity),rend(quantity));
        
        int m=quantity.size();
        //if we can fullfill, the status depends on the v.
        //vector<int> dp(m,-1); //knapsack 
        return helper(v,quantity,0);
    }
    
    int helper(vector<int>& v,vector<int>& q,int start){
        if(start>=q.size()) return 1;

        for(int i=0;i<v.size();i++){
            if(v[i]>=q[start]){
                v[i]-=q[start];
                if(helper(v,q,start+1)) return 1;
                v[i]+=q[start];
            }
        }
        return 0;
    }
```

The key optimization is to sort the quantity descending order.
otherwise, we will trigger a lot of recursive calls which ends up not successful.


	



 ## biweek 40

1668. Maximum Repeating Substring
<em>
For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0.

Given strings sequence and word, return the maximum k-repeating value of word in sequence.
</em>

straightforward

```cpp
    int maxRepeating(string sequence, string word) {
        if(sequence.find(word)==string::npos) return 0;
        int ans=1;
        string w=word;
        while(word.size()<sequence.size()){
            word+=w;
            if(sequence.find(word)!=string::npos){
                ans++;
            }
            else return ans;
                
        }
        return ans;
    }
```

1669. Merge In Between Linked Lists
<em>
You are given two linked lists: list1 and list2 of sizes n and m respectively.

Remove list1's nodes from the ath node to the bth node, and put list2 in their place.
Constraints:

3 <= list1.length <= 104
1 <= a <= b < list1.length - 1
1 <= list2.length <= 104
</em>

find the first and second node for the first linked list.
find the head and tail of the second linked list.

```cpp
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
        ListNode *head=0,*tail=0;
        head=list2;
        ListNode* p=list2;
        while(p) {tail=p;p=p->next;}
        int cnt=0;
        p=list1;
        ListNode* p1=0;
        while(cnt<=b){
            if(cnt+1==a){
                p1=p;
            }
            p=p->next;
            cnt++;
        }
        p1->next=head;
        tail->next=p;
        return list1;
    }
```


1670. Design Front Middle Back Queue
<em>
Design a queue that supports push and pop operations in the front, middle, and back.

Implement the FrontMiddleBack class:

FrontMiddleBack() Initializes the queue.
void pushFront(int val) Adds val to the front of the queue.
void pushMiddle(int val) Adds val to the middle of the queue.
void pushBack(int val) Adds val to the back of the queue.
int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.
int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.
int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.
Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:

Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].
Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].
Constraints:

1 <= val <= 10^9
At most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront, popMiddle, and popBack.
</em>

O(1) using two deque
O(n) using one vector

```cpp
    vector<int> v;
    FrontMiddleBackQueue() {
        
    }
    
    void pushFront(int val) {
        v.insert(v.begin(),val);
    }
    
    void pushMiddle(int val) {
        v.insert(v.begin()+v.size()/2,val);
    }
    
    void pushBack(int val) {
        v.push_back(val);
    }
    
    int popFront() {
        if(v.empty()) return -1;
        int t=v[0];
        v.erase(v.begin());
        return t;
    }
    
    int popMiddle() {
        if(v.empty()) return -1;
        int t=v[(v.size()-1)/2];
        v.erase(v.begin()+(v.size()-1)/2);
        return t;
    }
    
    int popBack() {
        if(v.empty()) return -1;
        int t=v.back();
        v.pop_back();
        return t;
    }
```

1671. Minimum Number of Removals to Make Mountain Array
<em>
You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.
Constraints:

3 <= nums.length <= 1000
1 <= nums[i] <= 10^9
It is guaranteed that you can make a mountain array out of nums.
</em>	

for each index, we assume it is the peak, and then it becomes Longest Increasing Sequence problem.

```cpp
    int minimumMountainRemovals(vector<int>& nums) {
        //any index can be a mountain index
        int n=nums.size();
        vector<int> left(n,1),right(n,1);
        //int rm=0; //number of removals on the left. or longest increasing sequence
        left[0]=1;
        for(int i=1;i<n-1;i++){ //index can be 1 to n-2, use the current one as the ending
            for(int j=i-1;j>=0;j--){
                if(nums[i]>nums[j])
                left[i]=max(left[i],left[j]+1);
            }
        }
        //print(left);
        //from right to left
        right[n-1]=1;
        int ans=0;
        for(int i=n-2;i;i--){ //index can be 1 to n-2, using current as the index
            
            for(int j=i+1;j<n;j++){
                if(nums[i]>nums[j])
                    right[i]=max(right[i],right[j]+1);
            }
            ans=max(ans,left[i]+right[i]-1);
        }
        
        return n-ans;
    }
```	

## biweek 41

1684. Count the Number of Consistent Strings
<em>
You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.

Return the number of consistent strings in the array words.
</em>

Straightforward using vector

```cpp
    int countConsistentStrings(string allowed, vector<string>& words) {
        vector<bool> v1(26),v2(26);
        for(char c: allowed) v1[c-'a']=1;
        int ans=0;
        for(auto w: words){
            bool b=1;
            for(char c: w){
                if(v1[c-'a']==0) {
                    b=0;
                    break;
                }
            }
            ans+=b;
        }
        return ans;
    }
```

1685. Sum of Absolute Differences in a Sorted Array
<em>
You are given an integer array nums sorted in non-decreasing order.

Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.

In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).
</em>

using prefix sum
```cpp
    vector<int> getSumAbsoluteDifferences(vector<int>& nums) {
        int prefix=0;
        int tsum=accumulate(begin(nums),end(nums),0);
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;i++){
            ans.push_back(tsum-2*prefix-(n-2*i)*nums[i]);
            prefix+=nums[i];
            
        }
        return ans;
    }
```

1686. Stone Game VI
<em>
Alice and Bob take turns playing a game, with Alice starting first.

There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.

You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.

The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.

Determine the result of the game, and:

If Alice wins, return 1.
If Bob wins, return -1.
If the game results in a draw, return 0.
</em>

greedy:
- since n is pretty large. O(N^2) dp approach will TLE.
we may need to consider greedy approach using sort O(nlogn)
- we need to conclude that the target is to maximize the score difference between A and B.

assume we have (a,b) and (c,d)
if A takes a, B take d optimally:
a-d>b-c  ->  a+b>c+d, so we need sort using combined value.

Note the object is not to make most points, but to guarantee that he wins.

for example (6,9),(3,12),(2,1)
A takes (6,2), B will get 12.
A takes (3,2), B will get 9.
```cpp
    int stoneGameVI(vector<int>& A, vector<int>& B) {
        vector<vector<int>> C;
        int res[2] = {0, 0}, n = A.size();
        for (int i = 0; i < n; ++i)
            C.push_back({A[i] + B[i], A[i], B[i]});
        sort(begin(C), end(C));
        for (int i = 0; i < n; ++i)
            res[i % 2] += C[n - i - 1][i % 2+1];
        return res[0] == res[1] ? 0: res[0] > res[1] ? 1 : -1;
    }
```
sort (equal number does not matter and will not produce difference).
A score:
=sum(Ai)-Sum(Bj) i and j are mutual exclusive
=Sum(Ai)-Sum(Bj)+Sum(Bi)-Sum(Bi)
=Sum(Ai+Bi)-Sum(B)

other intuition:
Alice can consider if he takes it, get a points
if not take it, get -b points. And the difference is a+b-c

see zero-sum game in game theory

1687. Delivering Boxes from Storage to Ports
<em>
You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.

You are given an array boxes, where boxes[i] = [ports​​i​, weighti], and three integers portsCount, maxBoxes, and maxWeight.

ports​​i is the port where you need to deliver the ith box and weightsi is the weight of the ith box.
portsCount is the number of ports.
maxBoxes and maxWeight are the respective box and weight limits of the ship.
The boxes need to be delivered in the order they are given. The ship will follow these steps:

The ship will take some number of boxes from the boxes queue, not violating the maxBoxes and maxWeight constraints.
For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.
The ship then makes a return trip to storage to take more boxes from the queue.
The ship must end at storage after all the boxes have been delivered.

Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.
</em>
dp + sliding window
greedy: load as many box as possible on ship
pop old order + greedy (when same dest order is popped, then pop all same dest orders).

```cpp
    int boxDelivering(vector<vector<int>>& A, int portsCount, int B, int W) {
        int n = A.size(), need = 0, j = 0, lastj = 0;
        vector<int> dp(n + 1, 1000001);
        dp[0] = 0;
        for (int i = 0; i < n; ++i) {
            while (j < n && B > 0 && W >= A[j][1]) {
                B -= 1;
                W -= A[j][1];
                if (j == 0 || A[j][0] != A[j - 1][0]) {
                    lastj = j;
                    need++;
                }
                j++;
            }
            dp[j] = min(dp[j], dp[i] + need + 1);
            dp[lastj] = min(dp[lastj], dp[i] + need);
            B += 1;
            W += A[i][1];
            if (i == n - 1 || A[i][0] != A[i + 1][0]) {
                need--;
            }
        }
        return dp[n];
    }
```	
## warmup contest
### 386. Lexicographical Numbers (***)
backtracking: starting with 1 to 9 and then append digits after it.
```cpp
    vector<int> lexicalOrder(int n) {
        vector<int> ans;
        string ns=to_string(n);
        int ndigit=ns.size();
        for(int i=1;i<=9;i++)
          backtrack(n,i,ans);
        return ans;
    }
    void backtrack(int n,int t,vector<int>& ans){
        int last_digit=t%10;
        if(t>n) return;
        if(t<=n) ans.push_back(t);
        for(int i=0;i<=9;i++){
            t=t*10+i;
            backtrack(n,t,ans);
            t/=10;
        }
    }
```

### 387. first unique character in a string (*)
using hashmap

### 388. longest absolute file path (****)
tree structure using stack to store the directory
also stringstream and string proces.
```cpp
    int lengthLongestPath(string input) {
        //file tree can use hashmap, but we can directly use the input for parsing
        //\n represent a line, \t represent the level
        stringstream ss(input);
        int level=0;
        vector<int> vlen;
        string name;
        int ans=0;
        char sbuf[256];
        while(ss.getline(sbuf,256,'\n')){ //it will skip \n and \t
            name=string(sbuf);
            level=0;
            while(name[level]=='\t') level++;
            if(name.find(".")!=string::npos){ //this is a file
                while(vlen.size()>level) vlen.pop_back();
                int tlen=0;
                for(int t: vlen) tlen+=t;
                ans=max(ans,tlen+(int)name.size());
            }
            else {//a directory name
                while(vlen.size()>level) vlen.pop_back();
                vlen.push_back(name.size()-level);
            }
        }
        return ans;
    }
```	
note: getline need use char* with delimiter.
## contest 2
### 389. find the difference (**)
find the extra char, using hashmap

### 390. elimination game (****)
dir change, step change
do not have to do the actual elimination.
```cpp
    int lastRemaining(int n) {
        //
        int head=1,dir=1,rem=n,step=1;
        while(rem>1){
            if(dir || rem%2) head+=step;
            dir^=1;
            rem/=2;
            step*=2;
        }
        return head;
    }
```

### 391. perfect rectangle (****)
the outside 4 points shall appear only one time, inside shall appear even times
total area shall equal to sum of all rectangles
```cpp
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        //get the 4 points outside and the total area
        //inner side points shall mod 2, outside point shall =1
        int total=0;
        int x0=INT_MAX,y0=INT_MAX,x1=INT_MIN,y1=INT_MIN;
        unordered_map<string,int> mp;
        for(auto r: rectangles){
            x0=min(x0,r[0]);
            y0=min(y0,r[1]);
            x1=max(x1,r[2]);
            y1=max(y1,r[3]);
            mp[forms(r[0],r[1])]++;
            mp[forms(r[0],r[3])]++;
            mp[forms(r[2],r[1])]++;
            mp[forms(r[2],r[3])]++;
            total+=(r[0]-r[2])*(r[1]-r[3]);
        }
        if(total!=(x0-x1)*(y0-y1)) return 0;
        if(mp[forms(x0,y0)]!=1 || mp[forms(x0,y1)]!=1 ||
          mp[forms(x1,y0)]!=1 || mp[forms(x1,y1)]!=1) return 0;
        //all other shall be even
        mp.erase(forms(x0,y0));
        mp.erase(forms(x0,y1));
        mp.erase(forms(x1,y0));
        mp.erase(forms(x1,y1));
        for(auto t: mp) if(t.second%2) return 0;
        return 1;
    }
    string forms(int x,int y){
        return to_string(x)+","+to_string(y);
    }
```
## contest 3
### 392. Is subsequence (***)
greedy match using two pointer. When all chars in s are matched, T can be non-completed.	
```cpp
    bool isSubsequence(string s, string t) {
        //greedy using two pointer
        int i=0,j=0;
        while(i<s.size() && j<t.size()){
            while(j<t.size() && t[j]!=s[i]) j++;
            i++;j++;
        }
        return i==s.size() && j<=t.size();
    }
```
### 393. utf8 validation (***)
idea: find the first byte signature and then check remaining contains 10 in binary
```cpp
    bool validUtf8(vector<int>& data) {
        int i=0,rem=0;
        while(i<data.size()){
            if(rem==0){
                if(data[i]<0x80) rem=0;
                else if((data[i]&0xe0)==0xc0) rem=1;
                else if((data[i]&0xf0)==0xe0) rem=2;
                else if((data[i]&0xf8)==0xf0) rem=3;
                else return 0;
            }
            else{
                if((data[i]&0xc0)!=0x80) return 0;
                rem--;
            }
            i++;
        }
        return rem==0;
    }
```

### 394. decode string (****)
recursive stack: common practice, add decoded results into stack and recusively solve subproblem and update the one in the stack top.
```cpp
    string decodeString(string s) {
        //using stack to do recursive
        int ncopy=0;
        stack<string> st;
        string t;
        int i=0;
        //cout<<s<<": "<<endl;
        while(i<s.size()){
            char c=s[i];
            if(isdigit(c)){
                if(t.size()) st.push(t);
                t.clear();
                ncopy=c-'0';
                while(i+1<s.size() && isdigit(s[i+1])){
                    ncopy=ncopy*10+(s[++i]-'0');
                }
                i++;
            }
            else if(isalpha(c)){
                t=c;
                while(i+1<s.size() && isalpha(s[i+1])){
                    t+=s[++i];
                }
                i++;
            }
            else if(c=='['){
                int j=i+1,p=1;
                while(p){
                    if(s[j]=='[') p++;
                    if(s[j]==']') p--;
                    j++;
                }
                
                j--;
                //from i+1 to j-1 (inclusive)
                string t=decodeString(s.substr(i+1,j-i-1));
                //repeat:
                string nt;
                for(int k=0;k<ncopy;k++) nt+=t;
                if(st.size()) st.top()+=nt;
                else st.push(nt);
                i=j+1;
                t.clear();
            }
        }
        string ans=t;
        while(st.size()){
            ans=st.top()+ans;
            st.pop();
        }
        //cout<<ans<<endl;
        return ans;
    }
```
### 395. Longest Substring with At Least K Repeating Characters (*****)
divide and conquer
idea: using the char appear less than k times as a separator

```cpp
    int longestSubstring(string s, int k) {
        //divide and conquer
        //find the char less then k times and divide into two parts
        return helper(s,k,0,s.size());
    }
    int helper(string& s,int k,int start,int end){
        //cout<<s.substr(start,end-start)<<endl;
        if(end-start<k) return 0;
        vector<int> cnt(26);
        
        for(int i=start;i<end;i++) 
            cnt[s[i]-'a']++;
        int ans=0,l=0;
        bool found=0;
        for(int i=start;i<end;i++){
            int t=cnt[s[i]-'a'];
            if(t && t<k){
                ans=max({ans,helper(s,k,l,i)});
                l=i+1;
                found=1;
            }
        }
        if(found) ans=max(ans,helper(s,k,l,end));
        else ans=end-start;
        return ans;
    }
```
## contest 4
### 396. Rotate Function (***)
find the recurrence relation using the example

```cpp
    int maxRotateFunction(vector<int>& A) {
        //f(k)=sum(i*Bi), f(k+1)=sum((i+1)%n*Bi)
        //f(1)-f(0)=A0+A1+....An-1-n*An-1
        //f(2)-f(1)=A0+A1+....An-1-n*An-2
        long tsum=accumulate(A.begin(),A.end(),0ll);
        int n=A.size();
        long ans=0;
        for(int i=0;i<n;i++)
            ans+=i*A[i];
        long sum=ans;
        for(int i=1;i<n;i++){
            //cout<<sum<<endl;
            sum+=tsum-(long)n*A[n-i];
            ans=max(ans,sum);
        }
        return ans;        
     }
```

### 397. Integer Replacement (***)
greedy: if (n+1)%4==0 then +1, if n-1%4==0 then -1
with exception n=3;

```cpp
    int integerReplacement(int n) {
        //equiv to from 1 to n using *2 and +/-1
        //greedy: if n+1 %4==0 +1, n-1%4==0 -1
        int ans=0;
        long nn=n;
        while(nn>1){
            if(nn%2==0) nn/=2;
            else{
                if(nn>3 && (nn+1)%4==0) nn++;
                else nn--;
            }
            ans++;
        }
        return ans;
    }
```

### 398. random pick index (***)
hashmap to store the index
```cpp
    unordered_map<int,vector<int>> mp;
    Solution(vector<int>& nums) {
        for(int i=0;i<nums.size();i++){
            mp[nums[i]].push_back(i);
        }
    }
    
    int pick(int target) {
        return mp[target][rand()%mp[target].size()];
    }
```
### 399. evaluate division (*****)
dfs approach: using previous value to cascade the division. using visited to avoid repeat visit.
union find: only then a and b in the same set, and then find the common parent a/b=(a/parent) * (parent/b)	
```cpp
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        //dfs: build a graph
        unordered_map<string,unordered_map<string,double>> mp;
        for(int i=0;i<equations.size();i++){
            mp[equations[i][0]].insert({equations[i][1],values[i]});
            mp[equations[i][1]].insert({equations[i][0],1.0/values[i]});
        }
        int n=queries.size();
        vector<double> ans(n,1);
        for(int i=0;i<n;i++) {
            unordered_set<string> v;
            ans[i]=solve(mp,queries[i][0],queries[i][1],1.0,v);
        }
        return ans;
    }
    double solve(unordered_map<string,unordered_map<string,double>>& mp,string a,string b,double prev,unordered_set<string>& v){
        if(!mp.count(a) || !mp.count(b)) return -1.0;
        if(a==b) return prev;
        v.insert(a);
        for(auto p: mp[a]){ 
            if(v.count(p.first)) continue;
            double ans=solve(mp,p.first,b,prev*p.second,v);
            if(ans>0) return ans;
        }
        return -1.0;
    }
```
## contest 5
### 400. Nth digit (****)
idea: binary search the number in which area, and then find the number, finally get the digit in the number
```cpp
    int findNthDigit(int n) {
        if(n<10) return n;
        vector<long> num(10,1);//1,9,2*90+9
        num[1]=9;
        for(int i=2;i<10;i++){
            num[i]=9*i*pow(10,i-1)+num[i-1];
            //cout<<num[i]<<" ";
        }
        int ind=upper_bound(num.begin(),num.end(),n)-num.begin(); //>=n
        n-=num[ind-1];
        int t=n/ind-1+pow(10,ind-1); //starting from 10...0, number of digits is ind.
        //cout<<t;
        int rem=n%ind;
        if(rem) t++;else rem=ind; //rem=0, the last digit
        //cout<<t<<" "<<rem;
        string s=to_string(t);
        return s[rem-1]-'0';
    }
```

### 401. Binary Watch (****)
idea: 10 bit all combinations and then check all valid combinations. We can also do the validation during backtracking to save space.
```cpp
    vector<string> readBinaryWatch(int num) {
        //hr: 4bits, min: 6bits (hr max 3 lights, min max 5 lights)
        //use it as a whole is easier 
        //backtrack
        vector<string> ans;
        if(num>8) return ans;
        vector<bitset<10>> vbits;
        bitset<10> t(0);
        backtrack(num,t,0,vbits);
        for(auto t: vbits){
            int n=t.to_ulong();
            int hr=(n&0x3c0)>>6;
            int mi=n&0x3f;
            if(hr>11 || mi>59) continue;
            char str[6];
            sprintf(str,"%d:%02d",hr,mi);
            ans.push_back(string(str));
        }
        return ans;
    }
    void backtrack(int n,bitset<10> t,int start,vector<bitset<10>>& vbit){
        if(n==0){
            vbit.push_back(t);
            return;
        }
        for(int i=start;i<10;i++){
            t[i]=1;
            backtrack(n-1,t,i+1,vbit);
            t[i]=0;
        }
    }
```
### 402. Remove K Digits	(*****)
using stack to remove the peak digits recursively

```cpp
    string removeKdigits(string num, int k) {
        //greedy:
        //1432219: remove 1 digit ->132219
        //remove 2 digit: 12219
        //remove 3 digit: 1219. approach: from left to right, repeatedly remove the first peak digit
        //using stack: if the curr digit is less than previous, then remove the stack top
        
        stack<char> st;
        for(char c: num){
            while(st.size() && k && c<st.top()){
                st.pop();
                k--;
            }
            st.push(c);
            //if(k==0) break;
        }
        while(k--){ //still need to remove, now it is sorted
            st.pop();
        }
        string ans;
        while(st.size()) {
            ans+=st.top();
            st.pop();
        }
        //remove leading zeros
        while(ans.back()=='0') ans.pop_back();
        if(ans.empty()) ans="0";
        reverse(ans.begin(),ans.end());
        return ans;
    }
```

### 403. Frog Jump	(****)
bfs with 3 options: k-1, k, k+1
important optimization: if keep k+1, then A[i] and A[i+1] can only have distance less than i.
can also use dfs (recursive approach)

```cpp
    bool canCross(vector<int>& stones) {
        //assuming at ith stone and previous step is k, then next must have a stone at k+1, k or k-1 distance
        //can use bfs
        unordered_set<int> st;
        for(int i=1;i<stones.size();i++){
            if(stones[i]>stones[i-1]+i) return 0;
            st.insert(stones[i]);
        }
        unordered_set<string> v;
        queue<vector<int>> q; //stores position vs step
        int n=stones.size();
        q.push({0,0});
        while(q.size()) {
            int sz=q.size();
            while(sz--){
                auto p=q.front();
                q.pop();
                int pos=p[0],step=p[1];
                if(pos==stones.back()) return 1;
                int ind=0;
                string s;
                s=to_string(pos+step-1)+","+to_string(step-1);
                if(step>1 && st.count(pos+step-1) && !v.count(s)) {q.push({pos+step-1,step-1});v.insert(s);}
                s=to_string(pos+step)+","+to_string(step);
                if(step && st.count(pos+step)&& !v.count(s)) {q.push({pos+step,step});v.insert(s);}
                s=to_string(pos+step+1)+","+to_string(step+1);
                if(st.count(pos+step+1)&& !v.count(s)) {q.push({pos+step+1,step+1});v.insert(s);}
            }
        }
        return 0;
    }
```
## contest 6
### 404. sum of left leaves (**)
traversal
### 405. convert a number to hex (**)
with negatives
### 406. queue reconstruction (**)
greedy, arrange the height according to height first in descendant and index ascending order
corner case: input is empty

### 407. Trapping rain water II (*****)
BFS with priority-queue. 
need to observe the following facts:
- inside is bound by outside ring. the amount of water is determined by the lowest bar in outside
- taller bar can also form a enclosed area with water. (not in the same level)
- approach: put the outside cells into min heap (pq)
- start from the min and add its neighbors into pq
- if cell is lower than maxh, add water.
- if cell is higher than maxh, update maxh.
queue store the h and x y so that we can extend to neighbors
do not forget when we add elements to queue, mark them as visited.

```cpp
    int trapRainWater(vector<vector<int>>& hm) {
        if(hm.empty()) return 0;
        int m=hm.size(),n=hm[0].size();
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
        //add the outside ring into pq
        vector<vector<bool>> v(m,vector<bool>(n));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0 || i==m-1 || j==0 || j==n-1) {
                    pq.push({hm[i][j],i,j});
                    v[i][j]=1;
                }
            }
        }
        int ans=0;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        
        int maxh=0;
        while(pq.size()){
            auto t=pq.top();
            pq.pop();
            int h=t[0],x0=t[1],y0=t[2];
            maxh=max(h,maxh);
            for(auto d: dir){
                int x=x0+d[0],y=y0+d[1];
                if(x<0||x>=m||y<0||y>=n||v[x][y]) continue;
                v[x][y]=1;
                int h=hm[x][y];
                ans+=max(0,maxh-h);
                pq.push({h,x,y});
            }
        }
        return ans;
    }
```
就是四面都是围墙，从最低的往里走；
如果里面有更低的，当然就可以蓄水，蓄水的量就是围墙最低 减去 此处的高度；
如果里面的比当前围墙高，那这个方向的围墙高度就增加了。
然后永远围墙最低的地方开始搜，最后就能把整个水池搜一遍。
## contest 7

### 408. valid word abbreviation (***)
two pointer approach
when we find a digit, we get the whole number and advance the other pointer by this number
and then match
at the end, both string shall be exhausted.
```cpp
    bool validWordAbbreviation(string word, string abbr) {
        int i=0,j=0;
        int num=0;
        while(i<word.size()&&j<abbr.size()){
            if(isdigit(abbr[j])){
                if(abbr[j]=='0') return 0; //leading zero not allowed
                num=0;
                while(j<abbr.size() && isdigit(abbr[j])) {num=num*10+abbr[j]-'0';j++;}
                i+=num;
            }
            else {
                if(word[i]!=abbr[j]) return 0;
                i++,j++;
            }
        }
        return i==word.size() && j==abbr.size();
    }
```
corner case: number of 0 or leading 0

### 409. longest palindrome (**)
greedy: palindrome will have 0 or 1 char with odd occurrence.

### 410. split array largest sum (****)
split the array into m subarray and minimize the maxsum of the subarrays
convert to binary search problem: given target max sum and to see the number of parts
```cpp
    int splitArray(vector<int>& nums, int m) {
        //binary search
        long tsum=accumulate(nums.begin(),nums.end(),0ll);
        long max0=*max_element(nums.begin(),nums.end());
        long l=max0,r=tsum;
        while(l<r){
            long mid=l+(r-l)/2;
            int num=split(nums,mid);
            if(num<=m) r=mid;
            else l=mid+1;
        }
        return l;
    }
    int split(vector<int>& nums,long target){
        int ans=0;
        long sum=0;
        for(int t: nums){
            if(t+sum>target){
                ans++;
                sum=0;
            }
            sum+=t;
        }
        ans+=(sum!=0);
        cout<<ans<<endl;
        return ans;
    }
```	

### 411. min unique word abbreviation (*****)
similar see: 408. validate abbreviation
320. generate all abbreviation

given a list of dictionary words and a word, find the min length abbreviation which is not conflict with abbr forms of the dictionary words
approach:
to not conflict with dictionary words, we need find a char which is different from the dict chars
bitset approach:
- generate the bits using each dict word (set bit if the char is different)
- we may need to keep 1 or more bits in the candidate
trie approach:
- build the trie using dictionary word's abbreviation form (may need backtracking to generate all abbrs)
- build the word's abbreviation form and check the first one not in the trie. (can use binary search)
- backtracking: keep 1,2,...n chars 

see the reference: https://leetcode.com/problems/minimum-unique-word-abbreviation/discuss/89920/6-ms-C%2B%2B-solution-based-on-modified-320's-generateAbbreviations-(DFS-backtracking)-and-408's-validWordAbbreviation
By applying following optimizations to reduce computations.

filter words in dictionary with length different than target's;
when generating abbreviations of target, stops when "length" of abbreviation is going to exceed the length of current best abbreviation;
when generating abbreviations of target, starts with larger number first, then small number, then letter.

```cpp
class Solution {
public:
    bool validWordAbbreviation(string &word, string &abbr) {
        int i = 0, j = 0, m = word.length(), n = abbr.length();
        while (i < m && j < n) {
            if (word[i] == abbr[j])
                ++i, ++j;
            else if (abbr[j] == '0')
                return false;
            else if (isdigit(abbr[j])) {
                int len = 0;
                while (j < n && isdigit(abbr[j]))
                    len = len * 10 + abbr[j++] - '0';
                i += len;
            }
            else
                return false;
        }
        return i == m && j == n;
    }
    
    void helper(vector<string> &dict, string &ans, int &ansLen, string &s, int len, string &word, int i) {
        if (i == word.length()) {
            if (len < ansLen) {
                int valid = false;
                for (string w : dict) {
                    if (validWordAbbreviation(w, s)) {
                        valid = true;
                        break;
                    }
                }
                
                if (!valid) {
                    ansLen = len;
                    ans = s;
                }
            }
            return;
        }
        
        if (len == ansLen)
            return;
        
        if (s.empty() || !isdigit(s.back())) {
            for (int j = word.length() - 1; j >= i; --j) {
                int pos = s.length();
                s += to_string(j - i + 1);
                ++len;
                helper(dict, ans, ansLen, s, len, word, j + 1);
                --len;
                s.erase(pos);
            }
        }
        
        s.push_back(word[i]);
        ++len;
        helper(dict, ans, ansLen, s, len, word, i + 1);
        --len;
        s.pop_back();
    }

    string minAbbreviation(string target, vector<string>& dictionary) {
        if (target.empty())
            return "";
        
        vector<string> dict;
        for (string word : dictionary) {
            if (word.length() == target.length())
                dict.push_back(word);
        }
        
        string s, ans = target;
        int ansLen = target.length();
        helper(dict, ans, ansLen, s, 0, target, 0);
        return ans;
    }
};
```
## contest 8
### 415. add strings. (**)
simple with cf.

### 416. partition equal subset sum (****)
dp knapsack to a target sum tsum/2
knapsack key points:
current item is not chosen
current item is chosen
subproblem: array length l and target w.
```cpp
    bool canPartition(vector<int>& num) {
      int tsum=accumulate(num.begin(),num.end(),0);
      if(tsum%2) return 0;
      int target=tsum/2;
      int n=num.size();
      vector<vector<bool>> dp(target+1,vector<bool>(n+1)); //
      //boundary condtion
      for(int i=0;i<=n;i++) dp[0][i]=1;//for w=0, choose none.
      for(int i=1;i<=n;i++){ //loop on the array
        for(int t=0;t<=target;t++){
          dp[t][i]=dp[t][i-1];
          if(t>=num[i-1]) 
			dp[t][i]=dp[t-num[i-1]][i-1] || dp[t][i];
        }
      }
      return dp[target][n];
    }
```	
we can optimize the space complexity.
```cpp
    bool canPartition(vector<int>& num) {
      int tsum=accumulate(num.begin(),num.end(),0);
      if(tsum%2) return 0;
      int target=tsum/2;
      int n=num.size();
      vector<bool> dp(target+1); //
      dp[0]=1;//boundary condtion
      for(int c: num){ //loop on the array
        for(int w=target;w>0;w--){
          if(w>=c) 
			dp[w]=dp[w-c] || dp[w]; //we need previous time smaller w so we need reverse loop
        }
      }
      return dp[target];
    }
```	

### 417. pacific atlantic water flow (****)
dfs from top left using type 1, dfs from bottom right using type 2
```cpp
    typedef vector<vector<int>> vvi;
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {
        vvi ans;
        if(matrix.empty()) return ans;
        int m=matrix.size(),n=matrix[0].size();
        vvi v(m,vector<int>(n));
        
        for(int i=0;i<m;i++){
            dfs(matrix,i,0,INT_MIN,1,v,ans); //left
            dfs(matrix,i,n-1,INT_MIN,2,v,ans); //right
        }
        for(int j=0;j<n;j++){
            dfs(matrix,0,j,INT_MIN,1,v,ans); //top
            dfs(matrix,m-1,j,INT_MIN,2,v,ans); //bottom
        }
        return ans;
    }
    void dfs(vvi& mat,int i, int j,int pre,int type,vvi& v,vvi& ans){
        if(i<0||j<0||i>=mat.size()||j>=mat[0].size()||(v[i][j]&type)||mat[i][j]<pre) return;
        v[i][j]|=type;
        if(v[i][j]==3) ans.push_back({i,j});
        pre=mat[i][j];
        dfs(mat,i-1,j,pre,type,v,ans);
        dfs(mat,i+1,j,pre,type,v,ans);
        dfs(mat,i,j-1,pre,type,v,ans);
        dfs(mat,i,j+1,pre,type,v,ans);
    }
```	

### 418. sentence screen fitting (****)
this is a very interesting problem but with a very smart approach.
first assemble the words into a sentence with space separator. (ending also with a space)
then use a pointer to indicate the length or char we are pointing (circular)
first we add a row to the pointer
and check if it is space, then next line do not need space, pointer++
otherwise, we shall add space to shift the current word to next line
last row do not need space if necessary, but it is already covered by pointer++

```cpp
    int wordsTyping(vector<string>& sentence, int rows, int cols) {
        string s;
        for(string w: sentence) s+=w+" ";
        int len=s.size();
        int start=0;
        for(int i=0;i<rows;i++){ //try each row
            start+=cols; //first advance the pointer by cols
            //if previous row ending word ends with no space, then start++
            //if previous row ending word ends with more than one space, then start--
            if(s[start%len]==' ') start++;
            else { //next char is not a space, it is a char
                while(start && s[(start-1)%len]!=' ') start--;
            }
        }
        return start/len;        
    }
```	
## contest 101

RLE Iterator4
Online Stock Span4
Numbers At Most N Given Digit Set7
Valid Permutations for DI Sequence

900. RLE Iterator
<em>
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.

The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead.

For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".
</em>

approach: one array stores the value, one array stores the number (prefix sum).

```cpp
    vector<long long> v1;
    vector<int> vnum;
    long long cur;
    RLEIterator(vector<int> A) {
        cur=0;
        for(int i=0;i<A.size();i++)
        {
            if(i%2) vnum.push_back(A[i]);
            else v1.push_back(A[i]+(i==0?0:v1.back()));
        }
    }
    
    int next(int n) {
        cur+=n;
        //binary search to find the position
        auto it=lower_bound(v1.begin(),v1.end(),cur); //<=
        if(it==v1.end()) return -1;
        int ind=it-v1.begin();
        return vnum[ind];
    }
```

901. Online Stock Span
<em>
Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day.

The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price.

For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].
</em>

monotonic stack

```cpp
    vector<int> prices;
    stack<int> st; //stack stores the index with decreasing order
    int days;
    StockSpanner() {
        days=0;
        st.push(0);
        prices.push_back(INT_MAX);
    }
    
    int next(int price) {
        prices.push_back(price);
        //if(st.empty()) {st.push(0);return 1;}
        //int last_day;
        while(st.size() && price>=prices[st.top()]) st.pop();
        days++;
        int ans;
        ans=days-st.top();
        st.push(days);
        return ans;
    }
```

902. Numbers At Most N Given Digit Set
<em>
You are given an array of digits, you can write numbers using each digits[i] as many times as we want.  For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'.

Return the number of positive integers that can be generated that are less than or equal to a given integer n
</em>

Take N = 2563, D = {"1", "2", "6"} as an example,
The first loop handles the count of x, xx, xxx which x belongs to D. the sum is 3^1 + 3^2 + 3^3.
The second loop handles xxxx from left most digit.
For example,
count of 1xxx is 3^3
count of 21xx is 3^2
count of 22xx is 3^2

If the elements of D can compose entired N, answer + 1
Although it could be coded in a single loop, the logic would be unclear to me. I keep them seperated.

```cpp
class Solution {
public:
    int atMostNGivenDigitSet(vector<string>& D, int N) {
        string NS = to_string(N);
        int digit = NS.size(), dsize = D.size(), rtn = 0;
        
        for (int i = 1 ; i < digit ; ++i)
            rtn += pow(dsize, i);
        
        for (int i = 0 ; i < digit ; ++i) {
            bool hasSameNum = false;
            for (string &d : D) {
                if (d[0] < NS[i]) 
                    rtn += pow(dsize, digit - i - 1);
                else if (d[0] == NS[i]) 
                    hasSameNum = true;
            }
            if (!hasSameNum) return rtn;
        }               
        return rtn+1;
    }
};	
```

903. Valid Permutations for DI Sequence
<em>
We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for "decreasing" and "increasing".)

A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:

If S[i] == 'D', then P[i] > P[i+1], and;
If S[i] == 'I', then P[i] < P[i+1].
How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.
</em>

dp approach:

```cpp
    int numPermsDISequence(string S) {
        int mod=1e9+7;
        int n=S.length();
        vector<vector<int>> dp(n+1,vector<int>(n+1,0));
        //dp[i][j]: the number of permutation with length=i and end at number j
        for(int i=0;i<n+1;i++) dp[0][i]=1; //boundary: length=0
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=i;j++)
            {
                if(S[i-1]=='D') //previous one shall be bigger
                {
                    for(int k=j;k<i;k++) {dp[i][j]+=dp[i-1][k];dp[i][j]%=mod;}
                }
                else //previous one shall be smaller
                {
                    for(int k=0;k<j;k++) {dp[i][j]+=dp[i-1][k];dp[i][j]%=mod;}
                }
            }
        }
        int ans=0;//length=n ending with all numbers.
        for(int i=0;i<n+1;i++) {ans+=dp[n][i];ans%=mod;}
        return ans;
    }
```
## contest 102

Sort Array By Parity2
Fruit Into Baskets5
Sum of Subarray Minimums6
Super Palindromes

905. Sort Array By Parity
<em>
Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.

You may return any answer array that satisfies this condition.
</em>

two pointer one from left,one from right.

```cpp
    vector<int> sortArrayByParity(vector<int>& A) {
        for(int i=0,even=0;i<A.size();i++)
        {
            if(A[i]%2==0) swap(A[i],A[even++]); //j is less
        }
        return A;
    }
```

904. Fruit Into Baskets
<em>
In a row of trees, the i-th tree produces fruit with type tree[i].

You start at any tree of your choice, then repeatedly perform the following steps:

Add one piece of fruit from this tree to your baskets.  If you cannot, stop.
Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.
Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.

You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.

What is the total amount of fruit you can collect with this procedure?
</em>

equiv. to find the window with only two types of fruits and the sum is the max.

```cpp
    int totalFruit(vector<int>& tree) {
        //this is to get the longest window which contains only two type of fruits
        unordered_map<int,int> ms;
        int i=0,j=0;
        int ans=0;
        while(j<tree.size()){
            ms[tree[j]]++;
            while(ms.size()>2) {
                ms[tree[i]]--;
                if(ms[tree[i]]==0) ms.erase(tree[i]);
                i++;
            }
            if(ms.size()<=2) ans=max(ans,j-i+1);
            j++;
        }
        return ans;        
    }
```	

907. Sum of Subarray Minimums
<em>
Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.

Since the answer may be large, return the answer modulo 10^9 + 7.
</em>

stack to find next greater.

```cpp
    int sumSubarrayMins(vector<int>& A) {
        stack<int> st_p,st_n;
        int n=A.size();
        vector<int> left(n),right(n);//max length
        for(int i=0;i<n;i++) {
            left[i]=i+1;
            right[i]=n-i;
        }
        //get previous less and next less
        //increasing order
        for(int i=0;i<A.size();i++){
            while(st_p.size() && A[i]<A[st_p.top()]){
                int tp=st_p.top();st_p.pop();
                right[tp]=i-tp;
            }
            if(st_p.size()) left[i]=i-st_p.top(); //else no change
            
            st_p.push(i);
        }
        int ans=0;
        int mod=1e9+7;
        for(int i=0;i<A.size();i++){
            //cout<<A[i]<<" "<<left[i]<<" "<<right[i]<<endl;
            ans+=left[i]*right[i]*A[i];
            ans%=mod;
        }
        return ans;
    }
```	

906. Super Palindromes

<em>
Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.

Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].

 
</em>

```cpp
    int superpalindromesInRange(string L, string R) {
     //R up to 10^5 since P<10^18  
        long l=stol(L);
        long r=stol(R);
        int limit=1e5;
        int ans=0;
        for(int i=1;i<limit;i++)
        {
            //odd and even arrange
            string s=to_string(i);
            string s_even=s+string(s.rbegin(),s.rend());
            //cout<<s_even<<" ";
            string s_odd=s+string(s.rbegin()+1,s.rend());
            
            long p=stol(s_even);
            p*=p;
            if(p>=l && p<=r)
            if(isPalindrome(p)) ans++;
            //cout<<s_odd<<endl;
            p=stol(s_odd);p*=p;
            if(p>=l && p<=r)
            if(isPalindrome(p)) ans++;
        }
        return ans;
    }
    bool isPalindrome(long x)
    {
        string s=to_string(x);
        int i=0,j=s.length()-1;
        while(i<j)
        {
            if(s[i]!=s[j]) return 0;
            i++,j--;
        }
        return 1;
    }
```## contest 103

Smallest Range I3
Snakes and Ladders6
Smallest Range II6
Online Election

### 908. Smallest Range I
<em>
Given an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i].

After this process, we have some array B.

Return the smallest possible difference between the maximum value of B and the minimum value of B.
</em>

given two number a<b:
if b-a>2k, the diff is b-a-2k.
if b-a<2k, the diff will be 0
```cpp
    int smallestRangeI(vector<int>& A, int K) {
        int min0=*min_element(A.begin(),A.end());
        int max0=*max_element(A.begin(),A.end());
        int d=max0-min0-2*K;
        return d>0?d:0;
    }
```

### 909. Snakes and Ladders
<em>
On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:


You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:

You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.
(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)
If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.
A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c].

Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at `3`, because you do not continue moving to `4`.)

Return the least number of moves required to reach square N*N.  If it is not possible, return -1.
</em>

convert to 1d array and uses bfs.

```cpp
    int snakesAndLadders(vector<vector<int>>& board) {
		vector<int> b1d;
		int n=board.size();
		for(int i=n-1;i>=0;i--)
		{
			int trow=n-1-i;
			if(trow%2==0) for(int t: board[i]) b1d.push_back(t);
			else for(int j=n-1;j>=0;j--) b1d.push_back(board[i][j]);
		}
        queue<int> q;
        vector<bool> visited(n*n);
        q.push(0);
        visited[0]=1;
        int step=0;
        while(q.size()){
            int sz=q.size();
            //cout<<endl;
            while(sz--){
                int ind=q.front();
                q.pop();
                //cout<<ind<<" ";
                if(ind==n*n-1) return step;
                for(int i=1;i<=6;i++){
                    int tind=ind+i;
                    if(tind<n*n){
                        if(b1d[tind]<0){
                            if(!visited[tind]) {q.push(tind),visited[tind]=1;}
                        }
                        else {
                            tind=b1d[tind]-1;
                            if(!visited[tind]) q.push(tind),visited[tind]=1;
                        }
                    }
                }
            }
            step++;
        }
        return -1;
    }
```

### 910. Smallest Range II
<em>
Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).

After this process, we have some array B.

Return the smallest possible difference between the maximum value of B and the minimum value of B.
</em>

greedy: sort the array, and left +k, right -k, compare the two options

```cpp
    int smallestRangeII(vector<int>& A, int K) {
        sort(A.begin(), A.end());
        int res = A[A.size() - 1] - A[0];
        int left = A[0] + K, right = A[A.size() - 1] - K;
        for (int i = 0; i < A.size() - 1; i++) {
            int maxi = max(A[i] + K, right), mini = min(left, A[i + 1] - K);
            res = min(res, maxi - mini);
        }
        return res;
    }
```

### 911. Online Election

<em>
In an election, the i-th vote was cast for persons[i] at time times[i].

Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.  

Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.
</em>
approach: binary search.
```cpp
    map<int, int> m;
    TopVotedCandidate(vector<int> persons, vector<int> times) {
        int n = persons.size(), lead = -1;
        unordered_map<int, int> count;
        for (int i = 0; i < n; ++i) {
            lead = ++count[persons[i]] >= count[lead] ? persons[i] : lead;
            m[times[i]] = lead;
        }
    }

    int q(int t) {
        return (--m.upper_bound(t))-> second;
    }
```

	
	
## contest 104

X of a Kind in a Deck of Cards3
Partition Array into Disjoint Intervals5
Word Subsets6
Cat and Mouse8

914. X of a Kind in a Deck of Cards
<em>
In a deck of cards, each card has an integer written on it.

Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:

Each group has exactly X cards.
All the cards in each group have the same integer.
</em>

- find the gcd of all card's number.

```cpp
    bool hasGroupsSizeX(vector<int>& deck) {
        unordered_map<int, int> count;
        int res = 0;
        for (int i : deck) count[i]++;
        for (auto i : count) res = __gcd(i.second, res);
        return res > 1;
    }
```

915. Partition Array into Disjoint Intervals
<em>
Given an array A, partition it into two (contiguous) subarrays left and right so that:

Every element in left is less than or equal to every element in right.
left and right are non-empty.
left has the smallest possible size.
Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.
</em>
lmax<rmin

```cpp
    int partitionDisjoint(vector<int>& A) {
        int n = A.size(), pmax = 0;
        vector<int> B(n);
        B[n - 1] = A[n - 1];
        for (int i = n - 2; i > 0; --i)
            B[i] = min(A[i], B[i + 1]);
        for (int i = 1; i < n; ++i) {
            pmax = max(pmax, A[i - 1]);
            if (pmax <= B[i]) return i;
        }
    }
```


916. Word Subsets
<em>
We are given two arrays A and B of words.  Each word is a string of lowercase letters.

Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, "wrr" is a subset of "warrior", but is not a subset of "world".

Now say a word a from A is universal if for every b in B, b is a subset of a. 

Return a list of all universal words in A.  You can return the words in any order.
</em>

combine b: but only takes the max frequency in b.
```cpp
    vector<string> wordSubsets(vector<string>& A, vector<string>& B) {
        vector<int> bmp(26);
        //reduce B into one word
        for(int i=0;i<B.size();i++)
        {
            vector<int> tmp(26);
            for(int j=0;j<B[i].size();j++) tmp[B[i][j]-'a']++;
            for(int j=0;j<26;j++)
            {
                bmp[j]=max(bmp[j],tmp[j]);
            }
        }
        
        vector<string> ans;
        for(int i=0;i<A.size();i++)
        {
            vector<int> tmp(26);
            for(int j=0;j<A[i].size();j++) tmp[A[i][j]-'a']++;
            bool found=1;
            for(int j=0;j<26;j++)
            {
                if(bmp[j]>tmp[j]) {found=0;break;}
            }
            if(found) ans.push_back(A[i]);
        }
        return ans;
    }
```

913. Cat and Mouse

<em>
A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.

The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.

Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.

During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1].

Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)

Then, the game can end in 3 ways:

If ever the Cat occupies the same node as the Mouse, the Cat wins.
If ever the Mouse reaches the Hole, the Mouse wins.
If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.
Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.
</em>

too hard!!	
## contest 105

Reverse Only Letters4
Maximum Sum Circular Subarray6
Complete Binary Tree Inserter7
Number of Music Playlists

917. Reverse Only Letters
<em>
Given a string S, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.
</em>

simple two pointer from both end

```cpp
    string reverseOnlyLetters(string S) {
      int left=0,right=S.length()-1;
      while(left<right)
      {
        while(!isalpha(S[left])) left++;
         while(!isalpha(S[right])) right--;
          if(left>=right) break;
          swap(S[left],S[right]);
          left++,right--;
      }
        return S;
    }
```

918. Maximum Sum Circular Subarray
<em>
Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.

Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.)

Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)

 
</em>

get the max and min at the same time, and the answer would be max(tsum-min,max) 

```cpp
    int maxSubarraySumCircular(vector<int>& A) {
        if (A.empty()) return 0;

        int n = A.size();
        int tot = 0, ma = A[0], last_ma = 0, mi = A[0], last_mi = 0;
        for (int i = 0; i < n; i++) {
            tot += A[i];
            ma = max(ma, last_ma = A[i] + max(0, last_ma));
            mi = min(mi, last_mi = A[i] + min(0, last_mi));
        }
        return ma < 0 ? ma : max(ma, tot - mi);
    }
```

919. Complete Binary Tree Inserter
<em>
A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.

Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:

CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root;
CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode;
CBTInserter.get_root() will return the head node of the tree.
</em>

using vector to store complete binary tree.
```cpp
    vector<TreeNode*> tree;
    CBTInserter(TreeNode* root) {
        tree.push_back(root);
        for(int i = 0; i < tree.size();++i) 
        {
            if (tree[i]->left) tree.push_back(tree[i]->left);
            if (tree[i]->right) tree.push_back(tree[i]->right);        
        }
    }
    
    int insert(int v) {
        int N = tree.size();
        TreeNode* node = new TreeNode(v);
        tree.push_back(node);
        if (N % 2)
            tree[(N - 1) / 2]->left = node;
        else
            tree[(N - 1) / 2]->right = node;
        return tree[(N - 1) / 2]->val;        
    }
    
    TreeNode* get_root() {
        return tree[0];
    }
```

920. Number of Music Playlists
<em>
Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:

Every song is played at least once
A song can only be played again only if K other songs have been played
Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.
0<=K<N<=L<=100
</em>

dp approach:
It is natural to define the problem as dp(n,l,k) with n songs, l in list, with k constraints.

We need to find how we can build the solution from sub-problems. That is the essence of DP technique.

if only N-1 songs are used in l-1 songs, then the last song can be anyone (not appeared yet)
dp[n,l,k]=n*dp[n-1,l-1,k]

if N songs are used in l-1 songs, then the previous k songs cannot be placed at the list end, which we have N-K choices
dp[n,l,k]=(n-k)*dp[n,l-1,k]

K dimension can be removed.

The answer is the sum of the two: dp[n,l,k]=n*dp[n-1, l-1, k]+(n-k)*dp[n, l-1, k], which is simplified to:

dp[n,l]=dp[n-1,l-1] * n+dp[n,l-1] * (n-k). 

Update only depends on left and up cell.

And the final answer is dp[N,L]

**Boundary condition:**
n=0, there is only 0 playlist dp[0,l]=0 but dp[0,0]=1 (empty vs empty)

since l>=n, we are only updating the upper triangle, and dp[n,n] is the boundary.

dp[n,n]=n! (when n songs and list is also n, any permutation is fine)

#### Implementation
```cpp
    int numMusicPlaylists(int N, int L, int K) {
        vector<vector<long long>> dp(N+1,vector<long long>(L+1));
        dp[0][0]=1;
        int mod=1e9+7;
        for(int i=1;i<=N;i++) dp[i][i]=(dp[i-1][i-1]*i)%mod;
        for(int n=1;n<=N;n++)
        {
            for(int l=n+1;l<=L;l++)
            {
                dp[n][l]=(n*dp[n-1][l-1])%mod;
                if(n>K) dp[n][l]+=((n-K)*dp[n][l-1])%mod;
                dp[n][l]%=mod;
            }
        }
        return dp[N][L];
    }
```
## contest 106

Sort Array By Parity II3
Minimum Add to Make Parentheses Valid4
3Sum With Multiplicity6
Minimize Malware Spread

922. Sort Array By Parity II
<em>
Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.

Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.

You may return any answer array that satisfies this condition.
</em>

two pointer

```cpp
    vector<int> sortArrayByParityII(vector<int>& A) {
        vector<int> ans(A.size());
        int odd=1,even=0;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]%2) {ans[odd]=A[i];odd+=2;}
            else {ans[even]=A[i],even+=2;}
        }
        return ans;
    }
```

923. 3Sum With Multiplicity
<em>
Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target.

As the answer can be very large, return it modulo 10^9 + 7
</em>
approach 1: sort and using 3 pointer.
```cpp
    int threeSumMulti(vector<int>& A, int target) {
        int modulus=1e9+7;
        int i,j,k,n=A.size();
        sort(A.begin(),A.end());
        int cnt_i=1,cnt_j=1,cnt_k=1,ans=0;
        int prev=0;
        for (i = 0; i < n; i++)
        {
            k = n - 1;
            j = i + 1;
            while (j < k)
            {
                if (A[i] + A[j] + A[k] > target) k--;
                else if (A[i] + A[j] + A[k] < target) j++;
                else //=target
                {
                    while (j < k-1 && A[k] == A[k - 1]) {k--;cnt_k++;}
                    while (j < k-1 && A[j] == A[j + 1]) {j++;cnt_j++;}
                    if(A[j]==A[k]) //choose 2 from number (cnk_k+cnt_j)
                        prev=((cnt_k+cnt_j)*(cnt_k+cnt_j-1)/2)%modulus;
                    else
                        prev=(cnt_j*cnt_k)%modulus;
                    ans+=prev;
                    ans%=modulus;
                    k--; j++;
                    cnt_i=1,cnt_j=1,cnt_k=1;
                }
            }
        }
        return ans%modulus;
    }
```

hashmap with 3 pointer:

```cpp
    int threeSumMulti(vector<int>& A, int target) {
        unordered_map<int, long> c;
        for (int a : A) c[a]++;
        long res = 0;
        for (auto it : c)
            for (auto it2 : c) {
                int i = it.first, j = it2.first, k = target - i - j;
                if (!c.count(k)) continue;
                if (i == j && j == k)
                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;
                else if (i == j && j != k)
                    res += c[i] * (c[i] - 1) / 2 * c[k];
                else if (i < j && j < k)
                    res += c[i] * c[j] * c[k];
            }
        return res % int(1e9 + 7);
    }
```


924. Minimize Malware Spread

<em>
In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.
</em>

union-find
idea: the node with the largest number of nodes in the set is the candidate.

```cpp
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        vector<int> parents(n),size(n,1);
        
        for(int i=0;i<n;i++) parents[i]=i;
        int num_set=n;
        for(int i=0;i<n;i++)
        {
            for(int j=i;j<n;j++)
            if(graph[i][j]) merge(parents,i,j,num_set,size);
        }
        //sort(initial.begin(),initial.end());
        //copy(size.begin(),size.end(),ostream_iterator<int>(cout," "));
        unordered_map<int,set<int>> mp;
        for(int i=0;i<initial.size();i++)
            mp[get_id(parents,initial[i])].insert(initial[i]);
        //if there are more than one, then it is 0
        int max0=0,ans=INT_MAX;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            if(it->second.size()>1) 
            {
                if(max0==0) ans=min(ans,*(it->second.begin()));
            }
            else
            {
                if(max0<size[it->first])
                {
                    max0=size[it->first];
                    ans=*(it->second.begin());
                }
                else if(max0==size[it->first])
                    ans=min(ans,*(it->second.begin()));
            }
        }
        return ans;
        
    }
    int get_id(vector<int>& parent,int i)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(vector<int>& parent,int i,int j,int& num_set,vector<int>& size)
    {
        int i_id=get_id(parent,i);
        int j_id=get_id(parent,j);
        if(i_id==j_id) return;
        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;}
        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;}
        num_set--;
    }    
```
	
	
## contest 107

925 Long Pressed Name - two pointer
926 Flip String to Monotone Increasing - two end min
927 Three Equal Parts - brutal force
928 Minimize Malware Spread II - union find, reverse.

925. Long Pressed Name
<em>
Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.

You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
</em>

two pointer approach:

```cpp
    bool isLongPressedName(string name, string typed) {
        //count char one by one
        int left1=0,left2=0;
        int cnt1=0,cnt2=0;
        while(left1<name.size() && left2<typed.size())
        {
            if(name[left1]==typed[left2])
            {
                while(name[left1+cnt1]==name[left1]) cnt1++;
                while(typed[left2+cnt2]==typed[left2]) cnt2++;
                if(cnt1>cnt2) return 0;
                left1+=cnt1,left2+=cnt2;
                cnt1=cnt2=0;
            }
            else return 0;
        }
        return left1==name.size() && left2==typed.size();
    }
```

926. Flip String to Monotone Increasing
<em>
A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)

We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.

Return the minimum number of flips to make S monotone increasing.
</em>

left and right two end meet:

```cpp
    int minFlipsMonoIncr(string S) {
        //need to flip to get two substring, left is all 0 right all 1
        int n=S.size();
        vector<int> left1(n+1);
        for(int i=0;i<S.size();i++) 
        {
            left1[i+1]=left1[i]+(S[i]=='1');
        }
            
        int minflip=n;
        int right0=0;
        for(int i=S.size()-1;i>=0;i--)
        {
            right0+=(S[i]=='0');
            minflip=min(minflip,right0+left1[i+1]-1);
            //cout<<i<<" "<<right0[i]<<" "<<left1[i+1]<<endl;
        }
        return minflip;
    }
```

927. Three Equal Parts
<em>
Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.

If it is possible, return any [i, j] with i+1 < j, such that:

A[0], A[1], ..., A[i] is the first part;
A[i+1], A[i+2], ..., A[j-1] is the second part, and
A[j], A[j+1], ..., A[A.length - 1] is the third part.
All three parts have equal binary value.
If it is not possible, return [-1, -1].

Note that the entire part is used when considering what binary value it represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.
</em>

- first we need have 3n set bits
- second we shall have 1 with same index difference
- right zero has effect, leading zero has no effect.

```cpp
    vector<int> threeEqualParts(vector<int>& A) {
      vector<int> ones;
        for(int i=0;i<A.size();i++) if(A[i]) ones.push_back(i);
        if(ones.size()%3) return vector<int>({-1,-1});
        if(ones.size()==0) return vector<int>({1,A.size()-1});
        int len=ones.size()/3;
        //check if the three parts has the same pattern
        for(int i=0;i<len;i++)
        {
            if(ones[i]-ones[0]!=ones[i+len]-ones[len] || ones[i]-ones[0]!=ones[i+2*len]-ones[2*len])
                return vector<int>({-1,-1});
        }
        //the pattern is the same, we need check number of zeros
        int nzeros3=A.size()-1-ones.back();
        int nzeros2=ones[2*len]-ones[2*len-1]-1;
        int nzeros1=ones[len]-ones[len-1]-1;
        
        if(nzeros1>=nzeros3 && nzeros2>=nzeros3)
        {
            return vector<int>({ones[len-1]+nzeros3,ones[2*len-1]+nzeros3+1});
        }
        return vector<int>({-1,-1});
    }
```

928. Minimize Malware Spread II

<em>

(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

 </em>

union-find

```cpp
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        //the idea: build the disjoint set by removing all infected nodes
        //add the infected nodes except the removed one one by one and find the one with most infected
        //union-find is fast to do union but not good for splitting and that is why we use the above approach
        int n=graph.size();
        vector<int> parents(n),size(n,1);
        //set<int> infected(initials.begin(),initials.end());
        
        sort(initial.begin(),initial.end());
        int minsize=INT_MAX,ans=INT_MAX;        
        for(int k=0;k<initial.size();k++)
        {
            int remove=initial[k];
            int infected_size=0;
            //build the union by disable the remove node
            for(int i=0;i<n;i++) {parents[i]=i;size[i]=1;}
            int num_set=n;
            for(int i=0;i<n;i++)
            {
                for(int j=i;j<n;j++)
                {
                    if(i==remove || j==remove) continue;
                    if(graph[i][j]) merge(parents,i,j,num_set,size);
                }
            }
            //get the number of infected nodes
            unordered_set<int> myset;
            for(int t=0;t<initial.size();t++)
            {
                if(initial[t]==remove) continue;
                myset.insert(get_id(parents,initial[t]));
            }
            
            for(auto it=myset.begin();it!=myset.end();it++)
                infected_size+=size[*it];
            if(minsize>infected_size) minsize=infected_size,ans=remove;
        }
        return ans;
    }
    int get_id(vector<int>& parent,int i)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(vector<int>& parent,int i,int j,int& num_set,vector<int>& size)
    {
        int i_id=get_id(parent,i);
        int j_id=get_id(parent,j);
        if(i_id==j_id) return;
        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;}
        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;}
        num_set--;
    }    
```	
	
 


## contest 108

929. Unique Email Addresses - hashmap
930 Binary Subarrays With Sum - sliding window
931 Minimum Falling Path Sum - dp
932 Beautiful Array - divide and conquer, greedy

### 929. Unique Email Addresses
<em>
Every email consists of a local name and a domain name, separated by the @ sign.

For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.

Besides lowercase letters, these emails may contain '.'s or '+'s.

If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.)

If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)

It is possible to use both of these rules at the same time.

Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? 
</em>

```cpp
    int numUniqueEmails(vector<string>& emails) {
        unordered_set<string> acct;
        for(string s: emails){
            int ind=s.find_first_of('@');
            string user=s.substr(0,ind);
            string domain=s.substr(ind);
            string trueuser;
            for(char c: user){
                if(c=='.') continue;
                if(c=='+') break;
                trueuser+=c;
            }
            acct.insert(trueuser+domain);
        }
        return acct.size();
    }
```

### 930. Binary Subarrays With Sum
<em>
In an array A of 0s and 1s, how many non-empty subarrays have sum S?
</em>
sliding window. left 0 and right 0 will add to the subarray.
- approach 1: get the 1's indices and work on the new array
- using prefix sum and hashmap
```cpp
    int numSubarraysWithSum(vector<int>& A, int S) {
        unordered_map<int, int> c({{0, 1}});
        int psum = 0, res = 0;
        for (int i : A) {
            psum += i;
            res += c[psum - S];
            c[psum]++;
        }
        return res;
    }
```

sliding window:
we accumulate the sum, when it is >S, we advance the left pointer.

```cpp
    int numSubarraysWithSum(vector<int>& A, int S) {
        return atMost(A, S) - atMost(A, S - 1);
    }

    int atMost(vector<int>& A, int S) {
        if (S < 0) return 0;
        int res = 0, i = 0, n = A.size();
        for (int j = 0; j < n; j++) {
            S -= A[j];
            while (S < 0)
                S += A[i++];
            res += j - i + 1;
        }
        return res;
    }
```
The best of this: do not need complicated logic, but simple sliding window.

### 931. Minimum Falling Path Sum
<em>
Given a square array of integers A, we want the minimum sum of a falling path through A.

A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.
</em>

simple dp:

```cpp
    int minFallingPathSum(vector<vector<int>>& A) {
        //use the matrix A for dp
        int n=A.size();
        for(int i=1;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(j>0 && j<n-1)
                    A[i][j]+=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]);
                else if(j==0) A[i][j]+=min(A[i-1][j],A[i-1][j+1]);
                else A[i][j]+=min(A[i-1][j],A[i-1][j-1]);
            }
        }
        //print(A);
        int ans=A[n-1][0];
        for(int i=0;i<n;i++) ans=min(ans,A[n-1][i]);
        return ans;
    }
```

### 932. Beautiful Array
<em>
For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that:

For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].

Given N, return any beautiful array A.  (It is guaranteed that one exists.)
</em>

thinking process:
- if A[i] is odd, A[j] is even, then A[i]+A[j] is odd, then no A[k]*2=A[i]+A[j]
- if A is beautiful array, 2*A is also a beautiful array-->this we can expand the range. 
for example odd=[1,3,5],even=[2,4,6], or equivalently odd=2i-1,even=2i. we only need to make i beautiful array
len=1: [1]
len=2: [1,2] 2i-1,2i i=1
len=4: [1,3,2,4], 2i-1, 2i, i=1,2
len=8: [1,5,3,7,2,6,4,8]
....

divide and conquer.

```cpp
    vector<int> beautifulArray(int N) {
        vector<int> res = {1};
        while (res.size() < N) {
            vector<int> tmp;
            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);
            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);
            res = tmp;
        }
        return res;
    }
```

	
	




## contest 109

Number of Recent Calls4
Knight Dialer5
Shortest Bridge6
Stamping The Sequence

933. Number of Recent Calls
<em>
Write a class RecentCounter to count recent requests.

It has only one method: ping(int t), where t represents some time in milliseconds.

Return the number of pings that have been made from 3000 milliseconds ago until now.

Any ping with time in [t - 3000, t] will count, including the current ping.

It is guaranteed that every call to ping uses a strictly larger value of t than before.

 

Example 1:

Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]
Output: [null,1,2,3,3]
 

Note:

Each test case will have at most 10000 calls to ping.
Each test case will call ping with strictly increasing values of t.
Each call to ping will have 1 <= t <= 10^9.
</em>

using deque

```cpp
    deque<int> dq;
    RecentCounter() {
        
    }
    
    int ping(int t) {
        dq.push_back(t);
        while(t-dq.front()>3000) dq.pop_front();
        return dq.size();
    }
```

934. Shortest Bridge
<em>
In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)

Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.

Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)

 
</em>

equivalent: find the min distance between two islands
- find the two parties
- find the shortest distance

```cpp
    int shortestBridge(vector<vector<int>>& A) {
        //two party problem can use paint
        //or use dfs/bfs to reach the other party
        //we can calculate the min distance between the two parties
        vector<vector<int>> partyA,partyB;
        for(int i=0;i<A.size();i++)
        {
            for(int j=0;j<A[0].size();j++)
            {
                if(A[i][j]==1) 
                {
                    if(partyA.size()==0) dfs(A,i,j,partyA);
                    else dfs(A,i,j,partyB);
                }
            }
        }
        //cout<<"OK";
        int mindist=INT_MAX;
        for(int i=0;i<partyA.size();i++)
        {
            for(int j=0;j<partyB.size();j++)
                mindist=min(mindist,abs(partyA[i][0]-partyB[j][0])+abs(partyA[i][1]-partyB[j][1]));
        }
        return mindist-1;
    }
    void dfs(vector<vector<int>>& A,int i,int j,vector<vector<int>>& pa)
    {
        //4 directions
        A[i][j]=2; 
        int n=A.size(),m=A[0].size();
        pa.push_back({i,j});
        if(i>0 && A[i-1][j]==1) dfs(A,i-1,j,pa);
        if(j>0 && A[i][j-1]==1) dfs(A,i,j-1,pa);
        if(i<n-1 && A[i+1][j]==1) dfs(A,i+1,j,pa);
        if(j<m-1 && A[i][j+1]==1) dfs(A,i,j+1,pa);
    }
```
see similar problem 1568. Minimum Number of Days to Disconnect Island

935. Knight Dialer
<em>
The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:

A chess knight can move as indicated in the chess diagram below:
We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).
Given an integer n, return how many distinct phone numbers of length n we can dial.

You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.

As the answer may be very large, return the answer modulo 109 + 7.
</em>

- dp: each step we may have 10 starting positions.
- similar to climb stairs, there are several paths from prev to current positions.

```cpp
    int knightDialer(int N) {
        if(N==1) return 10;
        vector<vector<int>> adj={{4,6},{8,6},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};

        vector<int> curr(10),prev(10);
        for(int i=0;i<10;i++) prev[i]=1;

        int mod=1e9+7;
        for(int i=1;i<N;i++) //hops
        {
            for(int j=0;j<10;j++) //digits
            {
                curr[j]=0;
                for(int k=0;k<adj[j].size();k++)
                {
					curr[j]+=prev[adj[j][k]];
					curr[j]%=mod;
				}
            }
            prev=curr;
        }
        
        int sum=0;
        for(int i=0;i<10;i++) {sum+=prev[i];sum%=mod;}
        return sum;
        
    }
```	
	
936. Stamping The Sequence

<em>
You want to form a target string of lowercase letters.

At the beginning, your sequence is target.length '?' marks.  You also have a stamp of lowercase letters.

On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to 10 * target.length turns.

For example, if the initial sequence is "?????", and your stamp is "abc",  then you may make "abc??", "?abc?", "??abc" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)

If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array.

For example, if the sequence is "ababc", and the stamp is "abc", then we could return the answer [0, 2], corresponding to the moves "?????" -> "abc??" -> "ababc".

Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves.  Any answers specifying more than this number of moves will not be accepted.
</em>

reverse operation and matching:

```cpp
    vector<int> movesToStamp(string stamp, string target) {
        //reverse operation: matched then change it to ***
        //until we change the target string into *****
        //note we can only match one end if it is covered
        int n=target.length();
        string final(n,'*');
        vector<int> ans;
        while(target!=final)
        {
            int ind=match_change(target,stamp);
            if(ind==-1) return vector<int>();
            ans.push_back(ind);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
    int match_change(string& target,string stamp)
    {
        //find the first matching and return
        //at least has one non * char inside, * matches any char
        bool matched=0;
        for(int i=0;i<target.size();i++)
        {
            int cnt_match=0;
            int j=0;
            for(j=0;j<stamp.size();j++)
            {
                if(target[i+j]=='*') continue;
                if(target[i+j]==stamp[j]) cnt_match++;
                else break;
            }
            if(j==stamp.size()&& cnt_match) 
            {
                for(j=0;j<stamp.size();j++) target[i+j]='*';
                return i;
            }
        }
        return -1; //no matching
    }
```

	## contest 110

Reorder Data in Log Files4
Range Sum of BST4
Minimum Area Rectangle5
Distinct Subsequences II7

937. Reorder Data in Log Files
<em>
You have an array of logs.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digits.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.

Return the final order of the logs.
</em>

approach:
- hashmap

```cpp
    vector<string> reorderLogFiles(vector<string>& logs) {
        map<string,set<string>> ms;
        vector<string> dlogs;
        for(string l: logs){
            int ind=l.find_first_of(' ');
            //while(l[ind]==' ') ind++;
            ind++;
            if(isdigit(l[ind])){
                dlogs.push_back(l);
            }
            else ms[l.substr(ind)].insert(l.substr(0,ind));
        }
        vector<string> ans;
        for(auto t: ms) 
            for(auto s: t.second) ans.push_back(s+t.first);
        for(auto t: dlogs) ans.push_back(t);
        return ans;
    }
```

note need use multimap to pass new tests.

938. Range Sum of BST
<em>
Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).

The binary search tree is guaranteed to have unique values.	
</em>

```cpp
    int rangeSumBST(TreeNode* root, int L, int R) {
        int sum=0;
        inorder(root,sum, L, R);
        return sum;
    }
    void inorder(TreeNode* root, int& sum,int L, int R)
    {
        if(!root) return;
        inorder(root->left,sum,L,R);
        if(root->val>=L && root->val<=R) sum+=root->val;
        inorder(root->right,sum,L,R);
    }
```

O(N) but we shall have O(H):
```cpp
    int rangeSumBST(TreeNode* root, int L, int R) {
        if(!root) return 0;
        if(root->val<L) return rangeSumBST(root->right,L,R);
        if(root->val>R) return rangeSumBST(root->left,L,R);
        return root->val+rangeSumBST(root->left,L,R)+rangeSumBST(root->right,L,R);
    }
```

939. Minimum Area Rectangle
<em>
Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.

If there isn't any rectangle, return 0.
</em>

divide and conquer

```cpp
    int minAreaRect(vector<vector<int>>& points) {
        map<int,set<int>> xy;
        for(auto p:points){
            xy[p[0]].insert(p[1]);
        }
        auto it=++xy.begin();
        int minarea=INT_MAX;
        for(;it!=xy.end();it++){ //find rect with previous coordinates
            for(auto it1=xy.begin();it1!=it;it1++){
                //find the intersection of two sets
                set<int> intersection;
                for(auto i: it->second){
                    if(it1->second.count(i)) intersection.insert(i);
                }
                if(intersection.size()<2) continue;
                int mindy=INT_MAX;
                auto iter=intersection.begin(),iter1=++intersection.begin();
                for(;iter1!=intersection.end();iter++,iter1++){
                    mindy=min(mindy,(*iter1)-(*iter));
                }
                //cout<<mindy;
                if(mindy<INT_MAX)
                minarea=min(minarea,mindy*(it->first-it1->first));
            }
        }
        return minarea==INT_MAX?0:minarea;
    }
```

940. Distinct Subsequences II
<em>
Given a string S, count the number of distinct, non-empty subsequences of S .

Since the result may be large, return the answer modulo 10^9 + 7.
</em>

dp: ending with different char.
```cpp
    int distinctSubseqII(string S) {
        int endwith[26]={0};
        int mod=1e9+7;
        for(int i=0;i<S.length();i++)
        {
            int t=0;
            for(int j=0;j<26;j++)
                t+=endwith[j], t%=mod;
            endwith[S[i]-'a']=t+1;
            //endwith[S[i]-'a']=accumulate(endwith,endwith+26,1LL)%mod;
        }
            
        return accumulate(endwith,endwith+26,0LL)%mod;
    }
```	
	

## contest 111
941. Valid Mountain Array (array, *)
942. Delete columns to make sorted (2d array, *)
943. DI string match (greedy, **)
944. Find the shortest superstring (dp, bitset, travelling businessman shortest distance)

941. Valid Mountain Array
```cpp
    bool validMountainArray(vector<int>& A) {
        if(A.empty()) return 0;
        int i=0,n=A.size(),j=n-1;
        while(i+1<n && A[i+1]>A[i]) i++;
        while(j && A[j-1]>A[j]) j--;
        return i<n-1 && j>0 && i==j;
    }
```
944. Delete Columns to Make Sorted
```cpp
    int minDeletionSize(vector<string>& A) {
        int ans=0;
        if(A.empty()) return 0;
        for(int j=0;j<A[0].size();j++){
            char c=A[0][j];
            for(int i=1;i<A.size();i++){
                if(A[i][j]<c) {ans++;break;}
                c=A[i][j];
            }
        }
        return ans;
    }
```
942. DI String Match
greedy: from two end to meet.
```cpp
    vector<int> diStringMatch(string S) {
        //greedy: I from smallest, D from largest
        int n=S.size();
        int i=0,j=n;
        vector<int> ans;
        for(char c: S){
            if(c=='I') ans.push_back(i++);
            else ans.push_back(j--);
        }
        ans.push_back(i);
        return ans;
    }
```
	
943. Find the Shortest Superstring.md

### Problem Summary
Given an array A of strings, find any smallest string that contains each string in A as a substring.

We may assume that no string in A is substring of another string in A.

 
Example 1:

Input: ["alex","loves","leetcode"]
Output: "alexlovesleetcode"
Explanation: All permutations of "alex","loves","leetcode" would also be accepted.
Example 2:

Input: ["catg","ctaagt","gcta","ttca","atgcatc"]
Output: "gctaagttcatgcatc"
 

Note:

1 <= A.length <= 12
1 <= A[i].length <= 20

### Analysis
- equivalent: think it as a graph, max the total sum of overlap, visiting each node once.
- traveling salesman problem

By calculating the total appending length from si to sj, the problem is the shortest path visiting each node once problem (graph[i,j])
By calculating the overlap length of si and sj, the problem is the max path (with weight) visiting each node once problem

steps:
1. form the graph, the edge i,j represents the number of char to add.
(define this is critical: A->B->C len(A)+len(B)-len(AB)+len(C)-len(BC), len(AB) is the A's suffix vs A.prefix common length. we define len(B)-len(AB) the edge weight, the number of chars to add. 
from A to destination we will get len(A)+sum(edge)).
2. using the bitset and check if we can relax using all other nodes
3. keep the shortest path
4. dp[i,j]: the status i and ending node j.
5. relax: dp[i,j]=min(dp[i,j],dp[i-(1<<j),k]+dist(k,j)). 
6. record the path and do backtrace.

```cpp
    string shortestSuperstring(vector<string>& A) {
        int n=A.size(); //number of nodes
        vector<vector<int>> graph(n,vector<int>(n));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                graph[i][j]=calc(A[i],A[j]);
                graph[j][i]=calc(A[j],A[i]);
            }
        }
        //dp: also need keep the path
        //other dimension shall be the bitset
        int m=1<<n;
        vector<vector<int>> dp(m,vector<int>(n,INT_MAX)),path(m,vector<int>(n));
        int last=-1,gmin=INT_MAX;
        //dp[i,j]: min distance ending with node j. 
        for(int i=1;i<m;i++) //0x0001 to 0xffff
        {
            for(int j=0;j<n;j++)
            {
                if(i & (1<<j)) //if node j is visited
                {
                    int prev=i-(1<<j); //previous status
                    if(prev==0) dp[i][j]=A[j].length(); //in case j is the starting node.
                    else //try to use other edge to relax  
                    {
                        for(int k=0;k<n;k++)
                        {
                            if(dp[prev][k]<INT_MAX && dp[i][j]>dp[prev][k]+graph[k][j])
                            {
                                dp[i][j]=dp[prev][k]+graph[k][j];
                                path[i][j]=k; //save the node
                            }
                        }
                    }
                }
                if(i==m-1 && gmin>dp[i][j]) {gmin=dp[i][j];last=j;} //all visited status==m-1, ending with different nodes.
            }
        }

        //backtrace to get the results, path stored in path[i][j]
        int curr=m-1; //0xffff
        vector<int> seq;
        while(curr)
        {
            seq.push_back(last);
            int t=path[curr][last];
            curr-=(1<<last);
            last=t;
        }
        //now connect the strings
        string ans=A[seq.back()];//the first
        for(int i=seq.size()-2;i>=0;i--)
        {
            int num_app=graph[seq[i+1]][seq[i]];
            int len=A[seq[i]].length();
            ans+=A[seq[i]].substr(len-num_app);
        }
        return ans;
    }
    
    int calc(string& a,string& b) //a -> b the adding length.
    {
        int m=a.size(),n=b.size();
        for(int i=1;i<a.size();i++) //no duplicates
        {
            if(b.substr(0,m-i)==a.substr(i)) return n-(m-i);
        }
        return n;
    }
```
## contest 112
945. min increment to make array unique (greedy)
946. validate stack sequences (stack)
947. most stones removed with same row or column (union-find)
948. bag of tokens (greedy)

### 945. Minimum Increment to Make Array Unique
one move: increment 1 to one element.
greedy: sort and increment neighborings and propagate.
```cpp
    int minIncrementForUnique(vector<int>& A) {
        sort(begin(A),end(A));
        int ans=0;
        for(int i=1;i<A.size();i++){
            int d=A[i]-A[i-1];
            ans+=max(1-d,0);
            A[i]+=max(1-d,0);
        }
        return ans;
    }
```	

### 946. Validate Stack Sequences
given pushed and popped with the same size and permutation of 1 to n.
two pointer, keep pushing if top!=pop, keep popping if top==pop.

```cpp
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        //simulate the stack
        int j=0,n=pushed.size();
        stack<int> st;
        for(int i=0;i<pushed.size();i++){
            st.push(pushed[i]);
            while(st.size() && j<n && st.top()==popped[j]) st.pop(),j++;
        }
        while(j<n && st.size()){
            if(popped[j]!=st.top()) return 0;
            st.pop();
            j++;
        }
        return st.empty();
    }
```	

### 947. Most Stones Removed with Same Row or Column
equivalent to find the number of disjoint set.
- since the m and n is not known, better use hashmap for the parent
- when no parent, we set the parent to itself and add size
- union the row and column (we shall differ the row and col, we use ~col to make it far apart)
- when union, the sz--

```cpp
    unordered_map<int,int> parent;
    int sz;
    int removeStones(vector<vector<int>>& stones) {
        //union-find.. equivalent to find number of set.
        //union column and rows.
        sz=0;
        for(auto p: stones){
            merge(p[0],~p[1]);
        }
        return stones.size()-sz;
    }
    int findp(int i){
        if(!parent.count(i)) {sz++;return parent[i]=i;}
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(int i,int j){
        int pi=findp(i),pj=findp(j);
        if(pi!=pj){
            parent[pi]=pj;
            sz--;
        }
    }
```

### 948. Bag of Tokens
<em>
ou have an initial power P, an initial score of 0 points, and a bag of tokens.

Each token can be used at most once, has a value token[i], and has potentially two ways to use it.

If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.
If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.
Return the largest number of points we can have after playing any number of tokens.
</em>

greedy:
buy the cheapest and sell at the most expensive
using two pointer
keep the max since we may lose points after the max and then we shall stop!!
```cpp
    int bagOfTokensScore(vector<int>& tokens, int P) {
        sort(tokens.begin(), tokens.end());
        int res = 0, points = 0, i = 0, j = tokens.size() - 1;
        while (i <= j) {
            if (P >= tokens[i]) {
                P -= tokens[i++];
                res = max(res, ++points);
            } else if (points > 0) {
                points--;
                P += tokens[j--];
            } else {
                break;
            }
        }
        return res;
    }
```
## contest 113
949. Largest Time for Given Digits 4
950. Flip Equivalent Binary Trees 5
951. Reveal Cards In Increasing Order 5
952. Largest Component Size by Common Factor 8

949. Largest Time for Given Digits.md

### Problem summary
given 4 digits from 0 to 9, build a largest time

### idea
greedy choice does not work and wasted me a lot of time, since the marked easy cheated a lot of people. This shall be at least medium.
4 digits only has 24 permutations and we build each of them, get rid of all those illegals and find the max

### code
```cpp
    string largestTimeFromDigits(vector<int>& A) {
        int maxtime=-1;
        sort(A.begin(),A.end());
        do{
            if(isvalid(A)) maxtime=max(maxtime,A[0]*1000+A[1]*100+A[2]*10+A[3]);
        }while(next_permutation(A.begin(),A.end()));
        if(maxtime<0) return "";
        string ans(5,':');
        ans[0]=maxtime/1000+'0';
        ans[1]=(maxtime%1000)/100+'0';
        ans[3]=(maxtime%100)/10+'0';
        ans[4]=(maxtime%10)+'0';
        return ans;
    }
    bool isvalid(vector<int>& A)
    {
        int hr=A[0]*10+A[1];;
        int min0=A[2]*10+A[3];
        return hr<24 && min0<60;
    }
```

### comment:
- note to use the next-permutation we need first sort the array, otherwise it will not be correct (from the smallest first) otherwise those smaller permutations are discarded.

950. Reveal Cards In Increasing Order.md

### problem summary
given a list of cards, the following operation
take the top one, move the second one to the bottom
need to form a list in increasing order
return the original order of the cards

### idea
reverse build the deck
the largest one first
when there are two or more cards, move the top one to the bottom and then add the new one
using a deque to add and pop easily

### code
```cpp
    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        //smallest always on top
        sort(deck.begin(),deck.end(),greater<int>());
        deque<int> dq;
        //reverse build the array, put back the cards sequentially
        //before add the card, we need bring the back to the front
        for(int i=0;i<deck.size();i++)
        {
            if(dq.size()>=2) 
            {
                dq.push_front(dq.back());
                dq.pop_back();
            }
            dq.push_front(deck[i]);
        }
        return vector<int>(dq.begin(),dq.end());
    }

```

951. Flip Equivalent Binary Trees.md

### problem summary
choose any node and flip its left and right tree, you can perform any times
check if two trees are from these operations

### idea
this is similar to scramble string, but this is much simpler.
check recursively
left vs left && right vs right
left vs right && right vs left

### code
```cpp
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if(!root1 && !root2) return 1; //both null
        else if(!root1 || !root2) return 0;
        if(root1->val!=root2->val) return 0;
        if(flipEquiv(root1->left,root2->left) && flipEquiv(root1->right,root2->right)) return 1;
        if(flipEquiv(root1->left,root2->right) && flipEquiv(root1->right,root2->left)) return 1;
        return 0;
    }
```


952. Largest Component Size by Common Factor.md

### Problem summary
if two numbers share same common factor(>1) connect them
return the largest length of connected group
array length could be very large up to 2e4
element max is 1e5
### idea
1. this is a disjoint set problem
2. blindly merge two numbers the complexity is O(N^2) and could get TLE, need some improvements here

since a number can be joined in the group if there is one common factor, so we can keep a set of factors for the group. Do not need to check elements one by one.

we first prime factorize each number. When a number is added into a group, merge all its prime factors into the group also.
The hardest part is the optimization!
Another way is to merge the prime factors together.

naive algorithm using disjoint set
```cpp
    int largestComponentSize(vector<int>& A) {
        int n=A.size();
        sort(A.begin(),A.end());
        vector<int> parent(n),size(n,1);
        for(int i=0;i<n;i++) parent[i]=i;
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(get_parent(i,parent)==get_parent(j,parent)) continue;
                if(gcd(A[j],A[i])>1) merge(i,j,parent,size);
            }
        }
        return *max_element(size.begin(),size.end());
    }
    int get_parent(int i,vector<int>&parent)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(int i,int j,vector<int>& parent,vector<int>& size)
    {
        int pi=get_parent(i,parent);
        int pj=get_parent(j,parent);
        if(pi<pj) {parent[pj]=pi,size[pi]+=size[pj],size[pj]=0;}
        if(pi>pj) {parent[pi]=pj,size[pj]+=size[pi],size[pi]=0;}
    }
    int gcd(int a,int b) 
    {
      if(a==0) return b;
      return (b%a,a);
    }
```    
This get TLE.

using prime factorization, each number is represented as a hashset of prime numbers. Since we sorted the array, the larger ones tends to have more prime factors. 

Since the prime numbers are limited, we can merge the prime numbers instead of the array.
We can build a hashmap with the key as the prime factor, and the value as the set of element index.

```cpp
    int largestComponentSize(vector<int>& A) {
        int n=A.size();
        sort(A.begin(),A.end());
        vector<int> parent(n),size(n,1);
        for(int i=0;i<n;i++) parent[i]=i;
        //vector<unordered_set<int>> factors(n);
        unordered_map<int,set<int>> factors;
        unordered_set<int> tset;
        //build the prime factors for each number
        for(int i=0;i<n;i++)
        {
            tset=factorize(A[i]);
            for(auto tt:tset) factors[tt].insert(i);
        }
        for(auto t:factors)
        {
            auto t0=t.second;
            if(t0.size()>=2)
            {
                int node=*t0.begin();
                for(auto it=++t0.begin();it!=t0.end();it++) merge(node,*it,parent,size);
            }
        }
        return *max_element(size.begin(),size.end());
    }
    int get_parent(int i,vector<int>&parent)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    int merge(int i,int j,vector<int>& parent,vector<int>& size)
    {
        int pi=get_parent(i,parent);
        int pj=get_parent(j,parent);
        if(pi<pj) {parent[pj]=pi,size[pi]+=size[pj],size[pj]=0;}
        if(pi>pj) {parent[pi]=pj,size[pj]+=size[pi],size[pi]=0;}
        return min(pi,pj);
    }
    unordered_set<int> factorize(int x)
    {
        unordered_set<int> prime;
        int d=2;
        while(d*d<=x)
        {
            if(x%d==0) 
            {
                while(x%d==0) x/=d; //remove all its multiples
                prime.insert(d);
            }
            d++;
        }
        if(x>1 || prime.empty()) prime.insert(x); //if there is no factor, itself is a prime number
        return prime;
    }
```

And this solution got accepted about 300ms

### comments
The key of the idea is using the prime factor to associate those elements.


## contest 114
953. Verifying an Alien Dictionary 4
954. Array of Doubled Pairs 5
955. Delete Columns to Make Sorted II 6
956. Tallest Billboard 8

953. Verifying an Alien Dictionary.md
### Problem Summary
Given the order of chars, check if the list of words is sorted

### idea
simple just using hashmap to map to normal order

### implementation
```cpp
    bool isAlienSorted(vector<string>& words, string order) {
        unordered_map<char,char> mp;
        for(int i=0;i<26;i++) mp[order[i]]='a'+i;
        char c=order[0];
        for(int i=0;i<words.size();i++)
        {
            for(int j=0;j<words[i].size();j++) words[i][j]=mp[words[i][j]];
        }
        
        return is_sorted(words.begin(),words.end());
    }
```    

954. Array of Doubled Pairs.md

### Problem Summary
Check if a list of numbers can be divided n and 2n pair. With negative positives.

### idea
In contest, I converted all negatives into positive and sort in a multiset.
Actually there is a flaw: even if we convert, we shall consider negatives and positives separately.

### implementation (with flaw)
```cpp
   bool canReorderDoubled(vector<int>& A) {
        multiset<int> pos,neg;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]>=0) pos.insert(A[i]);
            else neg.insert(-A[i]);
        }
        if(pos.size()%2 || neg.size()%2) return 0;
        return checkpairs(pos) && checkpairs(neg);
     }
    bool checkpairs(multiset<int> ms)
    {
        auto it=ms.begin();
        while(ms.size())
        {
            it=ms.begin();
            auto it1=ms.upper_bound((*it)*2);
            --it1;
            if(it1!=ms.begin() && *it1==*it*2)
            {
                ms.erase(it1);
                ms.erase(ms.begin());
            }
            else return 0;
            
        }
        return 1;        
    }
```

955. Delete Columns to Make Sorted II.md

### Problem summary
Given a list of words with same length, get min number of columns to remove to make the strings sorted

### Idea
column by column check if the previous strings are sorted.
0 to jth column is not sorted, mark the jth column to all '*'
if found some strings are equal, we need check later columns.
If it is sorted, we are done. No need to go further

### implementation
```cpp
    int minDeletionSize(vector<string>& A) {
        //previous col is sorted then is over
        int ans=0;
        int m=A.size(),n=A[0].size();
        for(int j=0;j<n;j++)
        {
            bool need_next=0;
            int i=1;
            for(;i<m;i++)
            {
                if(A[i].substr(0,j+1)<A[i-1].substr(0,j+1)) {ans++;break;}
                else if(A[i].substr(0,j)==A[i-1].substr(0,j)) need_next=1;
            }
            if(i==m && !need_next) return ans; //sorted
            if(i<m) for(int k=0;k<m;k++) A[k][j]='*';
        }
        return ans;
    }
```

956. Tallest Billboard.md

### Problem Summary
Given a list of numbers (positive), we need build two sums with same value. Get the maximum sum. Cannot reuse the numbers

### Idea
This is a DP problem and I tried to use knapsack with status (since it needs two target sum), but I did not make it.
We have observed that the target sum<=totalsum/2.
If dp is hard to approach, we can try recursion + memoization method.
One observation is very useful for the approach:
for every number, we have option: not choose, 0, choose to positive, 1, choose to negative -1. Our goal is to make the sum to be 0.

dp[i][j] represents whether the sum of first i numbers can be j - 5000. dp[0][5000] = true.
Then dp[i + 1][j] = dp[i][j - rods[i]] | dp[i][j + rods[i]] | dp[i][j].
max[i][j] represents the largest sum of all positive numbers when the sum of first i numbers is j - 5000.

Time complexity: O(N*sum)

Note: 
1. the target sum can be from -5000 to 5000. so we elevated the target sum index to 5000 so the index can be from 0 to 10001
2. we only maximize the positive sum;
3. the target sum is 0.

### implementation
```cpp
    int tallestBillboard(vector<int>& rods) {
        int n=rods.size();
        int tsum=accumulate(rods.begin(),rods.end(),0)/2;
        vector<vector<int>> dp(n,vector<int>(10001));//dp[i,j]: -tsum to tsum
        return helper(rods,0,5000,dp);
    }
    
    int helper(vector<int>& rods,int start,int tsum,vector<vector<int>>& dp)
    {
        if(start==rods.size()) return tsum==5000?0:INT_MIN/2;
        if(dp[start][tsum]) return dp[start][tsum];
        int ans=helper(rods,start+1,tsum,dp); //do not use current
        ans=max(ans,helper(rods,start+1,tsum-rods[start],dp)); //choose rods[i] as negative
        ans=max(ans,helper(rods,start+1,tsum+rods[start],dp)+rods[start]); //choose rods[i] as positive
        //note the answer is the sum of positives
        return dp[start][tsum]=ans;
    }
```

Convert to dp is a knapsack problem with not using, using to positive, using to negative, and maximize the positve sum.

## contest 115
957. Check Completeness of a Binary Tree5
958. Prison Cells After N Days6
959. Regions Cut By Slashes7
960. Delete Columns to Make Sorted III

957. Prison Cells After N Days.md

### Problem Summary
8 cell, when neighboring cell is the same, then it become 1, otherwise it becomes 0

Key observation:
- 8 bits only have at most 256 combinations, so when N is really large it is just repeating the pattern
- the boundary cell, the leftmost and rightmost will become 0 at the second day.
- using a hashmap to store the status and its first position, when a status appear again, we know the period.
- skipping to the remaing part and do the iteration.

### Implementation
```cpp
    vector<int> prisonAfterNDays(vector<int>& cells, int N) {
        //neigboring 0,0=>1 1,1=>0, otherwise =>0
        int n=cells.size();
        unordered_map<int,int> status;
        vector<int> curr(n);
        int period;
        for(int i=1;i<=N;)
        {
            int res=0;
            for(int j=1;j<n-1;j++)
            {
                int t=cells[j-1]+cells[j+1];
                curr[j]=t==1?0:1;
                res+=(curr[j]<<j);
            }
            if(status.count(res)) //we have a repeat pattern
            {
                period=i-status[res];
                int nskip=(N-i)/period*period;
                i+=nskip;
                i++;
            }
            else {status[res]=i;i++;}
            cells=curr;
        }
        return cells;
    }
```    

### Comments


958. Check Completeness of a Binary Tree.md

### Approach
level traversal. Pushing node's child into queue (including null child). When we find the first null node, we mark it, if there is no more null nodes behind, then it is a full tree.

### Implementation
```cpp
    bool isCompleteTree(TreeNode* root) {
        //level order traversal
        if(!root) return 1;
        queue<TreeNode*> q;
        q.push(root);
        int level=0;
        bool flag_null=0;
        while(q.size())
        {
            int sz=q.size();
            for(int i=0;i<sz;i++)
            {
                TreeNode* node=q.front();
                q.pop();
                if(node && flag_null) return 0;
                if(!node) {flag_null=1;continue;}
                q.push(node->left);
                q.push(node->right);
            }
            level++;
        }
        return 1;
    }
```    

959. Regions Cut By Slashes.md

### Problem Summary
The problem description is a bit hard to understand. It is easy to think that the problem can be approached using dfs/bfs/disjoint set. The difficulty lies how to convert the / and \ into more understandable format.
A / or \ split a cell into half. But we don't know how to represent a half cell.
If we upsample the grid, we can easily split the area with an approximated line. 
2x2 is not sufficient since the line is too thick to block the connected area. Using a 3x3 grid is clear enough
for example this case:
//
 /

### Implementation
using dfs and mark those visited, very simple

```cpp
    int regionsBySlashes(vector<string>& grid) {
        //upsample the grid by 2, so we can represent the /\ in a whole cell
        int n=grid.size();
        vector<vector<int>> g(3*n,vector<int>(3*n));

        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]=='\\') {g[3*i][3*j]=g[3*i+1][3*j+1]=g[3*i+2][3*j+2]=1;}
                else if(grid[i][j]=='/') {g[3*i][3*j+2]=g[3*i+1][3*j+1]=g[3*i+2][3*j]=1;}
            }
        }
        int numset=0;
        for(int i=0;i<3*n;i++)
        {
            for(int j=0;j<3*n;j++)
            {
                if(!g[i][j]) dfs(g,i,j),numset++;
            }
        }
        return numset;
    }
    void dfs(vector<vector<int>>& g,int i,int j)
    {
        if(i>=0 && j>=0 && i<g.size() && j<g.size()&& g[i][j]==0)
        {
            g[i][j]=1; //marks as visited
            dfs(g,i-1,j);
            dfs(g,i+1,j);
            dfs(g,i,j-1);
            dfs(g,i,j+1);
        }
    }
```

960. Delete Columns to Make Sorted III.md

### Problem summary
Given a list of words same length, each word in a row. return min number of columns removed so that every row is sorted.
Apparently this is a dp problem.

### approach
The final will be the longest increasing subsequence for all rows. We must apply the longest increasing subsequence to all strings at the same position. However if the position does not satisfy any string, it is not a candidate.

### Implementation
```cpp
    int minDeletionSize(vector<string>& A) {
        //longest increasing subsequence for all strings
        int m=A.size(),n=A[0].size();
        vector<int> dp(n);
        //check each column to see if it satisfy > previous
        int maxlen=0;
        for(int i=0;i<n;i++)
        {
            for(int k=0;k<i;k++) //compare to all previous
            {
                bool sorted=1;
                for(int j=0;j<m;j++) //all string
                {
                    if(A[j][i]<A[j][k]) {sorted=0;break;} //current i,k cannot be combined   
                }
                if(sorted) dp[i]=max(dp[i],dp[k]+1);
            }
            maxlen=max(maxlen,dp[i]+1);
        }
        return n-maxlen;
    }
```

### Comment
since we initialize dp to be 0, when another column is appended, this makes it two, but we only add 1.
so in the final step we add 1.


## contest 116
961. N-Repeated Element in Size 2N Array2
962. Maximum Width Ramp5
963. Minimum Area Rectangle II5
964. Least Operators to Express Number

### 961. N-Repeated Element in Size 2N Array.md

using hashset

```cpp
    int repeatedNTimes(vector<int>& A) {
        unordered_set<int> mp;
        for(int i=0;i<A.size();i++)
        {
            if(mp.count(A[i])) return A[i];
            mp.insert(A[i]);
        }
    }
```

### 962. Maximum Width Ramp.md

i<j and A[i]<=A[j], the ramp width=j-i.
Find the max ramp width

I came up several solutions:
1. bundle the index and sort the array, then using two pointer method
2. using decreasing stack
3. using lmin and rmax and uses binary search

All these solutions are O(nlogn)

1. two pointer method
i=0, j=1
- when index[j]>index[i], get the distance and j++ else i++
- when i==j, j++

2. decreasing stack
```cpp
int maxWidthRamp(vector<int>& A, int res = 0) {
  vector<pair<int, int>> v;
  for (int i = 0; i < A.size(); ++i) 
  {
    if (v.empty() || A[i]<v.back().first) v.push_back({ A[i], i });
    else 
      res = max(res, i - lower_bound(v.begin(), v.end(), make_pair( A[i], INT_MAX ), 
        greater<pair<int, int>>())->second);
  }
  return res;
}
```
Note: we do not need pop (which confused me and have to give up this method)

3. lmin and rmax
Get the lmin from left to right.
get the rmax from right to left. For each rmax, using binary search to find the rmax>=lmin
```cpp
    int maxWidthRamp(vector<int>& A) {
        //two pointers?
        int n=A.size();
        vector<int> lmin(A.size());
        lmin[0]=A[0];
        for(int i=1;i<A.size();i++) lmin[i]=min(lmin[i-1],A[i]);
        reverse(lmin.begin(),lmin.end());
        int rmax=A.back();
        int maxdiff=INT_MIN;
        for(int i=A.size()-1;i>=0;i--) //when size==2 does not work
        {
            rmax=max(rmax,A[i]);
            int ind=upper_bound(lmin.begin(),lmin.end(),rmax)-lmin.begin();
            ind--;
            if(rmax>=lmin[ind]) maxdiff=max(maxdiff,i-(n-1-ind));
        }
        return maxdiff==INT_MIN?0:maxdiff;
    }
```
Note: we do not need to reverse the lmin by using lower_bound with greater comparing function.




### 963. Minimum Area Rectangle II.md

given a list of points, find the min rectangle area. If no rectangle, return 0

Naive: (N^4)
all combinations of 4 points to see if it can combine a rectangle.
we need first determine:
- the 4 points can form a rectangle
- how to calculate the area from the 4 points
This involves some math and is not easy to figure out.
Better use vector or complex number.
suppose we have p0,p1,p2,p3 check if it is a rectangle.
vector p0p1, p0p2, p0p3: check if there exist perpendicular vectors. 
- Actually P3 is not needed. If we have p0p1 perpendicular to p0p2 and their amplitude is the same, we are able to find the other point.
- furthermore we only need two points to form a vector and its perpendicular vector is also known (two options: we can calculate from equations, these involves double and find in set, which is a mess.)
- hashset to store the vectors (but how to calculate hash function?) or we can use set
using above we can improve the efficiency greatly.

So from the idea to correct code there is still a long way to go.

https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208361/JAVA-O(n2)-using-Map
This is a much better approach:
It uses the vector as the diagnonal axis, the center and the distance combined and compose a string and use it as the key, the value is the two point pairs.
So all those vectors with the same center and length is now under the same key. (a rectangle does not require the two diagonal axes are perpendicular)

```cpp
    double minAreaFreeRect(vector<vector<int>>& points) {
        unordered_map<string,vector<vector<int>>> mp; //key vs diagonal axis (two points' index)
        int n=points.size();
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                int dx=points[i][0]-points[j][0];
                int dy=points[i][1]-points[j][1];
                long dist2=dx*dx+dy*dy;
                double cx=(points[i][0]+points[j][0])*0.5;
                double cy=(points[i][1]+points[j][1])*0.5;
                string s=to_string(dist2)+": "+to_string(cx)+", "+to_string(cy);
                //cout<<s<<endl;
                mp[s].push_back({i,j});
            }
        }
        double min_area=1e15;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            if(it->second.size()<2) continue;
            //there could be multiple rectangle inside
            //now we have 4 points in diagonal, p0-p2 diagonal, p1-p3 diagonal
            vector<vector<int>>& vrect=it->second;
            for(int i=0;i<vrect.size();i++)
            {
                for(int j=i+1;j<vrect.size();j++)
                {
                    int p0=vrect[i][0],p2=vrect[i][1];
                    int p1=vrect[j][0],p3=vrect[j][1];
                    int dx=points[p0][0]-points[p1][0];
                    int dy=points[p0][1]-points[p1][1];
                    long long dist01=dx*dx+dy*dy;
                    dx=points[p0][0]-points[p3][0];
                    dy=points[p0][1]-points[p3][1];
                    long long dist03=dx*dx+dy*dy;
                    double area=sqrt(double(dist01)*dist03);
                    min_area=min(min_area,area);
                }
            }
        }
        return min_area==1e15?0:min_area;
    }
```

Note:
-  with same center and same distance, there could be multiple rectangles (imagine the 4 points on the circle and the diagnonal are the diameter), so we need to find the min inside it.


### 964. Least Operators to Express Number.md

Given a x, and use +-*/ to reach a target, with not using ().
Get the least number of operators

I have not get any solution on this. 
- / is rational divide and we can only get x/x
- any * is used to get x^n (using n *) and x/x can be considered x^0
- + is to combine the result for all the x^n
- - is a bit harder. 

A number can be composed sum(x^i) with 0 or 1 as the coefficient, which is the binary representation of an integer. 
for x-ary base, the coefficient could be from 0 to x-1.

It's obvious that the expression should be
C0*x^0 + C1*x^1 + ... + Cn*x^n
And there is only one way to get x^0 by x / x, and it's the only use for divide operation.
Then regard target as a x base number(for example, the 3 base form of 19 is 201)

So:
Consider about generating parts[i]*x^i, you can get it by two ways (you will never generate parts[i] * x^i by some expression other than x^i):
x^i + x^i + ... + x^i (parts[i] times)
x^(i+1) - x^i - x^i - ... - x^i (x - parts[i] times).

Thinking the problem using x-base problem is the key!

As a concrete example, say x = 5, target = 123. We either add 2 or subtract 3. This leaves us with a target of 120 or 125. If the target is 120, we can either add 5 or subtract 20, leaving us with a target of 100 or 125. If the target is 100, we can either add 25 or subtract 100, leaving us with a target of 125 or 0. If the target is 125, we subtract 125.

dp approach: dp[i, target]: i is the exponential, target is the target to solve.

we first calculate all the digits, add a 0 in the end since we may carry a flag (using subtract)
AiX^i: it needs Ai*i operators if using positive way
X^(i+1)-(X-Ai)X^i: if we process as negative,
If previous is pos, then it is i*Ai+pos[i-1]
if previous is neg, then it is i*Ai+neg[i-1]+i (there is a carry over)

If we use negative for current:
- we send a carry over to i+1
- current operators (x-Ai)*i
- if previous is positive, there is no carry over, (x-Ai)*i+pos[i-1]
- if previous is negative, there is a carry over, (x-Ai-1)*i+neg[i-1]

so the solution could be as below:
```cpp
    int leastOpsExpressTarget(int x, int target) {
        //dp: x-ary number to use least operations
        //n=sum(Ai*X^i) to use less operator need to compare x^(i+1) and x^i
        vector<int> digits;
        while(target) {digits.push_back(target%x);target/=x;}
        
        int n=digits.size();
        digits.push_back(0);//could add a carrier flag before the MSB
        vector<int> pos(n+1),neg(n+1);
        pos[0]=digits[0]*2;
        neg[0]=(x-digits[0])*2; //x^0=x/x use more operations
        for(int i=1;i<=n;i++)
        {
            //if use neg, we have a carrier flag to i
            //Aix^i: add Ai times, each with i multplication
            pos[i]=digits[i]*i+min(pos[i-1],neg[i-1]+i); 
            //AiX^i=x^(i+1)-(x-Ai)x^i
            neg[i]=min((x-digits[i])*i+pos[i-1],(x-digits[i]-1)*i+neg[i-1]);
        }
        return min(pos[n],neg[n])-1;
    }
```

Note:
- the boundary needs *2 since it can only be obtained x/x
- final result needs -1

## contest 117
965. Univalued Binary Tree3
966. Numbers With Same Consecutive Differences5
967. Vowel Spellchecker6
968. Binary Tree Cameras


### 965. Univalued Binary Tree.md

check if the binary tree has one single value

there are quite a few methods such as using a hashset to traverse the tree
or use the root value to compare with all other node values

```cpp
    bool isUnivalTree(TreeNode* root) {
        if(!root) return 1;
        int val=root->val;
        return isSame(root,val);
    }
    bool isSame(TreeNode* root,int val)
    {
        if(!root) return 1;
        if(root->val!=val) return 0;
        return isSame(root->left,val) && isSame(root->right,val);
    }
```
### 966. Vowel Spellchecker.md

Given a word list and a query list
1. if exactly match, return the word
2. if ignore case match, return the first matched word in word list
3. if ignore the vowels match, return the first matched word in the word list

create a hashset for the word list
create a hashmap the lowered word vs the original word list
create a hashmap ignoring the vowels vs the original word list

```cpp
    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {
        unordered_map<string,string> mp_novow,mp_nocase; //word vs no vowels
        unordered_set<string> dict(wordlist.begin(),wordlist.end());
        char vow[]={'a','e','i','o','u'};
        unordered_set<char> vowels(vow,vow+6);
        for(int i=0;i<wordlist.size();i++)
        {
            //remove the vowels
            string s1,s2;
            for(int j=0;j<wordlist[i].size();j++)
            {
                char c=tolower(wordlist[i][j]);
                if(!vowels.count(c)) s1+=c;else s1+='*';
                s2+=c;
            }
            if(!mp_novow.count(s1))mp_novow[s1]=wordlist[i];//only need the first
            if(!mp_nocase.count(s2))mp_nocase[s2]=wordlist[i]; //only need the first
        }
        vector<string> ans(queries.size());
        for(int i=0;i<queries.size();i++)
        {
            if(dict.count(queries[i])) ans[i]=queries[i]; //exact match
            else //check if case match
            {
                string s1,s2;
                for(int j=0;j<queries[i].size();j++)
                {
                    char c=tolower(queries[i][j]);
                    s1+=c;
                    if(!vowels.count(c)) s2+=c;else s2+='*';
                }
                if(mp_nocase.count(s1)) ans[i]=mp_nocase[s1];
                else //case not match, check if no vowel match
                {
                    if(mp_novow.count(s2)) ans[i]=mp_novow[s2];//no vowels must also match position
                    else ans[i]="";
                }
            }
        }
        return ans;
    }
```

- could be shorter if we use functions to create noncased and novowels
- the first by ignoring the same keywords after.


### 967. Numbers With Same Consecutive Differences.md

Given digits 0 to 9, and N for a number with N digits, K for the absolute difference of consecuative digits
return all the numbers

This is a typical dfs problem. First choice is 1 to 9, the next is i+K and i-K

```cpp
    vector<int> numsSameConsecDiff(int N, int K) {
        //so this is a dfs problem
        vector<int> ans;
        if(N==1) return vector<int>({0,1,2,3,4,5,6,7,8,9});
        for(int i=1;i<10;i++)
            dfs(i,N-1,K,ans,0);
        return vector<int>(ans.begin(),ans.end());
    }
    void dfs(int start,int n,int K,vector<int>& ans,int res)
    {
        res=res*10+start;                
        if(n==0 ) {ans.push_back(res);return;}
     
        if(start+K<10) dfs(start+K,n-1,K,ans,res);
        if(K && start-K>=0) dfs(start-K,n-1,K,ans,res);
    }
```

- when we do the first round, leaving n-1
- when k=0, we need to avoid duplicates
- complexity O(9^N)

### 968. Binary Tree Cameras.md

a binary tree: a camera will cover its parent, itself and its immediate child
return the min number of camera needed

This is a dp problem similar to the house robber. 
Also it is a greedy problem.

Apply a recusion function dfs.
We use greedy algorithem here. We put camera at as higher level (closer to root) as possible. 
We use post-order DFS here. This would be O(n) time and O(h) space, where h is height of the tree.
The return value of DFS() has following meanings. 
- 0: there is no camera at this node, and it's not monitored by camera at either of its children, which means neither of child nodes has camera. 
- 1: there is no camera at this node; however, this node is monitored by at least 1 of its children, which means at least 1 of its children has camera. 
- 2: there is a camera at this node.

```cpp
class Solution {
public:
    int minCameraCover(TreeNode* root) {
        int sum=0;
        if(dfs(root,sum)==0)   sum++;// if root is not monitored, we place an additional camera here
        return sum;
    }
    
    int dfs(TreeNode * tr, int& sum){
        if(!tr) return 1;
        int l=dfs(tr->left,sum), r=dfs(tr->right,sum);
        if(l==0||r==0){// if at least 1 child is not monitored, we need to place a camera at current node 
            sum++;
            return 2;
        }else if(l==2||r==2){// if at least 1 child has camera, the current node is monitored. Thus, we don't need to place a camera here 
            return 1;
        }else{// if both children are monitored but have no camera, we don't need to place a camera here. We place the camera at its parent node at the higher level. 
            return 0;
        }
        return -1;// this return statement won't be triggered
    }
};

### comments
- This is hard and I cannot get the solution
## contest 118


969. Pancake Sorting.md

### Problem Summary
sorting the array by reverse the first k elements

### Approach
greedy: always move the biggest to the first and move to its sorted position
do not need to consider the special case when it is already in the first position
reverse to find the largest: the input is 1 to n, using this fact to make it more easier.

### code
```cpp
    vector<int> pancakeSort(vector<int> A) {
        vector<int> res;
        int x,i;
        for (x = A.size(); x > 0; --x) {
            for (i = 0; A[i] != x; ++i);
            reverse(A.begin(), A.begin() + i + 1);
            res.push_back(i + 1);
            reverse(A.begin(), A.begin() + x);
            res.push_back(x);
        }
        return res;
    }
```


970. Powerful Integers.md

### Problem Summary
given x and y, return all the number with x^i+y^j<=bound

### approach
just iterate all numbers
i<=log(bound-1)/log(x), j<=log(bound-1)/log(y)
edge case:
bound<2
x or y=1

### code
```cpp
    vector<int> powerfulIntegers(int x, int y, int bound) {
        if(bound<2) return vector<int>();
        if(x==1 && y==1) return vector<int>({2});
        if(x==1 || y==1) //bound-1=y^i
        {
            vector<int> ans;
            int xx=1;
            x=max(x,y);
            for(int i=0;i<=log(bound-1)/log(y);i++)
            {
                if(i) xx*=x;
                ans.push_back(xx+1);   
            }
            return ans;
        }
        int m=log(bound-1)/log(x),n=log(bound-1)/log(y);
        unordered_set<int> ans;
        int xx=1,yy=1;
        for(int i=0;i<=m;i++)
        {
            if(i) xx*=x;
            yy=1;
            for(int j=0;j<=n;j++)
            {
                if(j) yy*=y;
                if(xx+yy<=bound) ans.insert(xx+yy);
            }
        }
        return vector<int>(ans.begin(),ans.end());
    }
```

### comments
- we can break out when xx+yy>bound
- need to use hashset to remove duplicates

971. Flip Binary Tree To Match Preorder Traversal.md

### Problem Summary
given preorder traversal and an array of permutation. check if it is ok to flip left and right child to get the array

### approach
Match the array element by element using preorder traversal. If cannot match, try postorder traversal

### code
```cpp
    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
        vector<int> ans;
        int res=helper(root,voyage,0,ans);
        if(!res) return vector<int>({-1});
        return ans;
    }
    int helper(TreeNode* root, vector<int>& voyage,int ind,vector<int>& ans)
    {
        if(!root) return ind;
        if(root->val!=voyage[ind]) {return 0;}
        //see if we need flip its left and right
        //switch or not switch
        int res=helper(root->left,voyage,ind+1,ans);
        
        if(!res) //first left failure, we try to switch
        {
            res=helper(root->right,voyage,ind+1,ans);
            if(!res) return 0;
            res=helper(root->left,voyage,res,ans);
            if(!res) return 0;
            ans.push_back(root->val);
        }
        else 
        {
            res=helper(root->right,voyage,res,ans);
            if(!res) return 0;
        }
        return res;
    }
```

972. Equal Rational Numbers.md

### Problem Summary
Given two strings representing two rational number, check if they are equal

### Approach
translate the number into a double with all the precision
and then compare using string or double.
0.9999999 and 1 will be missed if using string.

### code
```cpp
    bool isRationalEqual(string S, string T) {
        return f(S) == f(T);
    }

    double f(string S) {
        auto i = S.find("(");
        if (i != string::npos) {
            string base = S.substr(0, i);
            string rep = S.substr(i + 1, S.length() - i - 2);
            for (int j = 0; j < 20; ++j) base += rep;
            return stod(base);
        }
        return stod(S);
    }
```
## contest 119
973. K Closest Points to Origin3
974. Largest Perimeter Triangle4
975. Subarray Sums Divisible by K6
976. Odd Even Jump


973. K Closest Points to Origin.md

### Problem Summary
Given a series of points in 2d plane return the list of k points closest to origin

### approach
using a priority_queue of size k, keeping popping out the max

### code
```cpp
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        priority_queue<pair<long,int>> pq;
        for(int i=0;i<points.size();i++)
        {
            long d=points[i][0]*points[i][0]+points[i][1]*points[i][1];
            pq.push(make_pair(d,i));
            if(pq.size()>K) pq.pop();
        }
        vector<vector<int>> ans;
        while(pq.size()) ans.push_back(points[pq.top().second]),pq.pop();
        reverse(ans.begin(),ans.end());
        return ans;
    }
```

974. Subarray Sums Divisible by K.md

### Problem summary
Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.

### Approach
This could be done using dp or simple approach using hashmap
prefix sum and mod by K, the same results will have [i,j] to be a section

### code
```cpp
    int subarraysDivByK(vector<int>& A, int K) {
        A[0]=(A[0]%K+K)%K;
        for(int i=1;i<A.size();i++) 
        {
            A[i]+=A[i-1];
            A[i]=(A[i]%K+K)%K;
        }
        sort(A.begin(),A.end());
        
        int ans=0,cnt=0;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]==0) ans++;
            if(i && A[i]==A[i-1]) cnt++,ans+=cnt;
            else cnt=0;
        }
        return ans;
    }
```    

### comment
- there are negatives, so first %K and +K and mod to convert to [0,k-1]


976. Largest Perimeter Triangle.md

### Problem Summary
Given a list of side length, find the triangle with max perimeter

### approach
a triangle must satisfy: a+b>c (a-b<c is equivalent)
sort in descending order, then we find the first a[i]<a[i+1]+a[i+2].

### code
```cpp
    int largestPerimeter(vector<int>& A) {
       //a triangle: a+b>c a-b<c
        sort(A.begin(),A.end(),greater<int>());
        for(int i=0;i<A.size()-2;i++)
        {
            if(A[i]<A[i+1]+A[i+2]) return A[i]+A[i+1]+A[i+2];
        }
        return 0;
    }
```

975. Odd Even Jump.md

### Problem summary
Given a list of numbers, you can start at some indices and make a series of jump:
odd jump: you jump to smallest index which is >= current
even jump: you jump to smallest index which is <=current
An index is good if you can jump to the end. 
return all the good indices.

### Approach
If not good to do it in one direction, what about the reverse direction?
Actually it is much easier, take a small example:
[10,13,12,14,15]
take 15: it is already the end, odd=1, even=1, +1
take 14: 1 step to end, odd=1, even=0, +1
take 12: 1 step to 14, odd=1, even=0, +1
take 13: odd you have to first jump to 14, but it is even jump, even has to jump to 12, odd=0, even=0
take 10: odd jump to 13, even jump: no legal, but 13 is not a good jump.

So it is a dp: 
we can put the visited nodes into a sorted order and then binary search to find the next number to jump for odd and even jump and check if it is legal.

There is one thing I missed: it also requires the first jump is odd, second jump is even!!!!!


```cpp
    int oddEvenJumps(vector<int>& A) {
        int n  = A.size(), res = 1;
        vector<int> higher(n), lower(n);
        higher[n - 1] = lower[n - 1] = 1;
        map<int, int> map;
        map[A[n - 1]] = n - 1;
        for (int i = n - 2; i >= 0; --i) {
            auto hi = map.lower_bound(A[i]), lo = map.upper_bound(A[i]);
            if (hi != map.end()) higher[i] = lower[hi->second];
            if (lo != map.begin()) lower[i] = higher[(--lo)->second];
            if (higher[i]) res++;
            map[A[i]] = i;
        }
        return res;
    }
```

## contest 120

977. Squares of a Sorted Array.md

### Problem Summary
given a list of sorted array, return sorted of its square

### approach
When squared, the negative could be larger
using two pointer from two ends and compare the square will get O(N) complexity.


978. Longest Turbulent Subarray.md

### Problem Summary
the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.
Return the length of a maximum size turbulent subarray of A.

### Approach
direct approach: count the +/- length

### Code
```cpp
    int maxTurbulenceSize(vector<int>& A) {
        int ans=1;
        int prev=0,curr=0,cnt=0;
        for(int i=1;i<A.size();i++)
        {
            if(A[i]>A[i-1]) curr=1;
            else if(A[i]<A[i-1]) curr=-1;

            else {curr=0;}
            if(prev && prev==-curr) cnt++;
            else {ans=max(ans,cnt+2);cnt=0;}
            prev=curr;
        }
        if(cnt) ans=max(ans,cnt+2);
        return ans;
    }
```

Note:
do not forget when the +/- ends at the last.

979. Distribute coins in binary tree

### Problem Summary
A tree with N nodes and N total coins, the objective is to distribute the coins to 1 at each node
each step you can pass a coin to parent or its direct child.

### Approach
For a node we shall calculate its left subtree and right subtree balance. (sum of coins - number of nodes)
the balance could be negative or positive. If negative, we shall pass in the balance from the root. If positive we need pass out balance to its parent, i.e the abs(coins)
each coin from root or to root need one step.
So, we can use postorder traversal to get the balance and add up the absolute values.

### code
```cpp
    int distributeCoins(TreeNode* root) {
        int steps=0;
        postorder(root,steps);
        return steps;
    }
    int postorder(TreeNode* root,int& steps)
    {
        if(!root) return 0;
        int coins=postorder(root->left,steps)+postorder(root->right,steps);
        coins+=root->val-1;
        steps+=abs(coins);//coins need to past to parent
        return coins;
    }
```

### comments
- get the balance of the subtree need not two dfs, but one is fine, to minus 1 from each node
- the steps, regardless the direction, count one step.


980. Unique Paths III.md

### Problem Summary
given a matrix, 1 is start, 2 is end, 0 is empty, -1 is obstacle.
Find the number of path: the path covers each empty cell once
4 directions

### Approach
Typical dfs problem with more constraints
-. need find the start and end, brutal force
-. need visit the cell only once, when visited, mark it as obstacle

### code
```cpp
    int uniquePathsIII(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        int nsteps=0,sx=0,sy=0;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1) sx=i,sy=j;
                if(grid[i][j]!=-1) nsteps++;
            }
        }
        return dfs(grid,sx,sy,1,nsteps);
    }
    int dfs(vector<vector<int>>& grid,int sx,int sy,int step,int nsteps)
    {
        int m=grid.size(),n=grid[0].size();
        if(sx<0 || sx>=m || sy<0 || sy>=n || grid[sx][sy]==-1) return 0;
        if(grid[sx][sy]==2) return step==nsteps?1:0;
        grid[sx][sy]=-1; //mark it visited
        int ans=dfs(grid,sx+1,sy,step+1,nsteps);
        ans+=dfs(grid,sx-1,sy,step+1,nsteps);
        ans+=dfs(grid,sx,sy+1,step+1,nsteps);
        ans+=dfs(grid,sx,sy-1,step+1,nsteps);
        grid[sx][sy]=0;
        return ans;
    }
```

### comments
- we are counting non-obstacle cells, so need starting from 1
- visited then we mark it as different color, this tech is often used in dfs.



## contest 121

981. Time Based Key-Value Store.md

### Problem Summary
set get key value and timestamp
get: return the most recent key value with ts<=timestamp

### Approach
using a hashmap, the value is a map sorted with the timestamp.

```cpp
    unordered_map<string, map<int, string>> m;
    void set(string key, string value, int timestamp) {
      m[key].insert({ timestamp, value });
    }
    string get(string key, int timestamp) {
      auto it = m[key].upper_bound(timestamp);
      return it == m[key].begin() ? "" : prev(it)->second;
    }  
```    

982. Triples with Bitwise AND Equal To Zero.md

### Problem summary
return the number of all triplets so that A&B&C=0

### Approach
straightforward: first evaluate all A&B. Store the results into a hashmap the result vs occurences.
and then evaluate the result & C

```cpp
    int countTriplets(vector<int>& A) {
        unordered_map<int,int> mp;
        int n=A.size();
        int ans=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++) mp[A[i]&A[j]]++;
        }
        for(int i=0;i<n;i++)
        {
            for(auto it=mp.begin();it!=mp.end();it++)
                if((it->first&A[i])==0) ans+=it->second;
        }
        return ans;
    }
```    

983. Minimum Cost For Tickets.md

### Problem Summary
Given a list of days, we can buy tickets for single day, 7-day and 30-days at different prices. To cover all the days, what is the lowest cost

### Approach
This is a dp problem, can also be combined with two pointer approach
dp[i] is the min cost for the subproblem ending at days[i]

It is:
min(dp[i-1]+cost1,dp[7th]+cost7,dp[30th]+cost30)

```cpp
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        sort(days.begin(),days.end());
        vector<int> dp(n+1);//dp[i] is the min cost ending at ith day
        for(int i=1;i<=n;i++)
        {
            dp[i]=dp[i-1]+costs[0];
            for(int j=i-1;j>0;j--)
            {
                if(days[i-1]-days[j-1]>=30) break;
                dp[i]=min(dp[i],dp[j-1]+costs[2]);
                if(days[i-1]-days[j-1]<7) dp[i]=min(dp[i],dp[j-1]+costs[1]);
            }
        }
        return dp[n];
    }
```

984. String Without AAA or BBB.md

### Problem Summary
given m A and n B, return a string without AAA or BBB

### Greedy solution
typical: make a greedy move and reduce to sub problem

```cpp
    string strWithout3a3b(int A, int B) {
        if(A == 0) return string(B, 'b');
        else if(B == 0) return string(A, 'a');
        else if(A == B) return "ab" + strWithout3a3b(A - 1, B - 1);
        else if(A > B) return "aab" + strWithout3a3b(A - 2, B - 1);
        else return strWithout3a3b(A - 1, B - 2) + "abb";
    }
```

## contest 122

985. Sum of Even Numbers After Queries.md

We have an array A of integers, and an array queries of queries.

For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.

(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)

Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.

 
 Approach
 Sraightforward: 
 
 ```cpp
     vector<int> sumEvenAfterQueries(vector<int>& A, vector<vector<int>>& queries) {
        int sum=0;
        vector<int> ans(queries.size());
        for(int i=0;i<A.size();i++) if(A[i]%2==0) sum+=A[i];
        for(int i=0;i<queries.size();i++)
        {
            int t=A[queries[i][1]]+queries[i][0];
            int ind=queries[i][1];
            if(t%2==0) //even
            {
                if(A[ind]%2) sum+=t;
                else sum+=queries[i][0];
            }
            else //odd
            {
                if(A[ind]%2==0) sum-=A[ind];
            }
            A[ind]=t;
            ans[i]=sum;
        }
        return ans;
    }
```    
986. Interval List Intersections.md

### Problem Summary
to return the intersection of two sorted list of intervals

### Approach
two pointers

```cpp
    vector<Interval> intervalIntersection(vector<Interval>& A, vector<Interval>& B) {
        int m=A.size(),n=B.size();
        vector<Interval> ans;
        int i=0,j=0;//two pointers
        while(i<m && j<n) //either is done
        {
            while(A[i].end<B[j].start) i++;
            while(B[j].end<A[i].start) j++;
            if(i<m && j<n)
            {
              int start=max(A[i].start,B[j].start);
              int end=min(A[i].end,B[j].end);
              if(start<=end) ans.push_back(Interval(start,end));
              if(A[i].end<B[j].end) i++;
              else if(A[i].end>B[j].end) j++;
              else i++,j++;
            }
        }
        return ans;
    }
```    

the above solution: 
1. make sure i, j not over bound
2. make sure start<end

987. Vertical Order Traversal of a Binary Tree.md

Return the vertical order traversal

The only thing: there will be node overlaps, and they shall be sorted

Direct Approach
traversal and get the x, y and val, and then sort

```cpp
struct node {
    int x,y,val;
    node(int x1,int y1,int v):x(x1),y(y1),val(v){}
};
bool cmp(node& a,node& b) {return a.x<b.x || (a.x==b.x && a.y<b.y) || (a.x==b.x && a.y==b.y && a.val<b.val);}
class Solution {
public:
    vector<node> vn;
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        inorder(root,0,0);
        sort(vn.begin(),vn.end(),cmp);
        vector<vector<int>> ans;
        int prev=INT_MIN;
        for(int i=0;i<vn.size();i++)
        {
            if(vn[i].x!=prev) {ans.push_back({vn[i].val});prev=vn[i].x;}
            else ans.back().push_back(vn[i].val);
        }
        return ans;
        
    }
    void inorder(TreeNode* root,int x,int y)
    {
        if(!root) return;
        inorder(root->left,x-1,y+1);
        vn.push_back(node(x,y,root->val));
        inorder(root->right,x+1,y+1);
    }
};
```
988. Smallest String Starting From Leaf.md

### Problem Summary
return the smallest string from leaf to root

### Approach
from root to leaf and dfs to get the string

```cpp
    string smallestFromLeaf(TreeNode* root) {
        //dfs to get the string
        string ans,t;
        dfs(root,ans,t);
        return ans;
    }
    void dfs(TreeNode* root,string& ans,string t)
    {
        t+=root->val+'a';
        if(root->left) dfs(root->left,ans,t);
        if(root->right) dfs(root->right,ans,t);
        if(!root->left && !root->right)
        {
            reverse(t.begin(),t.end());
            if(ans.size())ans=min(ans,t);else ans=t;
        }
    }
```    ## contest 123

989. Add to Array-Form of Integer.md

### Problem Summary
For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].

Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.

### Solution
Easy
convert both x and k to array form and then add from right to left

```cpp
    vector<int> addToArrayForm(vector<int>& A, int K) {
        int cf=0;
        string s=to_string(K);
        int n=A.size(),m=s.size();
        vector<int> ans;
        for(int i=n-1,j=m-1;i>=0||j>=0;i--,j--)
        {
            int t=(i>=0?A[i]:0)+cf+((j>=0)?s[j]-'0':0);
            ans.push_back(t%10);
            cf=t/10;
        }
        
        if(cf) ans.push_back(cf);
        reverse(ans.begin(),ans.end());
        return ans;
    }
```

Comments
- right to left and then reverse the result
- final may add one digit

990. Satisfiability of Equality Equations.md

### Problem Summary
Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: "a==b" or "a!=b".  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.

Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.

 ### Approach
 first collect all equals and connect them
 and then using the non-equals to verify
 disjoint set
 
 ### code
 ```cpp
     bool equationsPossible(vector<string>& equations) {
       //using disjoint set
        vector<int> parent(26);
        for(int i=0;i<26;i++) parent[i]=i;
        for(int i=0;i<equations.size();i++)
        {
            if(equations[i][1]=='=')
            {
                int t0=equations[i][0]-'a',t1=equations[i][3]-'a';
                merge(t0,t1,parent);
            }
        }
        for(int i=0;i<equations.size();i++)
        {
            if(equations[i][1]=='!')
            {
                int t0=equations[i][0]-'a',t1=equations[i][3]-'a';
                if(get_parent(t0,parent)==get_parent(t1,parent)) return 0;
            }
        }
        return 1;
    }
    void merge(int i,int j,vector<int>& parent)
    {
        int pi=get_parent(i,parent);
        int pj=get_parent(j,parent);
        if(pi==pj) return;
        if(pi<pj) {parent[pj]=pi;}
        else {parent[pi]=pj;}
    }
    int get_parent(int i,vector<int>& parent)
    {
        while(parent[i]!=i) i=parent[i];
        return i;
    }
```


991. Broken Calculator.md

### Problem Summary
On a broken calculator that has a number showing on its display, we can perform two operations:

Double: Multiply the number on the display by 2, or;
Decrement: Subtract 1 from the number on the display.
Initially, the calculator is displaying the number X.

Return the minimum number of operations needed to display the number Y.

### Analysis
This is a greedy choice.
If Y is odd, the last step is dec 1
If Y is even, the last step is x2
when y<x only dec is allowed

Decrease the problem Y to X, which is a typical greedy problem.

```cpp
    int brokenCalc(int X, int Y) {
        //every step we can choose -1 or *2
        //greedy solution: 
        //if Y is even, divide by 2, if Y is odd add 1
        int res = 0;
        while (Y > X) {
            Y = Y % 2 > 0 ? Y + 1 : Y / 2;
            res++;
        }
        return res + X - Y;        
    }
```



992. Subarrays with K Different Integers.md

### Problem Summary
Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.

(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)

Return the number of good subarrays of A.

### Brutal force
O(N^2), and this will TLE.
we use two pointer i and j to defines a region.
```cpp
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int ans=0;
        for(int i=0;i<A.size();i++)
        {
            unordered_map<int,int> mp;
            for(int j=i;j<A.size();j++)
            {
                mp[A[j]]++;
                if(mp.size()==K) ans++;
                if(mp.size()>K) break;
            }
        }
        return ans;
    }
```

O(N) solution.
Above solution tries every regions. The key observations:
when we had a region with k unique elements inside
- each time we add a new element into the group, it has two cases:
  - it does not increase the unique element, this case it will add multiple regions (ending with the new element)
  - it increase the unique element by 1 and we shall erase the region head element from the group
  
we define three pointers
i: the leftmost index for the k unique element group
j: the left index for the smallest k unique element group
k: the ending index of the group

when adding the new element:
if it does not increase element, add j-i+1 regions, need update j and the map
if it increase 1, then j and i shall be all set to j+1, update i and j and the map

```cpp
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int ans=0;
        int i=0,j=0,k=0;//use 3 pointers, i, j for the two left i<j
        unordered_map<int,int> mp;
        while(k<A.size())
        {
            mp[A[k]]++;
            if(mp.size()>K) {i=j+1;mp.erase(A[j]);}
            if(j<i) j=i;
            if(mp.size()==K) 
            {
                while(mp[A[j]]>1) {mp[A[j]]--;if(mp[A[j]]==0) mp.erase(A[j]);j++;}
                ans+=j-i+1;
            }
            k++;
        }
        return ans;
    }
```
 
 
## contest 124

993. Cousins in Binary Tree.md

### Problem 
In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.

Two nodes of a binary tree are cousins if they have the same depth, but have different parents.

We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.

Return true if and only if the nodes corresponding to the values x and y are cousins.

### Approach
traveral and record its depth and parent

```cpp
    bool isCousins(TreeNode* root, int x, int y) {
        TreeNode *px=0,*py=0;
        int hx=0,hy=0;
        dfs(NULL,root,x,y,px,py,hx,hy,0);
        return (px && py&& hx && hy) && px!=py && hx==hy;
    }
    void dfs(TreeNode* parent,TreeNode* root,int x,int y,TreeNode*& px,TreeNode*& py,int &hx,int &hy,int depth)
    {
        if(!root) return;
        dfs(root,root->left,x,y,px,py,hx,hy,depth+1);
        if(root->val==x) {hx=depth;px=parent;}
        if(root->val==y) {hy=depth;py=parent;}
        dfs(root,root->right,x,y,px,py,hx,hy,depth+1);
    }
```


994. Rotting Oranges.md

### Problem
In a given grid, each cell can have one of three values:

the value 0 representing an empty cell;
the value 1 representing a fresh orange;
the value 2 representing a rotten orange.
Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.

### Solution
- record each round all those rotten orange
- each round rot the surrounding orange
- each round shall have less fresh orange

```cpp
    int orangesRotting(vector<vector<int>>& grid) {
        //bfs to rotten the surrounding oranages
        int m=grid.size(),n=grid[0].size();
        int mins=0;
        int num_fresh=0;
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++) if(grid[i][j]==1) num_fresh++;
        while(num_fresh)
        {
            int prev=num_fresh;
            vector<vector<int>> ind;
            for(int i=0;i<m;i++)
            {
                for(int j=0;j<n;j++)
                {
                    if(grid[i][j]==2) ind.push_back({i,j});//{bfs(grid,i,j,num_fresh);}
                }
            }
            for(int k=0;k<ind.size();k++) bfs(grid,ind[k][0],ind[k][1],num_fresh);
            if(num_fresh==prev) return -1;
            mins++;
        }
        return mins;
    }
        
    void bfs(vector<vector<int>>& grid,int i,int j,int& num_fresh)
    {
        int m=grid.size(),n=grid[0].size();
        grid[i][j]=0;
        if(i-1>=0 && i-1<m && grid[i-1][j]==1) {grid[i-1][j]=2;num_fresh--;}
        if(i+1<m && grid[i+1][j]==1) {grid[i+1][j]=2;num_fresh--;}
        if(j-1>=0 && j-1<n && grid[i][j-1]==1) {grid[i][j-1]=2;num_fresh--;}
        if(j+1<n && grid[i][j+1]==1) {grid[i][j+1]=2;num_fresh--;}
    }
```

995. Minimum Number of K Consecutive Bit Flips.md

### Problem
In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.

### Approach
this is a greedy solution
flip the zeros from left to right

```cpp
    int minKBitFlips(vector<int>& A, int K) {
        //the leading bit shall be flipped and reduce to sub problem
        int minflips=0;
        
        for(int i=0;i<A.size()-K+1;i++)
        {
            if(A[i]==0) {if(minkflip(A,K,i)) minflips++;else return -1;}
        }
        int sum=accumulate(A.begin(),A.end(),0);
        if(sum!=A.size()) return -1;
        return minflips;
    }
    int minkflip(vector<int>& A,int K,int ind)
    {
        int m=A.size();
        for(int i=ind;i<ind+K;i++) A[i]^=1;
        if(m-ind==K) //last flip
        {
            int sum=accumulate(A.begin()+ind,A.end(),0);
            return sum==K;
        }
        
        return 1;
    }
```

996. Number of Squareful Arrays.md

Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.

Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].

### Approach
Direct using permutation will yield O(n!) complexity and is to get TLE
We can build a graph and using dfs (backtracking) to solve this problem

```cpp
    unordered_map<int, int> count;
    unordered_map<int, unordered_set<int>> cand;
    int res = 0;
    int numSquarefulPerms(vector<int>& A) {
        for (int &a : A) count[a]++;
        for (auto &i : count) {
            for (auto &j : count) {
                int x = i.first, y = j.first, s = sqrt(x + y);
                if (s * s == x + y)
                    cand[x].insert(y);
            }
        }
        for (auto e : count)
            dfs(e.first, A.size() - 1);
        return res;
    }

    void dfs(int x, int left) {
        count[x]--;
        if (!left) res++;
        for (int y : cand[x])
            if (count[y] > 0)
                dfs(y, left - 1);
        count[x]++;
    }
```

cand: the hashmap for the connection graph
count: the hashmap to record duplicate items and also used for record if the item is used or not
count[x]++ -- is for the backtracking. 

## contest 125

997. Find the Town Judge.md

In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.

### Approach
Be sure to pay attention to special case

```cpp
    int findJudge(int N, vector<vector<int>>& trust) {
        unordered_map<int,int> mp1,mp2;
        for(int i=0;i<trust.size();i++) 
        {
            mp1[trust[i][0]]++;//he trust
            mp2[trust[i][1]]++; //he is trusted
        }
        for(auto it=mp2.begin();it!=mp2.end();it++)
        {
            if(it->second==N-1 && mp1.count(it->first)==0) return it->first;
        }
        if(N==1) return 1;
        return -1;
    }
```

N=1 is the special case. no trust and no trusted.

998. Maximum Binary Tree II.md

We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.

Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:

If A is empty, return null.
Otherwise, let A[i] be the largest element of A.  Create a root node with value A[i].
The left child of root will be Construct([A[0], A[1], ..., A[i-1]])
The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]])
Return root.
Note that we were not given A directly, only a root node root = Construct(A).

Suppose B is a copy of A with the value val appended to it.  It is guaranteed that B has unique values.

Return Construct(B).

### Approach
1. Note the value appended to B, and shall always goes to the right branch.

A not so simple solution:
```cpp
    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
        if(val>root->val) 
        {
            TreeNode* p=new TreeNode(val);
            p->left=root;
            return p;
        }
        helper(NULL,root,val,1);
        return root;
    }
    void helper(TreeNode* parent,TreeNode* root,int val,int lr)
    {
        if(!root) //leaf node
        {
            TreeNode* p=new TreeNode(val);
            if(lr==0) parent->left=p;
            else parent->right=p;
            
            return;
        }
        if(root->val<val) //need to replace the current node
        {
            TreeNode* p=new TreeNode(val);
            if(lr==0) parent->left=p;
            else parent->right=p;
            p->left=root;
            return;
        }
        if(root->val>val) //prefer the larger branch, can pick any branch
        {
            helper(root,root->right,val,1);
        }
    }
```

There are better solution which yields shorter and more intuitive solution.
1. when the value>root value, node->left=root and return node
2. when the value<root value, goes to right branch. reduced to a subproblem
```cpp
    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
        if(!root) return new TreeNode(val);
        if(val>root->val) 
        {
            TreeNode* node=new TreeNode(val);
            node->left=root;
            return node;
        }
        root->right=insertIntoMaxTree(root->right,val);
        return root;
    }
```


999. Available Captures for Rook.md

On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.

The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.

Return the number of pawns the rook can capture in one move.

Simple:
```cpp
    int numRookCaptures(vector<vector<char>>& board) {
        //check 4 directions to 
        int ans=0;
        int r=0,c=0;
        for(int i=0;i<8;i++)
        {
            for(int j=0;j<8;j++) if(board[i][j]=='R') {r=i;c=j;break;}
        }
        
        if(c) for(int i=c-1;i>=0;i--) if(board[r][i]!='.') {if(board[r][i]=='p') ans++;break;}//left
        if(c<7)for(int i=c+1;i<8;i++) if(board[r][i]!='.') {if(board[r][i]=='p') ans++;break;}//right
        if(r) for(int i=r-1;i>=0;i--) if(board[i][c]!='.') {if(board[i][c]=='p') ans++;break;}//up
        if(r<7) for(int i=r+1;i<8;i++) if(board[i][c]!='.') {if(board[i][c]=='p') ans++;break;}//right
        return ans;
    }
```    

1000. Minimum Cost to Merge Stones.md

### Problem Summary
There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones.

A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.

### Analysis
1. K>1. other K has no solution
2. each time k piles reduce to 1 pile. so the number of pile must be able to divide by k-1
3. this is very similar to the burst balloon problem which is a typical dp problem.
assuming we choose ith element as the start, k is the length, it divides the left and right part. 
However, the subproblem needs cross the mid element. 
Similarly to the solution in burst balloon, we can think it in reversed way:
assuming starting i and ending j elements (some elements are already used) are the last action to merge

dp[l][i] represents the minimal cost to merge the piles in interval [i,i+l), here, we merge piles as much as possible. 
So, when l < 1+(K-1), we don't merge any piles, so dp[i][i+l] = 0; 
when 1+(K-1) <= l < 1+2(K - 1), we merge once; 
when 1+2(K-1) <= l < 1+3(K-1), we merge twice, and so on so forth.
Let's see for a certain interval length l, how can we get dp[l][i]. 
After all mergings, if we consider the leftmost pile in interval [i,i+l), then the status of this pile will show as below:

No merging happens in this pile, so it contains 1 original pile, let k = 1, then the cost is dp[k][i]+dp[l-k][i+k].
One merging happens in this pile, so it contains 1+(K-1) original piles, let k = 1+(K-1), then the cost is dp[k][i]+dp[l-k][i+k].
Two mergings happen in this pile, so it contains 1+2(K-1) original piles, let k = 1+2(K-1), then the cost is dp[k][i]+dp[l-k][i+k].
.......
When (l-1) mod (K-1)==0, we can see all piles in interval [i,i+l) can be finally merged into one pile, and the cost of the last merging is sum(stones[j]) for j in [i,i+l), regardless of the merging choices before the last one. And this "last cost" happens if and only if (l-1) mod (K-1)==0

```cpp
int mergeStones(vector<int>& stones, int K)
{
    int N = (int)stones.size();
    if((N - 1) % (K - 1)) return -1;
    
    vector<int> sum(N + 1, 0);
    for(int i = 0; i < N; i++) sum[i + 1] = sum[i] + stones[i];
    
    vector<vector<int> > dp(N + 1, vector<int>(N, 0));
    for(int l = K; l <= N; l++) //length
        for(int i = 0; i + l <= N; i++) //start position
        {
            dp[l][i] = 10000;
            for(int k = 1; k < l; k += K - 1) //
                dp[l][i] = min(dp[l][i], dp[k][i] + dp[l - k][i + k]);
            if((l - 1) % (K - 1) == 0) dp[l][i] += sum[i + l] - sum[i];
        }
    return dp[N][0];
}
```

The solution is hard to comprehend. k=1, 1+(K-1), 1+2*(K-1)....., we are looking for the min cost among all these possible choices:
dp[1+m*(k-1)][i] means the cost for the case where the left part can be merged to one pile at i (l-1)%(k-1)==0
dp[l-k][i+k] is the cost for the right part solution (merge to the left pile at i+k)
dp[l][i] then is the last merge where i to 1+m*(K-1) are all original piles (which is similar to the approach used in the burst balloon)
(we can also try the right piles to merge)

why we add the (l-1)%(K-1)==0 case? i.e l=1+m*(K-1) (the above loop does not finish the last merge) and the last merge is fixed.
so the approach is considering the subproblem starting at i with length l as the last step of merging.


## contest 126

### 1001	Grid Illumination		Hard	
On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 0 <= y < N has a lamp.

Initially, some number of lamps are on.  lamps[i] tells us the location of the i-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).

For the i-th query queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0.

After each query (x, y) [in the order given by queries], we turn off any lamps that are at cell (x, y) or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).)

Return an array of answers.  Each value answer[i] should be equal to the answer of the i-th query queries[i].

We use a hash map to record number of occurance of row, col, diag1 and diag2 diag1: r-c=const diag2: r+c=const each query will minus the row, col, diag1 and diag2 by 1

```cpp
    vector<int> gridIllumination(int N, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        unordered_map<int,int> rset,cset,diagset1,diagset2;
        unordered_set<string> lset;
        for(int i=0;i<lamps.size();i++)
        {
            int r=lamps[i][0],c=lamps[i][1];
            rset[r]++;cset[c]++;diagset1[r-c]++;diagset2[r+c]++;
            lset.insert(to_string(r)+","+to_string(c));
        }
        vector<int> ans;
        for(int i=0;i<queries.size();i++)
        {
            ans.push_back(query(N,queries[i][0],queries[i][1],rset,cset,diagset1,diagset2,lset));
        }
        return ans;
    }
  int query(int n,int r,int c,unordered_map<int,int>& rset,
            unordered_map<int,int>& cset,
            unordered_map<int,int>& dset1,
            unordered_map<int,int>& dset2,
            unordered_set<string>& lset)
  {
  //for i,j, row i and col j, diag1 r-c=i-j, diag2: r+c=i+j     
      int ans=rset.count(r) || cset.count(c) || dset1.count(r-c) || dset2.count(r+c);
      for(int i=-1;i<=1;i++)
      {
          for(int j=-1;j<=1;j++)
          {
              if(r+i<0 || r+i>=n || c+j<0 || c+j>=n) continue;
              int rr=r+i,cc=c+j;
              string s=to_string(r+i)+","+to_string(c+j);
              if(lset.count(s))
              {
                  lset.erase(s);
                  rset[rr]--;if(rset[rr]==0) rset.erase(rr);
                  cset[cc]--;if(cset[cc]==0) cset.erase(cc);
                  dset1[rr-cc]--;if(dset1[rr-cc]==0) dset1.erase(rr-cc);
                  dset2[rr+cc]--;if(dset2[rr+cc]==0) dset2.erase(rr+cc);
              }
          }
      }
      return ans;      
  }
```  

1002. Find Common Characters.md

Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.

You may return the answer in any order.

### Approach
This is simple. using two maps to get each letter's copy

```cpp
    vector<string> commonChars(vector<string>& A) {
        //find the min occurrance across all lists
        vector<vector<int>> freq(A.size(),vector<int>(26));
        for(int i=0;i<A.size();i++)
        {
            for(int j=0;j<A[i].size();j++) freq[i][A[i][j]-'a']++;
        }
        vector<string> ans;
        for(int i=0;i<26;i++)
        {
            int min0=INT_MAX;
            for(int j=0;j<A.size();j++) min0=min(min0,freq[j][i]);
            if(min0<INT_MAX)for(int j=0;j<min0;j++) ans.push_back(string(1,'a'+i));
        }
        return ans;
    }
```    

1003. Check If Word Is Valid After Substitutions.md

### Problem Summary
We are given that the string "abc" is valid.

From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V.  (X or Y may be empty.)  Then, X + "abc" + Y is also valid.

If for example S = "abc", then examples of valid strings are: "abc", "aabcbc", "abcabc", "abcabcababcc".  Examples of invalid strings are: "abccba", "ab", "cababc", "bac".

Return true if and only if the given string S is valid.

### Approach
using stack or deque to remove the paired abc. or in-place changing the string

```cpp
    bool isValid(string S) {
       //remove string when valid is found
        deque<char> dq;
        int i=0;
        while(i<S.length())
        {
            if(dq.size()>1 && S[i]=='c')
            {
                if(dq.back()=='b' && dq[dq.size()-2]=='a')
                {
                    dq.pop_back();
                    dq.pop_back();
                }
                else dq.push_back(S[i]);
            }
            else dq.push_back(S[i]);
            i++;
        }
        return dq.empty();
    }
```

1004. Max Consecutive Ones III.md

Given an array A of 0s and 1s, we may change up to K values from 0 to 1.

Return the length of the longest (contiguous) subarray that contains only 1s. 

### Approach
using two pointer method to find the region with number of 0s <= K. (this is the key equivalent conversion)

```cpp
    int longestOnes(vector<int>& A, int K) {
       //a sliding window which contains zeros<=K
        int i=0,j=0;
        int cnt0=0,ans=0;
        while(j<A.size())
        {
            if(A[j]==0) cnt0++;
            while(cnt0>K) cnt0-=(A[i++]==0); 
            ans=max(ans,j-i+1);
            j++;
        }
        return ans;
    }
```
## contest 127

1005. Maximize Sum Of Array After K Negations.md

### Problem
Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.)

Return the largest possible sum of the array after modifying it in this way.

### Approach
Naive greedy
sort and convert the smallest negative first
until all negatives are converted and K is not exhausted, compare the first positive with the previous negative and choose the abs smaller one to convert.

```cpp
    int largestSumAfterKNegations(vector<int>& A, int K) {
        int ans=0;
        sort(A.begin(),A.end());
        int t=A[0],i=0;
        while(A[i]<0 && K) {A[i]*=-1;K--;t=A[i];i++;}
        if(K%2) {if(A[i]>t) A[i-1]*=-1;else A[i]*=-1;}
        return accumulate(A.begin(),A.end(),0);
    }
```

1006. Clumsy Factorial.md

### Problem
Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.

We instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.

For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.

Additionally, the division that we use is floor division such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.

Implement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.

### Approach
Note: cannot use recursive due to the sign reverse
method 1: we can divide by N/4 parts to calculate
method 2: use a stack which is more general
method 3: the final part will have 1,2,3 numbers and N*(N-1)/(N-2)=N+1 for N>=5

```cpp
    int clumsy(int N) {
       int ans=N;
        char op[]={'*','/','+','-'};
        stack<int> st;
        int j=0;
        for(int i=N-1;i>=1;i--)
        {
            switch(op[j%4])
            {
                case '*': ans*=i;break;
                case '/': ans/=i;break;
                case '+': if(st.size()) {ans=st.top()-ans;st.pop();}ans+=i;break;
                case '-': st.push(ans);ans=i;break;
            }
            j++;
        }
        if(st.size()) {ans=st.top()-ans;st.pop();}
        return ans;
    }
  ```

1007. Minimum Domino Rotations For Equal Row.md

### Problem

In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)

We may rotate the i-th domino, so that A[i] and B[i] swap values.

Return the minimum number of rotations so that all the values in A are the same, or all the values in B are the same.

If it cannot be done, return -1.

### Approach
Straightforward approach:
count each element appearance and then find the min flips

```cpp
    int minDominoRotations(vector<int>& A, vector<int>& B) {
      //we need count 1 to 6 index in each row
        vector<vector<int>> inda(6,vector<int>()),indb(6,vector<int>());
        int n=A.size();
        for(int i=0;i<A.size();i++)
        {
            inda[A[i]-1].push_back(i);
            indb[B[i]-1].push_back(i);
        }
        int minstep=INT_MAX;
        for(int i=0;i<6;i++)
        {
            unordered_set<int> ms(inda[i].begin(),inda[i].end());;
            for(int j=0;j<indb[i].size();j++) ms.insert(indb[i][j]);
            if(ms.size()==n) minstep=min(minstep,n-max((int)inda[i].size(),(int)indb[i].size()));
        }
        return minstep==INT_MAX?-1:minstep;
    }
```    

This solution is pretty slow
Another much simpler intuition:
just try A[0] and B[0] to see how many flips if we keep A[0] or keep B[0]

1008. Construct Binary Search Tree from Preorder Traversal.md

Return the root node of a binary search tree that matches the given preorder traversal.

### Approach
This problem is solved before
Use recursion:
The leftmost is the root, 
left subtree: left+1 to the first element which is greater than the root value is the right
right subtree: the first element which is greater than root to the end

so use l and r to indicate the left and right of the array

```cpp
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        //root, left, right
        return helper(preorder,0,preorder.size());
    }   
    TreeNode* helper(vector<int>& preorder,int l,int r)        
    {
        //divide by two parts, the left and right, the first is the root
        if(l>=r) return NULL;
        TreeNode *root=new TreeNode(preorder[l]);
        int left=l+1;
        int right=r;
        for(int i=left;i<right;i++) 
        {
            if(preorder[i]>preorder[l]) {right=i;break;}
        }
        root->left=helper(preorder,left,right);
        root->right=helper(preorder,right,r);
        return root;
    }
```    

Note: the search for the left/right boundary can use upper_bound (binary search to speed the search since its left < right)



## contest  132

### 1025. Divisor Game.md

2 will win, 3 will lose
for odd number, it only has odd factors, so next one must be even
for even number, it has odd and even factors, A can always pass a odd number to B

so even number A will always win


### 1026. Maximum Difference Between Node and Ancestor.md

This is traversal to get the min/max and max difference

first I try the post-order traversal based on the fact that we need to get the min/max of all its children and get the difference for the root and the min/max. But this is very hard to get it correct.

preorder is much more clear. Since preorder is root, left, right, which is like the dfs for all the path to the leaf. We are calculating the previous min/max with the current node.

```cpp
  int gmax=0;
  int maxAncestorDiff(TreeNode* root) {
  if(!root) return 0;
  int mn=root->val,mx=root->val;
  preorder(root,mn,mx);
  return gmax;
  }
  
  void preorder(TreeNode* root,int mn,int mx)
  {
    if(!root) return;
    gmax=max(gmax,max(root->val-mn,mx-root->val));
    mn=min(mn,root->val);
    mx=max(mx,root->val);
    preorder(root->left,mn,mx);
    preorder(root->right,mn,mx);
  }
```

example: [8,3,10,1,6,null,14,null,null,4,7,13]


### 1027. Longest Arithmetic Sequence.md

classical DP
at every position i we have a hashmap difference vs length

The only thing we need to note: we may have longer same d in front, so we need to keep max.

```cpp
    int longestArithSeqLength(vector<int>& A) {
        //ending with a diff and length
        //dp shall contain i, diff
        int n=A.size();
        vector<unordered_map<int,int>> dp(n); //dp[i] the max length at i with difference d
        //at least 3 elements
        int maxlen=2;
        for(int i=1;i<n;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                int d=A[i]-A[j];
                if(dp[j].count(d)) {dp[i][d]=max(dp[i][d],dp[j][d]+1);}
                else dp[i][d]=max(dp[i][d],2);
                maxlen=max(maxlen,dp[i][d]);
            }
        }
        return maxlen;
    }
```


### 1028. Recover a Tree From Preorder Traversal.md

root depth is 0
output in preorder, before the node we output depth -

"1-2--3--4-5--6--7"
1 is the root
2 is 1's child
3 is 2's left child
4 is 2's right child
5 is 2's right child
6 and 7 is 5's child

every time we have a node, we push it into stack, and process its child.
in the stack we only store current node's parents.

if stack top has same depth as current one, append to right, else append to left

```cpp
    TreeNode* recoverFromPreorder(string S) {
        stack<pair<TreeNode*,int>> st;
        TreeNode* root=0;
        string w;
        int depth=0,prev_depth=0;
        S+='-';
        for(int i=0;i<S.size();i++)
        {
            char c=S[i];
            if(c=='-') 
            {
                if(w.size()) 
                {
                    int val=stoi(w);
                    TreeNode* t=new TreeNode(val);
                    if(st.empty()) root=t;
                    else
                    {
                        while(st.size() && st.top().second>depth) st.pop();
                        if(st.top().second==depth) {st.pop();st.top().first->right=t;}
                        else st.top().first->left=t;
                    }
                    st.push(make_pair(t,depth));
                    depth=0;
                    w="";
                }
                depth++;
            }
            else {w+=c;}
        }
        return root;
    }
```
## contest 133

### 1029. Two City Scheduling.md

This is not easy however.
greedy approach:
sort it by the difference of A and B, then choose the first the first N elements, the second for the last N elements
proof:
sum(Xi)+Sum(Yj) minimize
Xi+Yj minimize:
Xi+Yj<=Yi+Xj-->Xi-Yi<=Xj-Yj. that is why we sort it using the difference.

```cpp
    int twoCitySchedCost(vector<vector<int>>& costs) {
        sort(costs.begin(),costs.end(),[](vector<int>& a,vector<int>& b) {return a[0]-a[1]<b[0]-b[1];});
        int ans=0,n=costs.size();
        for(int i=0;i<n/2;i++) ans+=costs[i][0];
        for(int i=n/2;i<n;i++) ans+=costs[i][1];
        return ans;
    }
```
O(nlogn)

If we cannot get this intuition, we may have dp solution:
dp[i][j] represents the cost when considering first (i + j) people in which i people assigned to city A and j people assigned to city B.
```java
    public int twoCitySchedCost(int[][] costs) {
        int N = costs.length / 2;
        int[][] dp = new int[N + 1][N + 1];
        for (int i = 1; i <= N; i++) {
            dp[i][0] = dp[i - 1][0] + costs[i - 1][0];
        }
        for (int j = 1; j <= N; j++) {
            dp[0][j] = dp[0][j - 1] + costs[j - 1][1];
        }
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                dp[i][j] = Math.min(dp[i - 1][j] + costs[i + j - 1][0], dp[i][j - 1] + costs[i + j - 1][1]);
            }
        }
        return dp[N][N];
    }
```
O(N^2)

we can also try dfs search (similar to dp but top down):

### 1030. Matrix Cells in Distance Order.md

Just sort using the distance

```cpp
    vector<vector<int>> allCellsDistOrder(int n, int m, int x, int y) {
        vector<vector<int>> a(n * m, vector<int>(2));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                a[i * m + j] = {i, j};
            }
        }
        sort(a.begin(), a.end(),
            [&](const vector<int>& u, const vector<int>& v) {
                return abs(u[0] - x) + abs(u[1] - y) < abs(v[0] - x) + abs(v[1] - y);
            });
        return a;
    }
```
this is very straightforward. 

    
### 1031. Maximum Sum of Two Non-Overlapping Subarrays.md

this is a simplified problem to the 3 non-overlapping problem

similarly we can get the left max and right max, then add to find the global max

Bugs are often associated with the index calculations.

There are two similar problems involved. left and right window can switch.

```cpp
    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {
        return max(helper(A,L,M),helper(A,M,L));
    }
    int helper(vector<int>& A,int L,int M) //left and right fixed
    {
        int n=A.size();
        vector<int> lmax(n-M);
        int tsum=0;
        int leftmax=0;
        for(int i=0;i<L;i++) tsum+=A[i];
        lmax[L-1]=leftmax=tsum;
        for(int i=L;i<n-M;i++) 
        {
            tsum+=A[i]-A[i-L];
            lmax[i]=leftmax=max(leftmax,tsum);
        }
        
        int rmax=0;
        for(int i=n-1;i>=n-M;i--) rmax+=A[i];
        tsum=rmax;
        int gsum=rmax+lmax[n-M-1];
        for(int i=n-M-1;i>=L;i--)
        {
            tsum+=A[i]-A[i+M];
            rmax=max(rmax,tsum);
            gsum=max(gsum,rmax+lmax[i-1]);
        }
        
        return gsum;
    }
 ```

### 1032. Stream of Characters.md

This problem is actually not hard using trie.
1. the words shall be inserted in reverse order (since matching in that order)
2. need keep the max length of the whole trie
3. once match any (shortest) return true.

A program template will greatly help to improve the efficiency and avoid mistakes.

```cpp
    struct TrieNode
    {
        bool is_end;
        vector<TrieNode*> child;
        TrieNode(){is_end=0;child=vector<TrieNode*>(26);}
    };
    TrieNode *root;
    string qstr;
    int maxlen=0;
    TrieNode* get_root() {return root;}
    
    void add_word(string w)
    {
        TrieNode* p=root;
        maxlen=max(maxlen,(int)w.size());
        for(int i=w.size()-1;i>=0;i--) //reverse add
        {
            char c=w[i];
            int ind=c-'a';
            if(!p->child[ind]) p->child[ind]=new TrieNode();
            p=p->child[ind];
        }
        p->is_end=1;
    }
    
    bool startWith(string word)
    {
        //cout<<"search: "<<word;
   		TrieNode* p=root;
        int match=0;
      for(char c: word)
      {
        if(p->child[c-'a']==0) break;
        p=p->child[c-'a'];
              if(p->is_end) return 1;
      }
		return 0;//p->is_end;//must ending with a leaf
    }        
    
    StreamChecker(vector<string>& words) {
        root=new TrieNode();
        for(string w: words) add_word(w);
    }
    
    bool query(char letter) {
        qstr=letter+qstr;
        if(qstr.size()>maxlen) qstr.pop_back();//qstr=qstr.substr(0,2000);
        return startWith(qstr);
    }
```    
## contest 134

### 1033. Moving Stones Until Consecutive.md

sort the 3 numbers
note: there are 3 cases
1. 3 numbers are consecuative
2. two numbers are consecuative
3. two numbers are only one space away
4. three numbers are not above cases


```cpp
    vector<int> numMovesStones(int a, int b, int c) {
        vector<int> v({a,b,c});
        sort(v.begin(),v.end());
        int d1=v[1]-v[0],d2=v[2]-v[1];
        if(d1==1 && d2==1) return {0,0};
        if(d1==1) return {1,d2-1};
        if(d2==1) return {1,d1-1};
            
        //move to the median
        int mn=0,mx=0;
        if(d1<3 || d2<3) 
        {
            if(d1<3) return {1,d2};
            if(d2<3) return {1,d1};
        }
        return {2,d2+d1-2};
    }
```



### 1034. Coloring A Border.md

dfs with only the border
border: it is on the boundary or its neigbors are not the same group

note: the new color will be the same as the old or neighboring colors, so use it to replace the one while dfs may cause infinite loop

The best solution is use negative

```cpp
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {
        int oc=grid[r0][c0];
        dfs(grid,r0,c0,oc,color);
        for(int i=0;i<grid.size();i++)
            for(int j=0;j<grid[0].size();j++)
                if(grid[i][j]<0) grid[i][j]=color;
        return grid;
    }
    void dfs(vector<vector<int>>& grid,int r,int c,int oc,int nc)
    {
        if(r<0 ||c<0 ||r>=grid.size() || c>=grid[0].size() || grid[r][c]!=oc) return;
        grid[r][c]=-oc;
        dfs(grid,r+1,c,oc,nc);
        dfs(grid,r-1,c,oc,nc);
        dfs(grid,r,c+1,oc,nc);
        dfs(grid,r,c-1,oc,nc);
        if(r && c && r<grid.size()-1 && c<grid[0].size()-1)
        {
            if((abs(grid[r-1][c])==oc) && 
               (abs(grid[r+1][c])==oc) && 
               (abs(grid[r][c+1])==oc) && 
               (abs(grid[r][c-1])==oc))
                grid[r][c]=oc;
        }
    }
```

We can also use two different color to label the boundary and inside cells, but it is more complicated.
We need to understand the dfs when it is done, changing back the color is very safe.


### 1035. Uncrossed Lines.md

Developing intuition on problems are very important.
this problem is actually the variation of the longest common subsequence, but I did not recognizae it. if it is recognized, it is pretty simple.

we can do some preproc to remove those numbers not in both array to reduce memory requirement

```cpp
    int maxUncrossedLines(vector<int>& A, vector<int>& B) {
        preproc(A,B);
        int m=A.size(),n=B.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(A[i-1]==B[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
    void preproc(vector<int>& A,vector<int>& B)
    {
        unordered_map<int,bool> mpa,mpb;
        for(int a: A) mpa[a]=1;
        int i=0,j=0;
        for(j=0;j<B.size();j++)
        {
            if(mpa.count(B[j])) {mpb[B[j]]=1;B[i++]=B[j];}
        }
        B.resize(i);
        i=0,j=0;
        while(j<A.size())
        {
            if(mpb.count(A[j])) A[i++]=A[j];
            j++;
        }
        A.resize(i);
    }
```    

### 1036. Escape a Large Maze.md

The maze is 1M x 1M, so we cannot use plain dfs or bfs to search.
The blocks are limited to 200.

The only case that source cannot access target is:
the source and target are separated by the blocks into two different groups.
note the 4 boundaries also can be a part of the blocks.

due to the small amount of blocks, there are following cases:
1. source or target surrounded in the 4 corners
2. source or target surrounded by the 4 sides
3. source or target surrounded by the obstacles

the maximum area covered is a circle.
in the first case: 200 obstacles are densely arranged on the quarter circle, the length is pi*r/2=200
in the second case: 200 obstacles are densely arranged on the semi-circle, the length is pi*r=200
in the third case: 200 obstacles are densely arranged on the whole circle, the length is 2*pi*r=200

the max r=400/pi, the max area is pi*r^2=400^2/pi=51000.
the max radius is for max steps using bfs
the max area is for max steps using dfs

so the solution is:
if we can go more than the max steps from source and target. (if either cannot, we cannot pass)
also we need add a visited set to ensure no re-visit

```cpp
    int n=1e6,max_steps=52000;
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        unordered_set<string> obs;
        int steps=0;
        for(auto t: blocked) obs.insert(to_string(t[0])+","+to_string(t[1]));
        unordered_set<string> visited;
        bool res=dfs(obs,source[0],source[1],target[0],target[1],steps,visited);
        steps=0;visited.clear();
        res=res&&dfs(obs,target[0],target[1],source[0],source[1],steps,visited);
        return res;
    }
    bool dfs(unordered_set<string>& obs,int i,int j,int x,int y,int& steps,unordered_set<string>& visited)
    {
      if(i<0 || j<0 || i>=n || j>=n) return 0;
      string s=to_string(i)+","+to_string(j);
      if(obs.count(s) || visited.count(s)) return 0;
      if(i==x && j==y) return 1;
      visited.insert(s);
      steps++;
      if(steps>=max_steps) return 1;
      bool res=dfs(obs,i-1,j,x,y,steps,visited);
      if(!res) res=dfs(obs,i+1,j,x,y,steps,visited);
      if(!res) res=dfs(obs,i,j-1,x,y,steps,visited);
      if(!res) res=dfs(obs,i,j+1,x,y,steps,visited);
      return res;
    }
```

Above solution will trigger stack overflow.
why? the dfs is too deep and stack overflow.

hash can use x*col+y which is easier.
replace the exit condition with the Manhattan distance > obstacle's number is fine.
```cpp
    long n=1e6;
    int max_steps=20000;
    int sx,sy;
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        unordered_set<long> obs;
        for(auto t: blocked) obs.insert(t[0]*n+t[1]);
        unordered_set<long> visited;
        bool res=dfs(obs,sx=source[0],sy=source[1],target[0],target[1],visited);
        visited.clear();
        res=res&&dfs(obs,sx=target[0],sy=target[1],source[0],source[1],visited);
        return res;
    }
    bool dfs(unordered_set<long>& obs,int i,int j,int x,int y,unordered_set<long>& visited)
    {
      if(i<0 || j<0 || i>=n || j>=n) return 0;
      long t=i*n+j;
      if(obs.count(t) || visited.count(t)) return 0;
      if(i==x && j==y) return 1;
      //if(steps>=max_steps) return 1;
      if(abs(i-sx)+abs(j-sy)>obs.size()) return 1;
      visited.insert(t);
      
      bool res=dfs(obs,i-1,j,x,y,visited);
      if(!res) res=dfs(obs,i+1,j,x,y,visited);
      if(!res) res=dfs(obs,i,j-1,x,y,visited);
      if(!res) res=dfs(obs,i,j+1,x,y,visited);
      return res;
    }
```


Another approach:
compress continuous two rows or two columns without obstacles into a single row or column and then it is a conventional problem.
Note that in the sparse matrix if two adjacent rows/columns both have non-zero elements, then they should be adjacent in the dense matrix (eg. the row with s and the row with 1 in the matrix above). If they are not adjacent in the sparse matrix, they should not be adjacent in the dense matrix. (eg. the column with s and the column with 1 in the matrix above)## contest 137

1046 Last Stone Weight3
1047 Remove All Adjacent Duplicates In String4
1048 Longest String Chain6
1049 Last Stone Weight II

### 1049. Last Stone Weight II.md

We have a collection of rocks, each rock has a positive integer weight.

Each turn, we choose any two rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.)

 ### Approach
 assume we have a,b,c,d,e, we choose a-(b-(c-(d-e)))=a-b-c-d+e, so it is partition into two parts
 target=psum-nsum
 tsum=psum+nsum
 2*psum=target+tsum
 target=tsum-2*psum, to minimize target is equivalent to maximize psum (up to tsum/2)
 
 knapsack approach (2d dynamic)
 The kernel of knapsack is choose or not choose the item (0/1 discrete knapsack)
 ```cpp
     int lastStoneWeightII(vector<int>& stones) {
        int n=stones.size();
        int tsum=accumulate(stones.begin(),stones.end(),0);
        vector<vector<bool>> dp(tsum/2+1,vector<bool>(n+1));
        //boundary
        for(int i=0;i<=n;i++) dp[0][i]=1;//any sized choose 0.
        int maxsum=0;
        for(int i=1;i<=tsum/2;i++)
        {
            for(int j=1;j<=n;j++)
            {
                dp[i][j]=dp[i][j-1]; //not choosing
                if(dp[i][j-1] ||(i>=stones[j-1] && dp[i-stones[j-1]][j-1]))
                {
                    dp[i][j]=1;
                    maxsum=max(maxsum,i);
                }
            }
        }
        return tsum-2*maxsum;
    }
```    
1d dynamic:
```cpp
    int lastStoneWeightII(vector<int>& stones) {
        if (stones.empty())
            return 0;
        
        int sum = 0;
        for (int n : stones) sum += n;
        int target = sum / 2;
        bool dp[target + 1] = {false};
        dp[0] = true;
        for (int n : stones) {
            for (int j = target; j >= n; j--)
                dp[j] = dp[j] || dp[j - n];
        }
        for (int i = target; i > 0; i--) {
            if (dp[i])
                return abs(sum - 2*i);
        }
        return 0;
    }
```
recursive approach:
https://www.geeksforgeeks.org/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/
```cpp
int findMinRec(int arr[], int i, int sumCalculated, int sumTotal) 
{ 
    // If we have reached last element.  Sum of one 
    // subset is sumCalculated, sum of other subset is 
    // sumTotal-sumCalculated.  Return absolute difference 
    // of two sums. 
    if (i==0) 
        return abs((sumTotal-sumCalculated) - sumCalculated); 
  
  
    // For every item arr[i], we have two choices 
    // (1) We do not include it first set 
    // (2) We include it in first set 
    // We return minimum of two choices 
    return min(findMinRec(arr, i-1, sumCalculated+arr[i-1], sumTotal), 
               findMinRec(arr, i-1, sumCalculated, sumTotal)); 
} 
  
// Returns minimum possible difference between sums 
// of two subsets 
int findMin(int arr[], int n) 
{ 
    // Compute total sum of elements 
    int sumTotal = 0; 
    for (int i=0; i<n; i++) 
        sumTotal += arr[i]; 
  
    // Compute result using recursive function 
    return findMinRec(arr, n, 0, sumTotal); 
} 
```
 
 
 
 
 






## contest 139
1071. Greatest Common Divisor of Strings
gcd for strings. using similar algorithm for numbers. remove the shorter one from the longer one.

```cpp
    string gcdOfStrings(string str1, string str2) {
        if (str1.size() < str2.size()) return gcdOfStrings(str2, str1);
        if (str2.empty()) return str1;
        if (str1.substr(0, str2.size()) != str2) return "";
        return gcdOfStrings(str1.substr(str2.size()), str2);
    }
```
1072. Flip Columns For Maximum Number of Equal Rows
<em>Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column.  Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0.

Return the maximum number of rows that have all values equal after some number of flips.</em>

Idea:

It seems hard to find the row col relation. let us think k same row. if we flip any column, it must change k rows. but the property not change. So it is equivalent to find the most frequent duplicate 	 row. We can use string serialization for row using hashmap.

```cpp
    int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
		//row must be same or flip each bit the same.
		//so problem is converted to find the max number of such rows.
		int m=matrix.size(),n=matrix[0].size();
		unordered_map<string,int> mp;
		for(auto& v: matrix){
			int t=v[0];
			string s;
			for(int i: v) {if(i==t) s+='1';else s+='0';}
			mp[s]++;
		}
		//find the max
		int ans=0;
		for(auto t: mp) ans=max(ans,t.second);
		return ans;
	}
```

1073. Adding Two Negabinary Numbers
<em>Given two numbers arr1 and arr2 in base -2, return the result of adding them together.

Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.

Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.</em>

base as negative problem:
its coefficient is still non-negative, 0 and 1. (the good thing using negative base: no need to have a sign bit)
a number can represent as sum(A[i]*b^i)-->how to represent a number using negative base):
similarly, n%b->A[i] for example 3=(-2)^2+(-2)^1+(-2)^0=111
the operation for mod we shall use & and / shall use shift.

```cpp
    vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
        int cf=0;
        int m=arr1.size(),n=arr2.size();
        vector<int> ans;
        int i=m-1,j=n-1;
        while(cf || i>=0 || j>=0)
        {
            int d=cf+(i>=0?arr1[i]:0)+(j>=0?arr2[j]:0);
            //
            ans.push_back(d&1);
            cf=-(d>>1);
            i--,j--;
        }
        while(ans.size()>1 && ans.back()==0) ans.pop_back();
        reverse(ans.begin(),ans.end());
        
        return ans;
    }
```	

1074. Number of Submatrices That Sum to Target
<em>Given a matrix, and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.	
</em>
Classic problem: reduce to 1d sum to target problem.

```cpp
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
		int m=matrix.size(),n=matrix[0].size();
		int ans=0;
		for(int i=0;i<m;i++){
			vector<int> rsum(n);
			for(int j=i;j<m;j++){
				for(int k=0;k<n;k++) rsum[k]+=matrix[j][k];
				ans+=numsubarray_sum(rsum,target);
			}
		}
		return ans;
	}
	int numsubarray_sum(vector<int>& nums,int target){
		int sum=0;
		unordered_map<int,int> mp;
		mp[0]++;
		int ans=0;
		for(int i: nums){
			sum+=i; //prefix sum
			ans+=mp[sum-target];
			mp[sum]++;
		}
		return ans;
	}
```




	


## contest 140
### 1078. Occurrences After Bigram
<em>Given words first and second, consider occurrences in some text of the form "first second third", where second comes immediately after first, and third comes immediately after second.

For each such occurrence, add "third" to the answer, and return the answer.</em>
Approach:
find a two word pattern matching. store each word in a 2 word storage.

### 1079. Letter Tile Possibilities
<em>
You have a set of tiles, where each tile has one letter tiles[i] printed on it.  Return the number of possible non-empty sequences of letters you can make.</em>

Intuition:

Apparently this is permutation with duplicates. Also it allows different length of target.
- we can do combination and then sort the string and calculate the permutation.
- we can backtrack to get all permutation
combination:
```cpp
    int numTilePossibilities(string tiles) {
        unordered_set<string> ms;
        int ans=0;
        dfs(tiles,0,"",ms);
        //for each string in the ms, we can calculate number of its permutation
        for(auto t: ms)
            ans+=numperm(t);
        return ans;
    }
    void dfs(string& s,int start,string t,unordered_set<string>& ms)
    {
        if(t.size()) {
			string tt=t;
			sort(tt.begin(),tt.end());
			ms.insert(tt);
		}
        
        for(int i=start;i<s.size();i++)
        {
            t+=s[i];
            dfs(s,i+1,t,ms);
            t.pop_back();
        }
    }
    int numperm(string& t)
    {
        //cout<<t<<endl;
        vector<int> cmap(26);
        for(char c: t) cmap[c-'A']++;
        int n=t.length();
        int ans=1;
        for(int i=0;i<26;i++) //C(n,m) for each
            if(cmap[i]>0) {
                ans*=comb(n,cmap[i]);
                n-=cmap[i];
            }
        return ans;
    }
    //see 377
    int comb(int m,int n)
	{//m!/(n!*(m-n)!)
		int ans=1;
    	for(int i=n+1,j=1;i<=m || j<=m-n;i++,j++) {if(i<=m)ans*=i;if(j<=m-n) ans/=j;}
		return ans;
	}
```	
backtracking using hashmap:
```cpp
    int numTilePossibilities(string tiles) {
        vector<int> cnt(26);
        for(char c: tiles) cnt[c-'A']++;
        return dfs(cnt);
    }
    int dfs(vector<int>& cnt){
        int ans=0;
        for(int i=0;i<26;i++){
            if(cnt[i]==0) continue;
            ans++;
            cnt[i]--;
            ans+=dfs(cnt);
            cnt[i]++;
        }
        return ans;
    }
```

### 1080. Insufficient Nodes in Root to Leaf Paths
<em>Given the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.)

A node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit.

Delete all insufficient nodes simultaneously, and return the root of the resulting binary tree.	
</em>

Idea:

sum(path)<limit. if we do preorder traverse, we subtract the parent value and get new limit.
two cases: leaf node itself, inner node causing subtree removal.
```cpp
    TreeNode* sufficientSubset(TreeNode* root, int limit) {
        if(!root) return 0;
		if(root->left==root->right) 
            return root->val<limit?0:root; //decide if leaf node shall removed
		root->left=sufficientSubset(root->left,limit-root->val);
		root->right=sufficientSubset(root->right,limit-root->val);
		return root->left==root->right?0:root; //decide if substree shall be removed
    }
```	
- leaf node shall return 0 or root, if let leaf to process by recursion, then it is incorrect.

### 1081. Smallest Subsequence of Distinct Characters
<em>Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.
Example 1:

Input: "cdadabcc"
Output: "adbc"</em>

Intuition:

hashmap with monotonic stack.
we keep a hashmap of each char's hist, and then char by char to store in stack.
if current char is smaller than stack top, we pop it if it still has, otherwise we keep.

```cpp
    string smallestSubsequence(string s, string res = "") {
      int cnt[26] = {}, used[26] = {};
      for (auto ch : s) ++cnt[ch - 'a'];
      for (auto ch : s) {
        --cnt[ch - 'a'];
        if (used[ch - 'a']++ > 0) continue;
        while (!res.empty() && res.back() > ch && cnt[res.back() - 'a'] > 0) {
          used[res.back() - 'a'] = 0;
          res.pop_back();
        }
        res.push_back(ch);
      }
      return res;
    }   
```
	## Contest 141

### 1089. Duplicate Zeros (***)
very interesting problem. Need in-place to duplicate zero elements.

idea: 

using two pointer left to right and then right to left to fill zeros

```cpp
    void duplicateZeros(vector<int>& arr) {
        int i=0,j=0;
        int cnt0=0;
        while(i<arr.size()){
            if(arr[i]==0) j++;
            i++,j++;
        }
        i--,j--;
        while(i>=0){
            if(j<arr.size()) arr[j]=arr[i];
            if(arr[i]==0) {
                j--;
                if(j<arr.size()) arr[j]=0;
            }
            i--,j--;
        }
    }
```

	
### 1090. Largest Values From Labels
<em>Problem: 

We have a set of items: the i-th item has value values[i] and label labels[i].

Then, we choose a subset S of these items, such that:

|S| <= num_wanted
For every label L, the number of items in S with label L is <= use_limit.
Return the largest possible sum of the subset S.</em>
Idea:
keep each label only use_limit from large to small. Then pick global max.
pq is perfect for this.

```cpp
    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int num_wanted, int use_limit) {
        unordered_map<int,multiset<int,greater<int>>> mp;
        for(int i=0;i<values.size();i++) mp[labels[i]].insert(values[i]);
        //choose limit from the k-sorted list
        priority_queue<int> pq;
        int ans=0;
        for(auto t: mp){ //each set we can take limit from it
            for(int i=0;i<use_limit;i++) 
                if(t.second.size()) {
                    pq.push(*t.second.begin());
                    t.second.erase(t.second.begin());
                }
        }
        while(num_wanted-- && pq.size()) ans+=pq.top(),pq.pop();
        return ans;
    }
```

### 1091. Shortest Path in Binary Matrix
<em>In an N by N square grid, each cell is either empty (0) or blocked (1).

A clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, ..., C_k such that:

Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner)
C_1 is at location (0, 0) (ie. has value grid[0][0])
C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1])
If C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0).
Return the length of the shortest such clear path from top-left to bottom-right.  If such a path does not exist, return -1.
</em>
regular bfs with 8 directions:

```cpp
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        //bfs
        int n=grid.size();
        if(n<2) return n;
        vector<int> visited(n*n);
        if(grid[0][0]||grid[n-1][n-1]) return -1;
        queue<int> q;
        q.push(0);visited[0]=1;
        int step=1;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{1,1},{1,-1},{-1,1}};
        while(q.size())
        {
            int sz=q.size();
            while(sz--){
                int t=q.front();q.pop();
                if(t==n*n-1) return step;
                int i=t/n,j=t%n;
                for(auto v: dir){
                    int x=i+v[0],y=j+v[1];
                    if(x<0 ||y<0 ||x>=n || y>=n || grid[x][y] || visited[x*n+y]) continue;
                    //cout<<x<<" "<<y<<endl;
                    visited[x*n+y]=1;
                    q.push(x*n+y);
                }
            }
            step++;
        }
        return -1;
    }
```

### 1092. Shortest Common Supersequence
<em>Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences.  If multiple answers exist, you may return any of them.

(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)

Example 1:

Input: str1 = "abac", str2 = "cab"
Output: "cabac"
Explanation: 
str1 = "abac" is a subsequence of "cabac" because we can delete the first "c".
str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".
The answer provided is the shortest such string that satisfies these properties.
</em>
idea: 
shortest common supersequence = A+B-Intersection(A,B)
we can find the longest common subsequence and then form the shortest supersequence.
A bit different: we are looking for lcs string, not the length.

```cpp
    string shortestCommonSupersequence(string& A, string& B) {
        int i = 0, j = 0;
        string res = "";
        for (char c : lcs(A, B)) {
            while (A[i] != c)
                res += A[i++];
            while (B[j] != c)
                res += B[j++];
            res += c, i++, j++;
        }
        return res + A.substr(i) + B.substr(j);
    }

    string lcs(string& A, string& B) {
        int n = A.size(), m = B.size();
        vector<vector<string>> dp(n + 1, vector<string>(m + 1, ""));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                if (A[i] == B[j])
                    dp[i + 1][j + 1] = dp[i][j] + A[i];
                else
                    dp[i + 1][j + 1] = dp[i + 1][j].size() > dp[i][j + 1].size() ?  dp[i + 1][j] : dp[i][j + 1];
        return dp[n][m];
    }
```## contest 142
1093. Statistics from a Large Sample
<em>We sampled integers between 0 and 255, and stored the results in an array count:  count[k] is the number of integers we sampled equal to k.

Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers.  The mode is guaranteed to be unique.</em>

min,max,mean
median: odd/even
mode: the most frequent element

1094. car pooling
often seen add/remove action, interval problem
attention: for the same location, we need first unload passenger and then load

```cpp
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        map<int,int> mp;
        for(auto t: trips){
            mp[t[1]]+=t[0];
            mp[t[2]]-=t[0];
        }
        //check prefix sum to see if over capacity
        //print(mp);
        int prefix=0;
        for(auto t: mp){
            prefix+=t.second;
            if(prefix>capacity) return 0;
        }
        return 1;
    }
```	
1095. find in mountain array
two binary search problem.
we can also find the peak first and then do 2 binary search.

```cpp
    int findInMountainArray(int target, MountainArray &mountainArr) {
        //binary search in the peak
        int left=find1side(target,mountainArr,1);
        if(left==-1) return find1side(target,mountainArr,0);
        return left;
    }
    int find1side(int target,MountainArray& mt,int side){
        int l=0,r=mt.length()-1;
        int n=mt.length();
        while(l<r)
        {
            int mid=l+(r-l)/2;
            int m=mt.get(mid);
            if(side){ //search left
                if((mid<n-1 && m>mt.get(mid+1))||(m==n-1 && m<mt.get(mid-1))) r=mid; //mid is on right side
                else {
                    if(m==target) return mid;
                    if(m>target) r=mid-1;
                    else l=mid+1;
                    //cout<<m<<" "<<l<<" "<<r<<endl;
                }
            }
            else //right side
            {
                if((mid<n-1 && m<mt.get(mid+1))||(mid==n-1 && m>mt.get(mid-1))) l=mid+1; //it is on the left side
                else{
                    if(m==target) return mid;
                    if(m>target) l=mid+1;
                    else r=mid;
                    //cout<<m<<" "<<l<<" "<<r<<endl;
                }
            }
        }
        return mt.get(l)==target?l:-1;
    }
```	
1096. Brace expansion II.
again, recursive stack

```cpp
    vector<string> braceExpansionII(string expression){
        unordered_set<string> res=parser(expression);
        vector<string> ans(res.begin(),res.end());
        sort(ans.begin(),ans.end());
        return ans;
    }
	unordered_set<string> parser(string expression)
	{
		string s=expression;
		stack<unordered_set<string>> st;
		char presign=',';
        //cout<<s<<": ";
		for(int i=0;i<s.length();i++)
		{
			char c=s[i];
			if(c=='{')
			{
				int j=i,p=1;
				while(s[j]!='}' || p!=0 ) //find the paired }
				{
					j++;
					if(s[j]=='{') p++;
					if(s[j]=='}') p--;
				}
				unordered_set<string> vs=parser(s.substr(i+1,j-i-1));
				if(presign=='*')
				{
					auto t=st.top();
					st.pop();
					st.push(merge(t,vs));
				}
				else st.push(vs);
				i=j;
				presign='*';
			}
			else if(isalpha(c))
			{
				unordered_set<string> vs;
				string t;
                while(isalpha(s[i])) t+=s[i++];
                i--;
                vs.insert(t);//not a single letter, it allows string
                
				if(presign=='*')
				{
					unordered_set<string> t=st.top();
					st.pop();
					st.push(merge(t,vs));
				}
                else st.push(vs);
				presign='*';
			}
			if(c==',' || i==s.length()-1)
			{
				presign=',';
			}
		}
        
		unordered_set<string> ans;
		while(st.size())
		{
            auto vt=st.top();
			for(string t: vt)
			{
				ans.insert(t);
			}
			st.pop();
		}
        //copy(ans.begin(),ans.end(),ostream_iterator<string>(cout," "));cout<<endl;
		//sort(ans.begin(),ans.end());
		return ans;
	}
	
	unordered_set<string> merge(unordered_set<string>& l1,unordered_set<string>& l2)
	{
		unordered_set<string> ans;
		for(string s: l1)
			for(string t: l2)
				ans.insert(s+t);
		return ans;
	}
```	

## contest 143
### 1103. Distribute Candies to People (***)
<em>Problem:

We distribute some number of candies, to a row of n = num_people people in the following way:

We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.

Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.

This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).

Return an array (of length num_people and sum candies) that represents the final distribution of candies.
</em>

Idea:
If we want to derive math equations for this, it would be pretty tricky. but if we treat it as a 2d matrix with roation, it is much simpler.

```cpp
    vector<int> distributeCandies(int candies, int n) {
		vector<int> ans(n);
		int cnt=1;
		int i=0;
		while(candies){
			int m=min(candies,cnt);
			ans[i%n]+=m;
			candies-=m;
		}
		return ans;
	}
```

### 1104. Path in zigzag labelled binary tree (***)
<em>In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.

Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label
</em>

Analysis:
starting from layer 1.
it is a full tree.
given a node ->get the depth-> get the original id->id/2
id->depth: the left is 1,2,4,8
```cpp
    vector<int> pathInZigZagTree(int label) {
		vector<int> ans;
		int d=log2(label)+1;
		while(d){
			ans.push_back(label);
			int id=label2id(label,d);
			label=id2label(id/2,--d);
		}
		reverse(ans.begin(),ans.end());
		return ans;
    }
	int label2id(int l, int d){
		if(d%2) return l;
		return pow(2,d-1)+(pow(2,d)-1-l);
	}
	int id2label(int id,int d){
		if(d%2) return id;
		return pow(2,d)-1-(id-pow(2,d-1));
	}
```	
### 1105. Filling bookcase shelves (****)
<em>We have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].

We want to place these books in order onto bookcase shelves that have total width shelf_width.

We choose some of the books to place on this shelf (such that the sum of their thickness is <= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.  We repeat this process until there are no more books to place.

Note again that at each step of the above process, the order of the books we place is the same order as the given sequence of books.  For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.

Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.
</em>

Approach:
- shelf is bound by width. and each book has w x h
- book sequence is not to be changed.
- dp: a book can be placed after previous book if width is allowed. or it can start a new layer.
- subproblem shall be min height for n books. dp[i]
-  recurrence: if a new layer: dp[i]=dp[i-1]+h[i]. if append to previous: it can attach to i-1, i-2...j 
```cpp
    int minHeightShelves(vector<vector<int>>& books, int shelf_width) {
		int n=books.size();
		vector<int> dp(n+1, INT_MAX); //min height for i books.
		dp[0]=0; //no books
		for(int i=0;i<n;i++){
			dp[i+1]=dp[i]+books[i][1];
			int width=0,maxh=0;
			for(int j=i;j>=0;j--){
				if(width+books[j][0]<=shelf_width){
					maxh=max(maxh,books[j][1]);
					width+=books[j][0];
					dp[i+1]=min(dp[i+1],dp[j]+maxh);
				}
				else break; //this is essential otherwise it will not stop and gives wrong results.
			}
		}
		return dp[n];
    }
```	


### 1106. Parsing a boolean expression (*****)
<em>
Return the result of evaluating a given boolean expression, represented as a string.

An expression can either be:

"t", evaluating to True;
"f", evaluating to False;
"!(expr)", evaluating to the logical NOT of the inner expression expr;
"&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;
"|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...
</em>
Intuition:

- recursive stack for syntax analysis.
- &: when any is false, return false, all true return true.
- |: any is true return true, all 0 returns 0
- !: toggle the bool value.
- polish style

need to skip.
```cpp
bool parseBoolExpr(string e) {
  if (e.size() == 1) return e == "t" ? true : false;
  if (e[0] == '!') return !parseBoolExpr(e.substr(2, e.size() - 3));
  bool isAnd = e[0] == '&' ? true : false, res = isAnd;
  for (auto i = 2, j = 2, cnt = 0; res == isAnd && i < e.size(); ++i) {
    if (e[i] == '(') ++cnt;
    if (e[i] == ')') --cnt;      
    if (i == e.size() - 1 || (e[i] == ',' && cnt == 0)) {
      if (isAnd) res &= parseBoolExpr(e.substr(j, i - j));
      else res |= parseBoolExpr(e.substr(j, i - j));
      j = i + 1;
    }
  }
  return res;
}
```	
the coding is pretty tricky.## contest 144
### 1108. Defanging an IP Address (*)
simple

### 1109. Corporate Flight Bookings  (***)
<em>Problem:

There are n flights, and they are labeled from 1 to n.

We have a list of flight bookings.  The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive.

Return an array answer of length n, representing the number of seats booked on each flight in order of their label.

 

Example 1:

Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
</em>

The description is very unclear. Actually ii,j,k means from flight i to j, there are k seats booking. (i,j) is a flight range not an edge defining a flight).
so actually it is defining a list of intervals and get each number.
typical interval problem

```cpp
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<int> ans(n);
        map<int,int> book;
        for(auto t: bookings){
            book[t[0]]+=t[2]; //add
            book[t[1]+1]-=t[2]; //remove
        }
        int prefix=0;
        for(int i=0;i<n;i++){
            if(book.count(i+1)) {
                prefix+=book[i+1];
            }
            ans[i]=prefix;
        }
        return ans;
    }
```	

### 1110. Delete Nodes And Return Forest (***)
atually post-order is better.

```cpp
    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
        vector<TreeNode*> ans;
        unordered_set<int> del(to_delete.begin(),to_delete.end());
        if(delNodes(root,del,ans)) ans.push_back(root);
        return ans;
    }
    TreeNode* delNodes(TreeNode* root,unordered_set<int>& del,vector<TreeNode*>& ans){
        if(!root) return 0;
        if(del.empty()) return root;
        //preorder
        if(del.count(root->val)){
            del.erase(root->val);//root is deleted
            TreeNode* left=delNodes(root->left,del,ans);
            TreeNode* right=delNodes(root->right,del,ans);
            if(left) ans.push_back(left);
            if(right) ans.push_back(right);
            return 0;
        }

        //its left and right will be modified.
        root->left=delNodes(root->left,del,ans);
        root->right=delNodes(root->right,del,ans);
        return root;
    }
```
### 1111. Maximum Nesting Depth of Two Valid Parentheses Strings	(***)
<em>
A string is a valid parentheses string (denoted VPS) if and only if it consists of "(" and ")" characters only, and:

It is the empty string, or
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example,  "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

 

Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).

Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.

Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.

 

Example 1:

Input: seq = "(()())"
Output: [0,1,1,1,1,0]
Example 2:

Input: seq = "()(())()"
Output: [0,0,0,1,1,0,1,1]
</em>


Idea: 
if the total depth is n, then break into A and B with n/2 and n-n/2, the difference will be minimized.
so we shall choose depth alternatively.
for parenthesis, we can use ++-- or stack.
- calculate the depth and assign even depth to 0 and odd depth to 1.
example:
((()))
123321
010010
```cpp
    vector<int> maxDepthAfterSplit(string seq) {
        vector<int> ans(seq.size()); //all assigned as 0
		int sum=0;
		for(int i=0;i<seq.size();i++){
			if(seq[i]=='(') {
				sum++;
				if(sum%2) ans[i]=1;
			}
			else{
				if(sum%2) ans[i]=1;
				sum--;
			}
		}
		return ans;
    }
```	## contest 145
### 1122. Relative Sort Array (*)
simple using hashmap

### 1123. Lowest common ancestor of deepest leaves (***)
O(N^2) is simple using depth

O(N) approach finding depth and lca at the same time
```cpp
    int h=0;
    TreeNode* lca=0;
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        depth(root,0);
        return lca;
    }
    int depth(TreeNode* root,int d){
        h=max(h,d);
        if(!root) return d;
        int left=depth(root->left,d+1);
        int right=depth(root->right,d+1);
        if(left==h && right==h)
            lca=root;
        return max(left,right);
    }
```
### 1124. longest well-performing interval (***)
idea: >8 +1 and <=8 -1.
if sum>0 from 0 to i is a valid interval
else find the valid

```cpp
    int longestWPI(vector<int>& hours) {
        //we can conver to 1 0, and we are searching for longest window with more 1s than 0s.
        //then we can use prefix sum
        int n=hours.size();
        int ans=0;
        map<int,int> mp; //sum vs index
        int sum=0;
        for(int i=0;i<n;i++){
            sum+=hours[i]>8?1:-1;
            if(sum>0)
                ans=max(ans,i+1); //from 0 to i
            else { //find the one less
                auto it=mp.lower_bound(sum);
                auto it1=mp.begin();
                while(it1!=it) ans=max(ans,i-it1->second),it1++;
            }
            
            if(!mp.count(sum)){ //we have the sum seen
                mp[sum]=i;
            }
         }
        return ans;
    }
```
note: map/set has lower_bound member function

### 1125. Smallest Sufficient Team (****)
idea: 
- convert skills into bit set
- convert people to integer
- then use backtracking or dp to find the answer.

backtracking:
```cpp
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        unordered_map<string,int> skills;
        int n=req_skills.size();
        int np=people.size();
        //using bits
        int target=0;
        for(int i=0;i<n;i++) {
            skills[req_skills[i]]=1<<i;
            target+=1<<i;
        }
        //convert the people skill into integer with bits.
        //to reduce same skill or a subset skill people
        //optimization: we need try person with large set first.
        vector<int> person(np); 
        for(int i=0;i<np;i++){
            int t=0;
            for(auto s: people[i]) 
                if(skills.count(s)) t+=skills[s];
            bool include=1;
            for(int j=i-1;j>=0;j--){
                if(person[j]==0) continue;
                if(t==person[j] || (t<person[j] && (t|person[j])==person[j])){
                    include=0;
                    break;
                }
                //if((t|person[j])==t) person[j]=0;
            }
            if(include) {
                person[i]=t;
                //seen.insert(t);
            }
        }
        //copy(person.begin(),person.end(),ostream_iterator<int>(cout," "));cout<<endl;
        vector<int> ans;
        dfs(person,0,0,{},ans,target);
        return ans;
    }
    void dfs(vector<int>& person,int start,int interm,vector<int> cand,vector<int>& ans,int target){
        //cout<<start<<" "<<interm<<" [";
        //copy(cand.begin(),cand.end(),ostream_iterator<int>(cout," "));cout<<"]"<<endl;

        if(interm==target){
            if(ans.size()==0) ans=cand;
            else if(cand.size()<ans.size()) ans=cand;
            return;
        }
        if(start>=person.size() || (ans.size() && cand.size()>=ans.size())) return;
        for(int i=start;i<person.size();i++){
            if(person[i]==0 || (interm|person[i])==interm) continue;
            cand.push_back(i);
            dfs(person,i+1,interm|person[i],cand,ans,target);
            cand.pop_back();
        }
    }
```

dp approach:
dp[1<<n,m+1]: note it needs the people combination instead min number of people.
this is essentially bellman-ford algorithm.
```cpp
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
		int n = req_skills.size();
        int m=people.size();
		vector<vector<int>> dp(1<<n);  // using unordered_map, we improve on time
        unordered_map<string,int> skill_map;
        for(int i=0;i<n;i++)
            skill_map[req_skills[i]]=i;
        vector<int> skills(m);
        for(int i=0;i<m;i++){
            int curr_skill = 0;
            for(int j=0;j<people[i].size();j++)
                curr_skill |= 1<<skill_map[people[i][j]];
            skills[i]=curr_skill;
        }
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<(1<<n);j++)
            {
                int k = (dp[j].empty()?0:j) | skills[i]; //this is critical to make k correct.
                if(dp[k].size()==0 || dp[k].size()>1+dp[j].size()) 
                    //check if add this person can relax
                {
                    dp[k]=dp[j]; //using its combination
                    dp[k].push_back(i);//add current person
                    //cout<<i<<" "<<j<<" "<<k<<endl;
                }       
            }
        }
        return dp[(1<<n) -1];        
    }
```## contest 146
### 1128. Number of Equivalent Domino Pairs (**)
<em>Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.</em>


Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].	

Approach:

sort the dominions, and using hashmap to get the same pairs.

```cpp
   int numEquivDominoPairs(vector<vector<int>>& dominoes) {
        int ans=0;
        unordered_map<string,int> mp;
        for(auto t: dominoes){
            if(t[0]>t[1]) swap(t[0],t[1]);
            string s=to_string(t[0])+","+to_string(t[1]);
            ans+=mp[s];
            mp[s]++;
        }
        return ans;
    }
```

### 1129. Shortest Path with Alternating Colors
<em>Consider a directed graph, with nodes labelled 0, 1, ..., n-1.  In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.

Each [i, j] in red_edges denotes a red directed edge from node i to node j.  Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.

Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn't exist).
</em>

Approach: bfs, record i,j,k as the status. (i start node, j dest node, k color)
```cpp
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& red_edges, vector<vector<int>>& blue_edges) {
        //bfs with two options: starting with blue, starting with red.
        vector<int> ans(n,-1);
        ans[0]=0;
        //build graph i,j,k k is the color 0, 1
        vector<vector<vector<int>>> adj(n,vector<vector<int>>(2)); //[nx2xm]
        for(auto t: red_edges) adj[t[0]][0].push_back(t[1]); //red
        for(auto t: blue_edges) adj[t[0]][1].push_back(t[1]); //blue
        bool v[n][n][2];
        memset(v,0,n*n*2*sizeof(bool));
        queue<vector<int>> q;
        for(auto t: adj[0]){
            for(int r: adj[0][0]) {q.push({0,r,0});v[0][r][0]=1;}
            for(int b: adj[0][1]) {q.push({0,b,1});v[0][b][1]=1;}
        }
        int step=1;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                auto t=q.front();
                q.pop();
                int i=t[0],j=t[1],k=t[2];
                if(ans[j]<0) ans[j]=step;
                for(auto e: adj[j][k^1]){
                    if(v[j][e][k^1]==0){
                        v[j][e][k^1]=1;
                        q.push({j,e,k^1});
                    }
                }
            }
            step++;
        }
        return ans;
    }
```	
- note: if you are using bool v[n][n][2], we have to initialize it, otherwise it is random.
	

### 1130. Minimum Cost Tree From Leaf Values (****)
<em>Problem:

Given an array arr of positive integers, consider all binary trees such that:

Each node has either 0 or 2 children;
The values of arr correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.
Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.
</em>

Approach:

- This is a very good question. but Be careful what the problem asks. You cannot change the order of the  array. It is already arranged as is for the tree leaf nodes.
- a number can only combine its nieghboring, cannot cross!
- sorted order will be simple.
Once we are clear about that, we can use greedy approach.
every leaf shall be combined with its left or right. For each element it shall combine to the next larger number to get rid of itself.
So the problem is equivalent to find next larger integer in its left or right.
And this can be solved using stack.
for example [7,12,8,10]:
add 7 to stack
12>7: we pop 7 and get 7*12 (now stack is empty so to make min work, we can add a INT_MAX in the stack.
add 12 to stack
add 8 to stack
10>8 and we get 8*10

```cpp
    int mctFromLeafValues(vector<int>& arr) {
		stack<int> st; //monotonic stack decreasing order, so we know its left next larger.
		st.push(INT_MAX);
		int ans=0;
		for(int t: arr){
			while(t>=st.top()){
				int mid=st.top();
				st.pop();
				ans+=mid*min(st.top(),t);
			}
			st.push(t);
		}
		//now stack is in decreasing order.
		while(st.size()>1){
			int t=st.top();
			st.pop();
			ans+=t*st.top();
		}
		return ans;
	}
```
- add int-max to keep the decreasing order and do not handle empty case
- while loop to keep poping those larger elements in the stack.

### 1131. Maximum of Absolute Value Expression (****)
<em>Problem:

Given two arrays of integers with equal lengths, return the maximum value of:

|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|

where the maximum is taken over all 0 <= i, j < arr1.length.
</em>

Approach:

- we need remove the abs operator.
- if the abs is removed, this would be equiv to:
A[i]-A[j]+B[i]-B[j]+i-j. ie (A[i]+B[i]+i)-(A[j]+B[j]+j) when A[i]>=A[j] && B[i]>=B[j] && i>=j
A[j]-A[i]+B[i]-B[j]+i-j. ie (B[i]-A[i]+i)-(B[j]-A[j]+j) when A[i]<=A[j] && B[i]>=B[j] && i>=j
A[i]-A[j]+B[j]-B[i]+i-j. ie (A[i]-B[i]+i)-(A[j]-B[j]+j) when A[i]>=A[j] && B[i]<=B[j] && i>=j
A[j]-A[i]+B[j]-B[i]+i-j. ie (B[i]-A[i]+i)-(B[j]-A[j]+j) when A[i]<=A[j] && B[i]<=B[j] && i>=j
A[i]-A[j]+B[i]-B[j]+j-i. ie (A[i]+B[i]-i)-(A[j]+B[j]-j) when A[i]>=A[j] && B[i]>=B[j] && i<=j
A[j]-A[i]+B[i]-B[j]+j-i. ie (B[i]-A[i]-i)-(B[j]-A[j]-j) when A[i]<=A[j] && B[i]>=B[j] && i<=j
A[i]-A[j]+B[j]-B[i]+j-i. ie (A[i]-B[i]-i)-(A[j]-B[j]-j) when A[i]>=A[j] && B[i]<=B[j] && i<=j
A[j]-A[i]+B[j]-B[i]+j-i. ie (B[i]-A[i]-i)-(B[j]-A[j]-j) when A[i]<=A[j] && B[i]<=B[j] && i<=j

this is to find 4 types of max-min in the array.
code is simple but math requires some intuition.
```cpp
    int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {
        int n = arr1.size();
        vector<int> sum1(n),diff1(n),sum2(n),diff2(n);
        int max1=INT_MIN,max2=INT_MIN,max3=INT_MIN,max4=INT_MIN;
        int min1=INT_MAX,min2=INT_MAX,min3=INT_MAX,min4=INT_MAX;
        for(int i=0;i<n;i++) {
            sum1[i]=arr1[i]+arr2[i]+i;
            diff1[i]=arr1[i]-arr2[i]+i;
            sum2[i]=arr1[i]+arr2[i]-i;
            diff2[i]=arr1[i]-arr2[i]-i;
            max1=max(max1,sum1[i]);min1=min(min1,sum1[i]);
            max2=max(max2,diff1[i]);min2=min(min2,diff1[i]);
            max3=max(max3,sum2[i]);min3=min(min3,sum2[i]);
            max4=max(max4,diff2[i]);min4=min(min4,diff2[i]);
        }
        return max({max1-min1,max2-min2,max3-min3,max4-min4});
    }
```	## contest 147
### 1137. N-th Tribonacci Number (*)
trival, using O(1) space and O(n) time.

### 1138. Alphabet Board Path (***)
<em>Problem:

On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].

Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.
We may make the following moves:

'U' moves our position up one row, if the position exists on the board;
'D' moves our position down one row, if the position exists on the board;
'L' moves our position left one column, if the position exists on the board;
'R' moves our position right one column, if the position exists on the board;
'!' adds the character board[r][c] at our current position (r, c) to the answer.
(Here, the only positions that exist on the board are positions with letters on them.)

Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.
</em>

Approach: using bfs is overkill for this problem. Manhatton distance is the shortest.
The alphaboard is fixed from 0 to 25 fixed by 5 cols. But be careful the last row, you have to go up down first. 
if you start from 'z', you first have to pass 'u'
if you go to 'z', you first have to go to 'u'

```cpp
    string alphabetBoardPath(string target) {
		int cx=0,cy=0;
		char prev=-1;
		string ans;
		for(char c: target){
			if(c=='z'&&prev=='z') {ans+='!';continue;} //do not always have to go to 'u'
			if(c=='z' ||prev=='z') ans+=nextchar('u',cx,cy); //dest is z.
			ans+=nextchar(c,cx,cy);
			ans+='!';
			prev=c;
		}
		return ans;
    }
	string nextchar(char c,int &cx,int &cy){
		string ans;
		int t=c-'a';
		int row=t/5,col=t%5;
		int dx=row-cx,dy=col-cy;
		if(dx>0){
			for(int i=0;i<dx;i++) ans+='D';
		}else{
			for(int i=0;i<-dx;i++) ans+='U';
		}
		if(dy>0){
			for(int i=0;i<dy;i++) ans+='R';
		}else{
			for(int i=0;i<-dy;i++) ans+='L';
		}
		cx=row,cy=col;
		return ans;
	}
```	
### 1139. Largest 1-Bordered Square (****)
<em>Problem:

Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.

 

Example 1:

Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 9
Example 2:

Input: grid = [[1,1,0,0]]
Output: 1
</em>

Analysys:
- return the area of the square with all boarder as 1s.
- this is very similar to other all 1s square or rectangle problem which can be solved using dp
- first from top left to bottom right and find at [i,j] the horizontal and vertical length of 1s
- then from bottom right to top left and find 

```cpp
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        vector<vector<int>> hor(m,vector<int>(n)),ver(m,vector<int>(n));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]){
                    hor[i][j]=j==0?1:hor[i][j-1]+1;
                    ver[i][j]=i==0?1:ver[i-1][j]+1;
                }
            }
        }
        int maxlen=0;
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                if(grid[i][j]){
                    int len=min({hor[i][j],ver[i][j]});
                    //check ver[i][j-len+1] and hor[i-len+1][j]
                    for(int l=len;l>=1;l--){
                        if(ver[i][j-l+1]>=l && hor[i-l+1][j]>=l){
                            maxlen=max(maxlen,l);
                            break;
                        }
                    }
                }
            }
        }
        return maxlen*maxlen;
    }
```

### 1140. Stone Game II (*****)
<em>Problem:

Alex and Lee continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. 

Alex and Lee take turns, with Alex starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get.

 

Example 1:

Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger. 
</em>

dp problem with extra complexity.
```cpp
    int stoneGameII(vector<int>& piles) {
        int length = piles.size();
        vector<vector<int>>dp(length + 1, vector<int>(length + 1,0));
        vector<int> sufsum (length + 1, 0);
        for (int i = length - 1; i >= 0; i--) {
            sufsum[i] = sufsum[i + 1] + piles[i];
        }
        for (int i = 0; i <= length; i++) {
            dp[i][length] = sufsum[i];
        }
        for (int i = length - 1; i >= 0; i--) {
            for (int j = length - 1; j >= 1; j--) {
                for (int X = 1; X <= 2 * j && i + X <= length; X++) {
                    dp[i][j] = max(dp[i][j], sufsum[i] - dp[i + X][max(j, X)]);
                }
            }
        }
        return dp[0][1];
    }
```

## contest 152
### 1175. Prime Arrangement (***)
<em>Problem:

Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)

(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)

Since the answer may be large, return the answer modulo 10^9 + 7.
</em>
Idea:
suppose we have m primes, it takes m slots, and other takes (n-m) slots
m!*(n-m)!
- count prime numbers.
```cpp
    int mod=1e9+7;
    int numPrimeArrangements(int n) {
        int num_primes=getnum_primes(n);        
        return factor(num_primes)*factor(n-num_primes)%mod;
    }
    int getnum_primes(int n){
        vector<int> primes(n+1,1);
        primes[0]=primes[1]=0;
        for(int i=2;i<=sqrt(n);i++){
            for(long j=(long)i*i;j<=n;j+=i)
                primes[j]=0;
        }
        return accumulate(primes.begin(),primes.end(),0);
    }
    long factor(int n){
        long res=1;
        for(int i=1;i<=n;i++)
            res*=i,res%=mod;
        return res%mod;
	}
```

### 1176. Diet Plan Performance(*)
<em>Problem:

A dieter consumes calories[i] calories on the i-th day. 

Given an integer k, for every consecutive sequence of k days (calories[i], calories[i+1], ..., calories[i+k-1] for all 0 <= i <= n-k), they look at T, the total calories consumed during that sequence of k days (calories[i] + calories[i+1] + ... + calories[i+k-1]):

If T < lower, they performed poorly on their diet and lose 1 point; 
If T > upper, they performed well on their diet and gain 1 point;
Otherwise, they performed normally and there is no change in points.
Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for calories.length days.

Note that the total points can be negative.	
</em>
Idea: sliding window at a fixed win size.
		
### 1177. Can Make Palindrome from Substring (***)
<em>Problem:

Given a string s, we make queries on substrings of s.

For each query queries[i] = [left, right, k], we may rearrange the substring s[left], ..., s[right], and then choose up to k of them to replace with any lowercase English letter. 

If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.

Return an array answer[], where answer[i] is the result of the i-th query queries[i].

Note that: Each letter is counted individually for replacement so if for example s[left..right] = "aaa", and k = 2, we can only replace two of the letters.  (Also, note that the initial string s is never modified by any query.)
</em>

Idea:

- a palindrome string has zero or one char with odd occurrences, so just check if it is possible to reach this using k replace.
- a range count can be obtained using prefix sum. using 26 prefix sum.
```cpp
    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {
        //count the prefix sum for each number
        vector<vector<int>> cnt(26);
        for(int i=0;i<s.size();i++) cnt[s[i]-'a'].push_back(i);
        int n=queries.size();
        vector<bool> ans(n);
        for(int i=0;i<queries.size();i++){
            ans[i]=valid(cnt,queries[i]);
        }
        return ans;
    }
    bool valid(vector<vector<int>>& cnt,vector<int>& q){
        int l=q[0],r=q[1],k=q[2];
        if(l>r) return 0;
        if(l==r) return 1;
        vector<int> tmp(26);
        int num_rep=0;
        for(int i=0;i<26;i++){
            if(cnt[i].empty()) continue;
            auto it1=lower_bound(cnt[i].begin(),cnt[i].end(),l);
            auto it2=upper_bound(cnt[i].begin(),cnt[i].end(),r);
            tmp[i]=it2-it1;
            if(tmp[i]%2) num_rep++;
        }
        return num_rep/2<=k; //we can only keep 1 odd, and need 
    }
```	

### 1178. Number of Valid Words for Each Puzzle (****)
<em>Problem:

With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:
word contains the first letter of puzzle.
For each letter in word, that letter is in puzzle.
For example, if the puzzle is "abcdefg", then valid words are "faced", "cabbage", and "baggage"; while invalid words are "beefed" (doesn't include "a") and "based" (includes "s" which isn't in the puzzle).
Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i].
</em>

Approach:

- get the hist for each puzzle and also get hist for word, word must be a subset of puzzle O(m*n)
up to 10^9 which is too high complexity.
- trie: trie is generally a good choice for many string vs many string. but how?
	- build puzzle or word? for word
	- word need remove duplicates and sorted
	- word may have duplicates after preprocessing, need save count and hashset.
	```cpp
	    struct TrieNode{
        TrieNode* child[26];
        int count;
        set<char> ms;
        TrieNode(){count=0;memset(child,0,26*sizeof(TrieNode*));}
    };
    TrieNode* root;
	```
	- add words into trie:
	```cpp
	void addWord(string s){
        set<char> ms(s.begin(),s.end());
        //cout<<res<<endl;
        TrieNode* p=root;
        for(char c: ms){
            if(p->child[c-'a']==0)
                p->child[c-'a']=new TrieNode;
            p=p->child[c-'a'];
        }
        p->count++;
        p->ms=ms;
    }
	```
	- find match the puzzle with constraint: first letter in puzzle must in it.
		- sort the puzzle word (since trie is sorted)
		- dfs
		```cpp
	int find_word(string& s,bool match,int start,char first,TrieNode* p){
        //if(match && !p->child[first-'a']) return 0;
        if(start==s.size()) return 0;
        int ans=0;
        char c=s[start];
        if(!p->ms.empty() && p->ms.count(first))
            ans+=p->count;
        //cout<<c;
        for(int i=0;i<26;i++){
            if(p->child[i]==0) continue;
            char t='a'+i;
            int st=start;
            while(st<s.size() && s[st]!=t) st++;
            //bool mat=match||(t==first);
            ans+=find_word(s,match||(t==first),st,first,p->child[i]);
        }
       
        return ans;        
    }
	```## contest 153
### 1184. Distance Between Bus Stops (**)
<em>Problem:

A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.

The bus goes along both directions i.e. clockwise and counterclockwise.

Return the shortest distance between the given start and destination stops.
</em>
idea: it is a cycle, we just compare start-end distance and total-start,end distance, make sure start<end

### 1185. Day of the week (**)
- use built in date functions
- known today's weekday and calculate how many days between given date and today. and %7. We need to know how to get the leap year.

### 1186. Maximum Subarray Sum with One Deletion (****)
<em>Problem:

Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.

Note that the subarray needs to be non-empty after deleting one element.
</em>

idea:

- if in the subarray, min>0, we do not remove anything. if <0, then we remove the min.
- also remove the min helps to connect two subarrays
- dp (the max subarray sum is also a dp problem) and we add an extra constraint making it a 2d dp problem:
	- do not delete it: regular max subarray sum
	- delete it: only for negative number.
	- all negatives, return the max.
	
```cpp
    int maximumSum(vector<int>& arr) {
        vector<vector<int>> dp(arr.size(), vector<int>(2, 0)); //dp[i,0] no delete, dp[i,1] delete one element
        dp[0][0]=arr[0]; 
        int res=arr[0];
        for(int i=1;i<arr.size();i++) { 
            dp[i][0]=max(arr[i], dp[i-1][0]+arr[i]); //nodel
            dp[i][1]=max(arr[i], max(dp[i-1][1]+arr[i], dp[i-1][0])); //delete i or not delete i.
            res=max(res, max(dp[i][0], dp[i][1])); 
        }
        return res;
    }
```	
to make it more clear:
```cpp
    int maximumSum(vector<int>& arr) {
		int del=0,nodel=arr[0];
        int res=arr[0];
        for(int i=1;i<arr.size();i++) {
            int v=arr[i];
            del=max({v, del+v, nodel}); //delete i or not delete i: whether we shall connect to previous
			nodel=max(v, nodel+v); //nodel: either we shall connect to previous
            res=max({res, del, nodel}); 
        }
        return res;
    }
```

### 1187. Make Array Strictly Increasing (*****)
<em>Problem:

Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.

In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].

If there is no way to make arr1 strictly increasing, return -1.
</em>

Idea:
[1,5,3,6,7],[4,3,1]
sort the arr2 to [1,3,4]
replace 5 with 3, replace 3 with 4->[1,3,4,6,7]

- strictly increasing, so duplicate in arr2 is useless, we can remove those duplicates. and no element can be assigned more than one time.
- dp approach: 
  - first sort arr2 and remove duplicates, now the number of replace is the same as index in arr2
  - now think it is a variation of longest increasing subsequence, but now you can go to the other array
  arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
  first sort and remove duplicate of arr2=[1,2,3,4]
  1 5 3 6 7
    \  /
  1 2 3 4
  
it is like: find the longest increasing subsequence from arr1: 1,3,6,7 and check if we can fill the missing elements from arr2. The problem is we may have many LIS and we need to check all these combinations.
we can add INT_MIN to the head and INT_MAX to the tail of arr1 to make the base simpler.
using LIS, we only need to calculate the number of changes from j+1 to i-1.
```cpp
	int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {
		set<int> ms(arr2.begin(),arr2.end());
		arr2.clear();
		for(int t: ms) arr2.push_back(t);
		arr1.insert(arr1.begin(),INT_MIN);
		arr1.push_back(INT_MAX);
		int n=arr1.size();
		vector<int> dp(n,INT_MAX);
		dp[0]=0;
		for(int i=1;i<n;i++){
			for(int j=0;j<i;j++){
				if(arr1[i]>arr1[j] && dp[j]<INT_MAX){
				int change=check(arr1,j,i,arr2);
				if(change>=0) dp[i]=min(dp[i],dp[j]+change);
				}
			}
		}
		return dp[n-1]==INT_MAX?-1:dp[n-1];
	}
	//find the change number from start+1 to end-1
	int check(vector<int>& arr1,int start,int end,vector<int>& arr2){
		if(start+1==end) return 0;
		int mn=arr1[start],mx=arr1[end];
		int idx=upper_bound(arr2.begin(),arr2.end(),mn)-arr2.begin();
		int maxcount=end-start-1;
		int endi=idx+maxcount-1;
		if(endi<arr2.size() && arr2[endi]<mx) return maxcount;
		return -1;
	}
```
- it checks if replace all the element from start+1 to end-1 if arr2 has all the elements.
- the check function is quite hard to understand.
## contest 154
1189. Maximum Number of Balloons (**)
<em>Problem:
Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible.

You can use each character in text at most once. Return the maximum number of instances that can be formed.</em>

idea: 

using hashmap to record the occurrence of each char in balloon and then divide the cnt in balloon and get the gcd

### 1190. Reverse Substrings Between Each Pair of Parentheses (***)
<em>Problem:

You are given a string s that consists of lower case English letters and brackets. 

Reverse the strings in each pair of matching parentheses, starting from the innermost one.

Your result should not contain any brackets.
</em>
idea: recursive stack.
```cpp
    string reverseParentheses(string s) {
        string ans=parse(s);
        reverse(ans.begin(),ans.end());
        return ans;
    }
        
    string parse(string s) {
        stack<string> st;
        int i=0;
        string t;
        while(i<s.size()){
            if(s[i]!='('){
                t+=s[i];
                i++;
            }
            else{
                if(t.size()){
                    st.push(t);
                    t.clear();
                }
                int j=i+1,p=1;
                while(p){
                    if(s[j]=='(') p++;
                    if(s[j]==')') p--;
                    j++;
                }
                j--;
                string tp=parse(s.substr(i+1,j-i-1));//reversed
                st.push(tp);
                i=j+1;
            }
        }
        
        if(t.size()){
            st.push(t);
        } 
        string ans;
        while(st.size()){
            string w=st.top();
            st.pop();
            reverse(w.begin(),w.end());
            ans+=w;
        }
        return ans;//{ans.rbegin(),ans.rend()};
        
    }
```	

### 1191. K-Concatenation Maximum Sum (****)
<em>Problem:

Given an integer array arr and an integer k, modify the array by repeating it k times.

For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].

Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.

As the answer can be very large, return the answer modulo 10^9 + 7.</em>
idea:

- k=1:  find the max subarray sum in one array
- k=2:  find the max subarray sum in circular array: find the max and min at the same time, or use rotation. 
- k>2:  inside k-2 groups only count the sum of the array.
so only consider k=1 and 2 case.

```cpp
int kConcatenationMaxSum(vector<int>& arr, int k) {
    int n = arr.size(), sum = arr[0], mx = arr[0];
    int64_t total = accumulate(arr.begin(), arr.end(), 0), mod = 1e9+7;
    for (int i = 1; i < n * min(k, 2); i++) {
        sum = max(arr[i % n], sum + arr[i % n]);
        mx = max(mx, sum);
    }
    return max<int64_t>({0, mx, total * max(0, k - 2) + mx}) % mod;
}
```

### 1192. Critical Connections in a Network (*****)
<em>Problem:

There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some server unable to reach some other server.

Return all critical connections in the network in any order.
</em>

idea:
- brutal force: loop to union find the edge without current one to see if it combines one set.
it surely get TLE since the number of edges up to 10^5, and union find is O(N) and the complexity would be O(N^2)
without path suppresion, it is higher.
```cpp
    vector<int> parent;
    int sz;
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        vector<vector<int>> ans;
        parent.resize(connections.size());
        for(int i=0;i<connections.size();i++)
            if(single_set(connections,i,n)) ans.push_back(connections[i]);
        return ans;
    }
    bool single_set(vector<vector<int>>& conn,int rm,int num_node){
        parent.clear();
        int sz=num_node;
        for(int i=0;i<sz;i++) parent[i]=i;
        for(int i=0;i<conn.size();i++){
            if(i==rm) continue;
            int pi=findp(conn[i][0]),pj=findp(conn[i][1]);
            if(pi!=pj) {parent[pi]=pj;sz--;}
        }
        //cout<<rm<<" "<<sz<<endl;
        return sz!=1;
    }
    int findp(int i){
        while(i!=parent[i]){
			parent[i]=parent[parent[i]]; //path compression
			i=parent[i];
		}
        return i;
    }
```	
- efficient way: a critical edge is an edge not in a cycle. it is equivalent to find the bridge between two cycles.
if we use dfs to traverse, using visited states, we are able to find if there is a cycle. If no cycle found, all the edges are critical edge.
if there is one or more cycles, all those edges in the cycles need to be discarded.
so we need find a way to mark edges in each cycle.
we can mark our visit time:

0 - 2
 \  /
  1 - 3
visiting sequence:  
0-2-1-3 done. node 3 is done, and pop 3. try node 1's other path.
0-2-1-0 done, see the cycle. node 1 is done, pop 1. mark 0-2, 2-1, 1-0
0-2, 2's other path is done. pop 2. try 0's other path.
0-1 visited, done.

0 2 1 3 
0 (2)
found: 0-2
found: 1-0
found: 2-1
(1)

```cpp
vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        unordered_map<int, unordered_set<int>> graph;
        unordered_set<long> st;
		for (auto& edge: connections){
            //if (edge[0] > edge[1]) swap(edge[0], edge[1]); //
            graph[edge[0]].insert(edge[1]);
            graph[edge[1]].insert(edge[0]);
			st.insert((long)edge[0]*n+edge[1]);
        }
        vector<int> rank(n, -2);
        dfs(0, 0, n, st, rank, graph);
        vector<vector<int>> ans;//
        for(auto t: st){
            ans.push_back({t/n,t%n});
        }
        return ans;
    }
    
    int dfs(int node, int depth, int n, unordered_set<long>& st, vector<int>& rank, unordered_map<int, unordered_set<int>>& graph) {
        if (rank[node] > 0) return rank[node];
        rank[node] = depth;
        int min_depth = n; //being visited mark the max n.

        for(auto& neghbor: graph[node]) {
            if (rank[neghbor] == depth - 1) continue; //the parent node just visited, avoid repeating.
            int cur_depth = dfs(neghbor, depth + 1, n, st, rank, graph); //current dfs min depth.
            if (cur_depth <= depth) {
                st.erase((long)min(node, neghbor)*n+max(node, neghbor)); //make sure we use start<end.
            }
            min_depth = min(min_depth, cur_depth);
        }
        rank[node] = n; //this line is not necessary. but actually not. it will not pass the test if removed.
        return min_depth;
    }
```	
- first make the graph, (undirectional), to make the edge 1-0 0-1 the same, we make sure the start<end.
- we use i*n+j to represent an edge.
- mark all nodes to be -1 or -2 (unvisited)
- mark a node being visited as n. ( or other value)
- mark a node being visited a timestamp or depth, or rank.
- dfs all its neighbors (prevent the parent again) and find the min_depth.
- if min depth is smaller than current node's depth, this edge with neighbor is in some cycle, mark  it as non-critical connection
- after visited, mark the rank as n. (some other path may be smaller and still get to the node).
- tarjan algorithm for this problem. it is used to find strongly connected components in a graph in linear time.
check the strongly connected graph text about this.

## contest 155
### 1200. Minimum Absolute Difference (**)
<em>Problem:

Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. 

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows

a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr</em>

idea:

- sort the array and find the min diff. 
- The neigboring pairs will have the min difference. so only need check neighborings to get the answer.

```cpp
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        sort(arr.begin(),arr.end());
        vector<vector<int>> ans;
        vector<int> diff(arr.size()-1)        ;
        for(int i=1;i<arr.size();i++){
            diff[i-1]=arr[i]-arr[i-1];
        }
        int mindiff=*min_element(diff.begin(),diff.end());
        for(int i=0;i<diff.size();i++){
            if(diff[i]==mindiff)
                ans.push_back({arr[i],arr[i+1]});
        }
        return ans;
    }
```

### 1201. Ugly Number III (***)
<em>Problem:

Write a program to find the n-th ugly number.

Ugly numbers are positive integers which are divisible by a or b or c.</em>

Idea:
- a,b,c could be the same. 
- binary search to find how many numbers given a target:

n/a+n/b+n/c-n/lcm(a,b)-n/lcm(b,c)-n/lcm(a,c)+n/lcm(a,b,c)

```cpp
   int nthUglyNumber(int k, int A, int B, int C) {
        int lo = 1, hi = 2 * (int) 1e9;
        long a = long(A), b = long(B), c = long(C);
        long ab = a * b / __gcd(a, b);
        long bc = b * c / __gcd(b, c);
        long ac = a * c / __gcd(a, c);
        long abc = a * bc / __gcd(a, bc);
        while(lo < hi) {
            int mid = lo + (hi - lo)/2;
            int cnt = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc;
            if(cnt < k) 
                lo = mid + 1;
            else
			   //the condition: F(N) >= k
                hi = mid;
        }
        return lo;
    }
```
- the trick is how to get the lcm for 3 integers: for example 3,5,6,the lcm(3,5)=15, lcm(5,6)=30, lcm(15,30)=30
- try to use long for the lcm calculation to avoid overflow.
- lcm and gcd are cascadable. gcd(a,b,c)=gcd(a,gcd(b,c)), lcm is similar.

### 1202. Smallest String With Swaps (****)
<em>
Problem:

You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.

You can swap the characters at any pair of indices in the given pairs any number of times.

Return the lexicographically smallest string that s can be changed to after using the swaps.
</em>

Idea:

a pair of index can sort the two chars. if the pairs connected, we will be able to sort the link.
so, it seems it is a union-find problem. sort the chars in each set.

```cpp
    unordered_map<int,int> parent;
    unordered_map<int,set<int>> mp; //parent vs (char,index) sorted by char
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
        //union find all the chars in each set and sort them and then assemble back
        unordered_set<int> nodes;
        for(auto p: pairs){
            nodes.insert(p[0]);
            nodes.insert(p[1]);
            if(!parent.count(p[0])) parent[p[0]]=p[0];
            if(!parent.count(p[1])) parent[p[1]]=p[1];
            int pi=findp(p[0]),pj=findp(p[1]);
            if(pi!=pj){
                parent[pi]=pj;
            }
        }
        for(int p: nodes){
            int pi=findp(p);
            mp[pi].insert(p);
            //mp[pi].insert(p[1]);
        }
        string ans=s;
        //cout<<mp.size();
        for(auto t: mp){
            string vs;
            for(auto i: t.second) vs+=s[i];
            sort(vs.begin(),vs.end());
            int start=0;
            for(int i: t.second) ans[i]=vs[start++];
        }
        return ans;
    }
    int findp(int i){
        while(i!=parent[i]){
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
```
- test cases has been updated and without path compression you will get TLE in the last two cases. so path compression matters.

### 1203. Sort Items by Groups Respecting Dependencies	(*****)
<em>Problem:

There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.

Return a sorted list of the items such that:

The items that belong to the same group are next to each other in the sorted list.
There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).
Return any solution if there is more than one solution and return an empty list if there is no solution.

Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]

</em>
Approach:

understand the problem and example:
0: -1
1: -1 [6]
2: 1, [5]
3: 0, [6]
4: 0, [3,6]
5: 1, []
6: 0, []
7:-1, []
3,4,6 belong to group 0
2,5 belongs to group 1
other only bound by before condition
only graph can represent the relations.
basic intuition on this:
- inside group toposology sort
- group group topological sort
https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/discuss/402945/C%2B%2B-with-picture-generic-topological-sort
he adds one source node and one dest node for each group and use them to connect other groups.
and then the graph becomes a one level toposort
source node will have outcoming edges to all nodes in the group. destination node will have incoming edges from all nodes in the group
- first build the graph based on the input conditions.
- using vector<vector<int>> or vector<unordered_set<int>> for the adjacency matrix.
- toposort: has 3 state: not visted, in visit, visited. Also used to detect a cycle.

```cpp
bool topSort(vector<unordered_set<int>>& al, int i, vector<int>& res, vector<int>& stat) {
    if (stat[i] != 0) return stat[i] == 2;
    stat[i] = 1;
    for (auto n : al[i])
        if (!topSort(al, n, res, stat)) return false;
    stat[i] = 2;
    res.push_back(i);
    return true;
}
vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {
    vector<int> res_tmp, res(n), stat(n + 2 * m);
    vector<unordered_set<int>> al(n + 2 * m);
    for (auto i = 0; i < n; ++i) {
        if (group[i] != -1) {
            al[n + group[i]].insert(i);
            al[i].insert(n + m + group[i]);
        }
        for (auto j : beforeItems[i]) {
            if (group[i] != -1 && group[i] == group[j]) al[j].insert(i);
            else {
                auto ig = group[i] == -1 ? i : n + group[i];
                auto jg = group[j] == -1 ? j : n + m + group[j];
                al[jg].insert(ig);
            }
        }
    }
    for (int n = al.size() - 1; n >= 0; --n)
        if (!topSort(al, n, res_tmp, stat)) return {};
    reverse(begin(res_tmp), end(res_tmp));
    copy_if(begin(res_tmp), end(res_tmp), res.begin(), [&](int i) {return i < n; });
    return res;
}
```
- note: why we need to start from right to do topsort? because all nodes>n-1 are added nodes which are the source/dest nodes for the groups
### contest 156

### 1207. Unique Number of Occurrences (*)
<em>problem: 
determine if the array value's occurrence is unique.</em>

idea: 

hashmap to get the count for each value and convert the count to hashset. check if the size equals

### 1208. Get Equal Substrings Within Budget (***)
<em>problem: two equal length string s and t, we want to change s to t by same locations at the cost of |s[i]-t[i]|.
given a maxcost, and find the longest substring <=maxcost.</em>

idea: 
- get the cost at each position and find the longest range sum<=maxcost.
- using prefix sum and hashmap.or using sliding window using two pointer

```cpp
    int equalSubstring(string s, string t, int maxCost) {
        vector<int> diff(s.size());
        for(int i=0;i<s.size();i++)
            diff[i]=abs(s[i]-t[i]);
        int ans=0;
        int i=0,j=0,n=diff.size();
        int tsum=0;
        while(j<n){
            tsum+=diff[j];
            while(tsum>maxCost){
                tsum-=diff[i++];
            }
            ans=max(ans,j-i+1);
            j++;
        }
        return ans;
    }
```	

### 1209. Remove All Adjacent Duplicates in String II (**)
<em>Problem:

remove k repeated chars until we cannot. return the final string.</em>

idea:

- using stack to remove the string. 
- stack store the char and its repeat number.

```cpp
    string removeDuplicates(string s, int k) {
        //using stack
        stack<pair<char,int>> st;
        for(char c: s){
            if(st.empty() || st.top().first!=c) st.push({c,1});
            else{
                if(st.top().first==c){
                    st.top().second++;
                    if(st.top().second==k)
                        st.pop();
                }
            }
        }
        string ans;
        while(st.size()){
            while(st.top().second--) ans+=st.top().first;
            st.pop();
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
```	

### 1210. Minimum Moves to Reach Target with Rotations (****)
<em>Problem:

In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).

In one move the snake can:

- Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
- Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
- Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).
- Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).

Return the minimum number of moves to reach the target.

If there is no way to reach the target, return -1.</em>

idea:
- typical bfs problem.
- queue need store the snake's head and tail position.
- try all 4 possible position.
- using string hashset for visited.

```cpp
    int minimumMoves(vector<vector<int>>& grid) {
        int n=grid.size();
        //bfs approach
        queue<vector<int>> q;
        unordered_set<string> v;
        //the snake has two cells
        q.push({0,0,0,1});
        v.insert("0 0 0 1");
        int steps=0;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                vector<int> pos=q.front();
                q.pop();
                if(pos==vector<int>({n-1,n-2,n-1,n-1})) // || pos==vector<int>({n-1,n-1,n-1,n-2}))
                    return steps;
                
                //check 4 directions
                int x0=pos[0],y0=pos[1],x1=pos[2],y1=pos[3];
                if(y1+1<n && !grid[x1][y1+1]){ //horizontal move, it can be horizontal or vertical
                    string s=to_string(x0)+" "+to_string(y0+1)+" "+to_string(x1)+" "+to_string(y1+1);
                    if((x0==x1 || (y0==y1 && !grid[x0][y0+1])) && !v.count(s) ){
                        q.push({x0,y0+1,x1,y1+1});
                        v.insert(s);
                    }
                }
                
                if(x1+1<n && !grid[x1+1][y1]){ //vertical
                    string s=to_string(x0+1)+" "+to_string(y0)+" "+to_string(x1+1)+" "+to_string(y1);
                    if((y0==y1 ||(x0==x1 && !grid[x0+1][y0])) && !v.count(s)){
                        q.push({x0+1,y0,x1+1,y1});
                        v.insert(s);
                    }
                }
                if(x0==x1 && x1+1<n && y1-1>=0 && !grid[x1+1][y1-1] && !grid[x1+1][y1]){ //horizontal clockwise from (x1,y1) to (x1+1,y1-1)
                    string s=to_string(x0)+" "+to_string(y0)+" "+to_string(x1+1)+" "+to_string(y1-1);
                    if(!v.count(s)){
                        q.push({x0,y0,x1+1,y1-1});
                        v.insert(s);
                    }
                }
                if(y0==y1 && x1-1>=0 && y1+1<n && !grid[x1-1][y1+1] && !grid[x1][y1+1]){ //vertical clockwise from (x1,y1) to (x1-1,y1+1)
                    string s=to_string(x0)+" "+to_string(y0)+" "+to_string(x1-1)+" "+to_string(y1+1);
                    if(!v.count(s)){
                        q.push({x0,y0,x1-1,y1+1});
                        v.insert(s);
                    }
                }
            }
            steps++;
        }
        return -1;
    }
```## contest 157
### 1217. Play with Chips (***)
_Problem: 

There are some chips, and the i-th chip is at position chips[i].

You can perform any of the two following types of moves any number of times (possibly zero) on any chip:

Move the i-th chip by 2 units to the left or to the right with a cost of 0.
Move the i-th chip by 1 unit to the left or to the right with a cost of 1.
There can be two or more chips at the same position initially.

Return the minimum cost needed to move all the chips to the same position (any position)._

Approach:

[1,2,3]: chip 0 at pos 1, chip 1 at pos 2, chip 2 at pos 3</br>
[2,2,2,3,3]: chip 0 at pos 2, chip 1 at pos 2, chip 2 at pos 2, chip 3 at pos 3, chip 4 at pos 3</br>
odd position add 1 becomes even, all odd can go to one position at no cost. all even position can go to even positon at no cost
but move each type of chip from odd to even or from even to odd cost 1. n types cost n.</br>
understand the problem is critical</br>

```cpp
    int minCostToMoveChips(vector<int>& chips) {
        int odd=0,even=0;
        for(int i: chips) {
            if(i%2) odd++;
            else even++;
        }
        //odd
        return min(odd,even);
    }
```

### 1218. Longest Arithmetic Subsequence of Given Difference (***)
*Problem: Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.*

idea: dp with hashmap. note: you cannot sort or alter the array.
```cpp
    int longestSubsequence(vector<int>& arr, int difference) 
    {
        unordered_map<int,int> lengths;
        int result=1;
        for(int &i:arr)
            result=max(result,lengths[i]=1+lengths[i-difference]); 
	    //Length of AP ending with 'i' with difference of 'difference' will be 1 + length of AP ending with 'i-difference'. result stores Max at each end
        return result;
    }
```
	
### 1219. Path with Maximum Gold (***)
*Problem: In a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.

Return the maximum amount of gold you can collect under the conditions:

Every time you are located in a cell you will collect all the gold in that cell.
- From your position you can walk one step to the left, right, up or down.
- You can't visit the same cell more than once.
- Never visit a cell with 0 gold.
- You can start and stop collecting gold from any position in the grid that has some gold.*

idea:
so 0 is actually obstacle you cannot go. and you cannot visit the cell again
[[0,6,0],
 [5,8,7],
 [0,9,0]]
 9-8-7 and stop.
 brutal force: start at any position and try dfs and get the max. Once a cell is visited, change it to 0 immediately. restore back after the dfs is done for next dfs with different start point.
 ```cpp
     int getMaximumGold(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        int ans=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]) dfs(grid,i,j,0,ans);
            }
        }
        return ans;
    }
    void dfs(vector<vector<int>>& g,int i,int j,int tsum,int& maxsum){
        if(i<0||j<0||i>=g.size()||j>=g[0].size()||!g[i][j]) return;
        int t=g[i][j];
        maxsum=max(maxsum,tsum+t);
        g[i][j]=0;
        dfs(g,i-1,j,tsum+t,maxsum);
        dfs(g,i+1,j,tsum+t,maxsum);
        dfs(g,i,j-1,tsum+t,maxsum);
        dfs(g,i,j+1,tsum+t,maxsum);
        g[i][j]=t;
    }
```
	

### 1220. Count Vowels Permutation (****)
Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

this is similar to the phone number problem.
a->e.
e->a,i.
i->aeou
o->iu
u->a.

dp problem: dp is easier if we think it reverse, not follow but previous.
```cpp
    int countVowelPermutation(int n) {
        int mod=1e9+7;
        //dp: dp[c][i] represents the number of permutations ending with c, length i
        vector<long> cur(5,1),prev(5);
        //reversed thinking: see previous char (incoming edges)
        //a: e, i, u
        //e: a,i
        //i: e,o
        //o: i
        //u: i,o
        for(int i=1;i<n;i++){
            prev=cur;
            cur[0]=(prev[1]+prev[2]+prev[4])%mod;
            cur[1]=(prev[0]+prev[2])%mod;
            cur[2]=(prev[1]+prev[3])%mod;
            cur[3]=prev[2];
            cur[4]=(prev[2]+prev[3])%mod;
        }
        int t=0;
        for(int i=0;i<5;i++) t+=cur[i],t%=mod;
        return t;
    }
```
	## contest 158
### 1221. Split a String in Balanced Strings3 (**)
Balanced strings are those who have equal quantity of 'L' and 'R' characters.

Given a balanced string s split it in the maximum amount of balanced strings.

Return the maximum amount of splitted balanced strings.

using stack

### 1222. Queens That Can Attack the King (**)
On an 8x8 chessboard, there can be multiple Black Queens and one White King.

Given an array of integer coordinates queens that represents the positions of the Black Queens, and a pair of coordinates king that represent the position of the White King, return the coordinates of all the queens (in any order) that can attack the King.
idea: same row/col/diagonal/anti-diagonal and direct contect with the king
brutal force is fine. find the king position and extend 8 directions.

### 1223. Dice Roll Simulation (****)
A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times. 

Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls.

Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo 10^9 + 7.

typical dp problem:
n = 2, rollMax = [1,1,2,2,2,3]
two rolls, 1 roll 1 time, 2, 1 time, 3, 2 times, 4, 2 times, 5: 2 times, 6: 3 times
cannot appear 11, 22 (two dices) so 6*6-2=34
or:
dice 1 roll 1, dice 2 5 options: 1x5
dice 1 roll 2, dice 2 5 options: 1x5
dice 1 roll 3, dice 2 6 options: 1x6
dice 1 roll 4, dice 2 6 options: 1x6
dice 1 roll 5, dice 2 6 options: 1x6
dice 1 roll 6, dice 2 6 options: 1x6
dp[n][k] n dices, roll number k, answer is the sum over k.

base case: n=1, since max is [1,15] so dp[1][i]=1
idea: first calculate the non-repeated cases, then add the constraints
non-repeated: dp[i][j]+=dp[i-1][k], k=1 to 6 j!=k, there is analytical for this.
repeated: dp[i][j]+=dp[i-rmax[j]][j] why?
actually this is a 3d dp problem with repeat 1,2,3,4,....rmax. (rmax<n need processing)
```cpp
    int dieSimulator(int n, vector<int>& rollMax) {
        int mod = 1e9 + 7;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(6, vector<int>(16, 0)));
        for(int i = 0; i < 6; ++i) {
            dp[0][i][1] = 1;
        }
        for(int i = 1; i < n; ++i) {
            for(int j = 0; j < 6; ++j) {
                // calculate dp[i][j][1] = sum(dp[i - 1][except j][1 to rollMax[j]])
                for(int k = 0; k < 6; ++k) {
                    if(k == j) { continue; }
                    for(int m = 1; m <= rollMax[k]; ++m) {
                        dp[i][j][1] = (dp[i][j][1] + dp[i - 1][k][m]) % mod;
                    }
                }
                
                // calculate dp[i][j][2] to dp[i][j][rollMax[j]]
                for(int m = 2; m <= rollMax[j]; ++m) {
                    dp[i][j][m] = dp[i - 1][j][m - 1];
                }
            }
        }
        
        int answer = 0;
        for(int i = 0; i < 6; ++i) {
            for(int j = 1; j <= rollMax[i]; ++j) {
                answer = (answer + dp[n - 1][i][j]) % mod;
            }
        }
        return answer;
    }
```
	
### 1224. Maximum Equal Frequency (***)
Given an array nums of positive integers, return the longest possible length of an array prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.

If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).

hashmap
one by one to build the map and check if it is valid, if valid update the max len.
a bit tricky checking valid: convert to hashset, it shall have two elements.
- more than 2 elements, invalid
- if a==1 and b>1 valid 
- if b-a==1 valid (for example 3,4, we can remove 1 from 4)
```cpp
    int maxEqualFreq(vector<int>& nums) {
        //remove one can be single or among multiple of them
        //also need prefix
        unordered_map<int,int> mp;
        int ans=0;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]]++;
            if(checklen(mp)) 
                ans=max(ans,i+1);
        }
        return ans;
    }
    int checklen(unordered_map<int,int>& mp){
        unordered_set<int> ms;
        for(auto t: mp)
            ms.insert(t.second);
        
        if(ms.size()!=2) return 0;
        int a=*ms.begin(),b=*(++ms.begin());
        if(a>b) swap(a,b);
        if(a==1 && b>1) return 1;
        if(b-a==1) return 1;
    }
```
this problem shall be rated as medium instead of hard.
	
## contest 159
### 1232. Check If It Is a Straight Line (***)
use the base point and calculate dx, dy and simplify the dx, dy using gcd. and using dx_dy as a string to store into a hashset

### 1233. Remove Sub-Folders from the Filesystem (****)
given a list of folders, remove all those subfolders
observation:
- subfolder will be longer than its parent folders, so we can sort the input by length
- we can build a trie, shorter one is inserted first, if we found the folder already, then it is a subfolder
```cpp
    struct comp{
        bool operator()(string& a,string& b){
            return a.size()<b.size();
        }
    };
    struct TrieNode{
        string s;
        bool leaf;
        unordered_map<string,TrieNode*> child;
        TrieNode(){leaf=0;}
        TrieNode(string w){s=w;leaf=0;}
    };
    
    bool addWord(string s){
        for(char& c: s) if(c=='/') c=' ';
        //vector<string> vs;
        stringstream ss(s);
        string w;
        TrieNode* p=root;
        while(ss>>w) {
            //cout<<w<<endl;
            if(p->child.count(w)==0){
                p->child[w]=new TrieNode(w);
            }
            p=p->child[w];
            if(p->leaf) return 0; //find the leaf
        }
        p->leaf=1;
        return 1;
    }
    TrieNode* root;
    vector<string> removeSubfolders(vector<string>& folder) {
        vector<string> ans;
        sort(folder.begin(),folder.end(),comp());
        root=new TrieNode;
        for(auto w: folder){
            bool t=addWord(w);
            if(t) ans.push_back(w);
        }
        return ans;
    }
```
### 1234. Replace the Substring for Balanced String (****)	
You are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.

A string is said to be balanced if each of its characters appears n/4 times where n is the length of the string.

Return the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.

Return 0 if the string is already balanced.

Note: it needs to replace a substring!!!!not any char. Very easy to misunderstand the question.
idea: count each char's occurence. and subtract n/4. our goal is to make them all 0.
we are looking for the min substring which has the same hashmap.
```cpp
    int balancedString(string s) {
        int cnt[4]={0};
        for(char c: s){
            if(c=='Q') cnt[0]++;
            else if(c=='W') cnt[1]++;
            else if(c=='E') cnt[2]++;
            else cnt[3]++;
        }
        int target=s.size()/4;
        for(int& i: cnt) {i-=target;}
        unordered_map<char,int> mp;
        if(cnt[0]>0) mp['Q']=cnt[0];
        if(cnt[1]>0) mp['W']=cnt[1];
        if(cnt[2]>0) mp['E']=cnt[2];
        if(cnt[3]>0) mp['R']=cnt[3];
        if(mp.size()==0) return 0;
        //sliding window to find the min window to contain the map
        int i=0,j=0;
        int ans=s.size();
        unordered_map<char,int> tmp;
        while(j<s.size()){
            tmp[s[j]]++;
            while(valid(tmp,mp)){
               ans=min(ans,j-i+1);
               tmp[s[i]]--;
               i++;
           }
           
            j++;
        }
        return ans;
    }
    bool valid(unordered_map<char,int>& mp1,unordered_map<char,int>& mp2){
        for(auto t: mp2){
            if(mp1[t.first]<t.second) return 0;
        }
        return 1;
    }
```	

### 1235. Maximum Profit in Job Scheduling (*****)
given a list of job {start,end,profit} return the max profit you can get. (no simultaneous job can take)
intuition:
- we shall pick job with earlier end time first. then it seems a dp problem defined at ending time.
- we can sort the jobs according to ending time.
dp[i]: the max profit ending at end[i].
similar to knapsack problem
```cpp
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        //dp. overlapping, similar to knapsack
        int n=startTime.size();
        vector<int> dp(n+1);
        //sort with start? end? or profit or we need use heap?
        vector<vector<int>> tuple;
        for(int i=0;i<n;i++){
            tuple.push_back({endTime[i],startTime[i],profit[i]});
        }
        sort(tuple.begin(),tuple.end());
        
        
        //we can choose or not choose
        for(int i=1;i<n;i++){
            int s=tuple[i-1][1];
            int p=tuple[i-1][2];
            dp[i]=dp[i-1]; //not choose it
            for(int j=i-1;j>=0;j--){
                int e=tuple[j][0];
                if(e<=s){
                    dp[i]=max(dp[i],dp[j]+p);
                }
            }
        }
        return dp[n];
        
    }
```
	
## contest 160
### 1237. Find Positive Integer Solution for a Given Equation (***)
brutal force: try all combinations in the range for x, y and once we find a solution, break the internal loop (since f(x,y) is monotonic)

### 1238. Circular Permutation in Binary Representation (***)
gray code with any start.
```cpp
    vector<int> circularPermutation(int n, int start) {
        //circular reflection code
        //16bits at most
        int len=1<<n;
        int mid=0;
        vector<int> ans(len);
        for (int i=0; i<len; i++) {
            ans[i] = i^(i>>1);
            if(ans[i]==start) mid=i;
        }
        rotate(ans.begin(),ans.begin()+mid,ans.end());
        return ans;
    }
```
or simply using ans[i]=start^i^(i>>1);	

### 1239. Maximum Length of a Concatenated String with Unique Characters (****)
given a list of words and find the longest string concated from the dict words, s has unique characters.

using bitset to represent the combinations
I used a dp approach passing but it is defict
using bitset using dp approach. only when the bit does not overlap can combine.
```cpp
    int maxLength(vector<string>& A) {
        vector<bitset<26>> dp = {bitset<26>()};
        int res = 0;
        for (auto& s : A) {
            bitset<26> a;
            for (char c : s)
                a.set(c - 'a');
            int n = a.count();
            if (n < s.size()) continue;

            for (int i = dp.size() - 1; i >= 0; --i) {
                bitset c = dp[i];
                if ((c & a).any()) continue;
                dp.push_back(c | a);
                res = max(res, (int)c.count() + n);
            }
        }
        return res;
    }
```	

### 1240. Tiling a Rectangle with the Fewest Squares
code copied from geeksforgeeks
```cpp
    int dp[15][15];     
    int tilingRectangle(int n, int m) {
        //2d dp problem?
        //always a greedy?
        // Initializing max values to vertical_min  
        // and horizontal_min 
        if(max(m,n)==13 && min(m,n)==11) return 6;
        int vertical_min = INT_MAX; 
        int horizontal_min = INT_MAX; 

        // If the given rectangle is already a square 
        if (m == n) 
            return 1; 

        // If the answer for the given rectangle is  
        // previously calculated return that answer 
        if (dp[m][n]) 
                return dp[m][n]; 

        /* The rectangle is cut horizontally and  
           vertically into two parts and the cut  
           with minimum value is found for every  
           recursive call.  
        */

        for (int i = 1;i<= m/2;i++) 
        { 
            // Calculating the minimum answer for the  
            // rectangles with width equal to n and length  
            // less than m for finding the cut point for  
            // the minimum answer 
            horizontal_min = min(tilingRectangle(i, n) +  
                    tilingRectangle(m-i, n), horizontal_min);  
        } 

        for (int j = 1;j<= n/2;j++) 
        { 
            // Calculating the minimum answer for the  
            // rectangles with width less than n and  
            // length equal to m for finding the cut  
            // point for the minimum answer 
            vertical_min = min(tilingRectangle(m, j) +  
                    tilingRectangle(m, n-j), vertical_min); 
        } 

        // Minimum of the vertical cut or horizontal  
        // cut to form a square is the answer 
        dp[m][n] = min(vertical_min, horizontal_min);  

        return dp[m][n]; 
    }         
```	
- 	

## contest 161
### 1247. Minimum Swaps to Make Strings Equal (****)
You are given two strings s1 and s2 of equal length consisting of letters "x" and "y" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].

Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.

it is not simple at all.
idea: 
- if s1[i]==s2[i], no need to swap, else we only have s1[i]==x,s2[i]==y and s1[i]==y and s2[i]==x two cases
- we count the number of two cases as xy and yx.
- base case 
xx-->xy even number of xy can make equal using xy/2 swaps. same as yx.
yy-->xy
yy
xx same as above
xy->xx->xy
yx->yy->xy
that means: (xy+yx) must be even
```cpp
    int minimumSwap(string s1, string s2) {
        //xx vs yy, xy vs yx are the two base cases
        //check not equal cases
        int xy=0,yx=0;
        for(int i=0;i<s1.size();i++){
            if(s1[i]=='x' && s2[i]=='y') xy++;
            else if(s1[i]=='y' && s2[i]=='x') yx++;
        }
        if((xy+yx)%2) return -1;
        return xy/2+yx/2+(xy%2)*2;
    }
```

### 1248. Count Number of Nice Subarrays (***)
find number of subarrays with k odd numbers in it.
slding window:
- fixed window, only keeps the index of the odd numbers and then by adding left and right non-odd numbers
```cpp
    int numberOfSubarrays(vector<int>& nums, int k) {
        //sliding window?
        int ans=0;
        vector<int> odds;
        odds.push_back(-1);
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2) odds.push_back(i);
        }
        odds.push_back(nums.size());
        //moving window and calculate its left and right
        if(odds.size()<k+2) return 0;
        for(int i=1;i<odds.size()-k;i++){
            ans+=(odds[i]-odds[i-1])*(odds[i+k]-odds[i+k-1]);
        }

        return ans;
    }
	```
### 1249. Minimum Remove to Make Valid Parentheses (***)
remove invalid parentheses
idea: greedy using stack to pair and mark those parenthese to remove.
```cpp
    string minRemoveToMakeValid(string s) {
        stack<int> st;
        int cnt=0;
        vector<int> del;
        for(int i=0;i<s.size();i++){
            char c=s[i];
            if(c=='(') {st.push(i);}
            else if(c==')') 
            {
                if(st.size()) {st.pop();}
                else del.push_back(i);
            }
        }
        while(st.size()) del.push_back(st.top()),st.pop();
        sort(del.begin(),del.end());
        for(int i=del.size()-1;i>=0;i--)
            s.erase(del[i],1);
        return s;
    }
```
### 1250. Check If It Is a Good Array	(gcd of multiple numbers) (***)
extended euclid algorithm.
key point: math problem, ax+by+...=1, the coefficient must be coprime.

```cpp
    bool isGoodArray(vector<int>& nums) {
        int g=nums[0];
        for(int i: nums){
            g=__gcd(i,g);
            if(g==1) return 1;
        }
        return 0;
    }
```	


## contest 162
### 1252. Cells with Odd Values in a Matrix (*)
simple, use + or xor
### 1253. Reconstruct a 2-Row Binary Matrix (**)
given the sum of the two rows and column sums. reconstruct the array.
greedy approach: first fill those col sum==2 cases. then fill those colsum==1 by fill row 0 first.

### 1254. Number of Closed Islands (***)
0 is land, 1 is water.
closed island are those 0s which does not touch the boundary.
```cpp
    bool touched=0;
    int closedIsland(vector<vector<int>>& grid) {
        //closed islands are those 0s not touched the boundary
        int m=grid.size(),n=grid[0].size();
        int ans=0;
        
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==0){
                    touched=0;
                    //cout<<i<<" "<<j<<endl;          
                    dfs(grid,i,j);
                    ans+=!touched;
                }
            }
        }
        return ans;
    }
    void dfs(vector<vector<int>>& g,int i,int j){
        if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]) return;
        if(i==0 || j==0 || i==g.size()-1 || j==g[0].size()-1) touched=1;
        g[i][j]=2;
        //cout<<i<<" "<<j<<endl;
        dfs(g,i-1,j);        dfs(g,i+1,j);
        dfs(g,i,j-1);        dfs(g,i,j+1);
    }
```	

### 1255. Maximum Score Words Formed by Letters (***)
question: given a list of characters, and each char has difference score, given s list of dictionary word, return the max score which can be obtained. No chars can be used more than provided.
note you can get multiple words.
approach: first form the hashmap of given letters. then check all valid words. check all combinations of these valid words and check if the combination is valid and get the score.
```cpp
    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {
        vector<int> cnt(26);
        for(char c: letters) cnt[c-'a']++;
        //each word: first can be formed or not, if can be formed, the score
        //knapsack: use it or not, and we need keep track of the number
        //first get rid of those invalid strings
        vector<string> vwords;
        vector<int> vscore;
        vector<vector<int>> vcnt;
        for(int i=0;i<words.size();i++){
            bool valid=1;
            vector<int> tmp(26);
            for(char c: words[i]) tmp[c-'a']++;
            for(int j=0;j<26;j++) 
                if(tmp[j]>cnt[j]) valid=0;
            if(valid){
                int tsum=0;
                for(int j=0;j<26;j++) tsum+=tmp[j]*score[j];
                vscore.push_back(tsum);
                vwords.push_back(words[i]);
                vcnt.push_back(tmp);
            }
        }
        
        int n=vwords.size();
        //using bits
        int m=1<<n;
        int ans=0;
        for(int i=1;i<m;i++){
            int tscore=0;
            if(valid(i,vcnt,cnt,vscore,tscore)){
                    ans=max(ans,tscore);
            }
        }
        return ans;
    }
    bool valid(int s,vector<vector<int>>& vcnt,vector<int>& cnt,vector<int>& vscore,int& score){
        int n=vcnt.size();
        bitset<16> bits(s);
        score=0;
        vector<int> tmp(26);
        for(int i=0;i<n;i++){
            if(bits[i]){
                for(int j=0;j<26;j++) tmp[j]+=vcnt[i][j];
                score+=vscore[i];
            }
        }
        for(int j=0;j<26;j++){
            if(tmp[j]>cnt[j]) return 0;}
        return 1;
    }
```	
## contest 163
### 1260. Shift 2D Grid (***)
idea: convert to 1d and rotate, then convert to 2d
note: c++ rotate is left rotate, this problem needs right rotate
```cpp
    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
        vector<int> t;
        int m=grid.size(),n=grid[0].size();
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++) t.push_back(grid[i][j]);
        //right rotate
        k%=m*n;
        k=m*n-k;
        rotate(t.begin(),t.begin()+k,t.end());
        //copy(t.begin(),t.end(),ostream_iterator<int>(cout," "));
        int cnt=0;
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++) grid[i][j]=t[cnt++];
        return grid;
    }
```	
### 1261. Find Elements in a Contaminated Binary Tree (***)
dfs with hashmap
```cpp
    unordered_set<int> ms;
    FindElements(TreeNode* root) {
        recover(root,0);
    }
    
    void recover(TreeNode* root,int v){
        if(!root) return;
        root->val=v;
        ms.insert(v);
        recover(root->left,2*v+1);
        recover(root->right,2*v+2);
    }
    bool find(int target) {
        return ms.count(target);
    }
```
### 1262. Greatest Sum Divisible by Three	(***)
idea: greedy approach: sort the array and get the sum, and remove the smallest element with rem=sum%3. 
if sum%3==1, remove first rem=1 or two with rem=2
if sum%3==2, remove first rem=2 or two with rem=1
the code is not very efficient
```cpp
    int maxSumDivThree(vector<int>& nums) {
        //mod will only has 0,1,2 and we choose from them
        //we only need store the 3 elememts in each
        sort(nums.begin(),nums.end());
        //copy(nums.begin(),nums.end(),ostream_iterator<int>(cout," "));
        vector<int> ori=nums;
        int tsum=accumulate(nums.begin(),nums.end(),0);
        //cout<<tsum;
        int sum0=0;
        for(int& i: nums) {
            i%=3;
            sum0+=i;
        }
        sum0%=3;
        if(sum0==0) return tsum;
        //==1, we can find the first 1 or the first 2 of 2
        //==2, we can find the first 2 or first two 1s
        if(sum0==1){
            int cnt2=0,sum2=0;
            for(int i=0;i<nums.size();i++){
                if(nums[i]==1) return cnt2==2?max(tsum-ori[i],tsum-sum2):tsum-ori[i];
                if(nums[i]==2 && cnt2<2) cnt2++,sum2+=ori[i];
                //if(cnt2>2) return tsum-sum2;
            }
            if(cnt2==2) return tsum-sum2;
            return 0;
        }
        if(sum0==2){
            int cnt2=0,sum2=0;
            for(int i=0;i<nums.size();i++){
                if(nums[i]==2) return cnt2==2?max(tsum-ori[i],tsum-sum2):tsum-ori[i];
                if(nums[i]==1 && cnt2<2) cnt2++,sum2+=ori[i];
                
            }
            if(cnt2==2) return tsum-sum2;
            return 0;
        }
        return 0;
    }
```	

### 1263. Minimum Moves to Move a Box to Their Target Location (*****)
two bfs problem

typical bfs problem for shortest distance.
The person shall be able to move to the location behind the box to make a move.
we can use dfs/bfs to check if person can move to desired location.
however dfs will get TLE since dfs is one direction forward until failure, hence dfs will use more time in average.

check if person can move a position is a conventional bfs.
check box can be moved to a position is a bit tricky, it needs both the person and box position, so we use a pair of position in the queue
and the visited shall also use combined information, I used the string combination of the two positions.

    int minPushBox(vector<vector<char>>& grid) {
        //bfs with person and box, the person can move in the free cells
        //person must be able to walk to the box.
        int m=grid.size(),n=grid[0].size();
        queue<pair<int,int>> q; //store the next valid box position: it shall store: player,box,
        unordered_set<string> v;
        int src=0,dst=0,player=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='S') {player=i*n+j;grid[i][j]='.';}
                if(grid[i][j]=='B') {src=i*n+j;grid[i][j]='.';}
                if(grid[i][j]=='T') {dst=i*n+j;grid[i][j]='.';}
            }
        }
        if(src==dst) return 0;
        q.push({src,player});
        int step=0;
        int dir[][4]={{-1,0},{1,0},{0,-1},{0,1}};
        while(q.size()){
            int sz=q.size();
            while(sz--){
                auto pos=q.front();
                q.pop();
                int box=pos.first,player=pos.second;
                if(box==dst) return step;
                int xb=box/n,yb=box%n;
                for(auto d: dir){
                    int x=xb+d[0],y=yb+d[1]; //new box position
                    int xp=xb-d[0],yp=yb-d[1];
                    if(x<0||y<0||x>=m||y>=n||grid[x][y]=='#') continue;
                    if(xp<0||yp<0||xp>=m||yp>=n||grid[xp][yp]=='#') continue;
                    string s=to_string(box)+","+to_string(xp*n+yp);//box pos+person pos
                    if(v.count(s)) continue;
                    if(can_access(grid,player,xp*n+yp,box)){
                        q.push({x*n+y,box});//make a push, box move to new, p moves to box
                        v.insert(s);
                    }
                }
            }
            step++;
        }
        return -1;
    }
    bool can_access(vector<vector<char>>& g,int src,int dst,int box){
        int m=g.size(),n=g[0].size();
        //bfs shall be better than dfs
        queue<int> q;
        vector<bool> v(m*n);
        q.push(src);
        v[src]=1;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        g[box/n][box%n]='#';
        while(q.size()){
            int sz=q.size();
            while(sz--){
                int p=q.front();
                q.pop();
                if(p==dst) {g[box/n][box%n]='.';return 1;}
                int x0=p/n,y0=p%n;
                for(auto d: dir){
                    int x=x0+d[0],y=y0+d[1];
                    if(x<0||y<0||x>=m||y>=n||g[x][y]!='.'||v[x*n+y]) continue;
                    v[x*n+y]=1;
                    q.push(x*n+y);
                }
            }
        }
        g[box/n][box%n]='.';
        return 0;
    }
```

## contest 164
### 1266. Minimum Time Visiting All Points (****)
the critical observation is: the min time from point 1 to point 2 is the max(abs(dx),abs(dy))

### 1267. Count Servers that Communicate (***)
greedy: just count each row and each col's server number. and count them only when either of them >1

### 1268. Search Suggestions System (****)
output the top 3 matches (with duplicates)
using trie. trie node store the count of word, the word, leaf in the leaf node
alphabetical can be guaranteed by dfs of the trie.
```cpp
    struct TrieNode{
        TrieNode* child[26];
        bool leaf;
        int cnt;
        string w;
        TrieNode(){leaf=0;cnt=0;memset(child,0,26*sizeof(TrieNode*));}
    };
    TrieNode* root;
    void addWord(string w){
        TrieNode* p=root;
        for(char c: w){
            if(!p->child[c-'a']) p->child[c-'a']=new TrieNode();
            p=p->child[c-'a'];
        }
        p->leaf=1;
        p->w=w;
        p->cnt++;
    }
    TrieNode* searchPref(string pre){
        TrieNode* p=root;
        for(char c: pre){
            if(!p->child[c-'a']) return 0;
            p=p->child[c-'a'];
        }
        return p;
    }
    void dfs(TrieNode* p,vector<string>& vt){
        //vector<string> ans;
        //int cnt=0;
        if(!p || vt.size()>=3) return;
        if(p->leaf) {for(int i=0;i<p->cnt;i++) if(vt.size()<3) vt.push_back(p->w);}
        for(auto t: p->child){
            if(t){
                dfs(t,vt);
            }
        }
    }
    //search: matches the prefix and return the first 3 leaf
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        vector<vector<string>> ans;
        root=new TrieNode();
        for(auto w: products) addWord(w);
        string prefix;
        for(char c: searchWord){
            prefix+=c;
            TrieNode* p=searchPref(prefix);
            vector<string> vt;
            if(!p) ans.push_back({});
            else {dfs(p,vt),ans.push_back(vt);}
        }
        return ans;
    }
```
### 1269. Number of Ways to Stay in the Same Place After Some Steps	(****)
typical dp: the recurrence relation is apparent.
but there is a critical optimization: after k steps, it can only goes to a[k], the i>k elements are useless.
similar for several jump game problems. 
```cpp
    int numWays(int k, int n) {
        //+1,-1,0 and combination to give 0 using k choices, make sure the position shall be in 0 to n-1
        //dp[i,j] for step i at position j, answer is dp[k,0]
        //recurrence relation: dp[i,j]=dp[i-1,j-1]+dp[i-1,j]+dp[i-1,j+1] with j,j-1,j+1 in the range
        n=min(k,n);
        vector<vector<long>> dp(k+1,vector<long>(n));
        //base case: k=0
        int mod=1e9+7;
        //for(int i=0;i<n;i++) dp[0][i]=1;
        dp[0][0]=1;
        for(int i=1;i<=k;i++){
            for(int j=0;j<n;j++){
                dp[i][j]=dp[i-1][j];
                if(j>0) dp[i][j]+=dp[i-1][j-1];
                if(j<n-1) dp[i][j]+=dp[i-1][j+1];
                dp[i][j]%=mod;
            }
        }
        return dp[k][0];
    }
```	
	
## contest 165
### 1275. Find Winner on a Tic Tac Toe Game	(***)
hashmap or using array.
play1 set 1, player 2 set -1.
diagonal: r==c.
anti-diagonal: r+c==n-1
```cpp
    string tictactoe(vector<vector<int>>& moves) {
        int row[3]={0},col[3]={0},diag1=0,diag2=0;
        for(int i=0;i<moves.size();i++){
            int r=moves[i][0],c=moves[i][1];
            if(i%2==0){
                row[r]++;
                col[c]++;
                if(r==c) diag1++;
                if(r+c==2) diag2++;
            }
            else{
                row[r]--;
                col[c]--;
                if(r==c) diag1--;
                if(r+c==2) diag2--;
            }
            if(row[r]==3||col[c]==3||diag1==3||diag2==3) return "A";
            if(row[r]==-3||col[c]==-3||diag1==-3||diag2==-3) return "B";
        }
        if(moves.size()==9) return "Draw";
        return "Pending";
    }
```
### 1276. Number of Burgers with No Waste of Ingredients	 (*)
equation group to find integer solution, elementary math

### 1277. Count Square Submatrices with All Ones (***)
dp: using top left solution to build current solution
```cpp
    int countSquares(vector<vector<int>>& matrix) {
        //count left and top number of continuous 1s
        if(matrix.empty()) return 0;
        int m=matrix.size(),n=matrix[0].size();
        //vector<int> left(n),top(n),prerow(n);
        vector<vector<int>> dp(m,vector<int>(n)); //must be 2d, represent the side length
        int ans=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]){
                    dp[i][j]=min({i?dp[i-1][j]:0,j?dp[i][j-1]:0,i&&j?dp[i-1][j-1]:0})+1;
                    ans+=dp[i][j];
                }
            }
        }
        return ans;
    }
```
### 1278. Palindrome Partitioning III (*****)
subproblem dp[l,k] represents the min cost for string length l (from begining) with k pal-parts.
then dp[i,k]=min(dp[j, k-1]+cost(j,i),dp[i,k])
```cpp
    int palindromePartition(string s, int k) {
        //min cuts to make it palindrome?
        int n=s.size();
        vector<vector<int>> dp(n+1,vector<int>(k+1,n)); //min replace length of string with k parts
        dp[0][0]=0;
        for(int i=1;i<=n;i++){ //length 
            for(int j=1;j<=k;j++){ //number of pal groups
                for(int l=i-1;l>=0;l--) //start 
                {
                    int d=cost(s,l,i-1);
                    dp[i][j]=min(dp[l][j-1]+d,dp[i][j]);
                }
            }
        }
        return dp[n][k];
    }
    int cost(string s,int start,int end){
        int ans=0;
        while(start<end){
            if(s[start++]!=s[end--]) ans++;
        }
        return ans;
    }
```
complexity would be O(kn^3)

optimization: using memoization, we can reduce the cost(i,j) problem into another dp problem, the complexity would be O(kN^2)
dp[l,k] is the min cost for length l (starting from beginning) with k parts, dp1[i,j] is the cost to make s[i,j] to be one palindrome part.
dp1[i,j]=dp[i+1,j-1]+(s[i]!=s[j]).
```cpp
    int palindromePartition(string s, int k) {
        //two dp problem: dp1[l,k] cost for string from begin to l with k parts
        //dp2[i,j] cost for string s[i,j] as one parts
        int n=s.size();
        vector<vector<int>> dp(n+1,vector<int>(k+1,n)),dp1(n,vector<int>(n)); //min replace length of string with k parts
        dp[0][0]=0;
        for(int i=1;i<=n;i++){ //length 
            for(int j=1;j<=k;j++){ //number of pal groups
                for(int l=i-1;l>=0;l--) //start 
                {
                    dp1[l][i-1]=(l+1<i-1?dp1[l+1][i-2]:0)+(s[l]!=s[i-1]);
                    dp[i][j]=min(dp[l][j-1]+dp1[l][i-1],dp[i][j]);
                }
            }
        }
        return dp[n][k];
    }
```


## contest 166
### 1281. Subtract the Product and Sum of Digits of an Integer (*)
simple
### 1282. Group the People Given the Group Size They Belong To (**)
greedy: sort the group size with index and then take by turn the elements
### 1283. Find the Smallest Divisor Given a Threshold (***)
binary search to find the min value.
a small trick: it needs to get the ceil division

```cpp
    int smallestDivisor(vector<int>& nums, int threshold) {
        //binary search to find the divisor
        int l=1,r=1e6;
        while(l<r){
            int m=l+(r-l)/2;
            if(getsum(nums,m)<=threshold) r=m;
            else l=m+1;
        }
        return l;
    }
    int getsum(vector<int>& nums,int m){
        int ans=0;
        for(int t: nums){
            ans+=(t+m-1)/m;
        }
        return ans;
    }
```

### 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix	(***)
a typical bfs to get the shortest distance
target is mxn '0's.
queue to store the matrix, and visited using the serialized matrix string.
```cpp
    int minFlips(vector<vector<int>>& mat) {
        //using bfs
        int m=mat.size(),n=mat[0].size();
        string target="000000000";
        target=target.substr(0,m*n);
        typedef vector<vector<int>> vvi;
        queue<vvi> q;
        unordered_set<string> v;
        q.push(mat);
        v.insert(mat2str(mat));
        int step=0;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                vvi tm=q.front();
                q.pop();
                if(mat2str(tm)==target) return step;
                for(int i=0;i<m;i++){
                    for(int j=0;j<n;j++){
                        //choose i,j to flip
                        vvi ttm=tm;
                        ttm[i][j]^=1;
                        if(i) ttm[i-1][j]^=1;
                        if(i+1<m) ttm[i+1][j]^=1;
                        if(j) ttm[i][j-1]^=1;
                        if(j+1<n) ttm[i][j+1]^=1;
                        string s=mat2str(ttm);
                        if(v.count(s)) continue;
                        q.push(ttm);
                        v.insert(s);
                    }
                }
            }
            step++;
        }
        return -1;
    }
    string mat2str(vector<vector<int>>& m){
        string ans;
        for(int i=0;i<m.size();i++)
            for(int j=0;j<m[0].size();j++){
                ans+='0'+m[i][j];
            }
        return ans;
    }
```


## contest 167
### 1290. 1290. Convert Binary Number in a Linked List to Integer (*)
simple

### 1291. Sequential Digits (***)
simple backtracking
```cpp
    vector<int> sequentialDigits(int low, int high) {
        //backtrack
        string l=to_string(low),h=to_string(high);
        int m=l.size(),n=h.size();
        vector<int> ans;
        backtrack(ans,low,high,m,n,0,1);
        sort(ans.begin(),ans.end());
        return ans;
    }
    void backtrack(vector<int>& ans,int low,int high,int m,int n,int t,int ld){
        if(t>high) return;
        if(t>=low && t<=high){
            ans.push_back(t);
        }
        //first digit is 1
        for(int i=ld;i<=9;i++){ //try 
            int d=t%10;
            if(i==d+1 || d==0){
                t=t*10+i;
                backtrack(ans,low,high,m,n,t,d+1);
                t/=10;
            }
        }
    }
```

### 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold	(****)
prefix sum for 2d using dp.
note: we need add 0 to 1d prefix, and one extra col, one extra row to 2d (I didn't fix the bug in the contest)
```cpp
    int maxSideLength(vector<vector<int>>& mat, int threshold) {
        //dp: get the rect sum 
        int m=mat.size(),n=mat[0].size();
        int ans=0;
        vector<vector<int>> dp(m+1,vector<int>(n+1)); //max side length
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                int side=0;
                dp[i][j]=mat[i-1][j-1]+dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1];
                //check the lenght from 1 to i
                if(min(i,j)<ans) continue;
                for(int k=min(i,j);k>=0;k--){
                    int tsum=dp[i][j]-dp[i-k][j]-dp[i][j-k]+dp[i-k][j-k];
                    if(tsum<=threshold) {side=k;break;}
                }
                ans=max(ans,side);
            }
            
        }
        return ans;
    }
```	

### 1293. Shortest Path in a Grid with Obstacles Elimination (****)
regular bfs
one important observation: when number of obstacle > m-1+n-1, then we get the shortest length using dx+dy
this can be used in each step.
```cpp
    int shortestPath(vector<vector<int>>& grid, int k) {
        int m=grid.size(),n=grid[0].size();
        if(k>m+n-2) return m+n-2;
        queue<vector<int>> q;
        vector<bool> v(m*n*(k+1));
        int step=0;
        q.push({0,0,0});
        v[0]=1;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        while(q.size()){
            int sz=q.size();
            while(sz--){
                auto t=q.front();
                q.pop();
                int x=t[0],y=t[1],cnt=t[2];
                if(x==m-1 && y==n-1 && cnt<=k) return step;
                //optimization: remaining steps from [x,y] to bott-right with k steps
                if(k-cnt>m-1-x+n-1-y) return step+(m-1-x+n-1-y);
                for(int d=0;d<4;d++){
                    int x0=x+dir[d][0],y0=y+dir[d][1];
                    if(x0<0||y0<0||x0>=m||y0>=n||
                       cnt+grid[x0][y0]>k||v[x0*n*(k+1)+y0*(k+1)+cnt+grid[x0][y0]])
                        continue;
                    int c=cnt+grid[x0][y0];
                    q.push({x0,y0,c}); //eliminate current obstacle
                    v[x0*n*(k+1)+y0*(k+1)+c]=1;
                }
            }
            step++;
            //cout<<step<<endl;
        }
        return -1;
    }
```
Important: we need use k+1 for the 3rd dimension since it allows 0 to k.

 
## contest 168
### 1295. find numbers with even number of digits (*)
simple, convert each number to string

### 1296. divide array in sets of k consecutive numbers (***)
greedy: sort the array first, and start from the smallest and reduce the counting using hashmap
do not delete elements from hashmap since iterating will cause problem
```cpp
    bool isPossibleDivide(vector<int>& nums, int k) {
        map<int,int> mp;
        for(int t: nums) mp[t]++;
        auto it0=mp.begin();
        while(it0!=mp.end()){
            auto it1=it0;
            int v=it0->second;
            int n=0;
            
            while(n<k){
                if(it1->first==it0->first+n && it1->second>=v)
                    it1->second-=v;
                else return 0;
                n++;it1++;
            }
            bool found=0;
            for(it1=it0;it1!=mp.end();it1++) {
                if(it1->second){
                    found=1;
                    it0=it1;
                    break;
                }
            }
            if(!found) it0=mp.end();
        }
        return 1;
    }
```
### 1297. Maximum Number of Occurrences of a Substring	(***)
an important observation: larger length substr will be covered by smaller length substr.
two pointer with hashmap
```cpp
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        //greedy, the minsize window works also with maxsize
        int ans=0;
        int i=0,j=0;
        vector<int> mp(26);
        unordered_map<string,int> tmp;
        while(j<s.size()){
            mp[s[j]-'a']++;
            if(j-i+1==minSize){
                int count=0;
                for(int k=0;k<26;k++)
                    count+=(mp[k]>0);
                if(count<=maxLetters) 
                    ans=max(ans,++tmp[s.substr(i,minSize)]);
                mp[s[i]-'a']--;i++;
            }
            j++;
        }
        return ans;
    }
```
Note: when length equals to window size, we first check if it satisfies the conditions, then we advance the pointer i.

### 1298. Maximum Candies You Can Get from Boxes (***)
again it is a regular bfs problem.
we need to push all the found but un-opened boxes into queue, until we do not open any new boxes
```cpp
    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {
        //bfs
        queue<int> q;
        for(int t: initialBoxes) q.push(t);
        unordered_set<int> keys_owned;
        int ans=0;
        while(q.size()){
            int sz=q.size();
            bool found=0;
            while(sz--){
                int b=q.front();
                q.pop();
                if(status[b] || keys_owned.count(b)){
                    ans+=candies[b];
                    for(int k: keys[b]) keys_owned.insert(k);
                    for(int k: containedBoxes[b]) q.push(k);
                    found=1;
                }
                else q.push(b);
            }
            if(!found) break;
        }
        return ans;
    }
```	## contest 169.
### 1304. find n unique integers sum up to 0 (rate: *)
greedy, pretty simple
if odd, add 0
then add +/-1, +/-2... pairs

### 1305. All elements in two binary search tree (rate: **)
inorder traversal each tree and store in array and then merge.

### 1306. Jump game III (rate: ***)
regular bfs to store the position and the jump step.
using hashset for visited flags

dfs is also OK:
```cpp
unordered_set<int> vis;
bool canReach(vector<int>& arr, int st) {
    if (st >= 0 && st < arr.size() && vis.insert(st).second) {
        return arr[st] == 0 ||
            canReach(arr, st + arr[st]) || canReach(arr, st - arr[st]);
    }
    return false;
}
```
note: unordered_set insert will return a pair:
first is the iterator, second is if it is inserted successfully.

### 1307. verbal arithmetic puzzle (rate: *****)
typical backtracking problem with extra complexity</br>
first approach: O(N!) complexity</br>
we collect all unique letters and repeat 0 to 9 with the help of hashmap.</br>
however this will get TLE.</br>
A common mistake I often made is: loop over the letters and loop over the digits</br>
the recursive backtracking itself is a loop over the letters. So do not loop over it again.</br>

```cpp
    unordered_set<char> leading,chars;
    unordered_map<char,int> mp;
    bool used[10];
    bool isSolvable(vector<string>& words, string result) {
        //backtracking
        for(string w: words){
            leading.insert(w[0]);
            for(char c: w) chars.insert(c);
        }
        leading.insert(result[0]);
        for(char c: result) chars.insert(c);
        vector<char> arr(chars.begin(),chars.end());
        return backtrack(arr,0,words,result);
    }
    bool backtrack(vector<char>& arr,int start,vector<string>& words,string& result){
        if(start==arr.size()){
            if(valid(words,result)) return 1;
            else return 0;
        }
        char c=arr[start];
        for(int i=0;i<10;i++){
            if(used[i] || (i==0 && leading.count(c))) continue;
            used[i]=1;
            mp[c]=i;
            if(backtrack(arr,start+1,words,result)) return 1;
            used[i]=0;
            mp.erase(c);
        }
        return 0;
    }
    bool valid(vector<string>& words,string& result){
        int sum=0;
        for(string w: words){
            int num=0;
            for(char c: w) num=num*10+mp[c];
            sum+=num;
        }
        int res=0;
        for(char c: result) res=res*10+mp[c];
        return res==sum;
    }
```	
-note above code will give wrong answer for some case since it did not check leading digit==0

it is easy to understand, however it tries a lot of unnecessary combinations.</br>
for example when we choose the definition for the LSB of each words, the result bit is determined.</br>
but this approach still tries all the combination.</br>
More efficient way is to try col by col from the LSB.</br>
This approach is more complicated since it is a two-backtracking problem:</br>
- backtracking on a single column with cf.
- backtracking on columns (when current col fails, we need backtrack to previous col)
It helps greatly if we define it a 2d backtracking problem with row and col.
- reverse words and result so we can do from LSB to MSB
- col reaches result size, whole process completes, check if sum==0 (no carrier flag)
- row reaches words size, current col is done
  * if result char in this col is not mapped, then another backtracking:
    map it
	try next col
	restore if it fails
  * if result char in this col is mapped, check if matches
     matched: do next col
	 not match, return 0
- skip current row if word does not have it
- add current row and go to next row if result is mapped
- otherwise try from 0 to 9 (typical one column backtracking problem)
```cpp
    char i2c[10];
    int c2i[26];    
    bool isSolvable(vector<string>& words, string result) {
        for (auto &s : words) if (s.size() > result.size()) return false;
        memset(c2i, -1, sizeof c2i);
        memset(i2c, '\0', sizeof i2c);
        for (auto& s: words) reverse(s.begin(), s.end());
        reverse(result.begin(), result.end());
        return backtrack(words, result, 0, 0, 0);
    }    
    bool backtrack(vector<string>& words, string& result, int row, int col, int sum) 
    {
        if (col == result.size()) return sum == 0;//finished all cols
        
        if (row == words.size()) //finished one col
        {
            int d=sum%10;
            int cf=sum/10;
            int t=result[col] - 'A';
            if (c2i[t] != -1) //used
            {
                if (d == c2i[t])
                    return backtrack(words, result, 0, col+1, cf);
            }
            else if (i2c[d] == '\0') //not used, another backtrack
            {
                c2i[t] = d;
                i2c[d] = result[col];
                if (backtrack(words, result, 0, col+1, cf)) return true;
                c2i[t] = -1;
                i2c[d] = '\0';
            }
            return false;
        }
        
        if (col >= words[row].size()) //skip if current word has no char in the col
            return backtrack(words, result, row+1, col, sum);
        int t=words[row][col] - 'A';
        if (c2i[t] != -1) //if current char is mapped
            return backtrack(words, result, row+1, col, sum + c2i[t]);
        char c=words[row][col];
        for (int i = 0; i < 10; ++i) //not mapped
        {
            if (i2c[i] != '\0') continue;
            if (i == 0 && col == words[row].size() - 1 && words[row].size() > 1) continue;
            i2c[i] = c;
            c2i[t] = i;
            if (backtrack(words, result, row+1, col, sum + i))
                return true;
            i2c[i] = '\0';
            c2i[t] = -1;
        }
        return false;
    }
```
This solution is at 100 times faster than the O(n!) solution.
what would be the complexity then?
- first the result char is mapped directly so we basically eliminate those chars from the loop selection
- using hashmap to store c2i will make the time from 8ms changed to 100ms, using array is much more efficient.
	## contest 170 1309-1312
Participant performance: 903/5186 got 4/4 right. (17.4%)

### 1360. Decrypt String from Alphabet to Integer Mapping (**)
<em>Problem:
Given a string s formed by digits ('0' - '9') and '#' . We want to map s to English lowercase characters as follows:

Characters ('a' to 'i') are represented by ('1' to '9') respectively.
Characters ('j' to 'z') are represented by ('10#' to '26#') respectively. 
Return the string formed after mapping.

It's guaranteed that a unique mapping will always exist.

 

Example 1:

Input: s = "10#11#12"
Output: "jkab"
Explanation: "j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
</em>

idea:

backward:
```cpp
    string freqAlphabets(string s) {
        string ans;
        //from backword;
        int j=s.size()-1;
        while(j>=0){
            if(s[j]=='#'){
                int t=s[j-1]-'0'+(s[j-2]-'0')*10;
                ans+='j'+t-10;
                j-=3;
            }
            else {
                ans+='a'+s[j]-'1';
                j--;
            }
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
```	
### 1361. XOR Queries of a Subarray (**)
<em>Problem:

Given the array arr of positive integers and the array queries where queries[i] = [Li, Ri], for each query i compute the XOR of elements from Li to Ri (that is, arr[Li] xor arr[Li+1] xor ... xor arr[Ri] ). Return an array containing the result for the given queries.
 

Example 1:

Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
Output: [2,7,14,8] 
Explanation: 
The binary representation of the elements in the array are:
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
The XOR values for queries are:
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8
Example 2:

Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
Output: [8,0,4,4]
</em>

Idea:
math: prefix xor and range xor is prefix[j+1]^prefix[i]  for range [i,j]. xor is similar to sum.
```cpp
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        //xor
        int n=arr.size();
        vector<int> prefix(n+1);
        for(int i=0;i<n;i++) prefix[i+1]=prefix[i]^arr[i];
        vector<int> ans;
        for(auto q: queries){
            int t=prefix[q[1]+1]^prefix[q[0]];
            ans.push_back(t);
        }
        return ans;
    }
```	

### 1362. Get Watched Videos by Your Friends (***)
<em>Problem:

There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.

Level 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. In general, the level k of videos are all watched videos by people with the shortest path equal to k with you. Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest. 
</em>

idea:

build a graph relation and do bfs to get the layer nodes, and then use pq to sort.
```cpp
     struct comp{
        bool operator()(const pair<string,int>& a,const pair<string,int>& b) {
            return a.second>b.second || (a.second==b.second && a.first>b.first);
        }
    };   
    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {
        int n=friends.size();
        unordered_map<int,unordered_set<int>> mp;
        for(int i=0;i<n;i++){
            for(int t: friends[i]) mp[i].insert(t);
        }
        unordered_map<string,int> video;
        queue<int> q;
        vector<bool> v(n);
        q.push(id);v[id]=1;
        int step=0;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                int t=q.front();
                q.pop();
                for(int neig: mp[t]){
                    if(v[neig]) continue;
                    v[neig]=1;
                    q.push(neig);
                }
            }
            if(++step==level) break;
        }
        while(q.size()){
            int t=q.front();
            q.pop();
            for(string v: watchedVideos[t]) video[v]++;
        }
        priority_queue<pair<string,int>,vector<pair<string,int>>,comp> pq(video.begin(),video.end());
        vector<string> ans;
        while(pq.size()) ans.push_back(pq.top().first),pq.pop();

        return ans;
    }
```
Note:
- no need build the tree using another structure again. The given input is always an adjacency matrix.
- sort the list of pairs do not need pq, just using lambda function is fine.

### 1363. Minimum Insertion Steps to Make a String Palindrome(***)
<em>Problem:

Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

Example 1:

Input: s = "zzazz"
Output: 0
Explanation: The string "zzazz" is already palindrome we don't need any insertions.	
</em>

Idea: longest common subsequence equivalent.
```cpp	
    int minInsertions(string s) {
    //dp:
	string rs(s.rbegin(),s.rend());
	if(s==rs) return 0;
	//only insertion allowed
	int n=s.size();
	vector<vector<int>> dp(n+1,vector<int>(n+1,0)); //longest common sequence
	//for(int i=0;i<=n;i++) dp[0][i]=dp[i][0]=i; //empty vs non-empty
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(s[i-1]==rs[j-1]) dp[i][j]=dp[i-1][j-1]+1;//no insertion
			else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); //insert one char 
		}
	}
	return n-dp[n][n];
   }
```		
### 1317. Convert Integer to the Sum of Two No-Zero Integers (*)

approach: 

just try from 1 to n and break into i and j and check if they contains 0.

we can use string find to check 0.

I got stuck and wrong submission on this trying to get a greedy solution, which is overkill for an easy problem.

```cpp
    vector<int> getNoZeroIntegers(int n) {
        vector<int> ans;
        for(int i=1;i<n;i++){
            int j=n-i;
            string s=to_string(i)+to_string(j);
            if(s.find('0')!=string::npos) continue;
            else return {i,j};
        }
        return {};
    }
```

### 1318. Minimum Flips to Make a OR b Equal to c (**)
approach: 

convert the 3 integers to bitset and check if the ith bit c[i]!=a[i]||b[i] then:

c[i]==0: ans+=a[i]+b[i]

c[i]==1: ans++ (a[i] and b[i] must be 0)
```cpp
    int minFlips(int a, int b, int c) {
        bitset<32> sa(a),sb(b),sc(c);
        int ans=0;
        for(int i=0;i<32;i++){
            if(sc[i]==(sa[i]||sb[i])) continue;
            if(sc[i]==0) ans+=sa[i]+sb[i]; //0 but there is 1
            else ans++;//1 but we get 0, need one flip
        }
        return ans;
    }
```

### 1319. Number of Operations to Make Network Connected (***)
Approach:

- a connected graph with n nodes needs at least n-1 edges.
- equivalent to find number of disjoint set and connect each set needs only one edge.

```cpp
    vector<int> parent;
    int sz;
    int makeConnected(int n, vector<vector<int>>& connections) {
        //min spanning tree. we need n-1 edges
        if(connections.size()<n-1) return -1;
        parent.resize(n);
        sz=n;
        for(int i=0;i<n;i++) parent[i]=i;
        for(auto c: connections){
            int s=c[0],e=c[1];
            int pi=findp(s),pj=findp(e);
            if(pi!=pj) {
                parent[pi]=pj;
                sz--;
            }
        }
        return sz-1;
    }
    int findp(int i){
        while(i!=parent[i]){
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
```
### 1310. Minimum Distance to Type a Word Using Two Fingers (*****)
I think this problem is a 5-star problem.
Analysis:

- it is a dp problem. Someone also solved it using bfs.
- distance of two char can be calculated using manhantan distance easily.
- it is not easy to find the relation, top down is more understandable.
- define the subproblem: finger1 at char f1, finger 2 at char f2, and next type char is ith char. and the min move.
- state conversion for dp + top down is a better way to understand and find the solution
  * for this problem initial state (0,0,0), we start at char 0 and finger1 and finger 2 are undefined.
  * if we use finger 1 to word[i], then we get to new state (i+1,word[i],f2)
  * if we use finger 2 to word[i], then we get to new state (i+1,f1,word[i])
- relation: cost(f1,word[i])+dp(i+1,word[i],f2),cost(f2,word[i])+dp(i+1,f1,word[i])
  
```cpp
    int memo[300][26][26];
    int minimumDistance(string word) {
        //dp: 
        memset(memo,-1,300*26*26*sizeof(int));
        return dp(0,0,0,word);
        
    }
    int dp(int i,char f1,char f2,string& word){
        if(i>=word.size()) return 0;
        if(f1 && f2 && memo[i][f1-'A'][f2-'A']>=0) 
            return memo[i][f1-'A'][f2-'A'];
        int ans1=dist(f1,word[i])+dp(i+1,word[i],f2,word); //use finger 1, new state (i+1,word[i],f2)
        int ans2=dist(f2,word[i])+dp(i+1,f1,word[i],word); //use finger 2, new state (i+1,f1,word[i])
        if(f1&&f2) memo[i][f1-'A'][f2-'A']=min(ans1,ans2);
        return min(ans1,ans2);
    }
    int dist(char a, char b){
        if(!a||!b) return 0;
        int i=a-'A',j=b-'A';
        return abs(i/6-j/6)+abs(i%6-j%6);
    }
```    

- initial finger position is 0 and we assume its distance to any char is 0.
- we always keep the state: current position, finger 1's char, finger 2's char and keep solving the subproblem.
- memoization to speed the process.
1323. Maximum 69 Number
<em>Problem:

Given a positive integer num consisting only of digits 6 and 9.

Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).</em>

Pretty easy, find the first 6 and change it to 9.
```cpp
    int maximum69Number (int num) {
        //findd the first 6
        string s=to_string(num);
        int ind=s.find_first_of('6');
        if(ind!=string::npos) s[ind]='9';
        return stoi(s);
    }
```

1324. Print Words Vertically
<em>Problem:

Given a string s. Return all the words vertically in the same order in which they appear in s.
Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed).
Each word would be put on only one column and that in one column there will be only one word.</em>

Idea: need to add spaces in the front but not at the end.

```cpp
    vector<string> printVertically(string s) {
        vector<string> ans,vt;
        stringstream ss(s);
        string w;
        int cnt=0;
        while(ss>>w){
            int i=0;
            for(char c: w){
                if(ans.size()<=i) ans.push_back("");
                while(ans[i].size()<cnt) ans[i]+=' ';
                ans[i]+=c;
                i++;
            }
            cnt++;
        }
        return ans;
    }
```    

1325. Delete Leaves With a Given Value
<em>Problem:

Given a binary tree root and an integer target, delete all the leaf nodes with value target.

Note that once you delete a leaf node with value target, if it's parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you can't).
</em>
Idea: postorder traversal

```cpp
    TreeNode* removeLeafNodes(TreeNode* root, int target) {
        //postorder to remove
        if(!root) return 0;
        root->left=removeLeafNodes(root->left,target);
        root->right=removeLeafNodes(root->right,target);
        if(root->left==root->right && root->val==target) return 0;
        return root;
    }
```

1326. Minimum Number of Taps to Open to Water a Garden
<em>Problem:

There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).

There are n + 1 taps located at points [0, 1, ..., n] in the garden.

Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.

Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.
</em>

Idea:
Equivalent to the problem asking using min number of intervals to cover a given range.
we can use bfs, greedy or dp approach for this problem.
greedy: sort the intervals, and loop over each interval, and use the one which covers the start and extends to right the most.
```cpp
    int minTaps(int n, vector<int>& ranges) {
        //intervals: min number of intervals to cover [0,n]
        //greedy: choose the one covers 0 with largest right.
        vector<vector<int>> intervals;
        for(int i=0;i<ranges.size();i++){
            intervals.push_back({i-ranges[i],i+ranges[i]});
        }
        sort(intervals.begin(),intervals.end());
        int start=0,ans=1,right=0;
        for(int i=0;i<intervals.size();i++){
            if(intervals[i][0]<=start) right=max(right,intervals[i][1]);
            else{ //interval>start, check if 
                if(intervals[i][0]>right) return -1;
                start=right;
                right=max(right,intervals[i][1]);
                ans++;
            }
            if(right>=n) return ans;
        }
        return ans;        
    }
```

dp approach:
```cpp
    int minTaps(int n, vector<int>& A) {
        vector<int> dp(n + 1, n + 2);
        dp[0] = 0;
        for (int i = 0; i <= n; ++i)
            for (int j = max(i - A[i] + 1, 0); j <= min(i + A[i], n); ++j)
                dp[j] = min(dp[j], dp[max(0, i - A[i])] + 1);
        return dp[n]  < n + 2 ? dp[n] : -1;
    }
```    

 
## contest 173
### 1332. Remove Palindromic Subsequences
<em>
Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.</em>

three cases:
- empty string: 0 operations
- palindrome string, 1 operation
- contains a and b: 2 operations

```cpp
    int removePalindromeSub(string s) {
        if(s.empty()) return 0;
        string rs=s;
        reverse(rs.begin(),rs.end());
        if(rs==s) return 1;
        return 2;
    }
```

### 1333. Filter Restaurants by Vegan-Friendly, Price and Distance	
<em>
Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.

The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively.

Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.

 </em>
 
 Approach:
 
 filter all the restaurants and then sort.
 
 ```cpp
     vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> ans;
        for(auto t: restaurants){
            if((!veganFriendly || (veganFriendly && t[2])) && t[3]<=maxPrice && t[4]<=maxDistance){
                ans.push_back(t);
            }
        }
        sort(ans.begin(),ans.end(),[](vector<int>& a,vector<int>& b){
            return a[1]>b[1] || (a[1]==b[1] && a[0]>b[0]);
        });
        vector<int> res;
        for(auto t: ans) res.push_back(t[0]);
        return res;
    }
```

### 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance	
<em>
There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.

Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.
</em>

Idea: 
My first intuition is using bellman ford (dp like method) to relax the edges.
also called floyd warshall algorithm, used to find all the pair distance in a graph.

```cpp
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
		vector<vector<int>> dist(n,vector<int>(n,INT_MAX/2));
		for(auto e: edges){
			dist[e[1]][e[0]]=dist[e[0]][e[1]]=e[2];
		}
		for(int i=0;i<n;i++) dist[i][i]=0;//maybe not necessary?
		for(int k=0;k<n;k++){
			for(int i=0;i<n;i++){
				for(int j=0;j<n;j++){
					dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
				}
			}
		}
		int mincnt=n,ans=-1;
		for(int i=0;i<n;i++){
			int cnt=0;
			for(int j=0;j<n;j++) {
				if(dist[i][j]<=distanceThreshold) cnt++;
			}
			//ans=min(ans,cnt);
		if(mincnt>=cnt){
		mincnt=cnt;
		ans=i;
		} 
	}
	return ans;
}
```

using pq (dijkstra) to find the closest distance to other cities. If over the threshold, ignore
the implementation from leetcode discussion:
```cpp
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<unordered_map<int, int>> neighbors(n);
        for (auto & vec : edges){
            neighbors[vec[0]][vec[1]] = vec[2];
            neighbors[vec[1]][vec[0]] = vec[2];
        }
        int res = -1, minSize = INT_MAX;
        for (int i = 0; i < n; ++ i){
            int cnt = bfs(i, neighbors, distanceThreshold, n);
            if (cnt <= minSize){
                res = i;
                minSize = cnt;
            }
        }
        return res;
    }
    
    
    int bfs(int src, vector<unordered_map<int, int>>& neighbors, int distanceThreshold, int n){
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;
        minHeap.emplace(0, src);
        vector<int> dist(n, INT_MAX);
        dist[src] = 0;
        // handles duplicate points that might be discovered later, so we can't simply just count
        unordered_set<int> ret;
        while (!minHeap.empty()){
            auto c = minHeap.top();
            minHeap.pop();
            int x = c.second, curDist = c.first;
            for (auto it = neighbors[x].begin(); it != neighbors[x].end(); ++ it){
                int totalDist = curDist + it->second;
				// updates previous dist if we find a smaller one
                if (dist[it->first] > totalDist && totalDist <= distanceThreshold){
                    dist[it->first] = totalDist;
                    minHeap.emplace(totalDist, it->first);
                    ret.insert(it->first);
                }
            }
        }
        return ret.size();
    }
```

### 1335. Minimum Difficulty of a Job Schedule	
<em>
You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the i-th job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done in that day.

Given an array of integers jobDifficulty and an integer d. The difficulty of the i-th job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.
</em>

I first thought this is a binary search problem, but actually not, since each day may contain multiple tasks which is greater than our target difficulty.

Realized this is a dp problem, then we can think top down recursive approach first to make it correct.

for the first day we have option:</br>
1 tasks, leaving n-1 </br>
2 tasks, leaving n-2</br>
...</br>
n tasks, leaving 0.</br>
that is to say the dp problem is as belows:</br>
min(max(A[0..i])+sub(i+1,d-1))</br>

```cpp
    int minDifficulty(vector<int>& job, int d) {
		int n=job.size();
		if(d>n) return -1;
		vector<vector<int>> dp(n,vector<int>(d+1,INT_MAX/2));
		return helper(job,0,d,dp);
	}
	int helper(vector<int>& job,int start,int nday,vector<vector<int>>& dp){
		int n=job.size();
        if(start>=n || nday>n-start) return INT_MAX/2; //not valid
        if(dp[start][nday]<INT_MAX/2) return dp[start][nday];
		if(nday==1) return *max_element(job.begin()+start,job.end());
		int ans=INT_MAX,maxval=0;
		for(int i=start;i<n;i++){
			maxval=max(maxval,job[i]);
			ans=min(ans,maxval+helper(job,i+1,nday-1,dp));
		}
		return dp[start][nday]=ans;
	}
```

Important: it is always a good method for dp to try recursive approach first if we are not clear about the recurrence relation.	
## contest 174
### 1337. The K Weakest Rows in a Matrix
<em>
Given a m * n matrix mat of ones (representing soldiers) and zeros (representing civilians), return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest.

A row i is weaker than row j, if the number of soldiers in row i is less than the number of soldiers in row j, or they have the same number of soldiers but i is less than j. Soldiers are always stand in the frontier of a row, that is, always ones may appear first and then zeros.
</em>

Approach: count each row number of 1s and sort.
```cpp
    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
        if(mat.empty()) return {};
        int m=mat.size(),n=mat[0].size();
        vector<vector<int>> ans(m);
        for(int i=0;i<m;i++){
            int cnt=0;
            for(int j=0;j<n;j++) cnt+=mat[i][j];
            ans[i]={cnt,i};
        }
        stable_sort(ans.begin(),ans.end());
        //ans.resize(k);
        vector<int> res(k);
        for(int i=0;i<k;i++) res[i]=ans[i][1];
        return res;
    }
```
- use stable_sort to maintain its original order if they are tie.

### 1338. Reduce Array Size to The Half
<em>
Given an array arr.  You can choose a set of integers and remove all the occurrences of these integers in the array.

Return the minimum size of the set so that at least half of the integers of the array are removed.
</em>

Approach: using hashmap to get the histogram and then remove the most frequent ones
```cpp
    int minSetSize(vector<int>& arr) {
        int n=arr.size();
        //count and from max to min
        unordered_map<int,int> mp;
        for(int i: arr) mp[i]++;
        vector<int> cnt;
        for(auto t: mp) cnt.push_back(t.second);
        sort(cnt.begin(),cnt.end());
        int ans=0,t=0;
        for(int i=cnt.size()-1;i>=0;i--){
            t+=cnt[i]; ans++;
            if(t>=n/2) return ans;
        }
        return mp.size();
    }
```

### 1339. Maximum Product of Splitted Binary Tree
<em>
Given a binary tree root. Split the binary tree into two subtrees by removing 1 edge such that the product of the sums of the subtrees are maximized.
Since the answer may be too large, return it modulo 10^9 + 7.	
</em>

Intuition: when the a+b=sum and max(a*b) we shall make a b as close as possible or min(abs(a-b))
Approach: two pass postorder, first pass to get the total sum, second pass to get the mindiff.
```cpp
    int maxProduct(TreeNode* root) {
        //the difference of the two sum shall be minimized
        //postorder to get the sum of its left and right subtree
        int mindiff=INT_MAX;
        int tsum=sum(root);

        helper(root,tsum,mindiff);
        int a=(tsum+mindiff)/2,b=tsum-a;
        int mod=1e9+7;
        return (long)a*b%mod;
    }
    int sum(TreeNode* root){
        if(!root) return 0;
        return root->val+sum(root->left)+sum(root->right);
    }
    int helper(TreeNode* root,int tsum,int& mindiff){ //get the min diff
        if(!root) return 0;
        
        int left=helper(root->left,tsum,mindiff);
        int right=helper(root->right,tsum,mindiff);
        int sum=left+right+root->val;
        int diff=abs(2*sum-tsum);//
        mindiff=min(diff,mindiff);
        return sum;
    }
```	

### 1340. Jump Game V
<em>
Given an array of integers arr and an integer d. In one step you can jump from index i to index:

i + x where: i + x < arr.length and 0 < x <= d.
i - x where: i - x >= 0 and 0 < x <= d.
In addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)).

You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.

Notice that you can not jump outside of the array at any time.
</em>

Analysis:
equivalent: 
- jump from low to high
- at each index, the person has several options, and each option will lead to different subproblem, which is a typical dp problem.
- using top down + memoization:

```cpp
    int dp[1001] = {};
    int dfs(vector<int>& arr, int i, int d, int res = 1) {
        if (dp[i]) return dp[i];
        for (auto j = i + 1; j <= min(i + d, (int)arr.size() - 1) && arr[j] < arr[i]; ++j)
            res = max(res, 1 + dfs(arr, j, d));
        for (auto j = i - 1; j >= max(0, i - d) && arr[j] < arr[i]; --j)
            res = max(res, 1 + dfs(arr, j, d));
        return dp[i] = res;
    }
    int maxJumps(vector<int>& arr, int d, int res = 1) {
        for (auto i = 0; i < arr.size(); ++i)
            res = max(res, dfs(arr, i, d));
        return res;
    }
```

bottom up: we need first sort the array and then uses dp (start from highest) otherwise we will get wrong.
other solution can use bfs, dfs, but we need first apply the greedy sort algorithm, otherwise it will be wrong.


```cpp
    int maxJumps(vector<int>& arr, int d) {
        //typical dp
        int n=arr.size();
        int ans=0;
        vector<vector<int>> nums;
        for(int i=0;i<arr.size();i++){
            nums.push_back({arr[i],i});
        }
        sort(nums.begin(),nums.end());//jump from low to high
        vector<int> dp(n,1);
        for(int k=0;k<n;k++){
            int i=nums[k][1];
            for(int j=1;j<=d;j++){
                if(j+i>=n || arr[i]>=arr[j+i]) break;
                dp[i]=max(dp[i],dp[i+j]+1); //
            }
            for(int j=1;j<=d;j++){
                if(i-j<0 || arr[i]>=arr[i-j]) break;
                dp[i]=max(dp[i],dp[i-j]+1);
            }
            ans=max(ans,dp[i]);
        }
        return ans;
    }
```
This is wrong, why?
greedy: we just check smallest first. so we need still jump from high to low. 
change the >= to <= will fix the problem.

The top down approach applies to most dp problem and is the way to figure out the relation. Good problem and good practice.
	



 
## contest 175
### 1346. Check If N and Its Double Exist
<em>
Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).

More formally check if there exists two indices i and j such that :

i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]
</em>

Analysis: using hashmap, sort it. 
only check even numbers. 
for positives, check n/2
for negatives, check 2*n.

```cpp
    bool checkIfExist(vector<int>& arr) {
        sort(arr.begin(),arr.end(),greater<int>());
        unordered_set<int> ms;
        for(int i: arr){
            if(ms.count(i*2) || (ms.count(i/2) && i%2==0)) return 1;
            ms.insert(i);
        }
        return 0;
    }
```

### 1347. Minimum Number of Steps to Make Two Strings Anagram
<em>
Given two equal-size strings s and t. In one step you can choose any character of t and replace it with another character.

Return the minimum number of steps to make t an anagram of s.

An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.
</em>

Analysis:
- calculate the hist for s.
- subtract all occurrance of t 
- add all negatives
```cpp
    int minSteps(string s, string t) {
        vector<int> cnt(26);
        for(char c: s) cnt[c-'a']++;
        int ans=0;
        //need to replace all non-exist chars
        for(char c: t) cnt[c-'a']--;
        for(int i: cnt){
            if(i<0) ans+=-i;
        }
        return ans;
    }
```

### 1348. Tweet Counts Per Frequency
<em>
Implement the class TweetCounts that supports two methods:

1. recordTweet(string tweetName, int time)

Stores the tweetName at the recorded time (in seconds).
2. getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)

Returns the total number of occurrences for the given tweetName per minute, hour, or day (depending on freq) starting from the startTime (in seconds) and ending at the endTime (in seconds).
freq is always minute, hour or day, representing the time interval to get the total number of occurrences for the given tweetName.
The first time interval always starts from the startTime, so the time intervals are [startTime, startTime + delta*1>,  [startTime + delta*1, startTime + delta*2>, [startTime + delta*2, startTime + delta*3>, ... , [startTime + delta*i, min(startTime + delta*(i+1), endTime + 1)> for some non-negative number i and delta (which depends on freq).  
 
</em>
This problem is simple but the contest test is a disaster. It judges the right to be wrong.

```cpp
    unordered_map<string,multiset<int>> mp;
    TweetCounts() {
        
    }
    
    void recordTweet(string tweetName, int time) {
        mp[tweetName].insert(time);
    }
    
    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {
        vector<int> ans;
        //from start time to end time using the frequency
        int dt=0;
        if(freq=="minute") dt=60;
        else if(freq=="hour") dt=3600;
        else dt=3600*24;
        for(int t=startTime;t<=endTime;t+=dt){
            auto it1=mp[tweetName].lower_bound(t); //>=t
            auto it2=mp[tweetName].lower_bound(min(t+dt,endTime+1));//>t+dt
            ans.push_back(distance(it1,it2));
        }
        return ans;
    }
```
- using multiset for same id and same timestamp.
- using multiset actually is worse than vector since the distance is O(N) for multiset.

### 1349. Maximum Students Taking Exam
<em>
Given a m * n matrix seats  that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character.

Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible..

Students must be placed in seats in good condition.
Constraints:

seats contains only characters '.' and'#'.
m == seats.length
n == seats[i].length
1 <= m <= 8
1 <= n <= 8
</em>

My intuition on this is using backtracking, each valid seat can have an option to sit a person or not.
the complexity is O(2^n) n is up to 64. This will get TLE. and also it is not prooved that this will get the max solution.



	
 
 
## contest 177

### 1351. Count Negative Numbers in a Sorted Matrix
<em>Given a m * n matrix grid which is sorted in non-increasing order both row-wise and column-wise. 

Return the number of negative numbers in grid.
m,n<100
</em>

Intution:
100x100 is not large, brutal force is sufficient.
```cpp
    int countNegatives(vector<vector<int>>& grid) {
        int ans=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                ans+=grid[i][j]<0;
            }
        }
        return ans;
    }
```
binary search (for decreasing array)
```cpp
    int countNegatives(vector<vector<int>>& grid) {
        int ans=0;
		for(auto r: grid){
			auto it=upper_bound(r.rbegin(),r.rend(),-1)-r.rbegin();
			ans+=it;
		}
        return ans;
    }
```

### 1352. Product of the Last K Number
<em>
Implement the class ProductOfNumbers that supports two methods:

1. add(int num)

Adds the number num to the back of the current list of numbers.
2. getProduct(int k)

Returns the product of the last k numbers in the current list.
You can assume that always the current list has at least k numbers.
At any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.
</em>
Intuition:
- brutal force simple.
- prefix product and then using division
- prefix if there is 0 inside, it will break the property. The trick is reinitinialize the prefix array.
```cpp
    vector<int> A = {1};
    void add(int a) {
        if (a)
            A.push_back(A.back() * a);
        else
            A = {1};
    }

    int getProduct(int k) {
        return k < A.size() ? A.back() / A[A.size() - k - 1]  : 0;
    }
```
The prefix solution is 10 times faster than the brutal force.

### 1353. Maximum Number of Events That Can Be Attended
<em>
Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.

You can attend an event i at any day d where startTimei <= d <= endTimei. Notice that you can only attend one event at any time d.

Return the maximum number of events you can attend.	
</em>

Intuition:
- only sort by start or ending is not sufficient to solve the problem
- greedy approach: for day i, we choose the event with earliest ending date from all those event starting<=i.
- so we first sort by starting date, and then use min heap to find the earliest ending date event.
- once we choose a date, we need pop all those events which does not meet our criteria.

```cpp
    struct comp{
        bool operator()(vector<int>& a,vector<int>& b){
            return a[1]>b[1] || (a[1]==b[1] && a[0]>b[0]);
        }
    };
    int maxEvents(vector<vector<int>>& events) {
        int ans=0;
        //sort by the beginning time
        sort(events.begin(),events.end());
        //print(events);
        //add and sort by ending time
        priority_queue<vector<int>,vector<vector<int>>,comp> pq;
        //check all days and choose the one ending first.
        int i=0;
        int start=events[i][0];
        while(i<events.size()){
            while(i<events.size() && events[i][0]<=start) pq.push(events[i++]);
            if(pq.size()){
                auto e=pq.top();
                
                pq.pop();
                if(e[1]>=start) ans++;
                //cout<<start<<" "<<e[0]<<" "<<e[1]<<" "<<ans<<endl;
                start++;
                while(pq.size() && pq.top()[1]<start) pq.pop();
            }
            else start++; 
        }
        while(pq.size()){
            auto e=pq.top();
            pq.pop();
            if(e[1]>=start) ans++;
            start++;
        }
        return ans;
    }
```	
- the code could be more concise.

### 1354. Construct Target Array With Multiple Sums
<em>
Given an array of integers target. From a starting array, A consisting of all 1's, you may perform the following procedure :

let x be the sum of all elements currently in your array.
choose index i, such that 0 <= i < target.size and set the value of A at index i to x.
You may repeat this procedure as many times as needed.
Return True if it is possible to construct the target array from A otherwise return False.
</em>

Intution:
- goes reverse way from the current array to all ones array
- the max element is the previous sum: sum+sum-a[i]=cur_sum. Using pq to find the max.
- there is a case where we add to the same element a lot of times, and we shall optimize this, otherwise it will TLE.
- for the above case:
assume t=cur_sum, s=sum, 2*s-a[i]=t, a[i]=2*s-t
next step, a[i]->s, s->t, a[i]'=2*a[i]-s=2*(2*s-t)-s=3*s-2*t=2s-t+(s-t)
next step, a[i]'->s, a[i]->t, a[i]''=2*a[i]'-a[i]=2*(3s-2t)-2s+t=4s-3t=2s-t+2(s-t)
....
this goes to: (2s-t)%(s-t)

```cpp
    bool isPossible(vector<int>& target) {
        priority_queue<long> pq;
        long s(0);
		// push each element into max-heap, also sum all elements
        for (const int& i: target) {
            pq.push(i);
            s += i;
        }
        
        while (pq.top() != 1) { // until every element in heap is 1
			// we pop the largest from heap
            long t = pq.top();
            pq.pop();
			
			// (special case) by induction, [n, 1] -> [n-1, 1] -> ... -> [2, 1] -> [1, 1] is always possible
			if (s - t == 1) return true;
			// if it cannot be formed by other numbers in heap, return false
            if (s-t<1 || (2 * t - s) % (s - t) <= 0) return false;
			
			// otherwise, we push the previous number (possibly from many steps before / accelerate by module)
            pq.push((2 * t - s) % (s - t));
			// update current sum
            s += (2 * t - s) % (s - t) - t;
        }
        
        return true;
    }
```	
complexity O(nlogn)

The max drops to 1 exponentially, using max_element will be O(N)
```cpp
    bool isPossible(vector<int>& t) {
        auto s = accumulate(begin(t), end(t), (long long)0);
        auto i = max_element(begin(t), end(t)) - begin(t);
        while (s != 1 && t[i] > s / 2) {
            s -= t[i];
            if(s<1) return 0;
            t[i] = t[i] % s;
            s += t[i];
            i = max_element(begin(t), end(t)) - begin(t);
        }
        return s == 1 || s == t.size();
    }
```	


## contest 178

### 1365. How Many Numbers Are Smaller Than the Current Number
<em>
Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.
</em>

Since length is small <500, brutal force is sufficient.
Otherwise, we need maintain a hashmap the value vs the indices.
- brutal force: O(N^2)
- sort and then binary search O(nlogn)
- count sort (since the numbers are limited <100)


### 1366. Rank Teams by Votes
<em>
In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.

The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

Given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return a string of all teams sorted by the ranking system.
</em>

- two dimensional data.
- count each character along each column
- sort by column and finally by the name index

```cpp
    string rankTeams(vector<string>& votes) {
        int m=votes.size(),n=votes[0].size();
        vector<vector<int>> cnt(26,vector<int>(n)); //
        string ans;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++) cnt[votes[i][j]-'A'][j]++;
        }
        vector<vector<int>> v;
        for(int i=0;i<26;i++){
            int tsum=accumulate(cnt[i].begin(),cnt[i].end(),0);
            if(tsum) {cnt[i].push_back(i);v.push_back(cnt[i]);}
        }
        
        sort(v.begin(),v.end(),[](vector<int>& a,vector<int>& b){
           bool ans=0;
            for(int i=0;i<a.size()-1;i++){
                if(a[i]==b[i]) continue;
                return a[i]>b[i];
            }
            return a.back()<b.back(); //
        });
        for(auto t: v) ans+='A'+t.back();
        return ans;
    }
```

### 1367. Linked List in Binary Tree
<em>
Given a binary tree root and a linked list with head as the first node. 

Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.
</em>

idea:

- first dfs to get the nodes which has the value of the linklist head.
- then dfs from those nodes to find the list.
```cpp
    TreeNode* find(TreeNode* root,int val,vector<TreeNode*>& vnode){
        if(!root) return 0;
        if(root->val==val) {vnode.push_back(root);}
        auto left=find(root->left,val,vnode);
        auto right=find(root->right,val,vnode);
        return left?left:right;
    }
    bool isSubPath(ListNode* head, TreeNode* root) {
        //dfs pattern match?
        //find the head and match the root and then go dfs
        vector<TreeNode*> rt;
        find(root,head->val,rt);
        bool ans=0;
        for(auto r: rt){
            if(dfs(r,head)) return 1;
        }
        return 0;
    }
    bool dfs(TreeNode* root,ListNode* head){
        if(!head) return 1;
        if(!root) return 0;
        if(root->val!=head->val) return 0;
        bool ans=dfs(root->left,head->next)||dfs(root->right,head->next);
        return ans;
    }
```	
Lee215 solution:
```cpp
    bool isSubPath(ListNode* head, TreeNode* root) {
        if (!head) return true;
        if (!root) return false;
        return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);
    }

    bool dfs(ListNode* head, TreeNode* root) {
        if (!head) return true;
        if (!root) return false;
        return head->val == root->val && (dfs(head->next, root->left) || dfs(head->next, root->right));
    }
```
idea is: if root matches, then check it. otherwise, restart with its left and right.

### 1368. Minimum Cost to Make at Least One Valid Path in a Grid
<em>
Given a m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:
1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])
2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])
3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])
4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])
Notice that there could be some invalid signs on the cells of the grid which points outside the grid.

You will initially start at the upper left cell (0,0). A valid path in the grid is a path which starts from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path doesn't have to be the shortest.

You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.

 </em>
 
 This is a very good question on bfs.
 first, the problem can be converted to equivalent bfs problem.
 if we can go from current cell to next cell, the cost is 0
 if we cannot go from current cell to next cell, the cost is 1.
 Equivalent problem is then find the shortest cost path from (0,0) to (m-1,n-1)
 
 To apply bfs, we need build layers using cost, from 0 to 1, 2.....
 but one direction queue is hard to implement this.
 We can use deque, the same layer is in the front, the cost+1 is added to the back.
 
 ```cpp
     int minCost(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        deque<pair<int, int>> q{{0, 0}};  // for the pair, the first element is the cell position, the second is the path cost to this cell
        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        unordered_set<int> visited;
        
        int res = 0;
        while(!q.empty())
        {
            auto t = q.front(); 
            q.pop_front();

            int curi = t.first / n, curj = t.first % n;
            //v.insert return a pair of iterator and value, indicating if insert success.
            if (visited.insert(t.first).second)  // If we have never visited this node, then we have the shortest path to this node
                res = t.second;
            
            if (curi == m-1 && curj == n-1)
                return res;
            
            for (auto dir: dirs)
            {
                int x = curi + dir[0];
                int y = curj + dir[1];
                int pos = x * n + y;
                if (x<0 || x>=m || y<0 || y>=n || visited.count(pos)) continue;
                
                int cost;
                if (grid[curi][curj] == 1 && dir[0] == 0 && dir[1] == 1) cost = 0;
                else if (grid[curi][curj] == 2 && dir[0] == 0 && dir[1] == -1) cost = 0;
                else if (grid[curi][curj] == 3 && dir[0] == 1 && dir[1] == 0) cost = 0;
                else if (grid[curi][curj] == 4 && dir[0] == -1 && dir[1] == 0) cost = 0;
                else cost = 1;
                
                if (cost == 1)
                    q.push_back({pos, t.second + cost});
                else
                    q.push_front({pos, t.second + cost});
            }
        }
        return res;
    }
```
//note we only update the cost at the first time of visit.	
	

## contest 180

### 1374. Generate a String With Characters That Have Odd Counts
<em>
Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times.

The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.  
</em>

Approach:
if it is odd, then put all 'a'
if it is even, then put n-1 'a' and 1 'b'

```cpp
    string generateTheString(int n) {
        string ans;
        if(n%2==0){
            ans.append(n-1,'a');
            ans+='b';
        }
        else ans.append(n,'a');
        return ans;
    }
```

### 1375. Bulb Switcher III
<em>
There is a room with n bulbs, numbered from 1 to n, arranged in a row from left to right. Initially, all the bulbs are turned off.

At moment k (for k from 0 to n - 1), we turn on the light[k] bulb. A bulb change color to blue only if it is on and all the previous bulbs (to the left) are turned on too.

Return the number of moments in which all turned on bulbs are blue.	
</em>

Approach:
only after previous lights are all turned on, then it is all blue
use prefix sum. O(N)
```cpp
    int numTimesAllBlue(vector<int>& light) {
        long prefix=0;
        int ans=0;
        for(int i=0;i<light.size();i++){
            prefix+=light[i];
            if(prefix==(long)(i+1)*(i+2)/2) ans++;
        }
        return ans;
    }
```	

### 1376. Time Needed to Inform All Employees
<em>
A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID.

Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it's guaranteed that the subordination relationships have a tree structure.

The head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news.

The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news).

Return the number of minutes needed to inform all the employees about the urgent news.
</em>

approach:

- the structure forms a tree with the root as the headID
- dfs to traversal all nodes and get the max time.

```cpp
    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {
        //the depth of the tree structure with each 
        vector<vector<int>> adj(n);
        for(int i=0;i<manager.size();i++)
            if(manager[i]>=0) adj[manager[i]].push_back(i);
        //dfs to get the max sum
        int ans=0;
        //cout<<"OK";
        return dfs(adj,informTime,headID);
        
    }
    int dfs(vector<vector<int>>& adj,vector<int>& time,int root){
        int ans=0;
        for(int ch: adj[root]){
            ans=max(ans,time[root]+dfs(adj,time,ch));
        }
        return ans;
    }
```

### 1377. Frog Position After T Seconds
<em>
Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from the vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. 

The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi.

Return the probability that after t seconds the frog is on the vertex target.
</em>

Approach:

- it forms a n-ary tree.
- bfs to get layer by layer
- when T elapsed, and node is not reached, probability is 0
- when T elasped, and node is reached, probability is PI(1/Ni) Ni is the number of node at layer i.
- when T not elapsed, and node is reached, probability is 0
wrong: Ni shall not be the number of nodes in each layer, only the subtree.
it is easy from target to root, but we need also number of child and a directed tree.
dfs is better suited.

```cpp
class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        vector<vector<int>> tree(n);
        for(auto t: edges){
            tree[t[0]-1].push_back(t[1]-1);
            tree[t[1]-1].push_back(t[0]-1);
        }
        target--;
        vector<bool> v(n);
        return dfs(tree,0,t,target,n,v);
    }
    double dfs(vector<vector<int>>& tree,int root,int t,int target,int n,
               vector<bool>& v){
        double ans=0.0;
        //cout<<root+1<<": "<<t<<endl;
        if(t==0) return root==target?1:0;
        if(t<0) return 0;
        v[root]=1;
        int nchild=tree[root].size()-1;
        if(!root) nchild++;
        if(nchild==0) return t>=0 && target==root?1:0;//it is a leaf node, nowhere to go.
        for(int child: tree[root]){
            if(v[child]==0){
                double tt=dfs(tree,child,t-1,target,n,v)/nchild;
                ans+=tt;
            }
        }
        //cout<<"Prob: "<<root+1<<" "<<ans<<endl;
        return ans;
    }
};
```
- note: when the target is a leaf node, and t>=0, then shall return 1.0

## contest 181

### 1380. Lucky Numbers in a Matrix
<em>
Given a m * n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
</em>

- we can use number directly since there is no duplicates
- using hashmap

```cpp
    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        vector<int> ans;
        unordered_set<int> mn;
        int m=matrix.size(),n=matrix[0].size();
        for(int i=0;i<matrix.size();i++){
            int ind=*min_element(begin(matrix[i]),end(matrix[i]));//-begin(matrix[i]);
            mn.insert(ind);
            //cout<<matrix[i][ind]<<endl;
        }
        for(int i=0;i<matrix[0].size();i++){
            int ind=0;
            int max0=matrix[0][i];
            for(int j=1;j<matrix.size();j++){
                if(matrix[j][i]>max0) {
                    max0=matrix[j][i];
                    ind=i+j*n;
                }
            }   
            //cout<<max0<<endl;
            if(mn.count(max0)) ans.push_back(max0);
                        
        }
        return ans;
    }
```

### 1381. Design a Stack With Increment Operation
<em>
Design a stack which supports the following operations.

Implement the CustomStack class:

- CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize.
- void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize.
- int pop() Pops and returns the top of stack or -1 if the stack is empty.
void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.
</em>	

use two stack approach, not optimized:

```cpp
    stack<int> st1,st2;
    int size;
    CustomStack(int maxSize) {
        size=maxSize;
    }
    
    void push(int x) {
        if(st1.size()<size){
            st1.push(x);
        }
    }
    
    int pop() {
        if(st1.size()){
            int x=st1.top();
            st1.pop();
            return x;
        }
        return -1;
    }
    
    void increment(int k, int val) {
        while(st1.size()){
            int x=st1.top();
            st1.pop();
            st2.push(x);
        }
        while(st2.size() && k--){
            st1.push(st2.top()+val);
            st2.pop();
        }
        while(st2.size()) {
            st1.push(st2.top());
            st2.pop();
        }
    }
```

### 1382. Balance a Binary Search Tree
<em>
Given a binary search tree, return a balanced binary search tree with the same node values.

A binary search tree is balanced if and only if the depth of the two subtrees of every node never differ by more than 1.

If there is more than one answer, return any of them.
</em>

- reoganize the tree
- convert to sorted array and then convert to balanced BST.

```cpp
    TreeNode* balanceBST(TreeNode* root) {
        //put in an array and recursively balance it
        vector<int> arr;
        inorder(root,arr);
        int n=arr.size();
        return build(arr,0,n);
    }
    void inorder(TreeNode* root,vector<int>& arr){
        if(!root) return;
        inorder(root->left,arr);
        arr.push_back(root->val);
        inorder(root->right,arr);
    }
    TreeNode* build(vector<int>& arr,int l,int r){
        if(l>=r) return 0;
        int m=(l+r)/2;
        TreeNode* root=new TreeNode(arr[m]);
        
        root->left=build(arr,l,m);
        root->right=build(arr,m+1,r);
        return root;
    }
```

### 1383. Maximum Performance of a Team
<em>
There are n engineers numbered from 1 to n and two arrays: speed and efficiency, where speed[i] and efficiency[i] represent the speed and efficiency for the i-th engineer respectively. Return the maximum performance of a team composed of at most k engineers, since the answer can be a huge number, return this modulo 10^9 + 7.

The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers. 
</em>

- this is a very good question.
- bind the speed and efficiency.
- sort according to efficiency in decreasing order, so we know next will be lower efficiency person
- add k person into heap (sorted by speed)
- add one person into heap and pop the one with min speed.
- the key part: we need to get the max every time we add a person to the min heap.

```cpp
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        priority_queue<int, vector<int>, greater<int>> heap;
        vector<vector<int>> worker;
        vector<int> tmp(2,0);
        for (int i = 0; i < n; i++) {
            tmp[0] = speed[i];
            tmp[1] = efficiency[i];
            worker.push_back(tmp);
        }
        sort(worker.begin(), worker.end(), compare);
        long res = 0;
        long total = 0;
        long minE;
        for (int i = 0; i < k; i++) {
            total += worker[i][0];
            minE = worker[i][1];
            res = max(res, total*minE);
            heap.push(worker[i][0]);
        }
        for (int i = k; i < n; i++) {
            if (worker[i][0] > heap.top()) {
                total += (-heap.top()+worker[i][0]);
                minE = worker[i][1];
                res = max(res, total*minE);
                heap.pop();
                heap.push(worker[i][0]);
            }
        }
        return (int)(res%1000000007);
    }
```	

## contest 181

### 1389. Create Target Array in the Given Order
<em>
Given two arrays of integers nums and index. Your task is to create target array under the following rules:

Initially target array is empty.
From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
Repeat the previous step until there are no elements to read in nums and index.
Return the target array.

It is guaranteed that the insertion operations will be valid
</em>

- just simulate the array growing and insersion.

```cpp
    vector<int> createTargetArray(vector<int>& nums, vector<int>& index) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            ans.insert(ans.begin()+index[i],nums[i]);
        }
        return ans;
    }
```

### 1390. Four Divisors
<em>
Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors.

If there is no such integer in the array, return 0.
</em>

- 4 divisors, 1 and itself, so we only need find two divisors
- if it is a square number, then it will have odd number of divisors

```cpp
    int sumFourDivisors(vector<int>& nums) {
        //squares are not conisdered.
        int ans=0;
        for(int i: nums){
            int cnt=2;
            int i2=sqrt(i);
            if(i2*i2==i) continue;
            vector<int> vt;
            for(int j=2;j<=i2;j++){
                if(i%j==0) {
                    cnt+=2;
                    vt.push_back(j);
                    vt.push_back(i/j);
                }
                if(cnt>4) break;
            }
            if(cnt==4) {
                ans+=1+i+vt[0]+vt[1];
                //cout<<i<<" "<<vt[0]<<" "<<vt[1]<<endl;
            }
        }
        return ans;
    }
```

### 1391. Check if There is a Valid Path in a Grid
<em>
Given a m x n grid. Each cell of the grid represents a street. The street of grid[i][j] can be:
1 which means a street connecting the left cell and the right cell.
2 which means a street connecting the upper cell and the lower cell.
3 which means a street connecting the left cell and the lower cell.
4 which means a street connecting the right cell and the lower cell.
5 which means a street connecting the left cell and the upper cell.
6 which means a street connecting the right cell and the upper cell.

You will initially start at the street of the upper-left cell (0,0). A valid path in the grid is a path which starts from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.

Notice that you are not allowed to change any street.

Return true if there is a valid path in the grid or false otherwise.
</em>

dumb bfs approach:
- the road needs to be able to connect.
- put connected cells into queue.

```cpp
    bool hasValidPath(vector<vector<int>>& grid) {
        //bfs
        int m=grid.size(),n=grid[0].size();
        queue<int> q;
        vector<bool> v(m*n);
        q.push(0);
        v[0]=1;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        while(q.size()){
            int sz=q.size();
            while(sz--){
                int p=q.front();
                q.pop();
                int x=p/n,y=p%n;
                if(x==m-1 && y==n-1) return 1;
                for(auto d: dir){
                    int x0=x+d[0],y0=y+d[1];
                    //check if the two cells are connected
                    if(x0<0 || y0<0 || x0>=m ||y0>=n || v[x0*n+y0]) continue;
                    bool valid=0;
                    if(grid[x][y]==1){
                        valid=(d[1]>0 && (grid[x0][y0]==1 || grid[x0][y0]==3 || grid[x0][y0]==5)) ||
                        (d[1]<0 && (grid[x0][y0]==1 || grid[x0][y0]==4 || grid[x0][y0]==6));
                    }
                    else if(grid[x][y]==2){
                        valid=(d[0]>0 && (grid[x0][y0]==2 || grid[x0][y0]==5 || grid[x0][y0]==6)) ||
                        (d[0]<0 && (grid[x0][y0]==2 || grid[x0][y0]==3 || grid[x0][y0]==4));
                    }
                    else if(grid[x][y]==3){
                        valid=(d[1]<0 && (grid[x0][y0]==1 || grid[x0][y0]==4 || grid[x0][y0]==6)) ||
                        (d[0]>0 && (grid[x0][y0]==2 || grid[x0][y0]==5 || grid[x0][y0]==6));
                    }
                    else if(grid[x][y]==4){
                        valid=(d[1]>0 && (grid[x0][y0]==1 || grid[x0][y0]==3 || grid[x0][y0]==5)) ||
                        (d[0]>0 && (grid[x0][y0]==2 || grid[x0][y0]==5 || grid[x0][y0]==6));
                    }
                    else if(grid[x][y]==5){
                        valid=(d[0]<0 && (grid[x0][y0]==2 || grid[x0][y0]==3 || grid[x0][y0]==4)) ||
                        (d[1]<0 && (grid[x0][y0]==1 || grid[x0][y0]==4 || grid[x0][y0]==6));
                    }
                    else {
                        valid=(d[0]<0 && (grid[x0][y0]==2 || grid[x0][y0]==3 || grid[x0][y0]==4)) ||
                        (d[1]>0 && (grid[x0][y0]==1 || grid[x0][y0]==3 || grid[x0][y0]==5));
                    }
                    
                    
                    if(valid){
                        q.push(x0*n+y0);
                        v[x0*n+y0]=1;
                    }
                }
            }
        }
        return 0;
    }
```	

upscaled bfs: we can divide each cell by 3x3 and then it is much easier.

smarter way: union-find, union the connected cells and check if top left and bottom right are in the same set.
lee215 use upscaled 2x2 approach + union-find.

### 1392. Longest Happy Prefix
<em>
A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).

Given a string s. Return the longest happy prefix of s .

Return an empty string if no such prefix exists.
</em>

- rolling hash: treat the letter as a digit (base-26).
```cpp
    string longestPrefix(string s) {
        long h1 = 0, h2 = 0, mul = 1, base = 26, mod = 1e9 + 7, len = s.length(), ans = 0;
        for(int i = 0; i < len-1; i++) {
            h1 = (h1*base + (s[i]-'a' + 1))%mod;
            h2 = (h2 + (s[len-i-1]-'a'+1) * mul)%mod;
            mul = mul*base%mod;
            if(h1 == h2) ans = i + 1;
        }
        return s.substr(0, ans);
    }
```

	
	
## contest 182

### 1394. Find Lucky Integer in an Array
<em>
Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value.

Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return -1.
</em>

- using hashmap (or map)

```cpp
    int findLucky(vector<int>& arr) {
        map<int,int> mp;
        for(int i: arr) mp[i]++;
        for(auto it=mp.rbegin();it!=mp.rend();it++){
            if(it->first==it->second) return it->first;
        }
        return -1;
    }
```

### 1395. Count Number of Teams
<em>
There are n soldiers standing in a line. Each soldier is assigned a unique rating value.

You have to form a team of 3 soldiers amongst them under the following rules:

Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
A team is valid if:  (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams)
</em>

- brutal force: just count its left and right
- I used set, although searching is log(n) but get the distance is still O(N)

```cpp
    int numTeams(vector<int>& rating) {
        //for each number check number of smaller than it and number of larger in right
        int ans=0;
        set<int> left,right;
        left.insert(rating[0]);
        for(int i=1;i<rating.size();i++) right.insert(rating[i]);
        for(int i=1;i<rating.size();i++){
            right.erase(rating[i]);
            auto pit=left.equal_range(rating[i]); //>
            auto pit1=right.equal_range(rating[i]);//>
            int t0=distance(left.begin(),pit.first);
            int t1=distance(pit1.second,right.end());
            int t2=distance(pit.second,left.end());
            int t3=distance(right.begin(),pit1.first);
            ans+=t0*t1+t2*t3;
            left.insert(rating[i]);
        }
        return ans;
    }
```

### 1396. Design Underground System
<em>
Implement the class UndergroundSystem that supports three methods:

1. checkIn(int id, string stationName, int t)

A customer with id card equal to id, gets in the station stationName at time t.
A customer can only be checked into one place at a time.
2. checkOut(int id, string stationName, int t)

A customer with id card equal to id, gets out from the station stationName at time t.
3. getAverageTime(string startStation, string endStation) 

Returns the average time to travel between the startStation and the endStation.
The average time is computed from all the previous traveling from startStation to endStation that happened directly.
Call to getAverageTime is always valid.
You can assume all calls to checkIn and checkOut methods are consistent. That is, if a customer gets in at time t1 at some station, then it gets out at time t2 with t2 > t1. All events happen in chronological order.
</em>

- using two hashmap in and out.
- note the submitted solution cannot deal with the same id, multiple times.

```cpp
    unordered_map<string,unordered_map<int,int>> in,out;
    UndergroundSystem() {
        
    }
    
    void checkIn(int id, string stationName, int t) {
        in[stationName][id]+=t;
    }
    
    void checkOut(int id, string stationName, int t) {
        out[stationName][id]+=t;
    }
    
    double getAverageTime(string startStation, string endStation) {
        double ans=0;
        int n=0;
        for(auto t: in[startStation]){
            int id=t.first;
            if(out[endStation].count(id)) {
                ans+=out[endStation][id]-in[startStation][id];
                n++;
            }
        }
        return ans/n;
    }
```

better approach:

```cpp
    unordered_map<string, pair<int, int>> checkoutMap; // Route - {TotalTime, Count}
    unordered_map<int, pair<string, int>> checkInMap; // Uid - {StationName, Time}
    
    UndergroundSystem() {}
    
    void checkIn(int id, string stationName, int t) {
        checkInMap[id] = {stationName, t};
    }
    
    void checkOut(int id, string stationName, int t) {
        auto& checkIn = checkInMap[id];
        string route = checkIn.first + "_" + stationName;
        checkoutMap[route].first += t - checkIn.second;
        checkoutMap[route].second += 1;
    }
    
    double getAverageTime(string startStation, string endStation) {
        string route = startStation + "_" + endStation;
        auto& checkout = checkoutMap[route];
        return (double) checkout.first / checkout.second;
    }
```

### 1397. Find All Good Strings
<em>
Given the strings s1 and s2 of size n, and the string evil. Return the number of good strings.

A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 10^9 + 7.
</em>

This is a dp problem, but I cannot get it correct yet.

- two subproblem: less(s2,evil)-less(s1,evil)+s2.find(evil)
- less(s,evil) is to count the number of string which does not include evil as substring
- less(s,evil)=less(s)-less_has(s,evil)
- less(s) is easy to solve
- less_has(s,evil) evil string will divide the problem into two subproblem.

```cpp
    int mod = 1e9+7, m;
    vector<long> power{1};
    unordered_map<string, long> dic;
public:
    int findGoodStrings(int n, string s1, string s2, string evil) {
        for (int i = 0; i < n + 1; i++){
            power.push_back((power.back()*26) % mod);
        }
        m = evil.size();
        long ans =  (count(s2) - helper(s2, evil) - (count(s1) - helper(s1, evil)))%mod;
        if (s1.find(evil) == string::npos) ans ++;
        return (ans < 0) ? ans + mod: ans%mod;
    }


    long count(string s){
        long ans = 0;
        for (auto x: s){
            ans = (ans*26 + (x - 'a')) % mod;
        }
        return (ans + 1) % mod;
    }

    long helper(string s, string& e){
        if (dic.find(s) != dic.end()) return dic[s];
        int l = s.size();
        long a, b, c;
        if (l < m) return 0;
        if (l == m) return e <= s ? 1 : 0;
        b = (helper(s.substr(1), e) + (s[0] - 'a')*helper(string(l-1, 'z'), e)) % mod;
        if (s.substr(0, m) < e){
            dic[s] = b;
            return b ;
        }
        if (s.substr(0, m) == e){
            a = count(s.substr(m));
            c = (helper( e.substr(1) + s.substr(m), e) - helper(e.substr(1) + string(l - m,'a'), e)) % mod;
            if ((e.substr(1) + string(l - m, 'a')).find(e) != string::npos) c++;
        }
        else{
            a = power[l - m];
            c = (helper(e.substr(1) + string(l - m, 'z'), e) - helper(e.substr(1) + string(l-m,'a'), e)) % mod;
            if ((e.substr(1) + string(l-m,'a')).find(e) != string::npos) c++;
        }
        dic[s] = (a + b - c) % mod;
        return dic[s];
    }
```	


	
	
## contest 183 4/4/2020

### 1403. Minimum Subsequence in Non-Increasing Order
<em>
Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. 

If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. 

Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.
</em>

straightforward: sort and try largest first

```cpp
    vector<int> minSubsequence(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int tsum=accumulate(begin(nums),end(nums),0);
        int sum=0;
        vector<int> ans;
        for(int i=nums.size()-1;i>=0;i--){
            sum+=nums[i];
            ans.push_back(nums[i]);
            if(sum>tsum-sum) return ans;
        }
        return ans;
    }
```

### 1404. Number of Steps to Reduce a Number in Binary Representation to One

<em>
Given a number s in their binary representation. Return the number of steps to reduce it to 1 under the following rules:

If the current number is even, you have to divide it by 2.

If the current number is odd, you have to add 1 to it.

It's guaranteed that you can always reach to one for all testcases.
</em>

brutal force: string operations.

```cpp
    int numSteps(string s) {
        int ans=0;
        //number would be very large.
        while(s.size()>1){
            if(s.back()=='1') inc(s);
            else s.pop_back();
            ans++;
            //cout<<s<<endl;
        }
        if(s[0]=='0') ans++;
        return ans;
    }
    void inc(string& s){
        int cf=1;
        int i=s.size()-1;
        while(i>=0 && cf){
            int d=cf^(s[i]-'0');
            cf=cf&(s[i]-'0');
            s[i]='0'+d;
            i--;
        }
        if(cf) s="1"+s;
        //return s;
    }
```

smart way: do not have to simulate, but use a cf:
- if last bit is 0, discard it
- if last bit is 1, discard it but cf=1 to bring forward
- this optimize to O(N)

```cpp
int numSteps(string &s) {
    int res = 0, carry = 0;
    for (auto i = s.size() - 1; i > 0; --i) {
        ++res;
        if (s[i] - '0' + carry == 1) {
            carry = 1;
            ++res;
        }
    }
    return res + carry;
}
```

### 1405. Longest Happy String
<em>

A string is called happy if it does not have any of the strings 'aaa', 'bbb' or 'ccc' as a substring.

Given three integers a, b and c, return any string s, which satisfies following conditions:

s is happy and longest possible.
s contains at most a occurrences of the letter 'a', at most b occurrences of the letter 'b' and at most c occurrences of the letter 'c'.
s will only contain 'a', 'b' and 'c' letters.
If there is no such string s return the empty string ""

</em>

Approach:

- priority_queue: try to use the most frequent one first
- if the second one is one or zero less, we have to use 2 of it
otherwise we use one of it ( to make sure we have longest string and no violation)

```cpp
    string longestDiverseString(int a, int b, int c) {
        //always use the max one first two
        priority_queue<vector<int>> pq;
        if(a) pq.push({a,0});
        if(b) pq.push({b,1});
        if(c) pq.push({c,2});
        string s;
        while(pq.size()){
            auto t=pq.top();
            pq.pop();
            s.append(min(t[0],2),'a'+t[1]);
            
            if(pq.size()){
                auto t1=pq.top();
                pq.pop();
                //next time it may get 3 if it is max
                int next=0;
                if(t1[0]+1>=t[0]) next=min(t1[0],2);
                else next=min(t1[0],1);
                s.append(next,'a'+t1[1]);//to make sure it is smaller
                t[0]-=min(t[0],2);
                t1[0]-=next;
                if(t1[0]) pq.push(t1);
                if(t[0]) pq.push(t);
            }
        }
        return s;
    }
```

without using pq:
```cpp
string longestDiverseString(int a, int b, int c, char aa = 'a', char bb = 'b', char cc = 'c') {
    if (a < b)
        return longestDiverseString(b, a, c, bb, aa, cc);
    if (b < c)
        return longestDiverseString(a, c, b, aa, cc, bb);
    if (b == 0)
        return string(min(2, a), aa);
    auto use_a = min(2, a), use_b = a - use_a >= b ? 1 : 0; 
    return string(use_a, aa) +  string(use_b, bb) + 
		longestDiverseString(a - use_a, b - use_b, c, aa, bb, cc);
}
```

### 1406. Stone Game III

<em>

Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.

Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.

The score of each player is the sum of values of the stones taken. The score of each player is 0 initially.

The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.

Assume Alice and Bob play optimally.

Return "Alice" if Alice will win, "Bob" if Bob will win or "Tie" if they end the game with the same score.
</em>


Approach:

- dynamic programming
- 	use bob's score as negative and accumulate the scores.

```cpp
    string stoneGameIII(vector<int>& stoneValue) {
        //dp: both plays optimally
        int n=stoneValue.size();
        vector<int> mem(n,INT_MIN);
        int ans=dp(stoneValue,0,mem);
        if(ans>0) return "Alice";
        else if(ans<0) return "Bob";
        return "Tie";
    }
    int dp(vector<int>& stone,int start,vector<int>& mem){
        int ans=INT_MIN;
        if(start>=stone.size()) return 0;
        if(mem[start]>INT_MIN) return mem[start];
        //choose 1,2,3
        int sum=0;
        for(int i=start;i<min(start+3,(int)stone.size());i++){
            sum+=stone[i];
            ans=max(ans,sum-dp(stone,i+1,mem));
        }
        return mem[start]=ans;
    }
```	
- it is essential to initialize as INT_MIN instead of 0.
	

## contest 184

### 1408. String Matching in an Array
<em>
Given an array of string words. Return all strings in words which is substring of another word in any order. 

String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j].

 

Example 1:

Input: words = ["mass","as","hero","superhero"]
Output: ["as","hero"]
Explanation: "as" is substring of "mass" and "hero" is substring of "superhero".
["hero","as"] is also a valid answer.
</em>

Intuition:
- apparently only shorter ones can be substring of another string
O(N^2) brutal force

```cpp
    vector<string> stringMatching(vector<string>& words) {
        vector<string> ans;
        sort(words.begin(),words.end(),[](string& a,string &b){
            return a.size()<b.size();
        });
        for(int i=0;i<words.size();i++){
            for(int j=i+1;j<words.size();j++){
                if(words[j].find(words[i])!=string::npos){
                    ans.push_back(words[i]);
                    break;
                }
            }
        }
        return ans;
    }
```	

can also use suffix tree to store all suffix in the trie.
overkill for an easy problem

### 1409. Queries on a Permutation With Key
<em>
Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:

In the beginning, you have the permutation P=[1,2,3,...,m].
For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].
Return an array containing the result for the given queries.

 

Example 1:

Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  
</em>

Approach: simulation of the query. using hashmap to record the value vs index.

```cpp
    vector<int> processQueries(vector<int>& queries, int m) {
        unordered_map<int,int> v2i,i2v;
        for(int i=0;i<m;i++) {
            v2i[i+1]=i;//val vs index
            i2v[i]=i+1;
        }
        vector<int> ans;
        for(int q:queries){
            int ind=v2i[q];
            int val=i2v[0];
            //not swapping but move to the head
            for(int i=ind;i>0;i--){
                swap(v2i[i2v[i]],v2i[i2v[i-1]]);
                swap(i2v[i],i2v[i-1]);
            }
            ans.push_back(ind);
        }
        return ans;
    }
```

This is brutal force and has a complexity of O(N^2)
to have a better efficiency for removing a node and insert a node, we can use linked_list
better approach using binary index tree or Fenwick tree,

### 1410. HTML Entity Parser
<em>
HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.

The special characters and their entities for HTML are:

Quotation Mark: the entity is &quot; and symbol character is ".
Single Quote Mark: the entity is &apos; and symbol character is '.
Ampersand: the entity is &amp; and symbol character is &.
Greater Than Sign: the entity is &gt; and symbol character is >.
Less Than Sign: the entity is &lt; and symbol character is <.
Slash: the entity is &frasl; and symbol character is /.
Given the input text string to the HTML parser, you have to implement the entity parser.

Return the text after replacing the entities by the special characters.
</em>

straightforward: find and mark all position and replace from right to left.
cannot do inplace find and replace.

```cpp
    string entityParser(string text) {
        unordered_map<string,string> dict;
        dict.insert({"&quot;","\""});
        dict.insert({"&apos;","\'"});
        dict.insert({"&amp;","&"});
        dict.insert({"&gt;",">"});
        dict.insert({"&lt;","<"});
        dict.insert({"&frasl;","/"});
        string ans;
        for(auto t: dict){
            string patt=t.first,rep=t.second;
            int start=0;
            vector<int> pos;
            while(start<text.size()){
                start=text.find(patt,start);
                if(start==string::npos) break;
                pos.push_back(start);
                start+=patt.size();
            }
            for(int i=pos.size()-1;i>=0;i--){
                text.replace(pos[i],patt.size(),rep);
            }
        }
        return text;
    }
```	
	
### 1411. Number of Ways to Paint N × 3 Grid
<em>
You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colours: Red, Yellow or Green while making sure that no two adjacent cells have the same colour (i.e no two cells that share vertical or horizontal sides have the same colour).

You are given n the number of rows of the grid.

Return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 10^9 + 7.
</em>

Intuition: dp approach
- each layer can only have two choices: aba, abc
- aba: a has 3 options, b has 2 options total 6. abc has 3x2x1=6 options
- if previous one is aba, current layer can be aba and abc.
for example previous is RGR, current layer can be:
first can be G and B, second one can be B and R. third one can be G and B

G-B-G
  R-G
    B
B-R-G
    B
that is 3 type of aba and 2 type of abc

if previous is abc, for example RGB
then first one can be GB, secnd one can be RB, third one can be RG.
GRG
GBG
GBR
BRG

that is 2 types of aba and 2 types of abc

aba=6,abc=6 for n=1;
next layer: aba=4*aba+3*abc, abc=aba+2*abc
```cpp
    int numOfWays(int n) {
		int mod=1e9+7;
		vector<long> aba(n+1),abc(n+1);
		aba[1]=abc[1]=6;
		for(int i=2;i<=n;i++){
			aba[i]=3*aba[i-1]+2*abc[i-1];
			abc[i]=2*aba[i-1]+2*abc[i-1];
			aba[i]%=mod;
			abc[i]%=mod;
		}
		return (aba[n]+abc[n])%mod;
    }
```	
and this can reduce to O(1) space.
## contest 185
### 1417. Reformat The String
<em>
Given alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).

You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.

Return the reformatted string or return an empty string if it is impossible to reformat the string
</em>

straightforward, divide into letters and numbers. if number is longer,try number first

```cpp
    string reformat(string s) {
        string lett,num;
        for(char c: s){
            if(c>='0'&&c<='9') num+=c;
            else lett+=c;
        }
        if(abs((int)lett.size()-(int)num.size())>1) return "";
        if(lett.size()<num.size()) swap(lett,num);
        int i=0,j=0;
        string ans;
        while(i<lett.size()||j<num.size()) {
            if(i<lett.size()) ans+=lett[i++];
            if(j<num.size()) ans+=num[j++];
        }
        return ans;
    }
```

### 1418. Display Table of Food Orders in a Restaurant
<em>
Given the array orders, which represents the orders that customers have done in a restaurant. More specifically orders[i]=[customerNamei,tableNumberi,foodItemi] where customerNamei is the name of the customer, tableNumberi is the table customer sit at, and foodItemi is the item customer orders.

Return the restaurant's “display table”. The “display table” is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is “Table”, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.
</em>

hashmap approach

```cpp
    vector<vector<string>> displayTable(vector<vector<string>>& orders) {
        vector<vector<string>> ans;
        map<int,unordered_map<string,int>> table;
        set<string> food;
        for(auto o: orders){
            table[stoi(o[1])][o[2]]++;
            food.insert(o[2]);
        }
        ans.push_back({});
        ans[0].push_back("Table");
        vector<string> vt(food.size()+1);
        for(auto s: food) ans[0].push_back(s);
        for(auto t: table){
            vt[0]=to_string(t.first);
            int i=1;
            for(auto s: food){
                if(t.second.count(s)) vt[i]=to_string(t.second[s]);
                else vt[i]="0";
                i++;
            }
            ans.push_back(vt);
        }
        return ans;
    }
```

### 1419. Minimum Number of Frogs Croaking
<em>
Given the string croakOfFrogs, which represents a combination of the string "croak" from different frogs, that is, multiple frogs can croak at the same time, so multiple “croak” are mixed. Return the minimum number of different frogs to finish all the croak in the given string.

A valid "croak" means a frog is printing 5 letters ‘c’, ’r’, ’o’, ’a’, ’k’ sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of valid "croak" return -1.
</em>

this is similar to segment overlap. a segment starts with c and end with k.
also we need keep the ordering or croak
```cpp
    int minNumberOfFrogs(string croakOfFrogs) {
        //if overlapped, non-overlapped
        int cnt[5]={0};
        for(char c: croakOfFrogs){
            if(c=='c') cnt[0]++;
            else if(c=='r') cnt[1]++;
            else if(c=='o') cnt[2]++;
            else if(c=='a') cnt[3]++;
            else if(c=='k') cnt[4]++;
            else return -1;
            //the count needs to keep cnt[0]>=cnt[1]>=cnt[2]>=cnt[3]>=cnt[4]
            for(int i=0;i<4;i++){
                if(cnt[i]<cnt[i+1]) return -1;
            }
        }
        if(cnt[1]!=cnt[0] || cnt[2]!=cnt[0] || cnt[3]!=cnt[0] || cnt[4]!=cnt[0]) return -1;
        //using hashmap to record, when we see a k, we need end a word. when we see a c, we need start a word
        int ans=0;
        int pref=0;
        for(char c: croakOfFrogs){
            if(c=='c') pref++;
            if(c=='k') pref--;
            ans=max(ans,pref);
        }
        return ans;
    }
```

### 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons
<em>
Given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:
```cpp
	max=-1;
	mind=-1;
	cost=0;
	n=arr.size();
	for(int i=0;i<n;i++){
		if(max<arr[i]){
			max=arr[i];
			mind=i;
			cost++;
		}
	}
	return mind;
```
You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 10^9 + 7.	
</em>

Intuition: 3d dp problem
dp[i,j,k] i for length of the array, j: the max, k: the cost
base: i=1 just one element
final answer: dp[n,j,K] fix i and k but sum on all j.

```cpp
    long dp[51][101][101];
    int numOfArrays(int n, int m, int k) {
        int mod=1e9+7;
        //search cost=k, n: length, m: max
        //dp top down: number of ways
        //dp[i][j][k]: i length of array, j:the max value? k: the cost so far
        memset(dp,0,51*101*101*sizeof(long));
        //base case: k=0: the first element must be the max. (not a base casse)
        //base case: i=0,j=0,k=0, dp[0][0][0]=1
        //base case dp[0][x][y]=0, dp[]
        //dp[0][0][0]=1;
        for (int j = 1; j <= m; j++)
            dp[1][j][1] = 1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=m;j++){
                for(int l=1;l<=min(k,i);l++){ //cost is most the same as i
                    //current one contribute a cost or 0 cost
                    for(int a=1;a<j;a++){
                        dp[i][j][l]+=dp[i-1][a][l-1]; //current one is a cost, then it is the max, the previous could from 1 to j-1
                        dp[i][j][l]%=mod;
                    }
                    dp[i][j][l]+=j*dp[i-1][j][l]%mod; //current one is not a cost, the max is still the same, we can choose 1 to j         
                    dp[i][j][l]%=mod;
                }
            }
        }
        long ans=0;
        for(int j=1;j<=m;j++) ans+=dp[n][j][k]%mod,ans%=mod;
        return ans;
    }
```
	
## contest 186

### 1422. Maximum Score After Splitting a String
<em>
Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.
</em>

suppose the input length=n, and we have m 1s and n-m 0s
we just count 1s in the left for example:
length i, j 1s, i-j 0s

```cpp
    int maxScore(string s) {
        int ans=0;
        int sum=0,n=s.size();
        for(char c: s) sum+=c=='1';
        int prefix=s[0]=='1';
        ans=max(ans,1+sum-2*prefix);
        for(int i=1;i<s.size()-1;i++){
            prefix+=s[i]=='1';
            ans=max(ans,i+1-prefix+sum-prefix);
        }
        return ans;
    }
```

### 1423. Maximum Points You Can Obtain from Cards	
<em>
There are several cards arranged in a row, and each card has an associated number of points The points are given in the integer array cardPoints.

In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.

Your score is the sum of the points of the cards you have taken.

Given the integer array cardPoints and the integer k, return the maximum score you can obtain.
</em>

Equivalently we are looking for the min window sum with window size n-k.
dp will TLE for this.

```cpp
    int maxScore(vector<int>& cardPoints, int k) {
        int sum=accumulate(begin(cardPoints),end(cardPoints),0);
        int wsum=0,n=cardPoints.size();
        int ans=INT_MAX;
        k=n-k;
        for(int i=0;i<n;i++){
            wsum+=cardPoints[i];
            if(i>=k-1) {
                if(i>=k) wsum-=cardPoints[i-k];
                ans=min(ans,wsum);
            }
        }
        return sum-ans;
    }
```	
be careful sliding window sum, k-1 and >k-1 two cases

### 1424. Diagonal Traverse II
<em>
Given a list of lists of integers, nums, return all elements of nums in diagonal order as shown in the below images.
</em>

approach 1: sort by r+c, O(nlogn)
```cpp
    vector<int> findDiagonalOrder(vector<vector<int>>& nums) {
        //diagonal i+j=const
        int n=nums.size();
        //sort the matrix in i+j order
        vector<vector<int>> mat;
        for(int i=0;i<n;i++){
            for(int j=0;j<nums[i].size();j++) 
                mat.push_back({i,j,nums[i][j]});
        }
        sort(begin(mat),end(mat),[](vector<int>& a,vector<int>& b){
            return a[0]+a[1]<b[0]+b[1] || (a[0]+a[1]==b[0]+b[1] && a[0]>b[0]);
        });
        vector<int> ans;
        for(auto t: mat) ans.push_back(t[2]);
        return ans;
    }
```
This one TLE

Approach 2: BFS
starting from i+j=0 to infinite
O(N): add its down first and then its right
we can use hashset as visited to avoid duplicates.
bfs: think it as tree
```python
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        ans = []
        m = len(nums)
        
        queue = collections.deque([(0, 0)])
        while queue:
            row, col = queue.popleft()
            ans.append(nums[row][col])
            # we only add the number at the bottom if we are at column 0
            if col == 0 and row + 1 < m:
                queue.append((row + 1, col))
            # add the number on the right
            if col + 1 < len(nums[row]):
                queue.append((row, col + 1))
            
        return an
```

### approach: hashmap
```cpp
vector<int> findDiagonalOrder(vector<vector<int>>& nums) {
        vector<int> answer;
        unordered_map<int, vector<int>> m;
        int maxKey = 0; // maximum key inserted into the map i.e. max value of i+j indices.
        
        for (int i=0; i<nums.size(); i++) {
            for (int j=0; j<nums[i].size(); j++) {
                m[i+j].push_back(nums[i][j]); // insert nums[i][j] in bucket (i+j).
                maxKey = max(maxKey, i+j); // 
            }
        }
        for (int i=0; i<= maxKey; i++) { // Each diagonal starting with sum 0 to sum maxKey.
            for (auto x = m[i].rbegin(); x != m[i].rend(); x++) { // print in reverse order.
                answer.push_back(*x); 
            }
        }
        
        return answer;
    }
```

### 1425. Constrained Subsequence Sum
<em>
Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.
</em>

It seems that is a knapsack dp problem. Let's try this approach first.
if we choose ith element, we need ensure previous chosen is >i-k.

let's try top down approach first
```cpp
    int constrainedSubsetSum(vector<int>& nums, int k) {
        int mx=*max_element(begin(nums),end(nums));
        if(mx<0) return mx;
        return helper(nums,-1,0,k);
    }
	int helper(vector<int>& nums,int prev,int start,int k){
		if(start>=nums.size()) return 0; 
		if(prev<0){ //no chosen yet
			return max({nums[start],helper(nums,prev,start+1,k),
			nums[start]+helper(nums,start,start+1,k)});
		}
		if(start>prev+k) return 0; //cannot add
		return max({nums[start],helper(nums,prev,start+1,k),
		nums[start]+helper(nums,start,start+1,k)});
	}
```	
complexity O(2^n)
this will pass the example tests.

add memoization will be able to reduce to O(N^2) [prev][start]
however since n is up to 10^5, the complexity is too high

We really need O(N) or O(nlogn) complexity.
or equivalently we need to find the min sum and the index difference >k.

from the above, we need a 1d dp approach
assuming dp[i] is the maximum sum ending with nums[i], then we choose the max among all dp[i]
for current item, we want to append to previous max with j+k<=i.
if current max is out of range, pop it.
we can use heap or pq to do it.

```cpp
    int constrainedSubsetSum(vector<int>& nums, int k) {
		int n=nums.size();
		vector<int> dp(n);
		int ans=INT_MIN;
		priority_queue<vector<int>> pq; //sum with index
        
		for(int i=0;i<n;i++){
			while(pq.size() && i>pq.top()[1]+k) pq.pop();
			if(pq.empty()) dp[i]=nums[i];
			else dp[i]=max(pq.top()[0],0)+nums[i];
			pq.push({dp[i],i});
			ans=max(ans,dp[i]);
		}
		return ans;
    }
```	
- note: if previous sum is <0, we start a new one. This is very similar to max subarray sum.


hence we see that we are searching for the max, sliding window k.
using deque we can reduce it to O(N)

deque+dp. Monotonic deque
```cpp
    int constrainedSubsetSum(vector<int>& nums, int k) {
		int n=nums.size();
		vector<int> dp(n);
		int ans=INT_MIN;
	    deque<int> dq; //store the dp in the dq    
		for(int i=0;i<n;i++){
			//front
			while(dq.size() && i>dq.front()+k) dq.pop_front();
			if(dq.empty()) dp[i]=nums[i];
			else dp[i]=max(dp[dq.front()],0)+nums[i];
			while(dq.size() && dp[i]>=dp[dq.back()]) dq.pop_back();
			dq.push_back(i);
			ans=max(ans,dp[i]);
		}
		return ans;
    }
```

## contest 187

### 1436. Destination City
<em>
You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.
</em>

approach: count incoming and outcoming edges and the destination is the one with net negative incoming edges
```cpp
    string destCity(vector<vector<string>>& paths) {
        string ans;
        //all appear in-out except one
        unordered_map<string,int> mp;
        for(auto p: paths){
            mp[p[0]]++;
            mp[p[1]]--;
        }
        for(auto t: mp){
            if(t.second<0) return t.first;
        }
        return ans;
    }
```

other approach: using hashset, and check if the right one appears in the left.

### 1437. Check If All 1's Are at Least Length K Places Away
<em>
Given an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.
</em>

approach:

check the distance of 1 to the previous 1.

```cpp
    bool kLengthApart(vector<int>& nums, int k) {
        int prev=-1;
        for(int i=0;i<nums.size();i++){
            if(prev<0 && nums[i]){
                prev=i;
            }
            else if(prev>=0 && nums[i]){
                if(i-prev-1<k) return 0;
                prev=i;
            }
        }
        return 1;
    }
```
O(N)

### 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
<em>
Given an array of integers nums and an integer limit, return the size of the longest continuous subarray such that the absolute difference between any two elements is less than or equal to limit.

In case there is no subarray satisfying the given condition return 0.
</em>

approach 1: deque+binary search O(nlogn)
using binary search to find the largest length. And the problem is equivalent to check 
if the array can satisfy the condition: for the window k, there is one subarray satisfy max-min<=limit
so the problem is to search for max and min in a sliding window.
```cpp
    int longestSubarray(vector<int>& nums, int limit) {
        //the max-min<=k
        int l=1,r=nums.size();
        while(l<r){
            int m=l+(r-l+1)/2;
            if(valid(nums,limit,m)) l=m;
            else r=m-1;
        }
        return l;
    }
    int valid(vector<int>& nums,int limit,int k){
        //using deque to find the max and min in the sliding window
        deque<int> dqmin,dqmax;
        for (int i=0; i<nums.size(); i++) {
            if (!dqmax.empty() && dqmax.front() == i-k) dqmax.pop_front();
            while (!dqmax.empty() && nums[dqmax.back()] < nums[i])
                dqmax.pop_back();
            dqmax.push_back(i);

            if (!dqmin.empty() && dqmin.front() == i-k) dqmin.pop_front();
            while (!dqmin.empty() && nums[dqmin.back()] > nums[i])
                dqmin.pop_back();
            dqmin.push_back(i);
            if (i>=k-1) {
                if(nums[dqmax.front()]-nums[dqmin.front()]<=limit) return 1;
            }
        }
        return 0;        
    }
```	
- uses two deque to find max and min separately. Can we use one to find max and min at the same time?
	
optimization:
- use two deque, but using sliding window O(n) with two pointers:
```cpp
    int longestSubarray(vector<int>& A, int limit) {
        deque<int> maxd, mind;
        int i = 0, j;
        for (j = 0; j < A.size(); ++j) {
            while (!maxd.empty() && A[j] > maxd.back()) maxd.pop_back();
            while (!mind.empty() && A[j] < mind.back()) mind.pop_back();
            maxd.push_back(A[j]);
            mind.push_back(A[j]);
            if (maxd.front() - mind.front() > limit) {
                if (maxd.front() == A[i]) maxd.pop_front();
                if (mind.front() == A[i]) mind.pop_front();
                ++i;
            }
        }
        return j - i;
    }
```	

- using multiset for max/min with sliding window using two pointer O(nlogn)
```cpp
    int longestSubarray(vector<int>& A, int limit) {
        int i = 0, j;
        multiset<int> m;
        for (j = 0; j < A.size(); ++j) {
            m.insert(A[j]);
            if (*m.rbegin() - *m.begin() > limit)
                m.erase(m.find(A[i++]));
        }
        return j - i;
    }
```

### 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows
<em>
You are given an m * n matrix, mat, and an integer k, which has its rows sorted in non-decreasing order.

You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.
[[1,3,11],[2,4,6]], k = 5, answer=7
</em>

This is a very good problem, let's exam the example first
[1,3,11]
[2,4,6]
1st: 1+2=3
then 
we replace 1 with 3: 3+2=5
we replace 2 with 4: 1+4=5
3+2->11+2=13
  |->3+4=7
1+4->3+4=7 (visited)
  |->1+6=7
  
It is a bfs but with the smallest to go first.
The trick is we shall combine the sum with all its elements into one node. 
This is a bit similar to dijkstra

```cpp
    int kthSmallest(vector<vector<int>>& mat, int k) {
        //store sum and all its index in pq
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
        int sum=0;
        int m=mat.size(),n=mat[0].size();
        unordered_set<string> visited;
        vector<int> t(m+1);
        for(int i=0;i<m;i++){
            sum+=mat[i][0];  
            t[i+1]=i*n;
        } 
        t[0]=sum;
        pq.push(t);
        visited.insert(v2s(t));
        //do it like bfs!
        while(k>0){
            auto v=pq.top();
            pq.pop();
            sum=v[0];
            for(int i=1;i<v.size();i++){
                int r=v[i]/n,c=v[i]%n;
                if(c+1<n){
                    v[i]++;
                    if(visited.count(v2s(v))) {
                        v[i]--;
                        continue;
                    }
                    visited.insert(v2s(v));
                    v[0]+=mat[r][c+1]-mat[r][c];
                    pq.push(v);
                    v[0]-=mat[r][c+1]-mat[r][c];
                    v[i]--;
                }
            }
            k--;
        }
        return sum;
    }
    string v2s(vector<int>& t){
        string ans;
        for(int i=1;i<t.size();i++){
            ans+=to_string(t[i])+" ";
        }
        return ans;
    }
```
- I used index array to string for the visited.

complexity: 
we pop a node, then we need add n nodes in. total nodes will up to m*n.
priority_queue add is log time. 
O(m*n*log(m*n))

other approach:
- brutal force: get all combination sums and sort.




 
 

## contest 188

### 1441. Build an Array With Stack Operations
<em>
Given an array target and an integer n. In each iteration, you will read a number from  list = {1,2,3..., n}.

Build the target array using the following operations:

Push: Read a new element from the beginning list, and push it in the array.
Pop: delete the last element of the array.
If the target array is already built, stop reading more elements.
You are guaranteed that the target array is strictly increasing, only containing numbers between 1 to n inclusive.

Return the operations to build the target array.

You are guaranteed that the answer is unique.
</em>

straightforward, just simulate it.
if the number is not inside the target array, push it first and then pop it.

```cpp
    vector<string> buildArray(vector<int>& target, int n) {
        vector<string> ans;
        int start=1;
        for(int i: target){
            for(int j=start;j<i;j++){
                ans.push_back("Push");
                ans.push_back("Pop");
            }
            ans.push_back("Push");
            start=i+1;
        }
        return ans;
    }
```

### 1442. Count Triplets That Can Form Two Arrays of Equal XOR
<em>
Given an array of integers arr.

We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) Where a == b.
</em>

first intuition: using prefix xor (similar to prefix sum)
prefix(i+1)=arr[0]^......^arr[i]	
then prefix(i)^prefix(j)=arr[j]^.....arr[i-1]
then we can loop over j (from 1 to n-1) and separate into three parts
(note the right part can collapse to mid)

```cpp
    int countTriplets(vector<int>& arr) {
        //do it like prefix sum
        //xor(i,j)=pre(j)^pre(i)
        int n=arr.size();
        int ans=0;
        vector<int> pre(n+1);
        for(int i=0;i<n;i++) pre[i+1]=pre[i]^arr[i];
        
        //j start from 1 to n-1 and divide into left and right
        for(int j=1;j<n;j++){
            //left
            //cout<<j<<endl;
            unordered_map<int,int> left;
            for(int i=0;i<j;i++){ //i to j-1
                int t=pre[j]^pre[i];
                left[t]++;
            }
            for(int k=j;k<n;k++){ //j to k, K>=j
                int t=pre[k+1]^pre[j];
                if(left.count(t)) ans+=left[t];
            }
        }
        return ans;
    }
```	
complexity O(N^2)

more optimization -> O(N)
a==b.
means a^b=0, ie from i to k the xor is 0, or we are searching for the number of xor is the same as previous
pre[i]^pre(k+1)=0 with i<j<=k, equivalently the index distance>=2.
j can be any index from i+1 to k so the answer would be k-i-1 for each found region
for example we found three same xor at location a,b,c.
for b: we get b-a-1
for c: we get c-b-1+c-a-1=2*(c-b-1)+(b-a-1)
```cpp
    int countTriplets(vector<int>& A) {
        int n = A.size(), res = 0, prefix = 0;
        unordered_map<int, int> count = {{0, 1}}, total;
        for (int i = 0; i < n; ++i) {
            prefix ^= A[i];
            res += count[prefix]* i - total[prefix];
			count[prefix]++;
            total[prefix] += i + 1;
        }
        return res;
    }
```

### 1443. Minimum Time to Collect All Apples in a Tree
<em>
Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend in order to collect all apples in the tree starting at vertex 0 and coming back to this vertex.

The edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting the vertices fromi and toi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple, otherwise, it does not have any apple.

 </em>

Intuition:

- build a undirectional graph
- dfs from 0 and form a directional tree
- postorder tree traversal. if subtree sum is 0, then root has apple shall be counted, no apple, not counted
if subtree sum is not 0, root node shall be counted
- we are counting edges, so final result shall -1
- return to node 0 we shall double the results.

```cpp
    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
		vector<vector<int>> adj(n);
		for(auto e: edges){
			adj[e[0]].push_back(e[1]);
			adj[e[1]].push_back(e[0]);
		}
		return max(2*(postorder(adj,0,-1,hasApple)-1),0);
    }
	int postorder(vector<vector<int>>& adj,int root,int parent,vector<bool>& hasApple){
		if(adj[root].size()==1 && parent>=0) return hasApple[root];//leaf
		int ans=0;
		for(int child: adj[root]){
			if(child!=parent){
				ans+=postorder(adj,child,root,hasApple);
			}
		}
		if(ans || hasApple[root]) ans++;
		return ans;
	}
```	

Note: leaf only has one child, but the root sometimes may also has only one child.

### 1444. Number of Ways of Cutting a Pizza
<em>
Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. 

For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.

Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.

</em>

Intuition:

clearly this is a dp problem. Every step we have two option: cut horizontally or vertically
every time we need to know: 
cut horizontally, the top piece and remaining piece shall both have apples
cut vertically, the left piece and remaining piece shall both have apples

conveniently if we know the remaining apples,

- first build a postfix sum to get to know number of apples in the matrix from [i,j] to [m-1,n-1]
- recursive dp, depends on k, i, j.

```cpp
    int mod=1e9+7;
    int ways(vector<string>& pizza, int k) {
        //dp: everytime we have two choices, 
        //try recursive 
        //state k, i,j (the top left corner coord)
        int m=pizza.size(),n=pizza[0].size();
        vector<vector<int>> app(m+1,vector<int>(n+1));
        vector<vector<vector<long>>> dp(m,vector<vector<long>>(n,vector<long>(k)));
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                app[i][j]=app[i+1][j]+app[i][j+1]-app[i+1][j+1]+(pizza[i][j]=='A');
            }
        }
        return backtrack(app,k-1,0,0,dp)%mod;
    }
    long backtrack(vector<vector<int>>& app,int k,int i,int j,vector<vector<vector<long>>>& dp){
        if(k==0) {
            return app[i][j]>0;
        }
        if(app[i][j]<k) return 0; //there is no apple
        if(dp[i][j][k]) return dp[i][j][k];
        //now we want apply a cut
        //first cut horizontally
        long ans=0;
        for(int cut=i+1;cut<app.size()-1;cut++){
            //it cut into two parts, both need satisfy the condition
            int t=app[i][j]-app[cut][j];
            if(t==0) continue;
            ans+=backtrack(app,k-1,cut,j,dp)%mod;
            ans%=mod;
        }
        //or we apply cut vertically
        for(int cut=j+1;cut<app[0].size()-1;cut++){
            int t=app[i][j]-app[i][cut];
            if(t==0) continue;
            ans+=backtrack(app,k-1,i,cut,dp)%mod;
            ans%=mod;
        }
        return dp[i][j][k]=ans%mod;
    }
```	

## contest 189

### 1450. Number of Students Doing Homework at a Given Time
<em>
Given two integer arrays startTime and endTime and given an integer queryTime.

The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].

Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.
</em>

- since the length is <100, so we can use brutal force.
sort it, we need find the one with ending time >=querytime

- O(N): just loop over each interval and count those covering the time.

- map approach: startTime++, endTime-- (inclusive endTime+1--)
then do the prefix sum. For this we can just get each point value. 
This is good for multiple query. query is O(1)
but for this problem it is overkill.

```cpp
    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
        map<int,int> mp;
        for(int i=0;i<startTime.size();i++){
            mp[startTime[i]]++;
            mp[endTime[i]+1]--;
        }
        int pre=0,prev=0;
        for(auto t: mp){
            if(queryTime>=prev && queryTime<t.first) return pre;
            pre+=t.second;
            
            prev=t.first;
        }
        return 0;
    }
```

### 1451. Rearrange Words in a Sentence
<em>
Given a sentence text (A sentence is a string of space-separated words) in the following format:

First letter is in upper case.
Each word in text are separated by a single space.
Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.

Return the new text following the format shown above.
</em>
	
Brutal force approach:
convert to vector of string and then sort by length
Note we need keep original order.
- use stable_sort

```cpp
    string arrangeWords(string text) {
        vector<string> vs;
        stringstream ss(text);
        string w;
        while(ss>>w){
            w[0]=tolower(w[0]);
            vs.push_back(w);
        }
        stable_sort(begin(vs),end(vs),[](const string& a,const string& b){
            return a.size()<b.size();
        });
        vs[0][0]=toupper(vs[0][0]);
        string ans;
        for(auto word: vs){
            ans+=word+" ";
        }
        ans.pop_back();
        return ans;
    }
```
- note for stable_sort, the const is required.
- if using sort, we need carry the index information.

### 1452. People Whose List of Favorite Companies Is Not a Subset of Another List
<em>
Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).

Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.
1 <= favoriteCompanies.length <= 100
1 <= favoriteCompanies[i].length <= 500
1 <= favoriteCompanies[i][j].length <= 20
All strings in favoriteCompanies[i] are distinct.
All lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j].
All strings consist of lowercase English letters only. 
</em>

note using brutal force to check if one is another's subgroup O(N^2*M)
if using string, this requires another L.
This will get TLE if using string and set operations.

Optimization: using bit (or bool vector) to assign each person a bool vector.
```cpp
    vector<int> peopleIndexes(vector<vector<string>>& comp) {
        vector<int> ans;
        set<string> ms;
        for(auto t: comp){
            for(auto s: t) ms.insert(s);
        }
        unordered_map<string,int> mp;
        int i=0;
        for(auto t: ms) mp[t]=i++;
        vector<vector<bool>> v(comp.size(),vector<bool>(ms.size()));
        for(int i=0;i<comp.size();i++){
            for(int j=0;j<comp[i].size();j++) {
                string& s=comp[i][j];
                v[i][mp[s]]=1;
            }
        }
            
        //now just check the bools
        for(int i=0;i<comp.size();i++){
            bool valid=1;
            for(int j=0;j<comp.size();j++){
                if(i==j) continue;
                if(is_subset(v[i],v[j])) {
                    valid=0;
                    break;
                }
            }
            if(valid) ans.push_back(i);
        }
        return ans;
        //using bits to assign a number to it
    }
    bool is_subset(vector<bool>& a,vector<bool>& b){
        for(int i=0;i<a.size();i++){
            if(a[i] && !(a[i]&&b[i])) return 0; //
        }
        return 1;
    }
```

### 1453. Maximum Number of Darts Inside of a Circular Dartboard
<em>

You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane. 

Return the maximum number of points that are within or lie on any circular dartboard of radius r.

</em>

The idea:
brutal force: check each pair of points as a straightline, and draw a circle with radius r. There is only two circles.
check how many points lies inside it.
why? that is the key: if we found the circle covering the most points, we can always shrink the circle to have two points on the circle.
maybe move the circle is more suitable without losing a single point.

- just pick one side circle is fine
- need use double and add an eps

```cpp
    int numPoints(vector<vector<int>>& A, int r) {
        int res = 1, n = A.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int x1 = A[i][0], y1 = A[i][1];
                int x2 = A[j][0], y2 = A[j][1];
                double d = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                if (d > r * 2) continue;
                double x0 = (x1 + x2) / 2.0 + (y2 - y1) * sqrt(r * r - d * d / 4) / d;
                double y0 = (y1 + y2) / 2.0 - (x2 - x1) * sqrt(r * r - d * d / 4) / d;
                int cnt = 0;
                for (vector<int>& point : A) {
                    double x = point[0], y = point[1];
                    if ((x - x0) * (x - x0) + (y - y0) * (y - y0) <= r * r + 0.00001) {
                        cnt++;
                    }
                }
                res = max(res, cnt);
            }
        }
        return res;
    }
```	
	


## contest 190

### 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence
<em>
Given a sentence that consists of some words separated by a single space, and a searchWord.

You have to check if searchWord is a prefix of any word in sentence.

Return the index of the word in sentence where searchWord is a prefix of this word (1-indexed).

If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.

A prefix of a string S is any leading contiguous substring of S.
</em>

straightforward. just check one by one.
```cpp
    int isPrefixOfWord(string sentence, string searchWord) {
        stringstream ss(sentence);
        vector<string> vw;
        string w;
        int n=searchWord.size();
        while(ss>>w){
            if(w.size()>=searchWord.size() && w.substr(0,n)==searchWord)
                return vw.size()+1;
            vw.push_back(w);
        }
        return -1;
    }
```

### 1456. Maximum Number of Vowels in a Substring of Given Length
<em>
Given a string s and an integer k.

Return the maximum number of vowel letters in any substring of s with length k.

Vowel letters in English are (a, e, i, o, u).
</em>

simple and straightforward
using sliding window

```cpp
    bool isvowel(char c){
        return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';
    }
    int maxVowels(string s, int k) {
        //aeiou
        int cnt=0;
        int ans=0;
        int i=0;
        while(i<s.size()){
            cnt+=isvowel(s[i]);
            if(i>=k){
                cnt-=isvowel(s[i-k]);
            }
            if(i>=k-1) ans=max(ans,cnt);
            i++;
        }
        return ans;
    }
```

### 1457. Pseudo-Palindromic Paths in a Binary Tree
<em>
Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.

Return the number of pseudo-palindromic paths going from the root node to leaf nodes.
</em>

simple dfs, palindrome has at most one with odd number.

```cpp
    int pseudoPalindromicPaths (TreeNode* root) {
        //all except at most 1 appear odd times
        vector<int> cnt(10);
        return helper(root,cnt);
    }
    int helper(TreeNode* root,vector<int> cnt){
        if(!root) return 0;
        cnt[root->val]++;
        if(root->left==root->right) {return ispal(cnt);}
        return helper(root->left,cnt)+helper(root->right,cnt);
    }
    bool ispal(vector<int>& cnt){
        int odd=0;
        for(int i: cnt) odd+=i%2;
        return odd<=1;
    }
```

### 1458. Max Dot Product of Two Subsequences
<em>
Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).
</em>

typical dp. a good question.

- could be 3d, but it will TLE dp[i,j,k] means array length 1=i, array 2 length=j, and k pairs
- but we do not need k actually, we do not care how many pairs, we can just add a pair to previous if it is >0
- dp[i,j] reprsents the max dot product with array 1 length=i and array 2 length=j.
- there are several options:
* use i, but not use j, dp(i,j-1)
* use j, but not use i, dp(i-1,j)
* use i and j as a pair, A[i]*B[j]+dp[i-1,j-1], make sure A[i]*B[j]>0

```cpp
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
        int n = int(nums1.size()), m = int(nums2.size());
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j]);
                dp[i][j] = max(dp[i][j], dp[i][j - 1]);
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                dp[i][j] = max(dp[i][j], max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]);
            }
        }
        return dp[n][m];
    }
```

	


## contest 191

### 1464. Maximum Product of Two Elements in an Array
<em>Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
</em>

Trivial, just use O(N^2) two loop
sort and use the max and 2nd max. O(nlogn)
O(N): find max and 2nd max one pass
```cpp
    int maxProduct(vector<int>& nums) {
        int a=INT_MIN,b=INT_MIN;
        for(int i: nums){
            if(i>a){
                b=a;
                a=i;
            }
            else if(i>b){
                b=i;
            }
        }
        return (a-1)*(b-1);
    }
```

### 1465. Max area of a piece of cake after horizontal and vertical cuts

although the problem description is confusing, but the problem is simple.
just add a top and bottom, left and right (virtual cut) and sort the cuts and get the max horizontal interval and vertical interval.

```cpp
    int maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {
        int mod=1e9+7;
        horizontalCuts.push_back(h);
        verticalCuts.push_back(w);
        sort(begin(horizontalCuts),end(horizontalCuts));
        sort(begin(verticalCuts),end(verticalCuts));
        //intervals, get the vertical max and horiztonal max
        int mxh=0,mxv=0;
        int pre=0;
        for(auto h: horizontalCuts)
            mxh=max(mxh,h-pre),pre=h;
        pre=0;
        for(auto v: verticalCuts)
            mxv=max(mxv,v-pre),pre=v;
        return (long)mxh*mxv%mod;
    }
```

### 1466. Reorder Routes to Make All Paths Lead to the City Zero
<em>
There are n cities numbered from 0 to n-1 and n-1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by connections where connections[i] = [a, b] represents a road from city a to b.

This year, there will be a big event in the capital (city 0), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.

It's guaranteed that each city can reach the city 0 after reorder.
</em>

key: the graph is a tree root at 0.
building the graph with the edge direction information and then do a dfs from 0, count those direction not exist.

```cpp
    int minReorder(int n, vector<vector<int>>& connections) {
        //0 is the root, and all other shall be subtree
        int ans=0;
        vector<vector<pair<int,int>>>  adj(n);
        for(auto c: connections){
            adj[c[1]].push_back({c[0],1}); //incoming
            adj[c[0]].push_back({c[1],0});//incoming
        }
        //dfs
        vector<bool> v(n);
        dfs(adj,0,v,ans);
        return ans;
    }
    void dfs(vector<vector<pair<int,int>>>& adj,int root,vector<bool>& v,int& ans){
        v[root]=1;
        for(auto p: adj[root]){ //only check incoming 
            int node=p.first,incoming=p.second;
            if(v[node]) continue;
            if(!incoming) ans++;
            dfs(adj,node,v,ans);
        }
    }
```

use positive and negative for direction can simplify the data structure a bit.

### 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls
<em>
Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i. 

All the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).

Please note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).

We want to calculate the probability that the two boxes have the same number of distinct balls.
</em>

This is a permutation problem.
- before that we need to know the permutation with duplicates n!/(A1!*....*An!)
- then we only need to count the number of permutation with equal distinct color, which can be obtained using backtracking.
- backtracking is combination approach, after we get a valid combination we need to get the permutation
- backtracking for length n array would be (A+1)^n.
- use double for factorial.

The following code gives correct results however TLE.
```cpp
    double getProbability(vector<int>& balls) {
        int num2=accumulate(begin(balls),end(balls),0); //total number of balls
        int n=num2/2;
        double total=factor(num2);
        for(int i: balls) total/=factor(i);
        int nc=balls.size();
        double cnt=0;
        backtrack(balls,n,0,0,0,nc,{},cnt);
        return double(cnt)/total;
    }
    double factor(int n){
        if(n==0) return 1;
        double ans=1;
        for(int i=2;i<=n;i++) ans*=i;
        return ans;
    }
    double getperm(vector<int>& t,int n){
        double total=factor(n);
        for(int i: t) total/=factor(i);
        return total;
    }
    void backtrack(vector<int>& balls,int n,int start,int cnt,int nc0,int nc1,vector<int> t,double& ans){
        if(cnt==n && nc0==nc1){ //found one valid combination
            double t1=getperm(t,n);
            vector<int> tt=balls;
            for(int i=0;i<balls.size();i++) tt[i]=balls[i]-(i<t.size()?t[i]:0);
            double t2=getperm(tt,n);
            ans+=t1*t2;
            return;// ans;
        }
        if(start>=balls.size() || cnt>n) return;
        for(int j=0;j<=balls[start];j++){
            t.push_back(j);
            backtrack(balls,n,start+1,cnt+j,nc0+(j>0),nc1-(j==balls[start]),t,ans);
            t.pop_back();
        }
    }
```	

- using vector value passing is the key to slow down the speed.

the following code passes the tests with only change that the vector passing by reference:
```cpp
    double getProbability(vector<int>& balls) {
        //combination & permutation
        //first calculate number of total permutation
        int num2=accumulate(begin(balls),end(balls),0); //total number of balls
        int n=num2/2;
        //consider 2n slots and get the permutation, need get rid of those same
        //n!/(a1!*a2!....)
        double total=factor(num2);
        for(int i: balls) total/=factor(i);
        //now calculate the number of permutation with equal distinct color
        //get n balls, combination and then permutation
        int nc=balls.size();
        double cnt=0;
        //may need memoization
        //memset(dp,0,9*100*50*sizeof(double));
        vector<int> a(balls.size());
        backtrack(balls,n,0,0,0,nc,a,cnt);
        //cout<<cnt<<" "<<total<<endl;
        return double(cnt)/total;
    }
    double factor(int n){
        if(n==0) return 1;
        double ans=1;
        for(int i=2;i<=n;i++) ans*=i;
        return ans;
    }
    double getperm(vector<int>& t,int n){
        double total=factor(n);
        for(int i: t) total/=factor(i);
        return total;
    }
    double backtrack(vector<int>& balls,int n,int start,int cnt,int nc0,int nc1,vector<int>& t,double& ans){
        //cout<<n<<" "<<start<<" "<<cnt<<" "<<nc0<<" "<<nc1<<endl;
        if(cnt==n && nc0==nc1){ //found one valid combination
            //combination-->get the 
            double t1=getperm(t,n);
            vector<int> tt=balls;
            for(int i=0;i<balls.size();i++) tt[i]=balls[i]-t[i];
            double t2=getperm(tt,n);
            //cout<<"found"<<t1<<" "<<t2<<endl;
            ans+=t1*t2;
            return t1*t2;
            //return;// ans;
        }
        if(start>=balls.size() || cnt>n) return 0;
        double res=0;
        for(int j=0;j<=balls[start];j++){
            t[start]=j;
            res+=backtrack(balls,n,start+1,cnt+j,nc0+(j>0),nc1-(j==balls[start]),t,ans);
        }
        return res;
    }
```
- The complexity is O(M^N)

we can add memoization to reduce the complexity.
The state depends on start, cnt, nc. (the other side cnt and nc is totally dependent on this side's choice)
--wrong, cnt and nc cannot decide nc1. It also depends on each individual choices.
- or it totally depends on the each element choice.
similar to bitset, but each bit we have multiple choices, we can use string. Yes it works but still TLE since convert vector to string causes extra effort.

backtracking + memoization ==> dp.
```cpp
class Solution {
public:
    
    double getProbability(vector<int>& balls) {
        int num2=accumulate(begin(balls),end(balls),0); //total number of balls
        int n=num2/2;
        double total=factor(num2);
        for(int i: balls) total/=factor(i);
        int nc=balls.size();
        //memset(dp,0,9*100*50*50*sizeof(double));
        //vector<int> a(balls.size());
        string a(balls.size(),'0');;
        vector<unordered_map<string,double>> dp(balls.size());
        double cnt=backtrack(balls,n,0,0,0,nc,a,dp);
        return double(cnt)/total;
    }
    double factor(int n){
        if(n==0) return 1;
        double ans=1;
        for(int i=2;i<=n;i++) ans*=i;
        return ans;
    }
    double getperm(vector<int>& t,int n){
        double total=factor(n);
        for(int i: t) total/=factor(i);
        return total;
    }    
    double getperm(string& t,int n){
        double total=factor(n);
        for(char i: t) total/=factor(i-'0');
        return total;
    }
    double backtrack(vector<int>& balls,int n,int start,int cnt,int nc0,int nc1,string& t,vector<unordered_map<string,double>>& dp){
        
        if(cnt==n && nc0==nc1){ //found one valid combination
            double t1=getperm(t,n);
            vector<int> tt=balls;
            for(int i=0;i<balls.size();i++) tt[i]=balls[i]-(t[i]-'0');
            double t2=getperm(tt,n);
            return t1*t2;
        }
        if(start>=balls.size() || cnt>n) return 0;
        //string s=state2str(t);
        if(dp[start][t]>1e-6) return dp[start][t];
        double res=0;
        for(int j=0;j<=balls[start];j++){
            t[start]='0'+j;
            res+=backtrack(balls,n,start+1,cnt+j,nc0+(j>0),nc1-(j==balls[start]),t,dp);
        }
        return dp[start][t]=res;
    }
};
```

However this takes longer than the backtracking.
## contest 192

### 1470. Shuffle the Array
<em>
Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

Return the array in the form [x1,y1,x2,y2,...,xn,yn].</em>

too simple


### 1471. The k Strongest Values in an Array
<em>
Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).

 value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.
If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].
</em>

approach: sort first to get the median and then sort using the median difference

```cpp
    struct comp{
        int m;
        comp(int k):m(k){}
        bool operator()(int a,int b){
            return abs(a-m)>abs(b-m) || (abs(a-m)==abs(b-m) && a>b);
        }
    };
    vector<int> getStrongest(vector<int>& arr, int k) {
        sort(begin(arr),end(arr));
        int n=arr.size();
        int m=arr[(n-1)/2];
        sort(begin(arr),end(arr),comp(m));
        return {arr.begin(),arr.begin()+k};
    }
```

Approach 2: after first sort, we do not need to do second sort, it is the max and min element, similar to sorted array square
using two pointer

### 1472. Design Browser History
<em>
You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.

Implement the BrowserHistory class:

BrowserHistory(string homepage) Initializes the object with the homepage of the browser.
void visit(string url) visits url from the current page. It clears up all the forward history.
string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.
string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.
</em>

The only need to pay attention to is that visit need to clear all forward sites

```cpp
    vector<string> hist;
    int cur;
    BrowserHistory(string homepage) {
        hist.push_back(homepage);
        cur=0;
    }
    
    void visit(string url) {
        while(hist.size()>cur+1) hist.pop_back();
        hist.push_back(url);
        cur=hist.size()-1;
    }
    
    string back(int steps) {
        if(cur-steps<0) cur=0;
        else cur-=steps;
        return hist[cur];
    }
    
    string forward(int steps) {
        if(cur+steps>=hist.size()-1) cur=hist.size()-1;
        else cur+=steps;
        return hist[cur];
    }
```

### 1473. Paint House III
<em>
There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that has been painted last summer should not be painted again.

A neighborhood is a maximal group of continuous houses that are painted with the same color. (For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods  [{1}, {2,2}, {3,3}, {2}, {1,1}]).

Given an array houses, an m * n matrix cost and an integer target where:

houses[i]: is the color of the house i, 0 if the house is not painted yet.
cost[i][j]: is the cost of paint the house i with the color j+1.
Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods, if not possible return -1.
</em>
dp, not hard, but I messed it up for the base case.
- initial add a color out of range.
- when k==0 we need continue to end of list (k<0 is the end of recursion)
- I use long to avoid int overflow.

```cpp
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        for(int& i: houses) i=i-1;
        vector<vector<vector<long>>> dp(m,vector<vector<long>>(target+1,vector<long>(n+1,-1)));
        long ans=helper(houses,cost,0,n,target,dp);
        return ans>=INT_MAX?-1:ans;
    }
    long helper(vector<int>& houses,vector<vector<int>>& cost,int start,int prev,int k,vector<vector<vector<long>>>& dp){
        if(k<0) return INT_MAX;
        if(start>=houses.size()) return k==0?0:INT_MAX;//k>0 //k>0
        if(dp[start][k][prev]>=0) return dp[start][k][prev];
        
        int m=cost.size(),n=cost[0].size(); //m: number of houses, n: number of colors
        long ans=INT_MAX;
        if(houses[start]>=0){ //painted
            return dp[start][k][prev]=helper(houses,cost,start+1,houses[start],k-(houses[start]!=prev),dp); //
        }
        else{ //not painted
            for(int c=0;c<n;c++){ //paint house start with color c
                ans=min(ans,cost[start][c]+helper(houses,cost,start+1,c,k-(c!=prev),dp));
            }
        }
        return dp[start][k][prev]=ans;
    }
```	
	


## contest 193-1480

### 1480. Running sum pf 1d array

simple and straightforward prefix sum

```cpp

    vector<int> runningSum(vector<int>& nums) {
        for(int i=1;i<nums.size();i++)
            nums[i]+=nums[i-1];
        return nums;
    }
```
or using std::partial_sum

### 1481. Least Number of Unique Integers after K Removals
<em>Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.	
</em>

greedy: using hashmap to get the count of each type of elements and then sort using the count.
remove the elements from the min count.

```cpp
    int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
        unordered_map<int,int> mp;
        for(int i: arr) mp[i]++;
        //greedy remove smallest first
        vector<int> v;
        for(auto t: mp) v.push_back(t.second);
        sort(begin(v),end(v));
        int i=0;
        while(i<v.size() && k>=v[i] ){
            k-=v[i],i++;
        }
        return v.size()-i;
    }
```

### 1482. Minimum Number of Days to Make m Bouquets
<em>
Given an integer array bloomDay, an integer m and an integer k.

We need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.

The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.
</em>

binary search to find the first valid position

```cpp
    int minDays(vector<int>& bloomDay, int m, int k) {
        int l=INT_MAX,r=INT_MIN;
        for(int i: bloomDay)
            l=min(l,i),r=max(r,i);

        int t=0,mid=0;
        while(l<r){
            mid=l+(r-l)/2;
            t=count(bloomDay,mid,k);
            if(t>=m) r=mid;
            else l=mid+1;
        }
        t=count(bloomDay,l,k);
        if(t<m) return -1;
        return l;
    }
    int count(vector<int>& day,int mx,int k){
        int ans=0,cnt=0;
        for(int i: day){
            if(i<=mx) {
                cnt++;
                if(cnt>=k) {ans++;cnt=0;}
            }
            else cnt=0;
        }
        return ans;
    }
```	
m*k>n need to return -1. In that case, we don't need to check if l is fine.

### 1483. Kth Ancestor of a Tree Node
<em>
You are given a tree with n nodes numbered from 0 to n-1 in the form of a parent array where parent[i] is the parent of node i. The root of the tree is node 0.

Implement the function getKthAncestor(int node, int k) to return the k-th ancestor of the given node. If there is no such ancestor, return -1.

The k-th ancestor of a tree node is the k-th node in the path from that node to the root.
</em>

using dfs + memoization will TLE.

just similar to super power, we need use some trick called binary lifting.

The idea is:
dp[i][node]=dp[i-1][dp[i-1][node]]
dp[i,node] represents the 2^i parent of node.
we store the parent for each node's parent 2^0 parent->2^1 parent->2^2 parent->..... up to log2（N）

when search for kth parent:
for example k=5 (0b101), we first get 2^0's parent, and then get parent's 2^2 parent and that is it!

```cpp
    vector<vector<int> > P; // P[i][node] :::: [node] 's [2^i]th parent
    TreeAncestor(int n, vector<int>& parent) {
        // initialize
        P.resize(20, vector<int>(parent.size(), -1));
        
        // 2^0
        for(int i = 0; i < parent.size(); i++){
            P[0][i] = parent[i];
        }
        
        // 2^i
        for(int i = 1; i < 20; i++){
            for(int node = 0; node < parent.size(); node ++){
                int nodep = P[i-1][node];
                if(nodep != -1) P[i][node] = P[i-1][nodep];
            }
        }
    }
    
    int getKthAncestor(int node, int k) {
        for(int i = 0; i < 20; i++){
            if(k & (1 << i)){
                node = P[i][node];
                if(node == -1) return -1;
            }
        }

        return node;
    }
```	

## contest 194
this contest is a disaster.

### 1486. XOR Operation in an Array
<em>
Given an integer n and an integer start.

Define an array nums where nums[i] = start + 2*i (0-indexed) and n == nums.length.

Return the bitwise XOR of all elements of nums.
</em>

brutal force
```cpp
    int xorOperation(int n, int start) {
        int ans=0;
        for(int i=0;i<n;i++)
            ans^=start+2*i;
        return ans;
    }
```
with some thinking:
the last bit for all elements are the same. so we can get the last bit by the odd/even of the length.
we do it recursively and it is O(32)
The core principle used is that x ^ (x + 1) = 1 if x is even.

First, we also simplify by changing the problem from being:
start ^ (start + 2) ^ (start + 4) ^ ... (start + 2*i)
to:
start/2 ^(start/2 + 1)^...^(start + i)

We can do this by remembering the first bit of start, and then right shifting it. At the end, we can left shift our answer and add back the first bit where necessary.

We can derive for the even scenario by considering that start^(start+1)^(start+2)^(start+3) cancels out to 0 when start is even after right shifting. We can use a Switch block to return the answer, which we can figure out by considering n in chunks of 4.

The solution in the odd scenario when start is odd after right shifting can again be derived by using a Switch block, taking into consideration that (start+1)^(start+2)^(start+3)^(start+4) cancels out to 0. (start+1 is even, hence subsequent series is the same as the even scenario). We simply XOR a start to compensate for not considering the first start in the odd scenario.

Similarly, the first bit only has an effect when n is an odd number, as an even number of 1s XOR'd will cancel out to 0.

class Solution {
public:
    int xorOperation(int n, int start) {
        int first = start & 1;
        start = start >> 1;
        if(start % 2 == 0){
            switch(n % 4){
                case 0: return 0;
                case 1: return ((start + n - 1) << 1) + first;
                case 2: return 2;
                case 3: return ((1 ^ (start + n - 1)) << 1) + first;
            } 
        } else {
            switch(n % 4){
                case 0: return (start ^ 1 ^ (start + n - 1)) << 1;
                case 1: return (start << 1) + first;
                case 2: return (start ^ (start + n - 1)) << 1;
                case 3: return ((start ^ 1) << 1) + first;
            } 
        }
        return 0; //unreachable
    }
};
The solution was expressed in this way to simplify explanation, it can be shortened.

### 1487. Making File Names Unique
<em>
Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].

Since two files cannot have the same name, if you enter a folder name which is previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.

Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.
</em>

```cpp
    vector<string> getFolderNames(vector<string>& names) {
        unordered_map<string,int> m;// A map to store whether the particular name occurs how many times already
        for(int i=0;i<names.size();i++)
        {
            if(m.find(names[i])!=m.end())// if the name already came
            {
                int k=m[names[i]];// it contains the number in brackets
                while(m.find(names[i]+"("+to_string(k)+")")!=m.end())
                {
                    k++;// Increase number until that didn't exist
                    m[names[i]]++;//mean while update in the map too
                }
                m[names[i]]++;// Recently we will use one more number so increment
                 names[i]=names[i]+"("+to_string(k)+")";
            }
            m[names[i]]=1;// Here we are storing  for example ...abc(1)=1 and abc(2)=1 it means abc(1) occcured one time, and abc=2 it means abc occured 2 times.
			/*
			Suppose you have a file named ABC occurring twice, we will store ABC with occurrence =2 and ABC(1) with occurrence =1... It helps when we get another file with name ABC(1) we can store like ABC(1)(1)
			*/
			
        }
        return names;
    }
```

### 1488. Avoid Flood in The City

<em>
Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. If it rains over a lake which is full of water, there will be a flood. Your goal is to avoid the flood in any lake.

Given an integer array rains where:

rains[i] > 0 means there will be rains over the rains[i] lake.
rains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it.
Return an array ans where:

ans.length == rains.length
ans[i] == -1 if rains[i] > 0.
ans[i] is the lake you choose to dry in the ith day if rains[i] == 0.
If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.

Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes. (see example 4)

</em>

```cpp
    vector<int> avoidFlood(vector<int>& rains) {
        vector<int> res(rains.size(),-1);
        unordered_map<int, int> m;
        set<int> zero;
        for(int i =0; i < rains.size(); ++i)
        {
            if(rains[i] == 0)
            {
                zero.insert(i);
                res[i] = 1;
            }
            else
            {
                if(m.count(rains[i]))
                {
                    int lastIndex = m[rains[i]];
                    auto zeroIndex = zero.upper_bound(lastIndex);
                    if(zeroIndex == zero.end())
                    {
                        return {};
                    }
                    res[*zeroIndex] = rains[i];
                    zero.erase(zeroIndex);
                }
                m[rains[i]] = i;
            }
        }
        return res;
    }
```

### 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree
<em>
Given a weighted undirected connected graph with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between nodes fromi and toi. A minimum spanning tree (MST) is a subset of the edges of the graph that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the minimum spanning tree (MST) of the given graph. An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. A pseudo-critical edge, on the other hand, is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.
</em>
critical edge appears in all MST
pseudo critical edges appear in only part of MST
MST: connect the graph with min number of edges, weighted need to get the min sum.
MST often uses union-find the form it.

n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]

union-find:
- sort the edges (combined with index) according to weight.
- for the MST and get the sum of weight (rank).
- delete ith edge and calculate the MST's rank. if cannot form a rank, return max.
- if taken away the rank increases, this is a critical connection.
- if include the edge the rank no changes, this is a non-critical connection (but it shall be inside the some of the MST).
for example edge 6, it is not noncritical edge since it is not part of MST.
```cpp
	vector<int> parent;
	int sz;
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
		for(int i=0;i<edges.size();i++) edges[i].push_back(i);
		sort(begin(edges),end(edges),[](vector<int>& a,vector<int>& b){
			return a[2]<b[2];
		});
		vector<int> critical,noncritical;
		int rank=getMST(edges,-1,-1,n); //with remove an edge.
		for(int i=0;i<edges.size();i++){
            //cout<<i<<" "<<r<<endl;
			if(getMST(edges,i,-1,n)>rank) critical.push_back(edges[i][3]);
			else if(getMST(edges,-1,i,n)==rank) noncritical.push_back(edges[i][3]);
		}
		return {critical,noncritical};
    }
	int getMST(vector<vector<int>>& edges,int rm,int add,int n){
		int ans=0;
		parent.resize(n);
		for(int i=0;i<n;i++) parent[i]=i;
		sz=n;
		if(add>=0) parent[edges[add][0]]=edges[add][1],sz--,ans+=edges[add][2];
		for(int i=0;i<edges.size();i++){
            auto& e=edges[i];
			if(i==rm || i==add) continue;
			int pi=findp(e[0]),pj=findp(e[1]);
			if(pi!=pj) {
				parent[pi]=pj;
				ans+=e[2];
				sz--;
			}
		}
		return sz==1?ans:INT_MAX;
	}
	int findp(int i){
		while(parent[i]!=i) {
			parent[i]=parent[parent[i]];
			i=parent[i];
		}
		return i;
	}
```	
Note:
- final result shall be original index.
- with path compression. parent[parent[i]]->parent[i]->i.
- delete an edge for critical, add an edge for noncritical.


	
 
## contest 195

### 1496. Path Crossing
<em>
Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.

Return True if the path crosses itself at any point, that is, if at any time you are on a location you've previously visited. Return False otherwise.
<em>

simple using hashset to record previous locations

```cpp
    bool isPathCrossing(string path) {
        int x=0,y=0;
        unordered_set<string> ms;
        ms.insert("0,0");
        for(char c: path){
            if(c=='N') y++;
            if(c=='E') x++;
            if(c=='S') y--;
            if(c=='W') x--;
            if(ms.count(to_string(x)+","+to_string(y))) return 1;
            ms.insert(to_string(x)+","+to_string(y));
        }
        return 0;
    }
```

### 1497. Check If Array Pairs Are Divisible by k
<em>
Given an array of integers arr of even length n and an integer k.

We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.

Return True If you can find a way to do that or False otherwise.
</em>

idea: get the remainder into a hashmap

```cpp
    bool canArrange(vector<int>& arr, int k) {
        vector<int> mod(k);
        for(int i: arr) mod[(i-i/k*k+k)%k]++;
        //for(int i: mod) cout<<i<<" ";
        int i=1,j=mod.size()-1;
        if(mod[0]%2) return 0;
        while(i<j){
            if(mod[i]!=mod[j]) return 0;
            i++,j--;
        }
        return 1;
    }
```
note: to do the negative mod, we use (i-i/k*k+k)%k to get 0 to k-1

### 1498. Number of Subsequences That Satisfy the Given Sum Condition
<em>
Given an array of integers nums and an integer target.

Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal than target.

Since the answer may be too large, return it modulo 10^9 + 7.
</em>

idea: 
- each element can be the min or max for some subsequences.
- the order does not matter, sort will make things much easier.
- once we have l elements <=cur, each element can be chosen or not chosen, 2^n.

```cpp
    int numSubseq(vector<int>& A, int target) {
        sort(A.begin(), A.end());
        int res = 0, n = A.size(), l = 0, r = n - 1, mod = 1e9 + 7;
        vector<int> pows(n, 1);
        for (int i = 1 ; i < n ; ++i)
            pows[i] = pows[i - 1] * 2 % mod;
        while (l <= r) {
            if (A[l] + A[r] > target) {
                r--;
            } else {
                res = (res + pows[r - l++]) % mod;
            }
        }
        return res;
    }
```

### 1499. Max Value of Equation

<em>
Given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k.

Find the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length. It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.
</em>

heap.
since the array is sorted according to x, then xi+yi+(yj-xj) xi>xj.
suppose xj and yj are all those points with xj<xi, then we max yj-xj.

```cpp
    int findMaxValueOfEquation(vector<vector<int>>& pts, int k) {
        priority_queue<pair<int, int>> pq; // max-heap
        pq.push({pts[0][1]-pts[0][0],pts[0][0]});
        int ans= INT_MIN;
        for(int i=1;i<pts.size();i++) {
            int sum = pts[i][0]+pts[i][1];
            while(!pq.empty() && pts[i][0]-pq.top().second>k) pq.pop();
            if(!pq.empty())ans = max(ans,sum+pq.top().first);
            pq.push({pts[i][1]-pts[i][0],pts[i][0]});
        }
        return ans;
    }
```	


 
## contest 196

### 1502. Can Make Arithmetic Progression From Sequence
simple, sort and check difference

```cpp
    bool canMakeArithmeticProgression(vector<int>& arr) {
        if(arr.size()<3) return 1;
        sort(begin(arr),end(arr));
        int d=arr[1]-arr[0];
        for(int i=1;i<arr.size();i++){
            if(arr[i]-arr[i-1]!=d) return 0;
        }
        return 1;
    }
```

### 1503. Last Moment Before All Ants Fall Out of a Plank
<em>
We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with speed 1 unit per second. Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions doesn't take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank imediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right. Return the moment when the last ant(s) fall out of the plank.

 </em>
 
 observation:
 - ant goes back and forth will make things complicated
 - ant goes back is equivalent to go forward without collision
 - so we just check the leftmost ant going right and rightmost ant going left.
 
 ```cpp
     int getLastMoment(int n, vector<int>& left, vector<int>& right) {
        //the inner side ants will determine the last moment.
        //or equivalent the two ants exchange position
        int lmax=0,rmin=n;
        if(left.size()) lmax=*max_element(begin(left),end(left));
        if(right.size()) rmin=*min_element(begin(right),end(right));
        return max(n-rmin,lmax);
    }
```

### 1504. Count Submatrices With All Ones
idea:
- dp approach
- store the left number of 1s at each element position
- then go up and count the rect. (min of previous left)

```cpp
    int numSubmat(vector<vector<int>>& mat) 
    {
        int result=0;
        int m=mat.size(),n=mat[0].size();
        int dp[m][n];
        memset(dp,0,sizeof(dp));
        for(int i=0;i<m;i++) //calculate dp[m][n]
        {
            for(int j=0;j<n;j++)
            {
                if(mat[i][j])
                        dp[i][j]=(j?dp[i][j-1]:0)+1;//count consecutive left zeroes
            }
        }
        for(int j=0;j<n;j++) //from left to right
        {
            for(int i=0;i<m;i++) //from top to bottom
            {
                int minimum=dp[i][j];
                for(int k=i;k>=0 && dp[k][j];k--) //from i to top (count the number of rectangles that can be made)
                {
                    minimum=min(minimum,dp[k][j]);//the number of rectangles that can be made with the right edge extended from mat[i][j] to mat[k][j]
                    result+=minimum;
                }
            }
        }
        return result;
    }
```

### 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits
<em>
Given a string num representing the digits of a very large integer and an integer k.

You are allowed to swap any two adjacent digits of the integer at most k times.

Return the minimum integer you can obtain also as a string.
</em>

It is not hard to find that the correct answer is obtained using bubble sort if number of swap<k.
for example 4321 with k=4
1 to bring to first need 3 swaps-->1432
3 bring to forward need 1 swap->1342

greedy:

```cpp
	string minInteger(string num, int k) {
		if(k <= 0) 
			return num;
		int n = num.size();
		if(k>=n*(n+1)/2){ 
			sort(num.begin(), num.end());
			return num;
		}
		for(int i=0; i<10; i++){
			int idx = num.find(to_string(i));
			if(idx>=0 && idx<=k)
				return num[idx]+minInteger(num.substr(0,idx)+num.substr(idx+1), k-idx);
		}
		return num;
	}
```
The complexity is O(N^2) and will TLE for large K.

BIT (segment tree) to reduce to O(nlogn)

	


	
	
 
 
 
## contest 197
### 1512. Number of Good Pairs
<em>
Given an array of integers nums.

A pair (i,j) is called good if nums[i] == nums[j] and i < j.

Return the number of good pairs.
</em>
hashmap

```cpp
    int numIdenticalPairs(vector<int>& nums) {
        unordered_map<int,int> mp;
        int ans=0;
        for(int i: nums){
            if(mp.count(i)) ans+=mp[i];
            mp[i]++;
        }
        return ans;
    }
```

### 1513. Number of Substrings With Only 1s
<em>
Given a binary string s (a string consisting only of '0' and '1's).

Return the number of substrings with all characters 1's.

Since the answer may be too large, return it modulo 10^9 + 7.
</em>

ending with current 1: if len of 1=len, then we have len substrings ending with ith element.
```cpp
    int numSub(string s) {
        int mod=1e9+7;
        //all 1s subarray has 
        long ans=0;
        int cnt=0;
        for(char c: s){
            if(c=='1') {
                cnt++;
                ans+=cnt;
                ans%=mod;
            }
            else cnt=0;
        }
        return ans;
    }
```

### 1514. Path with Maximum Probability
<em>
You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].

Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.

If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.
</em>

this is very similar to cheapest flight cost.
using bellman-ford or dijkstra.
Bellman ford complexity is higher than dijkstra. O(N^2) vs O(nlogn)

Bellman ford:
```cpp
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
        double ans=0;
        //from start to end, get the max probability
        vector<double> dist(n,0.0);
        dist[start]=0;
        int m=edges.size();
        for(int i=0;i<m;i++){
            if(edges[i][0]==start) dist[edges[i][1]]=succProb[i];
            if(edges[i][1]==start) dist[edges[i][0]]=succProb[i];
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){ //to see if we use this can increase prob
                auto& p=edges[j];
                if(p[0]==start||p[1]==start) continue;
                double prob=succProb[j];
                if(dist[p[0]]>0 && dist[p[0]]*prob>dist[p[1]])
                    dist[p[1]]=dist[p[0]]*prob;
                if(dist[p[1]]>0 && dist[p[1]]*prob>dist[p[0]])
                    dist[p[0]]=dist[p[1]]*prob;
            }
        }
        return dist[end];
    }
```	
this got TLE for N>5000.

dijkstra:
- always try the largest prob first.
- add those nodes which can increase the prob. and add into heap.

```cpp
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& pro, int start, int end) {
        vector<vector<pair<int, double>>> g(n);
        for(int i=0; i<edges.size(); i++) {
            g[edges[i][0]].push_back({edges[i][1], pro[i]});
            g[edges[i][1]].push_back({edges[i][0], pro[i]});   
        }
        vector<int> seen(n, 0);
        
        priority_queue<pair<double, int>> q;
        q.push({(double)1.0, start});
        
        vector<double> mx(n, (double)0.0);
        mx[start] = 1.0;
        
        while(!q.empty()) {
            auto top = q.top();
            q.pop();
            double proba = top.first;
            int node = top.second;
            if(!seen[node]) {
                seen[node]++;
                for(auto &to: g[node]) {
                    if (mx[to.first] < to.second*proba) {
                        mx[to.first] = to.second*proba;
						q.push({mx[to.first], to.first});
                    }
                }
            }
        }
        return mx[end];
    }
```	

### 1515. Best Position for a Service Centre
<em>
A delivery company wants to build a new service centre in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new centre in a position such that the sum of the euclidean distances to all customers is minimum.

Given an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers.
</em>
Attention: it asks for the floating point coordinate, not just grid point.
so this is actually numerical analysis problem.
idea: start with an initial coordinate and a step dx and dy, find the steepest decreasing direction and reduce the step by half.

```cpp
    double dist(vector<int> &a, vector<double> &b) {
        return sqrt(pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2));
    }
    double all(vector<vector<int>> &A, vector<double> &p) {
        double ans = 0;
        for (auto &a : A) ans += dist(a, p);
        return ans;
    }
    const int dirs[4][2] = {{0,1},{0,-1},{-1,0},{1,0}};
    double getMinDistSum(vector<vector<int>>& A) {
        double ans = DBL_MAX;
        vector<double> p(2, 0);
        double step = 100, eps = 1e-6;
        while (step > eps) {
            bool found = false;
            for (auto &dir : dirs) {
                vector<double> next = {p[0] + step * dir[0], p[1] + step * dir[1]};
                double d = all(A, next);
                if (d < ans) {
                    ans = d;
                    p = next;
                    found = true;
                    break;
                }
            }
            if (!found) step /= 2;
        }
        return ans;
    }
```
	
	
	


## contest 198

### 1518. Water Bottles
<em>
Given numBottles full water bottles, you can exchange numExchange empty water bottles for one full water bottle.

The operation of drinking a full water bottle turns it into an empty bottle.

Return the maximum number of water bottles you can drink.
</em>

simple, just simulate the process

```cpp
    int numWaterBottles(int numBottles, int numExchange) {
        int ans=0,empty=0;
        while(numBottles){
            ans+=numBottles;
            empty+=numBottles;//%numExchange;
            numBottles=empty/numExchange;
            empty%=numExchange;
            //cout<<numBottles<<endl;
        }
        return ans;
    }
```

### 1519. Number of Nodes in the Sub-Tree With the Same Label
<em>
Given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).

The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.

Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.

A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.
</em>

idea:
- build adjacency matrix.
- postorder traversal.	
- using hashmap to store its subtree char's occurrence.

```cpp
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        vector<vector<int>> adj(n);
        for(auto e: edges){
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> ans(n),v(n);
        postorder(adj,labels,0,-1,v,ans);
        return ans;
    }
    vector<int> postorder(vector<vector<int>>& adj,string& labels,int root,int p,vector<int>& v,vector<int>& ans){
        vector<int> cnt(26);
        for(int child: adj[root]){
            if(v[child] || child==p) continue;
            v[child]=1;
            auto t=postorder(adj,labels,child,root,v,ans);
            for(int i=0;i<26;i++) cnt[i]+=t[i];
        }
        //cout<<root<<endl;
        cnt[labels[root]-'a']++;
        ans[root]=cnt[labels[root]-'a'];
        return cnt;
    }
```

### 1520. Maximum Number of Non-Overlapping Substrings
<em>
Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions:

The substrings do not overlap, that is for any two substrings s[i..j] and s[k..l], either j < k or i > l is true.
A substring that contains a certain character c must also contain all occurrences of c.
Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.

Notice that you can return the substrings in any order.
</em>

idea:
- get the first and last index for each char.
- using the char in the range, we need to extend the segment.
- then after each char's segment is settled, we need to find the longest non-overlapping segments, which is a greedy approach
sort using end, and always using smaller end segment first.

extending the segment could cause a lot of incorrect answers.
one idea is: we loop using the dynamically changed ending, when the left side does not change, then we reach the final segment.
```cpp
    vector<string> maxNumOfSubstrings(string s) {
        int n = s.length();
        vector<int> vals(n);
        for (int i = 0; i < n; i++) {
            vals[i] = s[i] - 'a';
        }
        
        vector<int> fst(26, 1e9);
        vector<int> lst(26, -1);
        for (int i = 0; i < n; i++) {
            fst[vals[i]] = min(fst[vals[i]], i);
            lst[vals[i]] = max(lst[vals[i]], i);
        }
        
        vector<pair<int, int>> t;
        for (int i = 0; i < 26; i++) {
            int start = fst[i];
            int end = lst[i];
            for (int j = start; j <= end; j++) {
                start = min(start, fst[vals[j]]);
                end = max(end, lst[vals[j]]);
            }
            if (start < n && start == fst[i]) {
                t.emplace_back(end, start);
            }
        }
        
        sort(t.begin(), t.end());
        vector<string> ans;
        int prev = -1;
        for (auto &[end, start] : t) {
            if (start > prev) {
                ans.push_back(s.substr(start, 1 + end - start));
                prev = end;
            }
        }
        
        return ans;
    }
```

### 1521. Find a Value of a Mysterious Function Closest to Target
the minimum of |func(A,l,r)-target|.
func(A,l,r) is the bit and of element in [l,r].

idea:
- and will not increase, only decrease or not change.
- using hash set to record previous and current and results
- the elements in hash set will not exceed 32.

```cpp
    int closestToTarget(vector<int>& arr, int target) {
        unordered_set<int> ms;
        int ans=INT_MAX;
        for(int i: arr){
            unordered_set<int> ms1;
            for(auto t: ms) ms1.insert(t&i);
            ms1.insert(i);
            for(auto t: ms1) ans=min(ans,abs(t-target));
            ms=ms1;
        }
        return ans;
    }
```
so the complexity would be O(32N)

	



	
## contest 199

### 1528 Shuffle string
give the index for each char in the string.
trivial

```cpp
    string restoreString(string s, vector<int>& indices) {
        string ans(s.size(),' ');
        for(int i=0;i<indices.size();i++) ans[indices[i]]=s[i];
        return ans;
    }
```

### 1529. Bulb Switcher IV	
bulbs off for 0 and on for 1.
each operation flip[i] will flip all lights from i to end.
to reach final status target, min number of flips.

idea:
greedy approach, from left to right, flip each light to correct status.
If flipped odd times, status remain the same
if flipped even times, status is opposite

similar to prefix sum.
```cpp
    int minFlips(string target) {
        //greedy: flip the left first
        //prefix
        int ans=0,pre=0;
        for(char c: target){
            if(c=='0') ans+=ans%2; //if it is 0,and we have flipped odd times
            else ans+=(ans%2==0);
        }
        return ans;
    }
```

### 1530 Number of good leaf node pairs
a good leaf node pair: two leaf distance <=k.
idea:
postorder traversal, save the leaf nodes depth into array.

```cpp
    int countPairs(TreeNode* root, int distance) {
        //postorder traversal, 
        int ans=0;
        post(root,0,distance,ans);
        return ans;
    }
    vector<int> post(TreeNode* root,int d,int k,int& ans){
        if(!root) return {};
        vector<int> v;
        auto l=post(root->left,d+1,k,ans); //left leafs
        auto r=post(root->right,d+1,k,ans); //right leafs
        if(root->left==root->right) v.push_back(d);
        for(int i: l){
            for(int j: r)
            {
                if(i+j-2*d<=k) ans++;
            }    
        }
        for(int i: l) v.push_back(i);
        for(int j: r) v.push_back(j);
        return v;
    }
```

### 1531. String Compression II
<em>
Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".

Notice that in this problem, we are not adding '1' after single characters.

Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.

Find the minimum length of the run-length encoded version of s after deleting at most k characters.
</em>

idea:
- apparently this is a dp problem, with each letter to delete or not delete
naive dp:
```cpp
    int getLengthOfOptimalCompression(string s, int k) {
        //once we delete a char or several chars, we need reduce the length
        //either from n to 1 so we can reduce 1 char, or eliminate a group
        //and also delete chars can connect same chars together
        //this is a dp problem: with greedy, first remove those with smallest number
        //dp[s,k]->min length for s with k deletion
        unordered_map<string,unordered_map<int,int>> dp;
        return helper(s,k,dp);
    }
    
    int helper(string s,int k,unordered_map<string,unordered_map<int,int>>& dp){
        if(k==0) return runlen(s);
        if(dp.count(s) && dp[s].count(k)) return dp[s][k];
        //if(start>=s.size()) return INT_MAX; 
        int ans=INT_MAX;
        for(int i=0;i<s.size();i++){ //delete
            ans=min(ans,helper(s.substr(0,i)+s.substr(i+1),k-1,dp));
        }
        return dp[s][k]=ans;
    }
    int runlen(string& s){
        string comp;
        char pre=-1;
        int cnt=0,i=0;
        while(i<s.size()){
            if(s[i]!=pre) {
                if(cnt>1) comp+=to_string(cnt);
                comp+=s[i];pre=s[i];
                cnt=1;
            }
            else cnt++;
            i++;
        }
        if(cnt>1) comp+=to_string(cnt);
        //cout<<s<<" "<<comp<<endl;
        return comp.size();        
    }
```
This will TLE
- using map string to int is slow
- everytime we need build new string and tried all combinations
- blindly tries all combination and get the final compressed length.

Opimization:
- get the compressed length during runtime.
- do not generate new strings, but keep the original string unchanged.
thus we can use dp[start][k] as the subproblem.
- how do we keep track the string? This need some thinking.
consider the first char:
- we delete it, and we get dp(start+1,k-1)
- we keep it,then no reason to delete followed same char. so the subproblem is:
Cn+dp(start+1,k). That is we delete all chars which is not the same as C.

```cpp
	int getLengthOfOptimalCompression(string s, int k) {
		int n=s.size();
		vector<vector<int>> dp(n,vector<int>(k+1,-1));
		int ans=n; //max length could be INT_MAX or n.
		return solve(s,0,k,dp);
	}
	int solve(string& s,int start,int k,vector<vector<int>>& dp){
		int n=s.size();
        //cout<<start<<" "<<k<<endl;
		if(k<0) return n;
		if(start>=n || n-start<=k) return 0; //not enough digits to delete
		if(dp[start][k]>=0) return dp[start][k];
		int ans=n;
		//greedy: in the range [start,j] we make the range all identical.
		//we choose the most frequent one.
		int most=0;
		vector<int> cnt(26);
		for(int i=start;i<n;i++){
			most=max(most,++cnt[s[i]-'a']);
			ans=min(ans,1+addLen(most)+solve(s,i+1,k-(i-start+1-most),dp));
		}
		return dp[start][k]=ans;
	}
	int addLen(int n){
		return n==1?0:n<10?1:n<100?2:3;
	}
```
- we use greedy approach to use the most frequent element
- we can also use to keep the first char as the group character.
complexity: 
for each char, we tried each range-->lead to O(N^2)
need also loop k to 0-->O(K)
O(KN^2)




## contest 200
### 1534. Count Good Triplets
<em>
Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.

A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:

0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c
Where |x| denotes the absolute value of x.

Return the number of good triplets.
</em>
brutal force O(N^3)
```cpp
    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {
        int ans=0;
        int n=arr.size();
        for(int i=0;i<n-2;i++){
            for(int j=i+1;j<n-1;j++){
                for(int k=j+1;k<n;k++){
                    if(abs(arr[i]-arr[j])<=a && abs(arr[j]-arr[k])<=b && abs(arr[i]-arr[k])<=c) ans++;
                }
            }
        }
        return ans;
    }
```
can improve a bit if we move ij diff out k loop.

### 1535. Find the Winner of an Array Game
<em>
Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0 and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.
</em>

I think it too complicated using stack, actually not necessary, just count the element winning times
approach: swap the smaller one to previous position.

```cpp
    int getWinner(vector<int>& arr, int k) {
        if(k>arr.size()) return *max_element(begin(arr),end(arr));
        int win=0,cnt=0;
        for(int i=0;i<arr.size()-1;i++){
            if(arr[i]>arr[i+1]) {
                swap(arr[i],arr[i+1]);
            }
            else cnt=0;
            win=arr[i+1];
            if(++cnt>=k) return win;
        }
        return win;
    }
```
### 1536. Minimum Swaps to Arrange a Binary Grid
<em>
Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.

A grid is said to be valid if all the cells above the main diagonal are zeros.

Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.

The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).
</em>

greedy approach:
- convert the matrix into 1d array with trailing zeros.
- sort the 1d array with n-1,n-2...zeros using bubble sort
- choose the first row satisfying the condition and bubble up to the top

```cpp
    int minSwaps(vector<vector<int>>& grid) {
        //need have n-1 to 0 zeros on the right.
        //count number of zeros
        int m=grid.size(),n=grid[0].size();
        vector<int> zeros(m);
        for(int i=0;i<m;i++){
            int cnt=0;
            for(int j=n-1;j>=0 && grid[i][j]==0;j--) cnt++;
            zeros[i]=cnt;
        }
        //now reduce to 1d problem: we need sort to n-1,n-2....0
        //similar to bubble sort. greedy: bubble the first satisfied to top.
        int ans=0;
        for(int i=0;i<m;i++){ //
            //int ind=lower_bound(begin(zeros)+i,end(zeros),m-i-1)-begin(zeros); //
            //for(int j: zeros) cout<<j<<" ";cout<<endl;
            int ind=i;
            while(ind<m) {
                if(zeros[ind]<m-i-1) ind++;
                else break;
            }
            if(ind==m) return -1;
               while(ind>i){
                swap(zeros[ind],zeros[ind-1]);
                ind--;
                ans++;
            }
        }
        return ans;
    }
```	

	
### 1537. Get the Maximum Score
<em>
You are given two sorted arrays of distinct integers nums1 and nums2.

A valid path is defined as follows:

Choose array nums1 or nums2 to traverse (from index-0).
Traverse the current array from left to right.
If you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).
Score is defined as the sum of uniques values in a valid path.

Return the maximum score you can obtain of all possible valid paths.

Since the answer may be too large, return it modulo 10^9 + 7.
Constraints:

1 <= nums1.length <= 10^5
1 <= nums2.length <= 10^5
1 <= nums1[i], nums2[i] <= 10^7
nums1 and nums2 are strictly increasing.

</em>

- a path shall start on array A and end on array A or start on B and end on B (Incorrect, see the example 2)
- we shall compare two options
- each option has a lot of paths.
- we can define two pointer i and j for array 1 and array 2.
- both arrays are increasing, i.e there will be no duplicates in a single array, can we record their index?
- we can use prefix sum to avoid one by one addition and directly jump to next.
- can we form intervals. 

```cpp
class Solution {
public:
	int maxSum(vector<int>& nums1, vector<int>& nums2) {
		//choose the intersection of two set
		int m=nums1.size(),n=nums2.size();
		vector<int> v(min(m,n));
		auto it=set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),v.begin());
		v.resize(it-v.begin());
		//calculate these segment difference
		long tsum1=0,tsum2=0,pre=0;
		int mod=1e9+7;
		int j=0;
		vector<long> diff; //note the path can start and end at any array
		for(int i: nums1) {
			tsum1+=i;
			if(j<v.size() && i==v[j]) {
				diff.push_back(tsum1-pre);
				pre=tsum1;
				j++;
			}
		}
        diff.push_back(tsum1-pre);
        
		j=0,pre=0;
		for(int i: nums2) {
			tsum2+=i;
			if(j<v.size() && i==v[j]){
				diff[j]-=tsum2-pre;
				pre=tsum2;
				j++;
			}
		}
        diff.back()-=tsum2-pre;
		long psum=0,nsum=0;
		for(long i: diff){
			if(i>=0) psum+=i;
			else nsum+=i;
		}
		return max(tsum1-nsum,tsum2+psum)%mod;
	}
};
```
although this is correct, but we can have less space and more efficient and concise solution.
from above, we can see that it actually calculate until we see a common one, then we shall choose the previous max (similar to merge sort):
```cpp
    int maxSum(vector<int>& arr1, vector<int>& arr2) {
        long long i = 0, j = 0, n = arr1.size() , m= arr2.size() , mod = 1e9+7;
        long long res = 0, sum1 = 0, sum2 = 0;

        while(i < n && j < m){
            if(arr1[i] < arr2[j]) sum1 += arr1[i++];
            else if(arr1[i] > arr2[j]) sum2 += arr2[j++];
            else{
                res += max(sum1,sum2);
                sum1 = 0,sum2 = 0;
                while(i < n && j < m && arr1[i] == arr2[j])
                {
                    res += arr1[i];
                    i++;
                    j++;
                }
            }
        }
        while(i < n) sum1 += arr1[i++];  // remaining element of any array
        while(j < m) sum2 += arr2[j++];
        res += max(sum1,sum2);
        return (res + mod) % mod;
    }
```	


		


## contest 201

### 1544. Make The String Great
if neighboring pairs are same char with different case, remove them
return the final string.
stack operation
```cpp
    string makeGood(string s) {
        string ans;
        for(char c: s){
            if(ans.size() && (
                (islower(c) && toupper(c)==ans.back()) ||
                (isupper(c) && tolower(c)==ans.back())))
               ans.pop_back();
            else ans+=c;
        }
        return ans;
    }
```

### 1545. Find Kth Bit in Nth Binary String
<em>
Given two positive integers n and k, the binary string  Sn is formed as follows:

S1 = "0"
Si = Si-1 + "1" + reverse(invert(Si-1)) for i > 1
Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).

For example, the first 4 strings in the above sequence are:

S1 = "0"
S2 = "011"
S3 = "0111001"
S4 = "011100110110001"
Return the kth bit in Sn. It is guaranteed that k is valid for the given n.
</em>

recurisve approach
- the Sn length is 2^n-1.
- the mid one is always 1-->2^(n-1)
- if it falls left side ->Sub(n-1,k)
- if it falls right side ->Sub(n-1,2^(n-1)-(k-2^(n-1)) (reverse order and reverse bit)
```cpp
    char findKthBit(int n, int k) {
        //length for sn=2^n-1
        //k start from 1
        //cout<<n<<" "<<k<<endl;
        if(n==1) return '0';
        if(k==1<<(n-1)) return '1';
        if(k<(1<<(n-1))) return findKthBit(n-1,k);
        return findKthBit(n-1,(1<<n)-k)=='0'?'1':'0'; //inverse it
    }
```

### 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target
<em>
Given an array nums and an integer target.

Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.
</em>

idea: 
- first find all the segments (two sum using hashmap)
- then sort the segments according to end.
- greedy find the max number of non-overlap regions

one optimization: we only keep the largest index (since the ending is fixed, the shorter one is always the choice)
```cpp
    int maxNonOverlapping(vector<int>& nums, int target) {
        //segment
        vector<vector<int>> seg;
        unordered_map<int,int> mp; //prefix vs index, we may only save the largest
        mp[0]=-1;
        int pre=0;
        for(int i=0;i<nums.size();i++){
            pre+=nums[i];
            if(mp.count(pre-target)){
                //for(int s: mp[pre-target]) seg.push_back({s+1,i});
                seg.push_back({mp[pre-target]+1,i});
            }
            mp[pre]=i;
        }
        //check the number of non-overlapping
        sort(begin(seg),end(seg),[](vector<int>& a,vector<int>& b){
            return a[1]<b[1];
        });
        //cout<<seg.size();
        //for(auto t: seg){cout<<t[0]<<","<<t[1]<<endl;}
        int ans=0;
        int end=-1;
        for(auto t: seg){
            if(t[0]>end){
                end=t[1];
                ans++;
            }
        }
        return ans;
    }	
```

### 1547. Minimum Cost to Cut a Stick
given a list of cut positons, n is the length.
cut cost is the length.
n up to 10^6 and cut up to 100.

analysis:
- it is a dp problem. we have m! permutations, and the complexity would be O(m!) which is too high
- the state totally depends the ordering, each cut position can have m choices
- dp[i,j] defines the min cost (arrange cut i at jth position)
- can we derive some relation? very hard.
- let's redefine dp[i,j] as the min cost for cut log from A[i] to A[j]
dp[i,j]=min(dp[i,j],dp[i,k]+dp[k,j]+A[j]-A[i])
- another thinking: reverse thinking: merge all the cut logs into one. similar to LC1000, min cost to merge stones.
```cpp
    int minCost(int n, vector<int>& A) {
        A.push_back(0);
        A.push_back(n);
        sort(begin(A), end(A));
        int N = A.size();
        vector<vector<int>> dp(N, vector<int>(N, INT_MAX));
        for (int i = 0; i < N - 1; ++i) dp[i][i + 1] = 0;
        for (int i = 0; i < N - 2; ++i) dp[i][i + 2] = A[i + 2] - A[i];
        for (int len = 2; len <= N; ++len) {
            for (int i = 0; i <= N - len; ++i) {
                int j = i + len - 1;
                for (int k = i + 1; k < j; ++k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[j] - A[i]);
            }
        }
        return dp[0][N - 1];
    }
```
	





	

## contest 202

### 1550. Three Consecutive Odds
straightforward
```cpp
    bool threeConsecutiveOdds(vector<int>& arr) {
        int cnt=0;
        for(int i: arr){
            if(i%2) {
                cnt++;
                if(cnt>=3) return 1;
            }
            else cnt=0;
        }
        return 0;
    }
```

### 1551. Minimum Operations to Make Array Equal
the array is 1,3,....2n+1
+1 and -1 pair to make the array equal

-greedy, all shall goes to median. using a for loop to n/2
- O(1). arithmetic sequence

### 1552. Magnetic Force Between Two Balls
<em>
In universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.
</em>

binary search to find the rightmost valid distance.
```cpp
    int maxDistance(vector<int>& position, int m) {
        sort(begin(position),end(position));
        //binary search the distance
        int l=1,r=position.back()-position[0];
        while(l<r){
            
            int mid=l+(r-l+1)/2;
            if(!valid(position,mid,m)) r=mid-1;
            else l=mid;
            
        }
        return l;
    }
    bool valid(vector<int>& pos,int d,int m){
        //greedy
        int cnt=1,pre=pos[0];
        for(int i=1;i<pos.size();i++){
            if(pos[i]-pre>=d) {cnt++,pre=pos[i];}
        }
        return cnt>=m;
    }
```	

### 1553. Minimum Number of Days to Eat N Oranges
eat one, left n-1
eat half (even), left n/2
eat 2/3 (divisible by 3), left n/3
n up to 2^32

direct dp:
```cpp
    int minDays(int n) {
        //dp
        vector<int> dp(n+1,n);
        dp[0]=0,dp[1]=1;
        for(int i=2;i<=n;i++){ //have i apples
            dp[i]=min(dp[i],min({dp[i-1],i%2==0?dp[i/2]:n,i%3==0?dp[i/3]:n})+1);
        }
        return dp[n];
    }
```	
It will TLE and MLE.

using top down recursive + hashmap is more suitable since we do not need solve each smaller problem:

```cpp
    unordered_map<int, int> dp;
    int minDays(int n) {
        if (n <= 1)
            return n;
        if (dp.count(n) == 0)
            dp[n] = 1 + min(n % 2 + minDays(n / 2), n % 3 + minDays(n / 3));
        return dp[n];
    }
```
- the key point is move the -1 steps to the end, so we only compare n/3 and n/2 path.

we can also use bfs (log(N) steps)
```cpp
    int minDays(int n) {
        //using bfs
        if(n<2) return n;
        queue<int> q;
        unordered_set<int> v;
        q.push(n);
        v.insert(n);
        int step=0;
        while(q.size()){
            int sz=q.size();
            
            while(sz--){
                int cur=q.front();
                q.pop();
                if(cur==0) return step;
                if(cur%3==0 && !v.count(cur/3)) q.push(cur/3),v.insert(cur/3);
                if(cur%2==0 && !v.count(cur/2)) q.push(cur/2),v.insert(cur/2);
                if(!v.count(cur-1)) q.push(cur-1),v.insert(cur-1);
            }
            step++;
        }
        return -1;
    }
```

	

	




	

## contest 203

1560. Most visited sector in a circular track

1561. Max number of coins you can get

1562. Find latest group of size Max

1563. Stone game V

### 1560. Most visited sector in a circular track ***
<em>
Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]

Return an array of the most visited sectors sorted in ascending order.

Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).
</em>

This is not an easy problem.
idea: 
- maintain an array of each sector's counter and get the max.
- the rounds: a->b we shall make b>a by adding a round to it. (multiple rounds does not matter since it add same to all sectors).
- increase the counter to all sectors between.

```cpp
    vector<int> mostVisited(int n, vector<int>& rounds) {
        vector<int> ans,v(n);
        for(int& i: rounds) i--;
        int pre=rounds[0];
        int mx=0;
        
        for(int i=1;i<rounds.size();i++){
            while(rounds[i]<=rounds[i-1]) rounds[i]+=n;
            for(int j=pre;j<rounds[i];j++) mx=max(mx,++v[j%n]);
            pre=rounds[i];
        }
        
        mx=max(mx,++v[rounds.back()%n]);
        for(auto i=0;i<n;i++) if(v[i]==mx) ans.push_back(i+1) ;
        return ans;
    }
```	
note: do not forget the last one.
actually, according to above analysis:
- the inner side rounds does not matter since the whole rounds make no difference
- we only need to process the first and last.

### 1561. Max number of coins you can get **
<em>
There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins which you can have.
</em>
greedy approach: we always choose the min and max and 2nd max.

```cpp
    int maxCoins(vector<int>& piles) {
        //greedy
        sort(begin(piles),end(piles));
        int i=0,n=piles.size(),j=n-1;
        int ans=0;
        while(i<j){
            ans+=piles[j-1];
            i++,j-=2;
        }
        return ans;
    }
```
	

### 1562. Find latest group of size Max ****
<em>
Given an array arr that represents a permutation of numbers from 1 to n. You have a binary string of size n that initially has all its bits set to zero.

At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1. You are given an integer m and you need to find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1s such that it cannot be extended in either direction.

Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.
</em>

My intuition on this is union-find, but I then thought it is also a binary search problem.
binary search is incorrect because the M group may appear on left, or appear on right, or sometimes disappear and then appear.  Only after I get several wrong answer I realize it.

union find is actually straightforward, we need to keep the group size vs count.
- union find to group consecutives
- maintain each group size
- maintain a reverse map: group size vs count.

```cpp
    vector<int> parent;
    unordered_map<int,int> size,revsize;
    
    int findLatestStep(vector<int>& arr, int m) {
        //union find and get the groups of m
        if(arr.empty()) return -1;
        int n=arr.size();
        vector<bool> v(n+1);
        parent.resize(n+1);
        //revsize[1]=n;//if we have one bit to set.
        for(int i: arr) parent[i]=i,size[i]=1;
        unordered_set<int> ms;
        //revsize[1]=n;//incorrect since we are doing one by one.
        int ans=-1;
        for(int i=0;i<arr.size();i++){
            int cur=arr[i];
            revsize[1]++;//first add current as a disjoint set.
            if(ms.count(cur-1)) merge(cur,cur-1);
            if(ms.count(cur+1)) merge(cur,cur+1);
            
            //check if there is any group==m
            if(revsize[m]>0) ans=i+1;
            ms.insert(cur);
        }
        return ans;
    }
    int findp(int i){
        while(i!=parent[i]){
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
    void merge(int i,int j){
        int pi=findp(i),pj=findp(j);
        if(pi!=pj){
            revsize[size[pi]]=max(revsize[size[pi]]-1,0);//the old set disappear
            revsize[size[pj]]=max(revsize[size[pj]]-1,0);//the old set disappear
            parent[pi]=pj;
            size[pj]+=size[pi];
            revsize[size[pj]]++;
            size[pi]=0;
        }
    }
```	
I got more than 7 wrong submission for this!!!

### 1563. Stone game V ***
<em>
There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.

In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.

The game ends when there is only one stone remaining. Alice's is initially zero.

Return the maximum score that Alice can obtain.
</em>

using top down, and we can get a dp approach using what the problem states.
the only thing is we shall not add the last stone (since we already added before the last).

```cpp
    int stoneGameV(vector<int>& stoneValue) {
        int n=stoneValue.size();
        vector<vector<long>> dp(n,vector<long>(n));
        return helper(stoneValue,0,n-1,dp);
    }
    long helper(vector<int>& stones,int l,int r,vector<vector<long>>& dp){
        if(r==l) return 0;//stones[l];
        if(dp[l][r]>0) return dp[l][r];
        long tsum=accumulate(begin(stones)+l,begin(stones)+r+1,0l);
        long lsum=0;
        long ans=0;
        for(int i=l;i<r;i++){
            lsum+=stones[i];
            if(2*lsum<tsum) ans=max({ans,lsum+helper(stones,l,i,dp)});
            else if(2*lsum==tsum) ans=max({ans,lsum+helper(stones,l,i,dp),lsum+helper(stones,i+1,r,dp)});
            else ans=max({ans,tsum-lsum+helper(stones,i+1,r,dp)});
        }
        return dp[l][r]=ans;
    }
```	

### contest 203
1566. Detect Pattern of Length M Repeated K or More Times
<em>
Given an array of positive integers arr,  find a pattern of length m that is repeated k or more times.

A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.

Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false.
</em>

correctly Understand the problem is the key!.
```cpp
    bool containsPattern(vector<int>& arr, int m, int k) {
        int n=arr.size();
        for(int i=0;i<=n-m*k;i++){
            bool valid=1;
            for(int j=i;j<i+m && valid;j++){
                for(int l=1;l<k;l++)
                    if(j+l*m>=arr.size() || arr[j+l*m]!=arr[j]) {
                        valid=0;break;
                    }
            }
            if(valid) return 1;
        }
        return 0;
    }
```

with optimization:
```cpp
 bool containsPattern(vector<int>& arr, int m, int k) {

        int cnt=0;
        for(int i=0;i+m < arr.size(); i++){
            
            if(arr[i]!=arr[i+m]){
              cnt=0;  
            }
            cnt += (arr[i] == arr[i+m]);
            if(cnt == (k-1)*m)
                return true;
            
        }
        return false;
    }
```

### 1567. Maximum Length of Subarray With Positive Product
<em>
Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.

A subarray of an array is a consecutive sequence of zero or more values taken out of that array.

Return the maximum length of a subarray with positive product.
</em>

intuition:
- two pointer. once we see zero, we finish previous and start a new segment.
- we record odd/even negative status of a segment.
- we record the first index of 0 and 1 (similar to hashmap) and accumulate the odd/even status and update the valid length

```cpp
    int getMaxLen(vector<int>& nums) {
        int n=nums.size();
        int i=0,j=0,k=0,ans=0;
        //prefix xor: //record the first index of 0 and 1
        int pre=0,ind0=-1,ind1=-1;
        while(j<n){
            if(nums[j]==0){
                pre=0;
                ind0=ind1=-1;
                i=j+1;
            }
            else{
                if(nums[j]<0) pre^=1;
                if(pre){
                    if(ind1<0) ind1=j;
                    else ans=max(ans,j-ind1);
                }
                else{
                    if(ind0<0) ind0=j;
                    else ans=max(ans,j-ind0);
                }
            }
            if(pre==0) ans=max(ans,j-i+1);
            j++;
        }
        return ans;
    }
```

### 1568. Minimum Number of Days to Disconnect Island
<em>
Given a 2D grid consisting of 1s (land) and 0s (water).  An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.

The grid is said to be connected if we have exactly one island, otherwise is said disconnected.

In one day, we are allowed to change any single land cell (1) into a water cell (0).

Return the minimum number of days to disconnect the grid.
</em>

only 3 cases:
- if there is 0 or more than 1 islands, just return 0
- if there is a critical edge connecting two islands, break it, return 1
- otherwise return 2 (using the bottom right or any cell with only two connected cells and separate it from the island)

```cpp
    int M, N, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    void dfs(vector<vector<int>> &G, int i, int j,vector<vector<int>> &seen) {
        seen[i][j] = true;
        for (auto &[dx, dy] : dirs) {
            int x = dx + i, y = dy + j;
            if (x < 0 || x >= M || y < 0 || y >= N || G[x][y] != 1 || seen[x][y]) continue;
            dfs(G, x, y, seen);
        }
    }
    bool disconnected(vector<vector<int>> &G) {
        vector<vector<int>> seen(M, vector<int>(N, false));
        int cnt = 0;
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                if (G[i][j] != 1 || seen[i][j]) continue;
                if (++cnt > 1) return true;
                dfs(G, i, j, seen);
            }
        }
        return cnt == 0;
    }
public:
    int minDays(vector<vector<int>>& G) {
        M = G.size(), N = G[0].size();
        if (disconnected(G)) return 0;
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                if (G[i][j] != 1) continue;
                G[i][j] = 0;
                if (disconnected(G)) return 1;
                G[i][j] = 1;
            }
        }
        return 2;
    }
```	
similar problem 934. Shortest Bridge

### 1569. Number of Ways to Reorder Array to Get Same BST

<em>
Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.

For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.

Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.

Since the answer may be very large, return it modulo 10^9 + 7.
</em>

observation:
- root fixed, then divide into left and right.
- we can choose either left or right first.
- in each subtree, you can also choose left or right first. (this is critical)

for example:
[3,1,2,5,4,6]
left=[1,2], right=[5,4,6], 4 and 6 are the left and right node of 5.
1 and 5 are left right nodes of 3.
left first
3,1,2,5,4,6
3,1,5,2,4,6
3,1,5,4,2,6
3,1,5,4,6,2
right first:
3,5,1,2,4,6
3,5,1,4,2,6
3,5,1,4,6,2
3,5,4,6,1,2
3,5,4,1,6,2
3,5,4,1,2,6
total 10, but we missed swap 4 and 6. so we need double it, the answer is 20.

so the approach:
- split into left and right
- the first element is always the root.
- use left child first + use right child first.

backtrack:
- when input is empty, return 1.
- ans+=nleft*nright (nleft is the subproblem for left subtree, and nright is the subproblem for right subtree)

```cpp
    int numOfWays(vector<int>& nums) {
		return helper(nums)-1;
    }
    int helper(vector<int>& nums){
		if(nums.empty()) return 1;
		int n=nums.size();
        int mod=1e9+7;
		int root=nums[0];
		vector<int> left,right;
		for(int i=1;i<nums.size();i++){
			if(nums[i]<root) left.push_back(nums[i]);
			else right.push_back(nums[i]);
		}
		int nleft=helper(left)%mod,nright=helper(right)%mod;
		long ans=(long)nleft*nright%mod;
        ans*=comb(n-1,left.size());
        ans%=mod;
        return ans;       
    }
	int comb(int m,int n){
		long ans=1;
		int mod=1e9+7;
		for(int i=1;i<=n;i++){
			ans=ans*(m-n+i)/i;
		}
		ans%=mod;
		return ans;
	}
```	

this will not be able to support m to 1000 since it will be too large.

using pascal triangle to calculate the table.
```cpp
    vector<vector<int>> pascal;
    int numOfWays(vector<int>& nums) {
        int mod=1e9+7;
        int n=nums.size();
        pascal.resize(n + 1);
        for(int i = 0; i < n + 1; ++i){
            pascal[i] = vector<int>(i + 1, 1);
            for(int j = 1; j < i; ++j){
                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j]) % mod;
            }
        }        
		return helper(nums)-1;
    }
    int helper(vector<int>& nums){
		if(nums.empty()) return 1;
		int n=nums.size();
        int mod=1e9+7;
		int root=nums[0];
		vector<int> left,right;
		for(int i=1;i<nums.size();i++){
			if(nums[i]<root) left.push_back(nums[i]);
			else right.push_back(nums[i]);
		}
		int nleft=helper(left)%mod,nright=helper(right)%mod;
		long ans=(long)nleft*nright%mod;
        ans*=pascal[n-1][left.size()];//comb(n-1,left.size());
        ans%=mod;
        return ans;       
    }
```

another approach: 
build the binary tree and count the traversal ways.









## contest 205

1579	Remove Max Number of Edges to Keep Graph Fully Traversable    		38.6%	Hard	
1578	Minimum Deletion Cost to Avoid Repeating Letters    		57.5%	Medium	
1577	Number of Ways Where Square of Number Is Equal to Product of Two Numbers    		34.5%	Medium	
1576	Replace All ?'s to Avoid Consecutive Repeating Characters    		46.4%

### 1576. Replace All ?'s to Avoid Consecutive Repeating Characters
<em>
Given a string s containing only lower case English letters and the '?' character, convert all the '?' characters into lower case letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.

It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.

Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints.
</em>

idea: compare with its left and right. change from 'a' to 'z'

```cpp
string modifyString(string s) {
    for (auto i = 0; i < s.size(); ++i) {
        if (s[i] == '?') {
            for (s[i] = 'a'; s[i] <= 'z'; ++s[i]) {
                if ((i == 0 || s[i - 1] != s[i]) && (i == s.size() - 1 || s[i + 1] != s[i]))
                    break;
            }
        }
    }
    return s;
}
```

### 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers
<em>
Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:

Type 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.
Type 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.
 
 </em>
 
 hashmap, two problems.
 
 ```cpp
     int numTriplets(vector<int>& nums1, vector<int>& nums2) {
        return helper(nums1,nums2)+helper(nums2,nums1);
 
    }
    int helper(vector<int>& nums1,vector<int>& nums2){
        int ans=0;
        unordered_map<int,int> mp;
        for(int i: nums2) mp[i]++;
        for(int i: nums1){
            long t=(long)i*i;
            //check all its factors
            //if(mp.count(1) && mp.count(t)) ans+=mp[1]*mp[t];
            for(int j=1;j<=i;j++){
                if(t%j==0 && mp.count(j) && mp.count(t/j)){
                    if((long)j*j==t) ans+=mp[j]*(mp[j]-1)/2; //choose 2 permutation
                    else ans+=mp[j]*mp[t/j];
                }
            }
        }
        return ans;
    }
```
- use long to avoid overflow.
- factor the same, choose 2 from it C(n,2)

### 1578. Minimum Deletion Cost to Avoid Repeating Letters
<em>
Given a string s and an array of integers cost where cost[i] is the cost of deleting the character i in s.

Return the minimum cost of deletions such that there are no two identical letters next to each other.

Notice that you will delete the chosen characters at the same time, in other words, after deleting a character, the costs of deleting other characters will not change.
</em>

idea: for the group of same chars, the cost is sum(cost)-max(cost). You do not need a heap.
to avoid the last one, add one element to both arrays.
```cpp
    int minCost(string s, vector<int>& cost) {
        int ans=0;
        //two together, choose the max cost char, all other deleted
        //more than 2, we need delete n-1 chars, choose the min cost
        s.push_back('$');cost.push_back(0);
        int sum=0,mx=0;
        char pre=0;
        for(int i=0;i<s.size();i++){
            if(s[i]!=pre){
                ans+=sum-mx;
                pre=s[i];
                sum=mx=cost[i];
            }
            else mx=max(mx,cost[i]),sum+=cost[i];
        }
        return ans;
    }
```
	
### 1579. Remove Max Number of Edges to Keep Graph Fully Traversable
<em>
Alice and Bob have an undirected graph of n nodes and 3 types of edges:

Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can by traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return -1 if it's impossible for the graph to be fully traversed by Alice and Bob.
</em>

idea: similar to MST (minimum spanning tree). using union find. 
greedy: choose 3 first.

```cpp
    vector<int> parent;
    int sz;
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
        //min spanning tree for alice and bob
        int ans=0;
        vector<vector<int>> e1,e2,e3;
        for(auto e: edges){
            if(e[0]==1) e1.push_back(e);
            else if(e[0]==2) e2.push_back(e);
            else e3.push_back(e);
        }
        //sort(begin(edges),end(edges),greater<vector<int>>()); //if 
        parent.resize(n);
        for(int i=0;i<n;i++) parent[i]=i;
        sz=n;
        int cnt=0;
        for(auto e: e3){
            int i=e[1]-1,j=e[2]-1;
            int pi=findp(i),pj=findp(j);
            if(pi!=pj){
                parent[pi]=pj;
                sz--;
            }
            else ans++;
            cnt++;
            if(sz==1) return ans+edges.size()-cnt;
        }
        //cout<<sz<<endl;
        //check 1 and 2
        int sz1=sz,cnt1=0;
        auto op=parent;
        cnt=0;
        for(auto e: e1){
            int i=e[1]-1,j=e[2]-1;
            int pi=findp(i),pj=findp(j);
            if(pi!=pj){
                parent[pi]=pj;
                sz1--;
            }
            else cnt1++;
            cnt++;
            if(sz1==1) {ans+=e1.size()-cnt;break;}
        }
        //cout<<sz1<<endl;
        if(sz1==1) ans+=cnt1;
        else return -1;
        parent=op;
        int sz2=sz,cnt2=0;
        cnt=0;
        for(auto e: e2){
            int i=e[1]-1,j=e[2]-1;
            int pi=findp(i),pj=findp(j);
            if(pi!=pj){
                parent[pi]=pj;
                sz2--;
            }
            else cnt2++;
            cnt++;
            if(sz2==1) {ans+=e2.size()-cnt;break;}
        }
        //cout<<sz2<<endl;
        if(sz2==1) ans+=cnt2;
        else return -1;
        return ans;
    }
    int findp(int i){
        while(i!=parent[i]) {
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
```

to avoid TLE: prune when size==1.
	


	
## contest 206

### 1582. Special Positions in a Binary Matrix
<em>
Given a rows x cols matrix mat, where mat[i][j] is either 0 or 1, return the number of special positions in mat.

A position (i,j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).
</em>

two passes:
```cpp
    int numSpecial(vector<vector<int>>& mat) {
        int m=mat.size(),n=mat[0].size();
        vector<int> row(m),col(n);
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++) row[i]+=mat[i][j],col[j]+=mat[i][j];
        }
        int ans=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++) {
                if(mat[i][j] && row[i]==1 && col[j]==1) ans++;
            }
        }
        return ans;
    }
```

### 1583. Count Unhappy Friends
<em>
You are given a list of preferences for n friends, where n is always even.

For each person i, preferences[i] contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from 0 to n-1.

All the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi.

However, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:

x prefers u over y, and
u prefers x over v.
Return the number of unhappy friends.
</em>

approach:
convert the preference into hashmap (2d matrix) so that we can access index directly.
```cpp
    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {
        int ans=0;
        vector<unordered_map<int,int>> pref(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<preferences[i].size();j++) pref[i][preferences[i][j]]=j;
        }
        vector<bool> vt(n);
        for(int i=0;i<pairs.size();i++){
            for(int j=i+1;j<pairs.size();j++){//check the 4 person
                int x=pairs[i][0],y=pairs[i][1],u=pairs[j][0],v=pairs[j][1];
                //find y,u,v index in x's 
                vt[x]=vt[x]||unhappy(x,y,u,v,pref);
                vt[y]=vt[y]||unhappy(y,x,u,v,pref);
                vt[u]=vt[u]||unhappy(u,v,x,y,pref);
                vt[v]=vt[v]||unhappy(v,u,x,y,pref);
            }
        }
        //for(auto i: vt) cout<<i<<" ";cout<<endl;
        return accumulate(begin(vt),end(vt),0);
    }
    bool unhappy(int x,int y,int u,int v,vector<unordered_map<int,int>>& pref){
        //x prefers u over y and u prefers x over v
        if(pref[x][u]<pref[x][y] && pref[u][x]<pref[u][v]) return 1;//x,u
        if(pref[x][v]<pref[x][y] && pref[v][x]<pref[v][u]) return 1;//x,v
        return 0;
    }
```

### 1584. Min Cost to Connect All Points
<em>
You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].

The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.

Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.
</em>

approach 1: 
min spanning tree: calculate all edge distance and sort and union find.

```cpp
    vector<int> parent;
    int size;
    int minCostConnectPoints(vector<vector<int>>& points) {
        //min total manhaton distance
        //each point connect to it closest points
        int n=points.size();
        vector<vector<int>> dist;
        parent.resize(n);
        for(int i=0;i<n;i++) parent[i]=i;
        size=n;
        
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++) {
                int d=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]);
                dist.push_back({d,i,j});
            }
        }
        sort(begin(dist),end(dist));
        
        //union find to build a MST
        //for each point pick the min 
        int ans=0; 
        //globally optimized shall use pq.
        for(auto p: dist){
            int pi=findp(p[1]),pj=findp(p[2]);
            if(pi!=pj){
                ans+=p[0];
                parent[pi]=pj;
                size--;
                if(size==1) break;
            }
        }
    
        return ans;
    }
    int findp(int i){
        while(i!=parent[i]) {parent[i]=parent[parent[i]];i=parent[i];}
        return i;
    }
```
N=n^2, and complexity would be O(NlogN) and it will TLE.

using priority_queue will TLE too.
using make_heap

but using array<int,3> to replace vector will make it faster and will pass the OJ
using array<int,3> with sort still TLE
so:
- vector<vector> is much more flexible and complicated so with low efficiency
- use array for fixed sized array is much faster.
- heap is faster than sort because we early terminated (form a heap is not sort the array)

dijkstra or prim's algorithm:
In the Prim's algorithm, we are building a tree starting from some initial point. We track all connected points in visited. For the current point, we add its edges to the min heap. Then, we pick a smallest edge that connects to a point that is not visited. Repeat till all points are visited.

```cpp
int minCostConnectPoints(vector<vector<int>>& ps) {
    int n = ps.size(), res = 0, i = 0, connected = 0;
    vector<bool> visited(n);
    priority_queue<pair<int, int>> pq;
    while (++connected < n) {
        visited[i] = true;
        for (int j = 0; j < n; ++j)
            if (!visited[j])
                pq.push({-(abs(ps[i][0] - ps[j][0]) + abs(ps[i][1] - ps[j][1])), j});
        while (visited[pq.top().second])
            pq.pop();
        res -= pq.top().first;
        i = pq.top().second;
        pq.pop();
    }
    return res;
}
```

### 1585. Check If String Is Transformable With Substring Sort Operations
<em>
Given two strings s and t, you want to transform string s into string t using the following operation any number of times:

Choose a non-empty substring in s and sort it in-place so the characters are in ascending order.
For example, applying the operation on the underlined substring in "14234" results in "12344".

Return true if it is possible to transform string s into string t. Otherwise, return false.

A substring is a contiguous sequence of characters within a string.
</em>

s=84532, t=34852
84532->84352->34852

- sort will shift the smaller one to the left and bigger one to the right. (bubble sort)
- using this we at least know the case for false. (if violate the case, compare the sorted case).
- t shall be smaller than s. (sort)
- the two string shall be equal if sorted.
- sort the subarray is equivalent to bubble sort (swapping adjacent two characters)

so we need move the char left to see if we can get t.
for example:
84532, first move 3 left,4 left,...

```cpp
bool isTransformable(string s, string t) {
    vector<vector<int>> idx(10);
    vector<int> pos(10); //each digit's current index
    for (int i = 0; i < s.size(); ++i)
        idx[s[i] - '0'].push_back(i); //store each digit indices in s into array.
    for (auto ch : t) {
        int d = ch - '0';
        if (pos[d] >= idx[d].size())
            return false;
        for (auto i = 0; i < d; ++i)
            if (pos[i] < idx[i].size() && idx[i][pos[i]] < idx[d][pos[d]])
                return false;
        ++pos[d];
    }
    return true;
}
```
pos[d] stores number of digit d used.







	


## contest 207

1592. Rearrange Spaces Between Words
<em>
You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.

Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.

Return the string after rearranging the spaces.
</em>

using stringstream and store words in vector and calculate space and spaces after the last one.

```cpp
    string reorderSpaces(string text) {
        stringstream ss(text);
        string w,ans;
        vector<string> vt;
        int len=0;
        while(ss>>w) vt.push_back(w),len+=w.size();
        int nspaces=text.size()-len;
        if(vt.size()==1) {
            ans=vt[0];
            ans.append(text.size()-vt[0].size(),' ');
            return ans;
        }
        //cout<<nspaces<<endl;
        int nadd=nspaces/(vt.size()-1);
        int nend=nspaces%(vt.size()-1);
        for(int i=0;i<vt.size()-1;i++){
            ans+=vt[i];
            ans.append(nadd,' ');
        }
        ans+=(vt.back());
        ans.append(nend,' ');
        return ans;
    }
```

1593. Split a String Into the Max Number of Unique Substrings
<em>
Given a string s, return the maximum number of unique substrings that the given string can be split into.

You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.

A substring is a contiguous sequence of characters within a string.
</em>
greedy does not work.
binary search is not easy
backtrack shall be able to do it
dp: not easy to store the status since it depends on previous cut.
backtrack: from 1 char to the whole string as the first step
```cpp
    int maxUniqueSplit(string s) {
        unordered_set<string> ms;
        
        return helper(s,ms);
    }
    int helper(string s,unordered_set<string>& ms){
        int ans=0;
        //if(s.empty()) return 0;
        for(int i=0;i<s.size();i++){
            string cand=s.substr(0,i+1);
            if(ms.count(cand)==0){
                ms.insert(cand);
                //cout<<cand<<" "<<i+1<<endl;
                ans=max(ans,1+helper(s.substr(i+1),ms));
                ms.erase(cand);
            }
        }
        return ans;
    }
```

Note: using value passing will TLE.

1594. Maximum Non Negative Product in a Matrix
<em>
You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.

Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.

Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative return -1.

Notice that the modulo is performed after getting the maximum product.
</em>

dp: keep tracking of min and max at the same time.

```cpp
    int maxProductPath(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        vector<vector<long>> mx(m+1,vector<long>(n+1,-1)),mn(m+1,vector<long>(n+1,INT_MAX));
        mx[0][1]=mx[1][0]=mn[0][1]=mn[1][0]=1;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(grid[i-1][j-1]>=0){
                    mx[i][j]=max(mx[i-1][j],mx[i][j-1])*grid[i-1][j-1];
                    mn[i][j]=min(mn[i-1][j],mn[i][j-1])*grid[i-1][j-1];
                }
                else{
                    mx[i][j]=min(mn[i-1][j],mn[i][j-1])*grid[i-1][j-1];
                    mn[i][j]=max(mx[i-1][j],mx[i][j-1])*grid[i-1][j-1];
                }
            }
        }
        int mod=1e9+7;
        return mx[m][n]<0?-1:mx[m][n]%mod;
    }
```	

1595. Minimum Cost to Connect Two Groups of Points
<em>
You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2.

The cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.

Return the minimum cost it takes to connect the two groups.
size 1 and 2<=12.
</em>

Apparently this is a dp problem with a lot of choices
consider the graph as a matrix, m[i,j] represents the edge cost between i and j. mxn choices. (looks similar to campus bike problem)
our target: all i is connected and all j is connected with the min prices.

The difficulty lies how we represent the requirements in data structure.
bitmask [1<<m][1<<n] and the answer is dp[1<<m-1,1<<n-1]
dp[i,j] represents the min cost using bitset i from group 1 and bitset 2 from group 2. (this does not include information which connects which)
then how do we make the next choices?

above approach is not right.

Instead we use the first group elements with second group bitmask dp[i,mask]
After finishing with the first group, we detect elements in group 2 that are still disconnected, and connect them with the "cheapest" node in the first group

the code below is taken from other's code post:

```cpp
int dp[13][4096] = {};
int dfs(vector<vector<int>>& cost, vector<int> &min_sz2, int i, int mask) {
    if (dp[i][mask]) return dp[i][mask] - 1;    
	int m=cost.size(),n=cost[0].size();
    int res = i >= m ? 0 : INT_MAX;
    if (i >= m){ //finished group 1
        for (auto j = 0; j < n; ++j)
            res += min_sz2[j] * ((mask & (1 << j)) == 0);
	}
    else{
        for (auto j = 0; j < n; ++j)
            res = min(res, cost[i][j] + dfs(cost, min_sz2, i + 1, mask | (1 << j)));
	}
    dp[i][mask] = res + 1;
    return res;
}
int connectTwoGroups(vector<vector<int>>& cost) {
    vector<int> min_sz2(cost[0].size(), INT_MAX);
    for (int j = 0; j < min_sz2.size(); ++j)
        for (int i = 0; i < cost.size(); ++i)
            min_sz2[j] = min(min_sz2[j], cost[i][j]);
    return dfs(cost, min_sz2, 0, 0);
}
```	




	
## contest 208

### 1598. Crawler Log Folder
<em>
The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:

"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
"./" : Remain in the same folder.
"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.

The file system starts in the main folder, then the operations in logs are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.
</em>

```cpp
    int minOperations(vector<string>& logs) {
        int ans=0;
        int level=0;
        for(auto s: logs){
            s.pop_back();
            if(s==".");
            else if(s=="..") {level--;if(level<0) level=0;}
            else level++;
        }
        return level;
    }
```

### 1599. Maximum Profit of Operating a Centennial Wheel
<em>
You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.

You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before customers[i] arrive. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.

You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.

Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.

 
</em>

tracking the rotation and profit.

```cpp
    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {
        //we can stop anytime
        int ans=0,num_rot=0,max_prof=INT_MIN;
        //max profit
        int num_wait=0,profit=0;
        int i=0;
        
        while(num_wait || i<customers.size()) {//for(int i: customers){
            num_wait+=i<customers.size()?customers[i]:0;
            int nboard=num_wait<4?num_wait:4;
            profit+=nboard*boardingCost-runningCost;

            if(profit>max_prof){
                ans=i+1;
                max_prof=profit;
            }
            //max_prof=max(max_prof,profit);
            num_wait-=nboard;
            i++;
        }
        return max_prof<0?-1:ans;
    }
```
	
### 1600. Throne Inheritance
<em>
A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.

The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance.

Successor(x, curOrder):
    if x has no children or all of x's children are in curOrder:
        if x is the king return null
        else return Successor(x's parent, curOrder)
    else return x's oldest child who's not in curOrder
For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack.

In the beginning, curOrder will be ["king"].
Calling Successor(king, curOrder) will return Alice, so we append to curOrder to get ["king", "Alice"].
Calling Successor(Alice, curOrder) will return Jack, so we append to curOrder to get ["king", "Alice", "Jack"].
Calling Successor(Jack, curOrder) will return Bob, so we append to curOrder to get ["king", "Alice", "Jack", "Bob"].
Calling Successor(Bob, curOrder) will return null. Thus the order of inheritance will be ["king", "Alice", "Jack", "Bob"].
Using the above function, we can always obtain a unique order of inheritance.

Implement the ThroneInheritance class:

ThroneInheritance(string kingName) Initializes an object of the ThroneInheritance class. The name of the king is given as part of the constructor.
void birth(string parentName, string childName) Indicates that parentName gave birth to childName.
void death(string name) Indicates the death of name. The death of the person doesn't affect the Successor function nor the current inheritance order. You can treat it as just marking the person as dead.
string[] getInheritanceOrder() Returns a list representing the current order of inheritance excluding dead people.
 </em>
 
 typical dfs, need to carry information of live or death
 using one hashmap or two hashmap
 ```cpp
     unordered_map<string,pair<bool,vector<pair<bool,string>>>> mp;
    string king;
    ThroneInheritance(string kingName) {
        mp[kingName]={0,{}};
        king=kingName;
    }
    
    void birth(string parentName, string childName) {
        mp[childName]={0,{}};
        mp[parentName].second.push_back({0,childName});
    }
    
    void death(string name) {
        mp[name].first=1;
    }
    
    vector<string> getInheritanceOrder() {
        //dfs search
        vector<string> ans;
        dfs(king,ans);
        return ans;
    }
    void dfs(string& root,vector<string>& ans){
        //if(mp[root].second.empty()) return;
        if(mp[root].first==0) ans.push_back(root);
        for(auto t: mp[root].second){
            dfs(t.second,ans);
        }
    }
```

### 1601. Maximum Number of Achievable Transfer Requests
<em>
We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.

You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.

All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.

Return the maximum number of achievable requests.
</em>
since number of requests <20, brutal force: bitmask from 0 to ffff and check all combinations. use or not use.

```cpp
    int maximumRequests(int n, vector<vector<int>>& requests) {
        //brutal force backtracking
        vector<int> inout(n);
        int ans=0;
        backtrack(requests,inout,ans,0,0);
        return ans;
    }
    void backtrack(vector<vector<int>>& req,vector<int>& cnt,int& ans,int start,int tsum){
        if(start==req.size()){
            for(int i: cnt) if(i) return;
            ans=max(ans,tsum);
            return;
        }
        
        cnt[req[start][0]]--;
        cnt[req[start][1]]++;
        backtrack(req,cnt,ans,start+1,tsum+1); //add this edge
        cnt[req[start][0]]++;
        cnt[req[start][1]]--;
        backtrack(req,cnt,ans,start+1,tsum); //not add this edge
    }
```

	
 ## contest 209

### 1608. Special Array With X Elements Greater Than or Equal X
<em>
You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.
</em>

approach: sort it and see number of <

```cpp
    int specialArray(vector<int>& nums) {
        sort(begin(nums),end(nums));
        int ans=-1,n=nums.size();
        for(int i=0;i<nums.size();i++){
            //n-i+1 elements >=nums[i], x=n-i+1
            if(nums[i]>=n-i && (!i || (i && nums[i-1]<n-i))) return n-i;
        }
        return -1;
    }
```

### 1609. Even Odd Tree
<em>
A binary tree is named Even-Odd if it meets the following conditions:

The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.
For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).
For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).
Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.
</em>

Note: the layer must all be odd or even, depending on its depth
approach: dfs and store one element in each layer.

```cpp
    bool isEvenOddTree(TreeNode* root) {
        vector<int> v;
        if(root->val%2==0) return 0;
        return dfs(root,1,v);
    }
    bool dfs(TreeNode* root,int d,vector<int>& v){
        if(!root) return 1;
        if(v.size()<d) {
            if(d%2==0 && root->val%2) return 0;
            if(d%2 && root->val%2==0) return 0;
            v.push_back(root->val);
        }
        else {
            if(d%2==0){
                if(root->val%2 || root->val>=v[d-1]) return 0;
                else v[d-1]=root->val;
            }
            else{
                if(root->val%2==0 || root->val<=v[d-1]) return 0;
                else v[d-1]=root->val;
            }
        }
        return dfs(root->left,d+1,v) && dfs(root->right,d+1,v);
    }
```	

### 1610. Maximum Number of Visible Points
<em>
You are given an array points, an integer angle, and your location, where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane.

Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2].


You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.

There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.

Return the maximum number of points you can see.
</em>

calculate each point angle using atan2
atan2 will give [-pi,pi] convert to [0,2pi]
circular array extends to 1d array by adding 2pi.
sliding window to find the range.

```cpp
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        
        map<double,int> mp; //dy/dx is the slope
        int x=location[0],y=location[1];
        int dup=0;
        for(auto p:points){
            int dx=p[0]-x,dy=p[1]-y;
            if(!dx && !dy) {dup++;continue;}
            double deg=atan2(dy,dx)*180.0/pi;
            if(deg<0) deg+=360;
            mp[deg]++;
        }
        //for(auto t: mp) cout<<t.first<<" "<<t.second<<endl;
        vector<pair<double,int>> v(begin(mp),end(mp));
        int n=v.size();
        for(int i=0;i<n;i++) v.push_back({v[i].first+360,v[i].second}); //circular
        //sliding window  ordered by the angles
        int mx=0,sum=0;
        if(angle==0){
            for(auto t: v) mx=max(mx,t.second);
            return mx+dup;
        }
        //circular sliding window
        int i=0,j=0;
        while(j<v.size()){
            sum+=v[j].second;
            while(v[j].first-v[i].first>angle+1e-9){
                sum-=v[i].second;//[1];
                i++;
            }
            mx=max(mx,sum);
            j++;
        }
        //cout<<mx<<" "<<dup<<endl;
        return mx+dup;
    }
```

note: the same as observation point shall be added.

### 1611. Minimum One Bit Operations to Make Integers Zero
<em>
Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.
n<=10^9
</em>


approach:
recursive or bfs approach

bfs approach:
```cpp
    int minimumOneBitOperations(int n) {
        //bfs
        if(!n) return 0;
        string s,t;
        while(n){
            s+='0'+n%2;
            n/=2;
        }
        //cout<<s<<endl;
        //reverse(begin(s),end(s));
        t.append(s.size(),'0');
        queue<string> q;
        //unordered_set<string> v;
        int k=s.size(),m=1<<k;
        vector<bool> v(m);
        //v.insert(s);
        v[stoi(s,0,2)]=1;
        q.push(s);
        int step=0;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                auto ss=q.front();
                q.pop();
                if(ss==t) return step;
                string ns=ss;

                int i=0;
                while(i<ss.size() && ns[i]=='0') i++;
                if(i+1<ss.size()) ns[i+1]='0'+(ns[i+1]-'0')^1;
                int num=stoi(ns,0,2);
                if(v[num]==0){
                    v[num]=1;//v.insert(ns);
                    q.push(ns);
                }
                ns=ss;
                ns[0]='0'+(ns[0]-'0')^1;
                num=stoi(ns,0,2);
                if(v[num]==0/*v.count(ns)==0*/){
                    //v.insert(ns);
                    v[num]=1;
                    q.push(ns);
                }
                
            }
            step++;
        }
        return -1;
    }
```

this will give us the correct results.
for example: 197259 will get answer 13183. This will TLE since the bfs expand exponentially and the layer is very large.

recursive approach:
we need to find the recurrence relation.
for example: 6=110
110->010
010->011
011->001
001->000

first consider one bit set.

1->0 needs 1 ops
2->0 needs 3 ops
4->0 needs 7 ops
2^k needs 2^(k+1)-1 ops.

for example: 
100->101->111->110->010->011->001->000 (7 ops)

1xxxx->110000->010000->0
1xxxx->110000 needs operation recursive(1xxxx^110000)

f(n) = f((b >> 1) ^ b ^ n) + 1 + b - 1
b=2^k which is <=n.

```cpp
    int minimumOneBitOperations(int n, int res = 0) {
        if (n == 0) return res;
        int b = 1;
        while ((b << 1) <= n)
            b = b << 1;
        return minimumOneBitOperations((b >> 1) ^ b ^ n, res + b);
    }
```

	


## contest 210

### 1614. Maximum Nesting Depth of the Parentheses
<em>
A string is a valid parentheses string (denoted VPS) if it meets one of the following:

It is an empty string "", or a single character not equal to "(" or ")",
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

Given a VPS represented as string s, return the nesting depth of s.
</em>

( +1 and ) -1, we are looking for the max positives.

```cpp
    int maxDepth(string s) {
        int ans=0;
        int cnt=0;
        for(char c: s){
            if(c=='(') cnt++;
            else if(c==')') ans=max(ans,cnt--);
        }
        return ans;
    }
```

### 1615. Maximal Network Rank
<em>

There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.

The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.

The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.

Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.
<em>

The statement is very confusing. Even the example I cannot figure out why.
It actually count: number of incoming for node i. The max of pair sum. The direct connection shall only count once.

so the approach: count each node's incoming and record direct connection and try all pairs

```cpp
    int maximalNetworkRank(int n, vector<vector<int>>& roads) {
        //correct understand this is critical
        //count incoming roads, direct connect count only once
        vector<int> cnt(n);
        unordered_set<int> adj;
        for(auto t: roads){
            if(t[0]>t[1]) swap(t[0],t[1]);
            cnt[t[0]]++;
            cnt[t[1]]++;
            adj.insert((t[0]<<16)+t[1]);
        }
        int ans=0;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                ans=max(ans,cnt[i]+cnt[j]-(int)adj.count((i<<16)+j));
            }
        }
        return ans;
    }
```

### 1616. Split Two Strings to Make Palindrome
<em>
You are given two strings a and b of the same length. Choose an index and split both strings at the same index, splitting a into two strings: aprefix and asuffix where a = aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b = bprefix + bsuffix. Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome.

When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s = "abc", then "" + "abc", "a" + "bc", "ab" + "c" , and "abc" + "" are valid splits.

Return true if it is possible to form a palindrome string, otherwise return false.

Notice that x + y denotes the concatenation of strings x and y.
</em>

approach:

note: it needs the same index!!!! two strings have the same length.
leng<=10^5

- two subproblem apre with bsuff, bpre with a suff.
- two pointer: greedily remove identical words and we only need check a[i,j] or b[i,j] is palindrome. (cut at i use b[i,j], cut at j use a[i,j])

```cpp
    bool isPa(string& s, int i, int j) {
        for (; i < j; ++i, --j)
            if (s[i] != s[j])
                return false;
        return true;
    }

    bool check(string& a, string& b) {
        for (int i = 0, j = a.size() - 1; i < j; ++i, --j)
            if (a[i] != b[j])
                return isPa(a, i, j) || isPa(b, i, j);
        return true;
    }

    bool checkPalindromeFormation(string a, string b) {
        return check(a, b) || check(b, a);
    }
```
note the submission is incorrect!

### 1617. Count Subtrees With Max Distance Between Cities
<em>
There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.

A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.

For each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.

Return an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.

Notice that the distance between the two cities is the number of edges in the path between them.
</em>
n<=15. This remind us the brutal force approach.
try all combinations using bitset
for each set, dfs to find the diameter of the tree. (it may be an invalid tree).

- need to get the combinations
- need to judge if it forms a tree
- need to find the tree's diameter (max distance)
find a tree's diameter: we can use any node as the root, and diameter=maxdepth+maxdepth2.
N-ary tree diameter:
for path passing current node: maxdepth+2nddepth
for path not passing current node: in its subtree.

dfs to get depth and diameter.

```cpp
    int diameter(Node* root) {
        int dia=0;
        dfs(root,dia);
        return dia;
    }
    int dfs(Node* root,int& dia){ //depth and diameter
        if(!root) return 0;
        //cout<<root->val<<endl;
        vector<int> vd;
        for(auto ch: root->children){
            vd.push_back(dfs(ch,dia));
        }
        sort(rbegin(vd),rend(vd));
        if(vd.size()==1) dia=max(dia,vd[0]);
        else if(vd.size()>1) dia=max(dia,vd[0]+vd[1]);
        //cout<<"dia="<<dia<<endl;
        return 1+(vd.size()?vd[0]:0);
    }
```

O(N)

using above algorithm we can get the approach:
```cpp
   vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges)	{
		vector<vector<int>> adj(n); //store child, connected or not
		for(auto t: edges){
			adj[t[0]-1].push_back(t[1]-1);
			adj[t[1]-1].push_back(t[0]-1);
		}
		int m=1<<n;
		vector<int> ans(n-1);
		for(int status=3;status<m;status++){ //only 1 bit set is invalid case
			int d=diameter(adj,status);
			if(d>=1) ans[d-1]++;
		}
		return ans;
   }
   
   int diameter(vector<vector<int>>& adj,int status){
	   int dia=0;
	   bitset<16> bs(status);
	   if(bs.count()<2) return 0;
	   int n=adj.size();
	   int v=0; //using same bitset
	   for(int i=0;i<n;i++){
			if(status&(1<<i)){
				dfs(adj,status,i,dia,v);
				break;
			}
	   }
       if(v!=status) return 0;
	   return dia;
   }
   
   int dfs(vector<vector<int>>& adj,int status,int root,int& dia,int& v){
		v |=1<<root;
		vector<int> vd;
		for(int ch: adj[root]){
			if( (v&(1<<ch))==0 && status & (1<<ch))
				vd.push_back(dfs(adj,status,ch,dia,v));
		}
        sort(rbegin(vd),rend(vd));
        if(vd.size()==1) dia=max(dia,vd[0]);
        else if(vd.size()>1) dia=max(dia,vd[0]+vd[1]);
        return 1+(vd.size()?vd[0]:0);
   }
```
we can get O(N) algorithm to find the max and 2nd max instead of using sort.


Some optimizations:
- precalculate the distance between any pair

```cpp
    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
        int INF = n; // Since cities form a tree so maximum distance between 2 cities always < n
        vector<vector<int>> dist(n, vector<int>(n, INF));
        for (auto& e : edges) 
            dist[e[0]-1][e[1]-1] = dist[e[1]-1][e[0]-1] = 1;
        
        for (int k = 0; k < n; k++)
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
        
        vector<int> ans(n - 1, 0);
        for (int state = 0; state < (1 << n); state++) {
            int d = maxDistance(state, dist, n);
            if (d > 0) ans[d - 1] += 1;
        }
        return ans;
    }
    
    int maxDistance(int state, vector<vector<int>>& dist, int n) {
        int cntEdge = 0, cntCity = 0, maxDist = 0;
        for (int i = 0; i < n; i++) {
            if (((state >> i) & 1) == 0) continue; // Skip if city `i` not in our subset
            cntCity += 1;
            for (int j = i + 1; j < n; j++) {
                if (((state >> j) & 1) == 0) continue; // Skip if city `j` not in our subset
                cntEdge += dist[i][j] == 1;
                maxDist = max(maxDist, dist[i][j]);
            }
        }
        if (cntEdge != cntCity - 1) return 0; // Subset form an invalid subtree!
        return maxDist;
    }
```




	


	
	
	

## contest 211

1624. Largest Substring Between Two Equal Characters
<em>
Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.

A substring is a contiguous sequence of characters within a string.
</em>

idea: save the first index for each char and update the max length
```cpp
    int maxLengthBetweenEqualCharacters(string s) {
        vector<int> ind(26,-1);
        int ans=-1;
        for(int i=0;i<s.size();i++){
            //cout<<s[i]<<" "<<ind[s[i]-'a']<<endl;
            if(ind[s[i]-'a']>=0) {
                ans=max(ans,i-ind[s[i]-'a']-1);
            }
            else ind[s[i]-'a']=i;
        }
        return ans;
    }
```

1625. Lexicographically Smallest String After Applying Operations

<em>
You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.

You can apply either of the following two operations any number of times and in any order on s:

Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = "3456" and a = 5, s becomes "3951".
Rotate s to the right by b positions. For example, if s = "3456" and b = 1, s becomes "6345".
Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, "0158" is lexicographically smaller than "0190" because the first position they differ is at the third letter, and '5' comes before '9'.

</em>

intuition: 
bfs or dfs
we've seen quite a few several operations either to get smallest one or the min steps to target
mostly we can use bfs to do it. or dp sometimes.


bfs is better to put all candidates in the queue. (since each operation the number of transform is limited)

```cpp
    string findLexSmallestString(string s, int a, int b) {
        //bfs/dfs
        unordered_set<string> v;
        queue<string> q;
        int n=s.size();
        b%=n;
        b=n-b;
        q.push(s);
        v.insert(s);
        string ans=s;
        while(q.size()){
            int sz=q.size();
            while(sz--){
                string t=q.front();
                q.pop();
                ans=min(ans,t);
                //apply rotate first it will end 
                string tt=t;
                while(1) {
                    rotate(begin(tt),begin(tt)+b,end(tt));
                    if(v.count(tt)) break;
                    v.insert(tt);
                    q.push(tt);
                }
                //applying add
                tt=t;
                while(1){
                    add(tt,a);
                    if(v.count(tt)) break;
                    v.insert(tt);
                    q.push(tt);
                }
            }
        }
        return ans;
    }
    void add(string& s,int a){
        for(int i=1;i<s.size();i+=2){
            int d=s[i]-'0';
            d+=a;
            d%=10;
            s[i]='0'+d;
        }
    }
```


1626. Best Team With No Conflicts
<em>
You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.

However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.

Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.
</em>

approach:
- sort the team according to score.
- then problem becomes a dp problem:
current member can be added to previous group if its age is smaller than previous member.
- the answer is max(use[n],notuse[n])
so we define two status:
use[n]: nth person is used, the max score
notuse[n]: nth person is not used, the max score
note: use or notuse is not arbitrary, but need to include all valid members.

```cpp
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        //age smaller score shall be smaller-->get the max sum
        int ans=0;
        //if we choose higher score with youner ages, then the age is restricted
        int n=scores.size();
        vector<vector<int>> vpair;
        for(int i=0;i<n;i++) vpair.push_back({scores[i],ages[i]});
        sort(rbegin(vpair),rend(vpair)); //sort by scores descending
        vector<int> use(n+1),notuse(n+1);
        use[1]=vpair[0][0];//dp
        notuse[1]=0;
        
        for(int i=1;i<n;i++){ //need has age non-ascending order
            int s=vpair[i][0],a=vpair[i][1];
            //we can choose use or not use 
            //use we shall append to previous age >=it
            for(int j=0;j<=i;j++){
                if(j==0 || vpair[j-1][1]>=a) use[i+1]=max(use[i+1],use[j]+s);
            }
            notuse[i+1]=max(use[i],notuse[i]);
            
        }
        return max(use[n],notuse[n]);
    }
```	
instead using two variables, we can use LIS approach.
```cpp
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        vector<pair<int, int>> players;
        int n = scores.size();
        for (int i=0; i<n; i++) {
            players.push_back({ages[i], scores[i]});
        }
        sort(players.begin(), players.end(), greater<>());
        
        int ans = 0;
        vector<int> dp(n);
        for (int i=0; i<n; i++) {
            int score = players[i].second;
            dp[i] = score;
            for (int j=0; j<i; j++) {
                if (players[j].second >= players[i].second) { // age of j is certainly >= i, so only important part to check 
													          //  before we add i and j in the same team is the score.
                    dp[i] = max(dp[i], dp[j] + score);
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
```	

1627. Graph Connectivity With Threshold

<em>
We have n cities labeled from 1 to n. Two different cities with labels x and y are directly connected by a bidirectional road if and only if x and y share a common divisor strictly greater than some threshold. More formally, cities with labels x and y have a road between them if there exists an integer z such that all of the following are true:

x % z == 0,
y % z == 0, and
z > threshold.
Given the two integers, n and threshold, and an array of queries, you must determine for each queries[i] = [ai, bi] if cities ai and bi are connected (i.e. there is some path between them).

Return an array answer, where answer.length == queries.length and answer[i] is true if for the ith query, there is a path between ai and bi, or answer[i] is false if there is no path.

 </em>
 
Union-find.
```cpp
    vector<int> parent;
    vector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) {
        vector<bool> ans(queries.size(),0);
        if(threshold==0) return vector<bool>(queries.size(),1);
        parent.resize(n+1);
        for(int i=1;i<=n;i++) parent[i]=i;
        vector<bool> v(n+1);
        for(int i=threshold;i<=n;i++){
            if(v[i]) continue;
            v[i]=1;
            for(int j=2*i;j<=n;j+=i){
                int pi=findp(i),pj=findp(j);
                if(__gcd(i,j)>threshold && pi!=pj){
                    parent[pi]=pj;
                }
            }
        }
        int i=0;
        for(auto q: queries){
            int pi=findp(q[0]),pj=findp(q[1]);
            ans[i++]=(pi==pj);
        }
        return ans;
    }
    int findp(int i){
        while(i!=parent[i]){
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
```

Note using sieve to preprocess the pairs are critical to avoid TLE.



 

 
## contest 212

### 1629. Slowest Key
<em>
A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.

You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.

The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].

Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.

Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.
</em>

straightforward, get the diff.

```cpp
    char slowestKey(vector<int>& releaseTimes, string keysPressed) {
        char ans=0;
        int mx=0;
        for(int i=0;i<keysPressed.size();i++){
            if(i==0) ans=keysPressed[i],mx=releaseTimes[i];
            else if(mx<=releaseTimes[i]-releaseTimes[i-1]){
                if(mx<releaseTimes[i]-releaseTimes[i-1]) 
                    ans=keysPressed[i],mx=releaseTimes[i]-releaseTimes[i-1];
                else if(ans<keysPressed[i]) ans=keysPressed[i];
            }
        }
        return ans;
    }
```

### 1630. Arithmetic Subarrays
<em>
A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:

1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.
</em>

brutal force
```cpp
    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {
        vector<bool> ans;
        for(int i=0;i<l.size();i++){
            multiset<int> ms(begin(nums)+l[i],begin(nums)+r[i]+1);
            auto it=ms.begin(),it1=++ms.begin();
            int d=*it1-*it;
            bool valid=1;
            while(it1!=ms.end()){
                if(*it1++-*it++!=d) {valid=0;break;}
            }
            ans.push_back(valid);
        }
        return ans;
    }
```

### 1631. Path With Minimum Effort

<em>
You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.

A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.

Return the minimum effort required to travel from the top-left cell to the bottom-right cell.
</em>

binary search + bfs/dfs

O(MN*logMx)

```cpp
    int minimumEffortPath(vector<vector<int>>& heights) {
        //binary search
        int l=0,r=1e6;
        while(l<r){
            int m=l+(r-l)/2;
            if(valid(heights,m)) r=m;
            else l=m+1;
        }
        return l;
    }
    bool valid(vector<vector<int>>& h,int diff){ //check if we can find a route with difference<=d
        int m=h.size(),n=h[0].size();
        queue<int> q;
        vector<bool> v(m*n);
        q.push(0);
        v[0]=1;
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        while(q.size()){
            int sz=q.size();
            while(sz--){
                int t=q.front();
                q.pop();
                int x=t/n,y=t%n;
                if(x==m-1 && y==n-1) return 1;
                for(auto d: dir){
                    int x0=x+d[0],y0=y+d[1];
                    if(x0<0 || y0<0 || x0>=m||y0>=n||v[x0*n+y0] || abs(h[x0][y0]-h[x][y])>diff) continue;
                    v[x0*n+y0]=1;
                    q.push(x0*n+y0);
                }
            }
        }
        return 0;
    }
```

other approach: using dijkstra O(MNlog(MN))
greedy: choose the min effort path first. using dp to record all i,j minimum.

```cpp
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m=heights.size(),n=heights[0].size();
        vector<vector<int>> dp(m,vector<int>(n,INT_MAX));
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
        pq.push({0,0,0});//effort, coordinate
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        vector<bool> v(m*n);
        v[0]=1;
        while(pq.size()){
            auto vt=pq.top();
            pq.pop();
            int eff=vt[0],x=vt[1],y=vt[2];
            if(x==m-1 && y==n-1) return eff;
            v[x*n+y]=1;
            if(eff>=dp[x][y]) continue; //prune, discard this path
            dp[x][y]=min(dp[x][y],eff);
            for(auto d: dir){
                int x0=x+d[0],y0=y+d[1];
                if(x0<0||y0<0||x0>=m||y0>=n||v[x0*n+y0]) continue;
                int tmp=max(eff,abs(heights[x0][y0]-heights[x][y]));
                pq.push({tmp,x0,y0});
            }
        }
        return dp[m-1][n-1];
    }
```	
dijkstra + visited is slow.
binary search + bfs is faster. 
binary search + dfs fastest. (less memory and faster). the worst case will try all paths.
binary search + union find (check if two nodes are connected).


### 1632. Rank Transform of a Matrix
<em>
Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].

The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:

If an element is the smallest element in its row and column, then its rank is 1.
If two elements p and q are in the same row or column, then:
If p < q then rank(p) < rank(q)
If p == q then rank(p) == rank(q)
If p > q then rank(p) > rank(q)
The rank should be as small as possible.
It is guaranteed that answer is unique under the given rules.
</em>

- greedy: process in sorted order.
- using map to store element vs positions
- using union find to group the same value elements into groups and process each group separately
- each group same value elements are assigned the group max +1


```cpp
    struct union_find{
        vector<int> &rmin,&cmin;
        vector<vector<int>>& v;
        unordered_map<int,int> parent; //node vs parent and max
        unordered_map<int,int> mx; //parent vs max
        union_find(vector<int>& r,vector<int>& c,vector<vector<int>>& vv):rmin(r),cmin(c),v(vv){}
        void merge(){
            for(auto t: v){
                int pi=findp(t[0]),pj=findp(~t[1]);
                if(pi!=pj){
                    parent[pi]=pj;
                    mx[pj]=max({mx[pj],rmin[t[0]],cmin[t[1]]});
                    rmin[t[0]]=cmin[t[1]]=mx[pj];
                }
            }
        }
        int findp(int i){
            if(parent.count(i)==0) parent[i]=i;
            else{
                while(i!=parent[i]){
                    parent[i]=parent[parent[i]];
                    i=parent[i];
                }
            }
            return i;
        }
        int getmx(int i) {return mx[findp(i)];}
    };
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        int m=matrix.size(),n=matrix[0].size();
        vector<vector<int>> ans(m,vector<int>(n));
        map<int,vector<vector<int>>> mp;
        vector<int> rmin(m),cmin(n);
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++) mp[matrix[i][j]].push_back({i,j});
        }
        
        for(auto p: mp){
            union_find uf(rmin,cmin,p.second);
            uf.merge();
            for(auto t: p.second)
                rmin[t[0]]=cmin[t[1]]=ans[t[0]][t[1]]=uf.getmx(t[0])+1;
            
        }
        return ans;
    }

```	
	
## contest 213

1640. Check Array Formation Through Concatenation
<em>
You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].

Return true if it is possible to form the array arr from pieces. Otherwise, return false.
</em>

hard approach:
convert to string and the problem converted to if can form the string using dictionary strings. (dp)

simple approach: 
using hashmap, only the first number as the key.

```cpp
    bool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {
        unordered_map<int,vector<int>> mp;
        for(auto t: pieces) mp[t[0]]=t;
        int i=0;
        while(i<arr.size()){
            if(mp.count(arr[i])){
                int j=0;
                auto& t=mp[arr[i]];
                while(j<t.size()){
                    if(arr[i]!=t[j]) return 0;
                    i++,j++;
                }
            }
            else return 0;
        }
        return 1;
    }
```

1641. Count Sorted Vowel Strings
<em>
Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.

A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.
</em>

approach 1: using backtrack to count
```cpp
    int countVowelStrings(int n) {
        //backtracking will be 5^50
        //5 digits to choose
        int ans=0;
        return backtrack(n,0);
        
        for(int i=0;i<5;i++){
            ans+=backtrack(n,i);
        }
        return ans;
    }
    int backtrack(int n,int start){
        if(start>4) return 0;
        if(n==0) return 1;
        int ans=0;
        for(int i=start;i<5;i++)
            ans+=backtrack(n-1,i);
        return ans;
    }
```

seems there is a math relation:
n=1: 5
n=2: 5+4+3+2+1=15
n=3: axx=15, exx=10,ixx=6,oxx=3,uxx=1, total=35
seems can use dp to get the relation.
- add 'a' to the begin dp[i]['a']=dp[i-1]['a']+dp[i-1]['e']+dp[i-1]['i']+dp[i-1]['o']+dp[i-1]['u']
- add 'e' to the begin dp[i]['e']=dp[i-1]['e']+dp[i-1]['i']+dp[i-1]['o']+dp[i-1]['u']
- add 'i' to the begin dp[i]['i']=dp[i-1]['i']+dp[i-1]['o']+dp[i-1]['u']
- add 'o' to the begin dp[i]['o']=dp[i-1]['o']+dp[i-1]['u']
- add 'u' to the begin dp[i]['u']=dp[i-1]['u']

```cpp
    int countVowelStrings(int n) {
        //dp approach
        vector<vector<int>> dp(n,vector<int>(5));
        for(int i=0;i<5;i++) dp[0][i]=1;
        for(int i=1;i<n;i++){
            for(int j=0;j<5;j++){
                for(int k=j;k<5;k++) dp[i][j]+=dp[i-1][k];
            }
        }
        int ans=0;
        for(int i=0;i<5;i++) ans+=dp[n-1][i];
        return ans;
    }
```

1642. Furthest Building You Can Reach
<em>
You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.

You start your journey from building 0 and move to the next building by possibly using bricks or ladders.

While moving from building i to building i+1 (0-indexed),

If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.
</em>

idea:

priority_queue: use ladder for the jump which needs the most bricks

```cpp
    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
        //greedy: we shall use the largest jmp for the ladder and other for the bricks
        //we can use pq to do this, once we find a larger one, 
        int n=heights.size();
        priority_queue<int> pq;
        int i=1;
        for(;i<n;i++){
            int d=heights[i]-heights[i-1];
            if(d>0){
                pq.push(d);
                if(bricks>=d){
                    bricks-=d;
                }
                else if(ladders>0){
                    if(pq.size()){ //use the ladder for larger one
                        bricks+=pq.top();
                        pq.pop();
                        //ladder--;
                        bricks-=d;
                    }
                    ladders--;//use one ladder
                }
                else break;//no more left
            }
        }
        return i-1;
    }
```	
using minheap:
Heap heap store k height difference that we need to use ladders.
Each move, if the height difference d > 0,
we push d into the priority queue pq.
If the size of queue exceed ladders,
it means we have to use bricks for one move.
Then we pop out the smallest difference, and reduce bricks.
If bricks < 0, we can't make this move, then we return current index i.
If we can reach the last building, we return A.length - 1.

```cpp
    int furthestBuilding(vector<int>& A, int bricks, int ladders) {
        priority_queue<int> pq;
        for (int i = 0; i < A.size() - 1; i++) {
            int d = A[i + 1] - A[i];
            if (d > 0)
                pq.push(-d);
            if (pq.size() > ladders) {
                bricks += pq.top();
                pq.pop();
            }
            if (bricks < 0)
                return i;
        }
        return A.size() - 1;
    }
```
Another approach:
binary search using greedy: sort the difference and use bricks for smallest, ladders for larger ones.
```cpp
    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
		int l=0,r=heights.size()-1;
		vector<int> diff(heights.size());
		for(int i=1;i<heights.size();i++){
			if(heights[i]>heights[i-1]) diff[i]=heights[i]-heights[i-1];
		}
		while(l<r){
			int m=l+(r-l)/2;
			if(valid(diff,bricks,ladders,m)) r=m;
			else l=m+1;
        }
		return l;
    }
	bool valid(vector<int>& dh,int bricks,int ladders,int m){
		priority_queue<int,vector<int>,greater<int>> pq;
		for(int i=0;i<=m;i++) if(dh[i]) pq.push(dh[i]);
		while(pq.size() && bricks>=pq.top()){
			bricks-=pq.top();
			pq.pop();
		}
		return pq.size()<=ladders;
	}
```	
O(nlogn*logn): binary search logn, valid nlogn. will TLE.
using sort will be faster and pass the tests:
```cpp
    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
		int l=0,r=heights.size()-1;
		vector<int> diff(heights.size());
		for(int i=1;i<heights.size();i++){
			if(heights[i]>heights[i-1]) diff[i]=heights[i]-heights[i-1];
		}
		while(l<r){ //find the max valid
			int m=l+(r-l+1)/2;
			if(!valid(diff,bricks,ladders,m)) r=m-1;
			else l=m;
        }
		return l;
    }
	bool valid(vector<int>& dh,int bricks,int ladders,int m){
		sort(begin(dh),begin(dh)+m+1);
        for(int i=0;i<=m;i++){
            if(dh[i]){
                if(bricks>=dh[i]) bricks-=dh[i];
                else if(ladders) ladders--;
                else return 0;
            }
        }
        return 1;
	}
```
PQ push/pop uses extra time.
pq use array to store the elements
it maintains a heap (tree) inside and the push/pop so takes O(logN) complexity.
the tree is a complete binary tree structure in array storage format.

push: 
Inserts a new element in the priority_queue. The content of this new element is initialized to val.

This member function effectively calls the member function push_back of the underlying container object, and then reorders it to its location in the heap by calling the push_heap algorithm on the range that includes all the elements of the container.

pop:
Removes the element on top of the priority_queue, effectively reducing its size by one. The element removed is the one with the highest value.

The value of this element can be retrieved before being popped by calling member priority_queue::top.

This member function effectively calls the pop_heap algorithm to keep the heap property of priority_queues and then calls the member function pop_back of the underlying container object to remove the element.


1643. Kth Smallest Instructions
<em>
Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination.

The instructions are represented as a string, where each character is either:

'H', meaning move horizontally (go right), or
'V', meaning move vertically (go down).
Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both "HHHVV" and "HVHVH" are valid instructions.

However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed.

Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.
</em>

brutal force using bits. 
H represent 0 and V represent 1, then the number of set bits=m-1.
find next bigger number with same number of set bits.
```cpp
    string kthSmallestPath(vector<int>& destination, int k) {
        //from (0,0) to (m,n), we have m H and n V
        //we are looking for the kth smallest combinations
        int n=destination[0],m=destination[1];
        //using bits (m+n) bits keep set bits
        int num=(1<<n)-1;
        int mx=num<<m;
        
        while(--k) num=next_bigger(num);
        //cout<<num<<endl;
        string ans;
        while(num){
            int d=num&1;
            ans.append(1,d?'V':'H');
            num>>=1;
        }
        if(ans.size()<m+n) ans.append(m+n-ans.size(),'H');
        reverse(begin(ans),end(ans));
        return ans;
    }
    unsigned next_bigger(unsigned a) {
      /* works for any word length */
      unsigned c = (a & -a);
      unsigned r = a+c;
      return (((r ^ a) >> 2) / c) | r;
    }    
```	
This will TLE since the complexity is C(m+n,m)

Analysis: 
for example (2,3): C(5,2)=10
the order are: 
"HHHVV", 
"HHVHV", 
"HHVVH", 
"HVHHV", 
"HVHVH", 
"HVVHH", 
"VHHHV", 
"VHHVH", 
"VHVHH", 
"VVHHH"
k<=C(5,2)/2 we have H at the first char.
K>C(5,2)/2 we have V at the first char.
then we can do it by reducing the K-C(m,n)/2;

or think like this:
string start H, C(m-1+n,m-1)
string start V: C(m+n-1,n-1)
```cpp
	int comb(int m,int n){
		//m!/(n!*(m-n)!)
		int ans=1;
		for(int i=n+1;i<=m;i++) ans=ans*i/(i-n);
		return ans;
	}
    string kthSmallestPath(vector<int>& destination, int k) {
        string ans;
		int m=destination[0],n=destination[1];
		while(k && m+n){
			int t=comb(m+n-1,n-1);
			if(k>t) ans+='V',k-=t,m--;
			else ans+='H',n--;
		}
		//remaining shall be in sorted order.
		if(n) ans.append(n,'H');
		if(m) ans.append(m,'V');
		return ans;
    }
```
complexity O((m+n)^2) m+n for reducing k, m+n for combination calculation
The thinking process is more important.
	





## contest 214

1646. Get Maximum in Generated Array
<em>
You are given an integer n. An array nums of length n + 1 is generated in the following way:

nums[0] = 0
nums[1] = 1
nums[2 * i] = nums[i] when 2 <= 2 * i <= n
nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
Return the maximum integer in the array nums​​​.
</em>

straightforward

```cpp
    int getMaximumGenerated(int n) {
        int mx=0;
        if(n<2) return n;
        vector<int> v(n+1);
        v[1]=1;
        for(int i=2;i<=n;i++){
            if(i%2) v[i]=v[i/2]+v[i/2+1];
            else v[i]=v[i/2];
            mx=max(mx,v[i]);
        }
        return mx;
    }
```

1647. Minimum Deletions to Make Character Frequencies Unique
<em>
A string s is called good if there are no two different characters in s that have the same frequency.

Given a string s, return the minimum number of characters you need to delete to make s good.

The frequency of a character in a string is the number of times it appears in the string. For example, in the string "aab", the frequency of 'a' is 2, while the frequency of 'b' is 1
</em>

idea: 
get each char's frequency into hashmap.
sort the frequency into map
from the largest, if it has multiple same frequency, reduce by 1 

```cpp
    int minDeletions(string s) {
        vector<int> cnt(26);
        for(char c: s) cnt[c-'a']++;
        //you can only decrease the count.
        map<int,int> mp;
        for(int i: cnt) if(i) mp[i]++; //count vs frequency
        int ans=0;
        //reduce the largest to the closest not used number
        while(mp.size()){
            auto it=mp.rbegin();
            if(it->second>1){
                ans+=it->second-1;
                if(it->first>1)  mp[it->first-1]+=it->second-1;
            }
            mp.erase(it->first);
        }
        return ans;
    }
```	

1648. Sell Diminishing-Valued Colored Balls
<em>
You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.

The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).

You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.

Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.
</em>

idea:
- sort the balls from largest to smallest.
- reduce the largest to second largest and merge with the 2nd largest.
- this does not require a heap (which will cause TLE).
we can also use binary search to remove the top (make it flat) and then remove one from the first
binary search: find the min k so that we take all A[i]>=k
note if we find the index, we will meet problem for the last step
for example [3,5] and orders=6 if we use index, we first take 2, and leave [3,3], and last step is wrong.
we shall find k=2, so that we used 4 and leave [2,2]

```cpp
    int maxProfit(vector<int>& inventory, int orders) {
        //inventory.push_back(0);
        sort(rbegin(inventory),rend(inventory));
		int l=0,n=inventory.size(),r=1e9;
		long ans=0;
        int mod=1e9+7;

		while(l<r){ //find the smallest k 
			int m=l+(r-l)/2;
			if(valid(inventory,m,orders)>=0) r=m; //make it smaller
			else l=m+1;
		}
        //cout<<l;
		for(int i=0;i<n;i++){
            if(inventory[i]<l) break;
			int d=inventory[i]-l;
			ans+=(long)inventory[i]*d-(long)d*(d-1)/2;
            inventory[i]=l;
            ans%=mod;
			orders-=d;
		}
        //cout<<"OK";
        if(orders){ //remaining 
            ans+=(long)l*orders; //each take one.
            ans%=mod;
        }
		return ans;
    }
	
	int valid(vector<int>& nums,int m,int orders){
		//from m to n-1, if the sums
		for(int i=0;i<nums.size();i++){
            if(nums[i]<m) break;
			int d=nums[i]-m; //reduce to a0.
			orders-=d;
			if(orders<0) return orders;
		}
		return orders;
	}
```

Note the binary search on the descending order and find the smallest k.
actually no sort is needed. without sort, the time can be reduced half.

This one is hard!

Similarly by using map to merge same inventory together.
by the top voted: no sort.
```cpp
    map<int, int, greater<>> m;

    int maxProfit(vector<int>& A, int T) {
        long ans = 0, mod = 1e9+7, L = 0, R = *max_element(begin(A), end(A));
        for (int n : A) m[n]++;
        while (L <= R) {
            long M = (L + R) / 2;
            if (valid(M, T)) L = M + 1;
            else R = M - 1;
        }
        for (auto &[n , cnt] : m) {
            if (n <= L) break;
            T -= cnt * (n - L);
            ans = (ans + (n + L + 1) * (n - L) / 2 % mod * cnt % mod) % mod;
        }
        if (T) ans = (ans + L * T % mod) % mod;
        return ans;
    }
    bool valid(int M, int T) {
        for (auto &[n , cnt] : m) {
            if (n <= M) break;
            T -= (long)cnt * (n - M);
            if (T <= 0) return true;
        }
        return T <= 0;
    }
```

sort and merge to the next:
```cpp
int maxProfit(vector<int>& inv, int orders) {
    long res = 0, colors = 1;
    int mod=1e9+7;
    sort(begin(inv), end(inv));
    for (int i = inv.size() - 1; i >= 0 && orders > 0; --i, ++colors) {
        long cur = inv[i], prev = i > 0 ? inv[i - 1] : 0;
        long rounds = min(orders / colors, cur - prev);
        orders -= rounds * colors;
        res = (res + (cur * (cur + 1) - (cur - rounds) * (cur - rounds + 1)) / 2 * colors) % mod;
        if (cur - prev > rounds) {
            res = (res + orders * (cur - rounds)) % mod;
            break;
        }
    }
    return res;
}
```


1649. Create Sorted Array through Instructions
<em>
Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:

The number of elements currently in nums that are strictly less than instructions[i].
The number of elements currently in nums that are strictly greater than instructions[i].
For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5].

Return the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 109 + 7
</em>

using equal_range will TLE:
```cpp
    int createSortedArray(vector<int>& instructions) {
        int mod=1e9+7;
        vector<int> v;
        long ans=0;
        for(int i: instructions){
            if(v.empty()) v.push_back(i);
            else { //binary search to find the position
                auto t=equal_range(begin(v),end(v),i);
                ans+=min(distance(v.begin(),t.first),distance(t.second,v.end()));
                v.insert(t.second,i);
                ans%=mod;
                
            }
        }
        return ans;
    }
```

	
	
	
## contest 215

### 1656. Design an Ordered Stream

<em>
There are n (id, value) pairs, where id is an integer between 1 and n and value is a string. No two pairs have the same id.

Design a stream that takes the n pairs in an arbitrary order, and returns the values over several calls in increasing order of their ids.

Implement the OrderedStream class:

OrderedStream(int n) Constructs the stream to take n values and sets a current ptr to 1.
String[] insert(int id, String value) Stores the new (id, value) pair in the stream. After storing the pair:
If the stream has stored a pair with id = ptr, then find the longest contiguous incrementing sequence of ids starting with id = ptr and return a list of the values associated with those ids in order. Then, update ptr to the last id + 1.
Otherwise, return an empty list.
</em>

straightforward.
```cpp
    vector<string> vs;
    vector<bool> vb;
    int ptr;
    OrderedStream(int n) {
        vs.resize(n);
        vb.resize(n);
        ptr=1;
    }
    
    vector<string> insert(int id, string value) {
        vs[id-1]=value;
        vb[id-1]=1;
        vector<string> ans;
        if(id==ptr){
            int i=id-1;
            while(i<vs.size() && vb[i]) ans.push_back(vs[i++]);
            ptr=i+1;
        }
        
        return ans;
    }
```

### 1657. Determine if Two Strings Are Close
<em>
Two strings are considered close if you can attain one from the other using the following operations:

Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
You can use the operations on either string as many times as necessary.

Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.
</em>

operation 1: just get to the desired order and will not change the histogram
operation 2: will change the histogram.
approach: just check if the histogram of two strings are similar.
```cpp
    bool closeStrings(string word1, string word2) {
        //swap will not change the histogram--> just sort
        //transform will change the histogram
        if(word1.size()!=word2.size()) return 0;
        vector<int> cnt1(26),cnt2(26);
        for(char c: word1) cnt1[c-'a']++;
        for(char c: word2) cnt2[c-'a']++;
        for(int i=0;i<26;i++){
            if((cnt1[i] && !cnt2[i]) ||(!cnt1[i] && cnt2[i])) return 0;
        }
        sort(begin(cnt1),end(cnt1));
        sort(begin(cnt2),end(cnt2));
        return cnt1==cnt2;
    }
```	

### 1658. Minimum Operations to Reduce X to Zero
<em>
You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.

Return the minimum number of operations to reduce x to exactly 0 if it's possible, otherwise, return -1.
</em>

equivalent: find the longest window which equals tsum-x
approach: using hashmap.
```cpp
    int minOperations(vector<int>& nums, int x) {
        //the left i elements and right j elements
        int tsum=accumulate(begin(nums),end(nums),0);
        if(tsum<x) return -1;
        if(tsum==x) return nums.size();
        int target=tsum-x;
        //cout<<target<<endl;
        unordered_map<int,int> mp;
        mp[0]=-1;
        int ans=-1,prefix=0,n=nums.size();
        for(int i=0;i<n;i++){
            prefix+=nums[i];//pj-pi=target
            //cout<<prefix<<endl;
            if(mp.count(prefix-target))
                ans=max(ans,i-mp[prefix-target]);
            mp[prefix]=i;
        }
        return ans<0?-1:n-ans;
    }
```

### 1659. Maximize Grid Happiness
<em>
You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.

You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.

The happiness of each person is calculated as follows:

Introverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).
Extroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).
Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.

The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.

Constraints:

1 <= m, n <= 5
0 <= introvertsCount, extrovertsCount <= min(m * n, 6)

</em>

typical dp bitmask problem, but with 3 states: 0: not occupied, -1: intro, 1, extrovert
the state is described by: number of introvert used, number of extrovert used

backtracking approach:
try all combinations of i and j and get the max.

```cpp
    int getMaxGridHappiness(int m, int n, int intro, int extro) {
        //each grid has 3 choices: intro, ext, null. +1,-1,0 has 3 states or 0,1,2, 3^25 status
        //dp problem, with intro<=m, extr<=n. m*n max 25, we can use bitmap dp.
        //or we can get the max score for using i intro and j extro
        int ans=0;
        for(int i=0;i<=intro;i++){
            for(int j=0;j<=extro;j++){
                ans=max(ans,backtrack(m,n,i,j));
            }
        }
        return ans;
    }
    int backtrack(int m,int n,int neg,int pos){ //get the max using neg and pos
        //better using bitmask to try all combinations
        if(neg+pos>m*n) return 0; //cannot do it
        vector<int> v(m*n);
        int i=0;
        while(neg--) v[i++]=-1;
        i=m*n-1;
        while(pos--) v[i--]=1;
        int ans=0;
        do{
            ans=max(ans,getscore(v,m,n));
        } while(next_permutation(begin(v),end(v)));
        return ans;
    }
    int getscore(vector<int>& v,int m,int n){
        int ans=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(v[i*n+j]==1){ //if neighbor is intro, we need minus 30
                    ans+=40;
                    if(j){
                        if(v[i*n+j-1]==1) ans+=40; //left is extro
                        else if(v[i*n+j-1]==-1) ans+=20-30;//left is intro
                    }
                    if(i){
                        if(v[(i-1)*n+j]==1) ans+=40;
                        else if(v[(i-1)*n+j]==-1) ans+=20-30;
                    }
                }
                else if(v[i*n+j]==-1){ //neg
                    ans+=120;
                    if(j){
                        if(v[i*n+j-1]==1) ans+=20-30;//left is extro, left+20, current -30
                        else if(v[i*n+j-1]==-1) ans+=-30-30;//left is intro
                    }
                    if(i){
                        if(v[(i-1)*n+j]==1) ans+=20-30;//top is extro
                        else if(v[(i-1)*n+j]==-1) ans+=-30-30;//top is intro
                    }
                    
                }
            }
        }
        return ans;
    }
```	
the complexity is very high and will TLE.
combination of number of intro K and extro L: O(KL)
for each combination K,L, we have C(mn,K)*C(mn-K,L)
for each layout, we have O(mn).

To optimize it, we need use memoization.
several important facts need to be used:
- to place a person at i,j, we need use dp[i-1,j] and dp[i,j-1], that is we only need to keep previous m positions.

- the state: 
  index=i*n+j up to 25.
  remaining introverts, <=6
  remaining extroverts, <=6
  introvert mask 2^(m+1)-1
  extrovert mask 2^(m+1)-1
The bitmask is a bit tricky:
- since we only need the last m cells, we only keep the status of the last m cells
- use two bitmask to avoid using base-3 system.
- actually we can also use base-3 system which have 3^m=243 and we combine the last two states, which saves time.

@votrubac's 5D dp solution:

```cpp
int dp[25][7][7][64][64] = {};

int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}

int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    if(p>=m*n) return 0;
	int i = p / n, j = p % n;
    if (dp[p][in][ex][mask_in][mask_ex])
		return dp[p][in][ex][mask_in][mask_ex] - 1; //-1 since we add extra 1 to it.
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex); //no person is placed
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, 20);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1; //+1 just to avoid to get 0
    return res;
}

int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
```

use base-3 to reduce 1d complexity:
every time we need left shift a position (use 0,1,2 system). But the left shift and get bits for base 3 is not straightforward. 
or we can use string to represent the bitmask.
base 3: we can also use -1,0,1


	
	## contest 216

1662. Check If Two String Arrays are Equivalent
<em>
Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.
</em>

```cpp
    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {
        string s1,s2;
        for(auto w: word1) s1+=w;
        for(auto w: word2) s2+=w;
        return s1==s2;
    }
```
or we can compare and remove using two pointer

1663. Smallest String With A Given Numeric Value
<em>
The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.

The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string "abe" is equal to 1 + 2 + 5 = 8.

You are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.

Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

 </em>
 
 greedy approach:
 fill all with 'a' first, and then try to fill 'z' from right.
 
 ```cpp
     string getSmallestString(int n, int k) {
        //reduced to 26 numbers, sum(c*i)==k
        //greedy: use 'a...a' of length k
        //and then increment from right
        string ans;
        ans.append(n,'a');
        k-=n;
        int j=n-1;
        for(char c='z';c>'a';c--){
            int add=c-'a';
            int mx=k/add;
            k-=mx*add;
            while(mx--) ans[j--]=c;
        }
        return ans;
    }
```

1664. Ways to Make a Fair Array
<em>
You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.

For example, if nums = [6,1,7,4,1]:

Choosing to remove index 1 results in nums = [6,7,4,1].
Choosing to remove index 2 results in nums = [6,1,4,1].
Choosing to remove index 4 results in nums = [6,1,7,4].
An array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values.

Return the number of indices that you could choose such that after the removal, nums is fair.
Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104
</em>

at the removal point, the right side odd and even swaps.
if we assign negative to odd, then it becomes prefix sum.

```cpp
    int waysToMakeFair(vector<int>& nums) {
        //int tsum=accumulate(begin(nums),end(nums),0);
        //tsum-a shall at least to be even.
        //mark the odd index negative, even index positive
        //we shall get the tsum=0
        int ans=0;
        int n=nums.size();
        for(int i=1;i<n;i+=2) nums[i]*=-1;
        
        vector<int> odd(n); //use even-odd
        //prefix sum
        for(int i=0;i<n;i++){
            odd[i]=(i?odd[i-1]:0)+nums[i];
        }
        int even=0;
        for(int i=n-1;i>=0;i--){
            even+=nums[i];
            if(even==odd[i]) ans++;
        }
        return ans;
    }
```	

1665. Minimum Initial Energy to Finish Tasks
<em>
You are given an array tasks where tasks[i] = [actuali, minimumi]:

actuali is the actual amount of energy you spend to finish the ith task.
minimumi is the minimum amount of energy you require to begin the ith task.
For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it.

You can finish the tasks in any order you like.

Return the minimum initial amount of energy you will need to finish all the tasks.
Constraints:

1 <= tasks.length <= 105
1 <= actual​i <= minimumi <= 104
</em>

greedy and math problem:
given a target Initial energy (fixed), then if we want to complete as much as possible tasks, we shall finish the task saving the most.

```cpp
    int minimumEffort(vector<vector<int>>& A) {
        int res = 0;
        for (auto &a : A)
            a[0] = a[1] - a[0];
        sort(A.begin(), A.end());
        for (auto &a : A)
            res = max(res + a[1] - a[0], a[1]);
        return res;
    }

```




 

	

 ## contest 217

### 1672. Richest customer wealth
<em>
You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.
</em>

trivial:

```cpp
    int maximumWealth(vector<vector<int>>& accounts) {
        int ans=0;
        for(auto r: accounts){
            ans=max(ans,accumulate(begin(r),end(r),0));
        }
        return ans;
    }
```

### 1673. Find the Most Competitive Subsequence
<em>
Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.

An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.

We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.
</em>

Greedy:
equivalent to find the smallest sequence with length = k.
the min of the first n-k-1 element as the first element. Then discard all previous elements including the min.
so it is now to find the sliding minimum. using stack or deque to get O(N)
```cpp
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        vector<int> ans; //smallest lex subsequence
        //moving window first is the min from 0 to n-k
        int i=0,j=0,n=nums.size();
        int last=-1,mn=INT_MAX;
        deque<int> dq;
        for(int i=0;i<n;i++){
            while(dq.size() && nums[dq.back()]>nums[i]) dq.pop_back();
            dq.push_back(i);
            if(i+k>=n){
                while(dq.size() && dq.front()<=last) dq.pop_front();
                ans.push_back(nums[dq.front()]);
                last=dq.front();
            }
        }
        return ans;
    }
```

### 1674. Minimum Moves to Make Array Complementary
<em>
You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.

The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.

Return the minimum number of moves required to make nums complementary.
Constraints:

n == nums.length
2 <= n <= 10^5
1 <= nums[i] <= limit <= 10^5
n is even.
</em>

Critical: the target sum of each pair is limited in the range [2,2*limit]
brutal force: loop over all target from 2 to 2*limit and check the min moves O(N^2) and will TLE. but it is a good start.
a+b, a and b in the range [1,L], a+b in the range [2,2*L]
given target sum T in the range [2,2*L]: (now is the tricky part to determine number of moves needed):
a+b=S.
- S=T, no changes needed
- S!=T: 
change a, not change b: T-b shall be in [1,limit]
change b, not change a: T-a shall be in [1,limit]
```cpp
    int minMoves(vector<int>& nums, int limit) {
        //sum in the range [2,2*limit]
        int n=nums.size(),ans=n;
        for(int t=2;t<=2*limit;t++){
            int i=0,j=n-1,cnt=0;
            while(i<j){
                int a=nums[i],b=nums[j];
                if(a>b) swap(a,b);
                int sum=a+b;
                if(sum!=t){ //replace one or two a+b
                    if((t-a>=1 && t-a<=limit) || (t-b>=1 && t-b<=limit)) cnt+=1;
                    else cnt+=2;
                }
                i++,j--;
            }
            ans=min(ans,cnt);
        }
        return ans;
    }
```	
or better brutal force easier to optimize:
```cpp
    int minMoves(vector<int>& nums, int limit) {
        //sum in the range [2,2*limit]
        int n=nums.size(),ans=n;
		vector<int> moves(2*limit+1);
        moves[0]=moves[1]=n;
		for(int i=0;i<n/2;i++){
			int a=nums[i],b=nums[n-1-i];
			for(int t=2;t<=2*limit;t++){
				if(a+b!=t){
                    if((t-a>=1 && t-a<=limit) || (t-b>=1 && t-b<=limit)) moves[t]+=1;
                    else moves[t]+=2;
				}
			}
		}
        
		for(int i: moves) ans=min(ans,i);//,cout<<i<<" ";
		return ans;
	}
```	
Optimization:
- for each pair, we can calculate the min moves for each target in [2,2*limit]
- store the movement changes.
- accumulate the movement for all pairs. (similar using hashmap to reduce O(N))
For each pair of numbers (at index i and N - 1 - i) l and r:

After only one move (change one of the numbers to a number between 1 and limit)
The minimum sum we can get is (min(l, r) + 1) (let this be oneMoveMin)
The maximum sum we can get is (max(l, r) + limit) (let this be oneMoveMax)
We need no move to get (l + r) (let this be justGood)
Therefore, to get:

[~, oneMoveMin - 1] - 2 moves
[oneMoveMin, justGood-1] - 1 move
[justGood] - 0 move
[justGood + 1, oneMoveMax] - 1 move
[oneMoveMax + 1, ~] - 2 moves

For each pair of numbers

We start with 2 moves (using 2 moves we can reach anything)
From oneMoveMin we need 1 less move
From justGood we need another 1 less move
From justGood + 1 we need 1 more move
From oneMoveMax + 1 we need another 1 more move
(note we are using a difference array i.e move[i]-move[i-1], and then we recover
the array using accumulate sum or prefix sum. Using diff array, we efficiently reduce O(N) to O(1), This is more apparent if we reverse the loop in the brutal force solution, see the 2nd brutal force approach):

```cpp
int minMoves(vector<int>& nums, int limit) {
    int N = nums.size();
    vector<int> diff(limit*2 + 2, 0);
    for (int i = 0; i < N/2; ++i) {
        int l = nums[i], r = nums[N-1-i];
        --diff[min(l, r) + 1];
        --diff[l + r];
        ++diff[l + r + 1];
        ++diff[max(l, r) + limit + 1];
    }
    int ans = N, curr = N; //max n movements.
    for (int i = 2; i <= limit*2; ++i) {
        curr += diff[i];
        ans = min(ans, curr);
    }
    return ans;
}
```
The approach uses a lot of memory. but in linear time.
If the limit is very large, then memory is not sufficient.
To avoid this, we can use binary search approach:

```cpp
    int minMoves(vector<int>& nums, int limit) {
        vector<int> p1, p2; // p1: min value array, p2: max value array
        int n = nums.size();
        map<int, int> d; // map to record appearance count of sum values
        for (int i=0;i<(n>>1);i++) {
            int mini = min(nums[i], nums[n - 1 - i]);
            int maxi = max(nums[i], nums[n - 1 - i]);
            p1.push_back(mini);
            p2.push_back(maxi);
            d[maxi + mini] += 1;
        }
        sort(p1.begin(), p1.end());
        sort(p2.begin(), p2.end());
		// sorted max and min values are needed
        int ans = n;
        int l1 = -1;
        int l2 = -1;
        d[limit + 1] += 0;
        for (auto it: d) {
            int i = it.first;
			// answers must appear at all sum values' positions or limit + 1, so iterate all sum value, ans limit + 1 as well
			//then count how many pairs take two moves: as i becomes larger, the numbers increase/decrease
		    while (l1+1 < (n>>1) && p1[l1+1] < i) l1++;
            while (l2+1 < (n>>1) && i - p2[l2+1] > limit) l2++;
            ans = min(ans, n - (l1 - l2) - it.second);
        }
        return ans;
    }
```	
### 1675. Minimize Deviation in Array
<em>
You are given an array nums of n positive integers.

You can perform two types of operations on any element of the array any number of times:

If the element is even, divide it by 2.
For example, if the array is [1,2,3,4], then you can do this operation on the last element, and the array will be [1,2,3,2].
If the element is odd, multiply it by 2.
For example, if the array is [1,2,3,4], then you can do this operation on the first element, and the array will be [2,2,3,4].
The deviation of the array is the maximum difference between any two elements in the array.

Return the minimum deviation the array can have after performing some number of operations.
n = nums.length
2 <= n <= 10^5
1 <= nums[i] <= 10^9
</em>
observation:
- odd can only be doubled once. even can be halved until becomes odd.
- each number are bounded and only have several discrete choices. 
for example: 12 can change to [12,6,3], and 5 can be [5,10]
try all path to get the min using dfs and we can get the minimum.
The complexity would be exponential.

we find the upper bound and lower bound for every elements, turning each element into an interval [lower, upper]. We then take the lower bound value for each interval to start with. While we still can, we double the smallest value, updating the final result along the way.

Thus two directions are reduced to one direction only which greatly simplified the problem.

In this case, we can use a heap to do it.
equivalent: change the array into all odd, only *2 is allowed.
or change the array into all even, only /2 is allowed.

Very valuable approach: two directions are too complicated and try to simplified it to one direction only.

```cpp
    int minimumDeviation(vector<int>& nums) {
        set<int>s;
        for(int i=0;i<nums.size();i++){
            s.insert(nums[i]%2==0?nums[i]:nums[i]*2);//insert even directly and odd with one time multiplication and it will become even.
        }
        int diff=*s.rbegin()-*s.begin();
        while(*s.rbegin()%2==0){//run the loop untill difference is minimized
            int x=*s.rbegin();
            s.erase(x);
            s.insert(x/2);
            diff = min(diff,*s.rbegin()-*s.begin());
        }
        return diff;
    }
```	



 
 ## contest 218

1678. Goal Parser Interpretation
<em>
You own a Goal Parser that can interpret a string command. The command consists of an alphabet of "G", "()" and/or "(al)" in some order. The Goal Parser will interpret "G" as the string "G", "()" as the string "o", and "(al)" as the string "al". The interpreted strings are then concatenated in the original order.

Given the string command, return the Goal Parser's interpretation of command.
</em>

straightforward, using string as stack.

```cpp
    string interpret(string command) {
        string ans;
        for(char c: command){
            ans+=c;
            if(c==')') {
                ans.pop_back();
                if(ans.back()=='(') {
                    ans.back()='o';
                }
                else{
                    ans.pop_back(),ans.pop_back(),ans.pop_back();
                    ans+="al";
                }
            }
        }
        return ans;
    }
```

1679. Max Number of K-Sum Pairs
<em>
You are given an integer array nums and an integer k.

In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.

Return the maximum number of operations you can perform on the array.
</em>

O(Nlogn):sort and use two pointer
O(nlogn): sort and use hashmap.

```cpp
    int maxOperations(vector<int>& nums, int k) {
        unordered_map<int,int> ms;
        int ans=0;
        sort(begin(nums),end(nums));
        for(int i: nums){
            if(ms.count(k-i)){
                ms[k-i]--;
                if(ms[k-i]==0) ms.erase(k-i);
                ans++;
            }
            else ms[i]++;
        }
        return ans;
    }
```

1680. Concatenation of Consecutive Binary Numbers
<em>
Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.
</em>

straightforward, left shift and add.

```cpp
    int concatenatedBinary(int n) {
        int mod=1e9+7;
        //every double we get the same string
        long ans=0;
        for(int i=1;i<=n;i++){
            int k=i;
            int nbits=0;
            while(k){
                k/=2,nbits++;
            }
            ans=(ans<<nbits)+i;
            ans%=mod;
        }
        return ans;
    }
```

1681. Minimum Incompatibility
<em>
You are given an integer array nums​​​ and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.

A subset's incompatibility is the difference between the maximum and minimum elements in that array.

Return the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.

A subset is a group integers that appear in the array with no particular order.

Constraints:

1 <= k <= nums.length <= 16
nums.length is divisible by k
1 <= nums[i] <= nums.length
</em>

since n is small, we can try backtracking first.
backtracking for this is a bit tricky:
- we can first convert to map (sorted)
- iterate over loop, for one solution, we need get k subset, for each subset we get one diff.
- the backtrack shall return the sum of diff.
- do not use the scheme to put ans and min, but use the recursive approach.
this is similar to k equal sum subset problem.
```cpp
    int minimumIncompatibility(vector<int>& nums, int k) {
        map<int,int> mp;
        int n=nums.size();
        for(int i: nums) {
            if(++mp[i]>k) return -1;
        }
        vector<pair<int,int>> cnt(begin(mp),end(mp));
        return backtrack(cnt,0,0,0,n/k,k,{});
    }
    
    int backtrack(vector<pair<int,int>>& vp,int start,int ci,int cj,int n,int k,vector<int> t)     {
        
        //cout<<start<<": ";
        //for(int i: t) cout<<i<<" ";cout<<endl;
        if(ci==n){ //find one 
            return t.back()-t[0]+backtrack(vp,0,0,cj+1,n,k,{}); 
        }
        if(cj==k){
            //cout<<"found one answer"<<endl;
            return 0;
        }

        if(start>=vp.size()) return INT_MAX/2;
        //put the available min as the first element
        int ans=INT_MAX/2;
        //for(auto tt: vp) cout<<tt.first<<" "<<tt.second<<";" ;cout<<endl;
        for(int i=start;i<vp.size();i++){
            if(vp[i].second){
                vp[i].second--;
                t.push_back(vp[i].first);
                ans=min(ans,backtrack(vp,i+1,ci+1,cj,n,k,t));
                vp[i].second++;
                t.pop_back();
            }
        }
        return ans;
    }
```

- note the order of the end of recursive function matters:
  first check one subset is done.
  second check k subsets is done.
  not done one subset but the array is done.
- backtrack shall be done on the input array.
this will TLE:
for example: [1,2,1,4] with k=2
we have 1: 2, 2:1, 4:1 as the input, the backtrack will try these combinations:

[1 2 ],[1 4 ]

[1 4 ],[,1,2] //redundant

[2 4 ],[1,1] //invalid

[6,3,8,1,3,1,2,2]
4
the input is: {1:2},{2:2},{3:2},{6:1},{8:1}
we need have 4 groups, each group has 2 elements.

To optimize:
- use bitmask for the vector t.
- the above backtrack actually find all the permutation of the sets. If we can reduce to find only the combination, the complexity would be reduced by k!
- eary exit (prune): when we found intermediate result > ans, we can return early.
- memoization to avoid repeated calculations.
- use hashset to avoid permutation.

```cpp
	int mn=INT_MAX,m;
	int minimumIncompatibility(vector<int>& nums, int k) {
		int n=nums.size();
		m=n/k; //bin size
		vector<set<int>> sets(k); //k sets
		backtrack(nums,0,sets,0);
		return mn==INT_MAX?-1:mn;
	}
	
	void backtrack(vector<int>& nums,int idx,vector<set<int>>& sets,int sum){
		if(idx>=nums.size()){
			mn=min(mn,sum);
			return;
		}
		set<set<int>> visited;
		for(auto& st: sets){ //this will apply change into the sets.
			if(st.count(nums[idx]) || st.size()==m || visited.count(st)) continue;
			int impact=computeImpact(st,nums[idx]);
			sum+=impact;
			if(sum<mn){
				st.insert(nums[idx]);
				backtrack(nums,idx+1,sets,sum);
				st.erase(nums[idx]);
			}
			sum-=impact;
			visited.insert(st);
		}
	}
	
	int computeImpact(set<int>& st,int num){
		if(st.size()==0) return 0;
		if(st.size()==1) return abs(*st.begin()-num);
		int lo=INT_MAX,hi=INT_MIN;
		for(int i: st) lo=min(lo,i),hi=max(hi,i);
		if(num<lo) return lo-num;
		if(num>hi) return num-hi;
		return 0;
	}
```	

we can see there is some greedy approach can be used. 
- the smallest has to be min for some of the subsets.
- the maximum has to be the max for some of the subsets
- the min<A<max can be min or max or between for some of the subsets.




	

	
## contest 219

1688. Count of Matches in Tournament
<em>
You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.
</em>

```cpp
    int numberOfMatches(int n) {
        int ans=0;
        while(n>1){
            ans+=n/2;
            n=(n+1)/2;
        }
        return ans;
    }
```

1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
<em>
A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.

Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.
</em>

greedy: digits all reduce to 1 or 0, so the max number of transformation is the largest digit.

```cpp
    int minPartitions(string n) {
        int ans=0;
        char mx=0;
        for(char c: n)
            mx=max(mx,c);
        return mx-'0';
    }
```

1690. Stone Game VII
<em>
Alice and Bob take turns playing a game, with Alice starting first.

There are n stones arranged in a row. On each player's turn, they can remove either the leftmost stone or the rightmost stone from the row and receive points equal to the sum of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.

Bob found that he will always lose this game (poor Bob, he always loses), so he decided to minimize the score's difference. Alice's goal is to maximize the difference in the score.

Given an array of integers stones where stones[i] represents the value of the ith stone from the left, return the difference in Alice and Bob's score if they both play optimally.
</em>

It is essentially to maxmize the score, so it is same as before.

```cpp
    int dp[1000][1000][2];//={};
    int stoneGameVII(vector<int>& stones) {
        //alice remove the min of two ends, bob remove the max of two ends
        int n=stones.size();
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++) dp[i][j][0]=dp[i][j][1]=INT_MIN;
        }
        vector<int> prefix(n+1);
        for(int i=0;i<n;i++) prefix[i+1]=prefix[i]+stones[i];
        int ans=helper(prefix,stones,0,n-1,0);
        //print(n);
        return ans;
    }
    int helper(vector<int>& prefix,vector<int>& stones,int l,int r,int op){
        if(l>=r) return 0;
        if(dp[l][r][op]!=INT_MIN) return dp[l][r][op];
        int ans=0; //maximize the difference
		int rmleft=prefix[r+1]-prefix[l+1];
		int rmright=prefix[r]-prefix[l];
		ans=max(rmleft-helper(prefix,stones,l+1,r,op^1),rmright-helper(prefix,stones,l,r-1,op^1));
        return dp[l][r][op]=ans;
    }
```	

Actually the op is not needed and we can reduce it to 2d dp.

It is found that memset does not work and I do not why.

1691. Maximum Height by Stacking Cuboids

<em>
Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.

You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.

Return the maximum height of the stacked cuboids.
</em>

during contest, I did not notice the height requirement, which is a lesson.

approach:
- sort each cube so that height is the max. (greedy)
- sort the array of boxes --> LIS problem

```cpp
    int maxHeight(vector<vector<int>>& A) {
        for (auto& a : A)
            sort(begin(a), end(a));
        A.push_back({0, 0, 0});
        sort(begin(A), end(A));
        int n = A.size(), res = 0;
        vector<int> dp(n);
        for (int j = 1; j < n; ++j)
            for (int i = 0; i < j; ++i)
                if (A[i][0] <= A[j][0] && A[i][1] <= A[j][1] && A[i][2] <= A[j][2]) {
                    dp[j] = max(dp[j], dp[i] + A[j][2]);
                    res = max(res, dp[j]);
                }
        return res;
    }
```	

 
 


# contest 220

1694. Reformat phone number
<em>
You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.

You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:

2 digits: A single block of length 2.
3 digits: A single block of length 3.
4 digits: Two blocks of length 2 each.
The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.

Return the phone number after formatting.
</em>

use recursive (down the size each time)
or brutal force

```cpp
    string reformatNumber(string number) {
        string s;
        for(char c: number){
            if(isdigit(c)) s+=c;
        }
        int n=s.size();
        int rem=0;
        if(n%3==1) rem=4;
        if(n%3==2) rem=2;
        string ans;
        for(int i=0;i<n-rem;i+=3){
            ans+=s.substr(i,3)+"-";
        }
        if(rem==0) ans.pop_back();
        if(rem==2) ans+=s.substr(n-2,2);
        if(rem==4) ans+=s.substr(n-4,2)+"-"+s.substr(n-2,2);
        return ans;
    }
```

1695. Maximum Erasure Value
<em>
You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.

Return the maximum score you can get by erasing exactly one subarray.

An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).
</em>

sliding window + hashset/hashmap

```cpp
    int maximumUniqueSubarray(vector<int>& nums) {
        //subarray with unique element with max sum
        int i=0,j=0,ans=0;
        int n=nums.size();
        if(n==1) return nums[0];
        vector<int> pre(n+1);
        unordered_map<int,int> mp;
        while(j<nums.size()){
            pre[j+1]=pre[j]+nums[j];
            if(mp.count(nums[j])){
                //ans=max(ans,pre[j]-pre[mp[nums[j]]]);
                i=max(i,mp[nums[j]]+1); //i keeps going up
            }
            mp[nums[j]]=j;
            ans=max(ans,pre[j+1]-pre[i]);  //shall include current one,  
            j++;
            
        }
        
        return ans;
    }
```

1696. Jump Game VI
<em>
You are given a 0-indexed integer array nums and an integer k.

You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.

You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.

Return the maximum score you can get.
</em>
First we need to recoginize this is a dp problem. 
dp[i]=max(dp[i-1],...dp[i-k+1])
this leads us a sliding window max using pq or monotonic deque

```cpp
    int maxResult(vector<int>& nums, int k) {
        int ans=0;
        vector<int> dp(nums.size());
        dp[0]=nums[0];
        priority_queue<vector<int>> pq;
        pq.push({nums[0],0});
        for(int i=1;i<nums.size();i++){
            while(pq.size() && pq.top()[1]<i-k) pq.pop();

            dp[i]=pq.top()[0]+nums[i];
            pq.push({dp[i],i});
        }
        return dp.back();
    }
```	
using monotonic deque
```cpp
	int maxResult(vector<int>& nums, int k) {
		vector<int> dp(nums.size());
		deque<int> dq;
		dp[0]=nums[0];
		dq.push_back(0);
		for(int i=1;i<nums.size();i++){
			while(dq.size() && dq.front()<i-k) dq.pop_front(); //old ones
			dp[i]=dp[dq.front()]+nums[i];
			while(dq.size() && dp[dq.back()]<dp[i]) //maintain a monotonic queue
				dq.pop_back();
			dq.push_back(i);
		}
		return dp.back();
	}
```

1697. Checking Existence of Edge Length Limited Paths
<em>
An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes.

Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj .

Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.<em>

actually it is pretty straightforward, just build the union-find from small edge length to larger one, and get the query from small to large.

```cpp
    vector<int> parent;
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
       //node and eges and query are large, dfs will TLE
        //union find may be better. using limit edge length as the key for union
        sort(begin(edgeList),end(edgeList),[](vector<int>& a,vector<int>& b){
            return a[2]<b[2];
        });
        int m=queries.size();
        vector<bool> ans(m);
        for(int i=0;i<m;i++) queries[i].push_back(i);
        sort(begin(queries),end(queries),[](vector<int>& a,vector<int>& b){
            return a[2]<b[2];
        });
        parent.resize(n);
        for(int i=0;i<n;i++) parent[i]=i;
        int start=0;
        
        for(int i=0;i<m;i++)
        {
            int limit=queries[i][2],ind=queries[i][3];
            int ni=queries[i][0],nj=queries[i][1];
            while(start<edgeList.size() && edgeList[start][2]<limit){
                merge(edgeList[start][0],edgeList[start][1]);
                start++;
            }
            ans[ind]=findp(ni)==findp(nj);
        }
        return ans;
    }
    int findp(int i){
        while(i!=parent[i]){
            parent[i]=parent[parent[i]];
            i=parent[i];
        }
        return i;
    }
    void merge(int i,int j){
        int pi=findp(i),pj=findp(j);
        //cout<<i<<" "<<j<<" "<<pi<<" "<<pj<<endl;
        if(pi!=pj){
            parent[pi]=pj;
        }
    }
```	






