### Problem Summary
This is a pretty hard DP problem.

matrix: 0 empty, 1 cherry -1: thorn

You need go roundtrip from top left to bottom right and back to top left and get the max cherry.

### Approach:

- intuitively way that maximizes the first pass and changes the optimal path and then finds the second pass optimal path will not work. Since this will only maximize the first pass and the global optimal is not guaranteed.

- From top left to bottom right is equivalent to from bottom right to top left

- The correct approach is to try the two passes simultaneously and make the two passes optimal. The only constraint is: the two passes cannot pick up the same cherry twice.

- for a matrix n x n, one trip takes 2N-1 steps. We can try all possible locations for two passes for each step and this is the key point. i.e., the first pass goes to (i,j) and second pass goes to (p,q) and i+j=p+q=steps. The only constraint is (i, j)=(p, q). The cherry picked up at these two locations are grid[i, j]+grid[p, q].

- From previous position to current (i,j) and (p,q), the previous combination could be the following: (i-1, j, p-1, q, k-1) (i-1, j, p, q-1, k-1) (i, j-1, p-1, q, k-1) (i, j-1, p, q-1, k-1). k is the number of steps.

- So the recurrence relation is dp(i, j, p, q, k)=max(dp(i-1, j, p-1, q, k-1), dp(i-1, j, p, q-1, k-1), dp(i, j-1, p-1, q, k-1), dp(i, j-1, p, q-1, k-1))+grid(i, j)+grid(p,q).

- Since i and j are associated, also p and q are associated, dp shall not use i and j, but we need use i and p, or j and q. (the x coordinate for two positions or y coordinates for the two passes).

    - dp(i-1, j, p-1, q, k-1) reduced to dp(i-1, p-1, k-1)

    - dp(i-1, j, p, q-1, k-1) reduced to dp(i-1, p, k-1)

    - dp(i, j-1, p-1, q, k-1) reduced to dp(i, p-1, k-1)

    - dp(i, j-1, p, q-1, k-1) reduced to dp(i, p, k-1)
    
Since only k-1 iteration is involved, we may not need the 3rd dimension, but extra care is needed, generally reverse iteration is required to avoid using updated values.

And finally we reached the solution:

Attention:

Since we reduce the 3d problem into 2d problem we need do reverse iteration to use n-1 values

when grid[x][y]<0, we need set dp[x1][x2]=-1 it is necessary since it is dp[x1][x2][n]! and dp[x1][x2][n-1] may be >0 but dp[x1][x2][n] may be <0. Need to keep updating.

two legs can cross the same position, but can only pick the cherry once.

### code
```cpp
    int cherryPickup(vector<vector<int>>& grid) {
        int n=grid.size();
        vector<vector<int>> dp(n,vector<int>(n,-1));
        dp[0][0]=grid[0][0];
        for(int nstep=1;nstep<2*n-1;nstep++)
        {
            for(int x1=n-1;x1>=0;x1--)
            {
                for(int x2=n-1;x2>=0;x2--) //can share the same position but cannot pick twice
                {
                    int y1=nstep-x1,y2=nstep-x2;
                    if(y1<0 || y2<0 ||y1>=n || y2>=n) continue;
                    if(grid[x1][y1]<0 || grid[x2][y2]<0) {dp[x1][x2]=-1;continue;}
                    int delta=grid[x1][y1];
                    if(x1!=x2) delta+=grid[x2][y2];
                    int best=-1;
                    if(x1 && x2 && dp[x1-1][x2-1]>=0) best=max(best,dp[x1-1][x2-1]+delta);
                    if(y1 && x2 && dp[x1][x2-1]>=0) best=max(best,dp[x1][x2-1]+delta);
                    if(x1 && y2 && dp[x1-1][x2]>=0) best=max(best,dp[x1-1][x2]+delta);
                    if(y1 && y2 && dp[x1][x2]>=0) best=max(best,dp[x1][x2]+delta); 
                    dp[x1][x2]=best; 
                }
            }
        }
        return dp[n-1][n-1]==-1?0:dp[n-1][n-1];
    }

```

### Attention:
- this is a 3d problem with space reduced to 2d, especial care needs attention. one is the reverse iteration, one is setting dp to be -1 when there is a thorn at either position
- cannot pick the same cherry
- initialize to -1 to mark. do not have to be int_min which makes things more complicated.
- complexity O(N^3)
