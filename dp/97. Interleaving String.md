### Problem summary: 
check if s1 and s2 interleaves to s3

### Approach
This is similar to a mxn matrix which we can find a path of s3

dp[i, j] represents s1[0...i-1] with s2[0...j-1] can interleave to s3[0...i+j-1]

when s1[i-1]==s3[i+j-1] we may choose s1[i-1], previous solution is dp[i-1, j]

when s2[j-1]==s3[i+j-1], we may choose s2[j-1], previous solution is dp[i, j-1]

when both s1[i-1] and s2[j-1] equals s3[i+j-1] we may choose either of them.

So, the recurrence relation is:

dp[i, j]=(dp[i-1, j] && s1[i-1]==s3[i+j-1]) || (dp[i, j-1] && s2[j-1]==s3[i+j-1])

Boundary condition:
0th row: when s1 is empty, dp[0,i] depends previous dp[0, i-1] and current char if the same

0th col: when s2 is empty, dp[i,0] depends previous dp[i-1,0] and current char if the same

### code
```cpp

    bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.size(),n2=s2.size();
        if(s3.length() != n1+n2) return 0;
        if(n1==0) return s3==s2;
        if(n2==0) return s3==s1;
        vector<vector<bool>> dp(n1+1,vector<bool>(n2+1));
        dp[0][0]=1; //empty vs empty
        //boundary condition
        for(int i=1;i<=n1;i++) dp[i][0]=dp[i-1][0] && (s1[i-1]==s3[i-1]); //j=0, s1 compare with s3
        for(int j=1;j<=n2;j++) dp[0][j]=dp[0][j-1] && (s2[j-1]==s3[j-1]); //i=0: s2 compare with s3
        for(int i=1; i<=n1; i++)
        {
            for(int j=1; j<=n2; j++)
            {
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1] ) || (dp[i][j-1] && s2[j-1] == s3[i+j-1] );
            }
        }   
        return dp[n1][n2];
    }
    
```

### Attention:
- this is a direct dp problem, which uses dp(i, j) directly for the string s1 with len i and s2 with string j and s3 with len i+j
- deal with special case: which is easy
- boundary condition: easy but if incorrectly specified, will get wrong results
- complexity O(N^2)
