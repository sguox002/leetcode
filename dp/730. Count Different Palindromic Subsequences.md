### Problem Summary
Given a string of length n, find the number of different Palindrome subsequences, string has only a,b,c,d
Attention: it asks for **subsequences**, not substring

### ideas
1. it is easy to extend to 26 chars

2. a palindrome string can be from i to j. It is naturally use a start, end pair, or a start, length pair to indicate a palindrome string.

3. dp natural thinking: we start from the (i,len) subproblem and extend to see if we can solve bigger problem
assuming we add a char to s[i, i+len-1] (we use xxxx to indicat the string which is palindrome):

4. if we define dp[i,len,x] as the number of different pal-subsequence starting at i, with length=len, with start/end char =x

if s[i]!='x', we can ignore (remove) first char, dp[i,len,x]=dp[i+1,len-1,x]
else if s[j]!='x', we can ignore (remove) last char, dp[i,len,x]=dp[i,len-1,x] (the head is x but tail is not)

if both are x: 
dp[i,len,x]=dp[i+1,len-2,'a']+dp[i+1,len-2,'b']+dp[i+1,len-2,'c']+dp[i+1,len-2,'d']+2

why?
  - we are adding one x to the head and one x to the tail, which makes xa..ax, xb..bx, xc..cx, xd..dx all different pal-subsequence. Since we are making the length increased by 2, and they are all different.
  
  - +2: we can add x and xx into it since we add two x into previous solution, and we at least have length>=3
  
for example: we have aabaa, the subsequence start and end with a:

a,aa,aaa,aaaa,aba,aabaa

when add a to head and tail, they become:

aaa,aaaa,aaaaaa,aabaa,aaabaaa

and we add a and aa into it.

5. since it only involves len-2, len-1 and len, we only need 3 matrices.

6. The final answer is the sum of start=0, len=n, and char=a, b, c, d

# Implementation
```cpp
    int countPalindromicSubsequences(string s) {
        int md = 1e9+7;
        int n = s.size();
        //dp0 for len-2, dp1 for len-1, dp2 for len
        vector<vector<int>> dp0(n,vector<int>(4)),dp1(n,vector<int>(4)),dp2(n,vector<int>(4));
        for (int len=1; len<=n; ++len) 
        {
            for (int i = 0; i + len <=n; ++i)
            {
                for (char c = 'a'; c <= 'd'; ++c)  
                {
                    int x=c-'a';
                    dp2[i][x]=0;
                    int j = i + len - 1;//j the end, and i the start
                    if (len == 1) dp2[i][x] = s[i] == c;
                    else 
                    {
                        if (s[i] != c) dp2[i][x] = dp1[i+1][x];//first char is not the char looking for, just ignore the first char
                        else if (s[j] != c) dp2[i][x] = dp1[i][x];//end char is not the char looking for, just ignore the last char
                        else //first char=last char=c
                        {
                            dp2[i][x] = 2;//a...a, it at least add a, and aa for just the substring
                            if (len > 2) //len>2 we can remove the first and last char
                            {
                                for (int y = 0; y < 4;++y) 
                                {
                                    dp2[i][x] += dp0[i+1][y];//excluding the first and last character
                                    dp2[i][x] %=md;
                                }
                            }
                        }
                    }
                }
            }
            dp0=dp1;
            dp1=dp2;
        }
        int ret = 0;
        for (int x = 0; x < 4;++x) ret = (ret + dp2[0][x]) %md;
        return ret;
    }
```

### comments
- it needs subsequence, not substring, this is very important to the understanding of the algorithm
- need special treat len=1 case
- need special treat len==2 case when add two char (empty)
- when an iteration on len is done, we need update len-1->len-2, len->len-1
- every time len shall be initialized since we reuse the matrix. that is why dp2[i][x]=0 is needed



