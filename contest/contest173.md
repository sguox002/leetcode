## contest 173
### 1332. Remove Palindromic Subsequences
<em>
Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.</em>

three cases:
empty string:
palindrome string, 1 operation
contains a and b: 2 operations

```cpp
    int removePalindromeSub(string s) {
        if(s.empty()) return 0;
        string rs=s;
        reverse(rs.begin(),rs.end());
        if(rs==s) return 1;
        return 2;
    }
```

### 1333. Filter Restaurants by Vegan-Friendly, Price and Distance	
<em>
Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.

The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively.

Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.

 </em>
 
 Approach:
 
 filter all the restaurants and then sort.
 ```cpp
     vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> ans;
        for(auto t: restaurants){
            if((!veganFriendly || (veganFriendly && t[2])) && t[3]<=maxPrice && t[4]<=maxDistance){
                ans.push_back(t);
            }
        }
        sort(ans.begin(),ans.end(),[](vector<int>& a,vector<int>& b){
            return a[1]>b[1] || (a[1]==b[1] && a[0]>b[0]);
        });
        vector<int> res;
        for(auto t: ans) res.push_back(t[0]);
        return res;
    }
```

### 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance	
<em>
There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.

Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.
</em>

Idea: 
My first intuition is using bellman ford (dp like method) to relax the edges.
also called floyd warshall algorithm, used to find all the pair distance in a graph.
```cpp
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
		vector<vector<int>> dist(n,vector<int>(n,INT_MAX/2));
		for(auto e: edges){
			dist[e[1]][e[0]]=dist[e[0]][e[1]]=e[2];
		}
		for(int i=0;i<n;i++) dist[i][i]=0;//maybe not necessary?
		for(int k=0;k<n;k++){
			for(int i=0;i<n;i++){
				for(int j=0;j<n;j++){
					dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
				}
			}
		}
		int mincnt=n,ans=-1;
		for(int i=0;i<n;i++){
			int cnt=0;
			for(int j=0;j<n;j++) {
				if(dist[i][j]<=distanceThreshold) cnt++;
			}
			//ans=min(ans,cnt);
            if(mincnt>=cnt){
                mincnt=cnt;
                ans=i;
            } 
		}
		return ans;
	}


using pq (dijkstra) to find the closest distance to other cities. If over the threshold, ignore
the implementation from leetcode discussion:
```cpp
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<unordered_map<int, int>> neighbors(n);
        for (auto & vec : edges){
            neighbors[vec[0]][vec[1]] = vec[2];
            neighbors[vec[1]][vec[0]] = vec[2];
        }
        int res = -1, minSize = INT_MAX;
        for (int i = 0; i < n; ++ i){
            int cnt = bfs(i, neighbors, distanceThreshold, n);
            if (cnt <= minSize){
                res = i;
                minSize = cnt;
            }
        }
        return res;
    }
    
    
    int bfs(int src, vector<unordered_map<int, int>>& neighbors, int distanceThreshold, int n){
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;
        minHeap.emplace(0, src);
        vector<int> dist(n, INT_MAX);
        dist[src] = 0;
        // handles duplicate points that might be discovered later, so we can't simply just count
        unordered_set<int> ret;
        while (!minHeap.empty()){
            auto c = minHeap.top();
            minHeap.pop();
            int x = c.second, curDist = c.first;
            for (auto it = neighbors[x].begin(); it != neighbors[x].end(); ++ it){
                int totalDist = curDist + it->second;
				// updates previous dist if we find a smaller one
                if (dist[it->first] > totalDist && totalDist <= distanceThreshold){
                    dist[it->first] = totalDist;
                    minHeap.emplace(totalDist, it->first);
                    ret.insert(it->first);
                }
            }
        }
        return ret.size();
    }
```

### 1335. Minimum Difficulty of a Job Schedule	
<em>
You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the i-th job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done in that day.

Given an array of integers jobDifficulty and an integer d. The difficulty of the i-th job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.
</em>
I first thought this is a binary search problem, but actually not, since each day may contain multiple tasks which is greater than our target difficulty.
Realized this is a dp problem, then we can think top down recursive approach first to make it correct.
for the first day we have option:
1 tasks, leaving n-1 
2 tasks, leaving n-2
...
n tasks, leaving 0.
that is to say the dp problem is as belows:

min(max(A[0..i])+sub(i+1,d-1))

```cpp
    int minDifficulty(vector<int>& job, int d) {
		int n=job.size();
		if(d>n) return -1;
		vector<vector<int>> dp(n,vector<int>(d+1,INT_MAX/2));
		return helper(job,0,d,dp);
	}
	int helper(vector<int>& job,int start,int nday,vector<vector<int>>& dp){
		int n=job.size();
        if(start>=n || nday>n-start) return INT_MAX/2; //not valid
        if(dp[start][nday]<INT_MAX/2) return dp[start][nday];
		if(nday==1) return *max_element(job.begin()+start,job.end());
		int ans=INT_MAX,maxval=0;
		for(int i=start;i<n;i++){
			maxval=max(maxval,job[i]);
			ans=min(ans,maxval+helper(job,i+1,nday-1,dp));
		}
		return dp[start][nday]=ans;
	}
```

Important: it is always a good method for dp to try recursive approach first.	
