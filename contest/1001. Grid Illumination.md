# hashtable

## contents

771	Jewels and Stones		Easy	
760	Find Anagram Mappings 	Easy	
961	N-Repeated Element in Size 2N Array		Easy	
1002 Find Common Characters		Easy	
811	Subdomain Visit Count		Easy	
359	Logger Rate Limiter 	Easy	
500	Keyboard Row		Easy	
463	Island Perimeter		Easy	
884	Uncommon Words from Two Sentences		Easy	
266	Palindrome Permutation 	Easy	
136	Single Number		Easy	
575	Distribute Candies		Easy	
706	Design HashMap		Easy	
953	Verifying an Alien Dictionary		Easy	
349	Intersection of Two Arrays		Easy	
690	Employee Importance		Easy	
748	Shortest Completing Word		Easy	
705	Design HashSet		Easy	
389	Find the Difference		Easy	
242	Valid Anagram		Easy	
217	Contains Duplicate		Easy	
387	First Unique Character in a String		Easy	
447	Number of Boomerangs		Easy	
409	Longest Palindrome		Easy	
599	Minimum Index Sum of Two Lists		Easy	
350	Intersection of Two Arrays II		Easy	
202	Happy Number		Easy	
720	Longest Word in Dictionary		Easy	
1	Two Sum		Easy	
594	Longest Harmonious Subsequence		Easy	
246	Strobogrammatic Number 	Easy	
645	Set Mismatch		Easy	
734	Sentence Similarity 	Easy	
970	Powerful Integers		Easy	
438	Find All Anagrams in a String		Easy	
205	Isomorphic Strings		Easy	
624	Maximum Distance in Arrays 	Easy	
219	Contains Duplicate II		Easy	
290	Word Pattern		Easy	
170	Two Sum III - Data structure design 	Easy	
204	Count Primes		Easy	

535	Encode and Decode TinyURL		Medium	
739	Daily Temperatures		Medium	
94	Binary Tree Inorder Traversal		Medium	
311	Sparse Matrix Multiplication 	Medium	
451	Sort Characters By Frequency		Medium	
609	Find Duplicate File in System		Medium	
347	Top K Frequent Elements		Medium	
508	Most Frequent Subtree Sum		Medium	
648	Replace Words		Medium	
676	Implement Magic Dictionary		Medium	
781	Rabbits in Forest		Medium	
694	Number of Distinct Islands 	Medium	
981	Time Based Key-Value Store		Medium	
454	4Sum II		Medium	
939	Minimum Area Rectangle		Medium	
249	Group Shifted Strings 	Medium	
554	Brick Wall		Medium	
244	Shortest Word Distance II 	Medium	
49	Group Anagrams		Medium	
718	Maximum Length of Repeated Subarray		Medium	
692	Top K Frequent Words		Medium	
325	Maximum Size Subarray Sum Equals k 	Medium	
974	Subarray Sums Divisible by K		Medium	
36	Valid Sudoku		Medium	
380	Insert Delete GetRandom O(1)		Medium	
525	Contiguous Array		Medium	
560	Subarray Sum Equals K		Medium	
966	Vowel Spellchecker		Medium	
314	Binary Tree Vertical Order Traversal 	Medium	
299	Bulls and Cows		Medium	
957	Prison Cells After N Days		Medium	
930	Binary Subarrays With Sum		Medium	
187	Repeated DNA Sequences		Medium	
274	H-Index		Medium	
954	Array of Doubled Pairs		Medium	
987	Vertical Order Traversal of a Binary Tree		Medium	
356	Line Reflection 	Medium	
18	4Sum		Medium	
3	Longest Substring Without Repeating Characters		Medium	
355	Design Twitter		Medium	
138	Copy List with Random Pointer		Medium	
288	Unique Word Abbreviation 	Medium	
166	Fraction to Recurring Decimal		Medium	

895	Maximum Frequency Stack		Hard	
632	Smallest Range		Hard	
159	Longest Substring with At Most Two Distinct Characters 	Hard	
711	Number of Distinct Islands II 	Hard	
770	Basic Calculator IV		Hard	
992	Subarrays with K Different Integers		Hard	
726	Number of Atoms		Hard	
340	Longest Substring with At Most K Distinct Characters 	Hard	
37	Sudoku Solver		Hard	
1001	Grid Illumination		Hard	
85	Maximal Rectangle		Hard	
358	Rearrange String k Distance Apart 	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed		Hard	
710	Random Pick with Blacklist		Hard	
336	Palindrome Pairs		Hard	
76	Minimum Window Substring		Hard	
30	Substring with Concatenation of All Words		Hard	
1044 Longest Duplicate Substring		Hard	
149	Max Points on a Line		Hard	

## easy
### 771	Jewels and Stones		Easy	
simple. a list of jewels and a list of stones

### 760	Find Anagram Mappings 	Easy	
locked

### 961	N-Repeated Element in Size 2N Array		Easy	
simple, shown more than once is the answer

### 1002 Find Common Characters		Easy	
just count chars in each word and then choose the min of all

### 811	Subdomain Visit Count		Easy
discuss.leetcode.	com, count each domain

### 359	Logger Rate Limiter 	Easy	
locked

### 500	Keyboard Row		Easy	
simple

### 463	Island Perimeter		Easy	
this does not need hashtable just check top and left and subtract


### 884	Uncommon Words from Two Sentences		Easy	
two maps and remove those common

### 266	Palindrome Permutation 	Easy	
locked

### 136	Single Number		Easy	
every appear twice except one, using xor

### 575	Distribute Candies		Easy	
candies: number represent different type
return max number of candies can give to brothers and sisters.
apparently we can only get half of the types.
```cpp
    int distributeCandies(vector<int>& candies) {
        //build a map with its count
        //the strategy: first assign the candies with the smallest 
        unordered_set<int> table(candies.begin(),candies.end());
        return min(table.size(),candies.size()/2); 
    }
```	
### 706	Design HashMap		Easy	
hashmap using array of limited size, and each element can store a linked list for collision
```cpp    vector<list<pair<int,int>>> m_data;
    size_t m_size = 10000;
public:
    /** Initialize your data structure here. */
    MyHashMap() {
        m_data.resize(m_size);
    }
    
    /** value will always be non-negative. */
    void put(int key, int value) {
        auto &list = m_data[key % m_size];
        for (auto & val : list) {
            if (val.first == key) {
                val.second = value;
                return;
            }
        }
        list.emplace_back(key, value);
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        const auto &list = m_data[key % m_size];
        if (list.empty()) {
            return -1;
        }
        for (const auto & val : list) {
            if (val.first == key) {
                return val.second;
            }
        }
        return -1;
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
        auto &list = m_data[key % m_size];
        list.remove_if([key](auto n) { return n.first == key; });
    }
```
	
### 953	Verifying an Alien Dictionary		Easy	
a-z but in different order, verify the list of words order correct or not
convert words and a-z into conventional order and then compare
```cpp
    bool isAlienSorted(vector<string>& words, string order) {
        unordered_map<char,char> mp;
        for(int i=0;i<26;i++) mp[order[i]]='a'+i;
        char c=order[0];
        for(int i=0;i<words.size();i++)
        {
            for(int j=0;j<words[i].size();j++) words[i][j]=mp[words[i][j]];
        }
        
        return is_sorted(words.begin(),words.end());
    }
```

### 349	Intersection of Two Arrays		Easy	
no duplicates allowed in result.
use set_intersection or hand write
```cpp
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        //use set_intersection
        vector<int> v(min(nums1.size(),nums2.size()));
        //sort them first
        set<int> s1,s2;
        for(int i=0;i<nums1.size();i++) s1.insert(nums1[i]);
        for(int i=0;i<nums2.size();i++) s2.insert(nums2[i]);
        vector<int>::iterator it;
        it=set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),v.begin());//note the two arrays have to be sorted
        v.resize(it-v.begin());
        return v;
    }
```	
### 690	Employee Importance		Easy	
see dfs

### 748	Shortest Completing Word		Easy	
need to complete the license plate using words, 
sort the words according to length
if there is tie, return the first
so use stable_sort
```cpp
bool cmp(const string& a,const string& b) {return a.size()<b.size();}
class Solution {
public:
    string shortestCompletingWord(string licensePlate, vector<string>& words) {
        unordered_map<char,int> mp;
        for(int i=0;i<licensePlate.size();i++)
        {
            if(isalpha(licensePlate[i])) mp[tolower(licensePlate[i])]++;
        }
        //need sort the word list using the strlen
        stable_sort(words.begin(),words.end(),cmp);
        for(int i=0;i<words.size();i++)
        {
            if(contains(words[i],mp)) return words[i];
        }
        return string();
    }
    bool contains(string& w,unordered_map<char,int> mp)
    {
        for(int i=0;i<w.size();i++)
        {
            if(mp.count(w[i])) {mp[w[i]]--;if(mp[w[i]]==0) mp.erase(w[i]);}
            if(mp.empty()) return 1;
        }
        return 0;
    }
};
```

### 705	Design HashSet		Easy	
similar approach for hashmap

### 389	Find the Difference		Easy	
two strings, only one char is extra, just xor

### 242	Valid Anagram		Easy	
simple

### 217	Contains Duplicate		Easy	
convert to hashset and check if size is the same

### 387	First Unique Character in a String		Easy	
count in hashmap and find the first char with counter=1 (two pass)
or store the index into hash, and loop the hashtable which is more efficient.


### 447	Number of Boomerangs		Easy	
Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).
approach: just O(n^2) to get all distance and save into hashmap. 
```cpp
    int numberOfBoomerangs(vector<pair<int, int>>& points) {
        //brutal force: for each point get the distance to all other points, store the distance in a map
        int res=0;
        for(int i=0;i<points.size();i++) //point by point
        {
            unordered_map<long long,int> distmap;
            for(int j=0;j<points.size();j++)
            {
                if(j==i) continue;
                int dx=points[i].first-points[j].first;
                int dy=points[i].second-points[j].second;
                long long dist=(long long)dx*dx+(long long)dy*dy;
                distmap[dist]++;
            }
        
            //now calculate the number of boomerang
            //if we have n equal distance, the number of boomerang is n*(n-1)=P(n,2)

            for(auto it=distmap.begin();it!=distmap.end();it++)
            {
                if(it->second>1) res+=(it->second)*(it->second-1);
            }
        }
        return res;
    }
```
	
### 409	Longest Palindrome		Easy	
Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.

This is case sensitive, for example "Aa" is not considered a palindrome here.
only one is allowed to be odd times

```cpp
    int longestPalindrome(string s) {
        //palindrome is the same from forward or backward
        //understand the problem is most important
        //pick only those letters with even plus at least one with odd times
        //char with odd numbers can be used even numbers and leave one!
        unordered_map<char,int> mp;
        for(int i=0;i<s.size();i++) mp[s[i]]++;
        //count number of odd numbers
        int count=0;
        for(auto it=mp.begin();it!=mp.end();it++) if(it->second&1) count++;
        if(count) return s.size()-count+1;
        return s.size();
        
    }
```	
### 599	Minimum Index Sum of Two Lists		Easy	
common interest with min index sum
one map is fine, and check against another array.
```cpp
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        vector<string>res;
        unordered_map<string,int>m;
        int min = INT_MAX;
        for(int i = 0; i < list1.size(); i++) m[list1[i]] = i;
        for(int i = 0; i < list2.size(); i++)
            if(m.count(list2[i]) != 0)
                if(m[list2[i]] + i < min) min = m[list2[i]] + i, res.clear(), res.push_back(list2[i]);
                else if(m[list2[i]] + i == min) res.push_back(list2[i]);
        return res;
    }
```	
### 350	Intersection of Two Arrays II		Easy	
need keep the duplicates, using hashmap to keep the counters
or use multiset
```cpp
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> v(min(nums1.size(),nums2.size()));
        multiset<int> s1,s2;
        for(int i=0;i<nums1.size();i++) s1.insert(nums1[i]);
        for(int i=0;i<nums2.size();i++) s2.insert(nums2[i]);
        vector<int>::iterator it;
        it=set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),v.begin());
        v.resize(it-v.begin());
        return v;
    }
```	
### 202	Happy Number		Easy	
sum of digit square which equals to 1
either there is a cycle or go to 1

### 720	Longest Word in Dictionary		Easy	
the longest word can be built one char by one char from words in the dictionary
approach 1: each time remove one char at the end. and check if in the dictionary
approach 2: trie, first insert the longest one, later one we will judge start with.
```cpp
    Trie t;    
    string longestWord(vector<string>& words) {
        //trie method
        sort(words.begin(),words.end(),cmp);
        //copy(words.begin(),words.end(),ostream_iterator<string>(cout," "));
        unordered_set<string> myset(words.begin(),words.end());
        for(int i=0;i<words.size();i++)
        {
            t.insert(words[i]);
            bool found=1;
            for(int j=1;j<words[i].size();j++)
            {
                string ts=words[i].substr(0,j);
                if(!myset.count(ts) || !t.startsWith(ts)) {found=0;break;}
            }
            if(found) return words[i];
        }
        return string();
    }
```
	
### 1	Two Sum		Easy	
trivial

### 594	Longest Harmonious Subsequence		Easy	
in the array max-min=1 
find the longest harmoniuos subsequence.
hashmap to record each number's counters
then for each number we look for its neighboring

```cpp
    int findLHS(vector<int>& nums) {
        map<int,int> mp;
        if(nums.size()<2) return 0;
        for(int i=0;i<nums.size();i++) mp[nums[i]]++;
        //look for neighboring keys with difference to be 1
        int maxlen=0;
        auto it1=mp.begin(); //this needs at least two elements
        auto it=it1;//this changes the it1 to the same element
        it++;
        for(;it!=mp.end();it++,it1++)
        {
            if(it->first==it1->first+1)
            {
                int len=it->second+it1->second;
                if(len>maxlen) maxlen=len;
            }
        }
        return maxlen;
    }
```	
### 246	Strobogrammatic Number 	Easy	
locked

### 645	Set Mismatch		Easy	
### 1 to n, one number converts to other number, so one is missing and one is duplicated.
find the two numbers
xor will find a^b
we need another pass to find the duplicate or the missing. (using seen, change to negative)

### 734	Sentence Similarity 	Easy	
locked

### 970	Powerful Integers		Easy	
z=x^i+y^j
just use brutal force

### 438	Find All Anagrams in a String		Easy	
sliding window for hashmap

### 205	Isomorphic Strings		Easy	
s and t can be replaced. the two string has the same pattern
convert a third pattern
```cpp
    bool isIsomorphic(string s, string t) {
        //need preserve the order
        unordered_map<char,char> mp;
        string ss,tt;
        char c='a';
        for(char tc: s) {
            if(!mp.count(tc)) mp[tc]=c++; 
            ss+=mp[tc];
        }
        mp.clear();
        c='a';
        for(char tc: t) {
            if(!mp.count(tc)) mp[tc]=c++;
            tt+=mp[tc];
        }
        return ss==tt;
    }
```	


### 624	Maximum Distance in Arrays 	Easy	
locked
### 219	Contains Duplicate II		Easy	
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.
```cpp
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        //using hashmap to store the elements and its index
        unordered_map<int,int> mymap;
        for(int i=0;i<nums.size();i++)
        {
            if(mymap[nums[i]] && i-mymap[nums[i]]<k) return 1;
            mymap[nums[i]]=i+1;
        }
        return 0;
    }
```
	
### 290	Word Pattern		Easy	
very similar to 205, check if the string has the same pattern
convert to the same pattern for both a and b.
```cpp
bool wordPattern(string pattern, string str) {
    map<char, int> p2i;
    map<string, int> w2i;
    istringstream in(str);
    int i = 0, n = pattern.size();
    for (string word; in >> word; ++i) {
        if (i == n || p2i[pattern[i]] != w2i[word])
            return false;
        p2i[pattern[i]] = w2i[word] = i + 1;
    }
    return i == n;
}
```

### 170	Two Sum III - Data structure design 	Easy	
locked

### 204	Count Primes		Easy	
this is a typical problem
```cpp
    int countPrimes(int n) {
        //matlab implementation on primes
        if(n<3) return 0;
        vector<bool> primes(n/2,1); //only store odd numbers, the number=2*k+1
        //note primes[0]=2 instead of 1
        for(int i=3;i<=sqrt(n);i+=2) //only odd factors
        {
            if(primes[(i-1)/2]) 
                for(int j=i*i;j<n;j+=2*i) {primes[(j-1)/2]=0;}
        }
        return accumulate(primes.begin(),primes.end(),0);
    }
```	

## medium
### 535	Encode and Decode TinyURL		Medium	
```cpp
    string dict = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    int id = 0;
    unordered_map m;  //key is longURL, value is shortURL
    unordered_map idm;  //key is id in DB, value is longURL
    // Encodes a URL to a shortened URL.
    string encode(string longUrl) {
        if(m.find(longUrl) != m.end())return m[longUrl];
        string res = "";
        id++;
        int count = id;
        while(count > 0)
        {
            res = dict[count%62] + res;
            count /= 62;
        }
        while(res.size() < 6)
        {
            res = "0" + res;
        }
        m[longUrl] = res;
        idm[id] = longUrl;
        return res;
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl) {
        int id = 0;
        for(int i = 0; i < shortUrl.size(); i++)
        {
            id = 62*id + (int)(dict.find(shortUrl[i]));
        }
        if(idm.find(id) != idm.end())return idm[id];
        return "";
    }
```

### 739	Daily Temperatures		Medium	
Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.

For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].
stack problem
```cpp
    vector<int> dailyTemperatures(vector<int>& T) {
		stack<int> st; //store the index
		for(int i=0;i<T.size();i++)
		{
			while(st.size() && T[i]>T[st.top()])
			{
				int ind=st.top();
				st.pop();
				T[ind]=i-ind;
			}
			st.push(i);
		}
		while(st.size()) T[st.top()]=0,st.pop();
		return T;
    }
```	
### 94	Binary Tree Inorder Traversal		Medium	
see tree

### 311	Sparse Matrix Multiplication 	Medium	
locked
### 451	Sort Characters By Frequency		Medium	
trivial, sort the map pairs with second.
or no sorting put into buckets. upper bound is the string length

### 609	Find Duplicate File in System		Medium	
see string, use content as key in hashmap

### 347	Top K Frequent Elements		Medium	
hashmap and then put into priority_queue

### 508	Most Frequent Subtree Sum		Medium	
see  tree
### 648	Replace Words		Medium	
all words has the prefix is replaced with prefix
use trie
```cpp
struct Node
{
    Node* next[26]; //use pointer is much convenient than using array!
    bool is_leaf;
    Node(bool b=0) {fill(next,next+26,(Node*)0);is_leaf=b;}
};
class Trie {
public:
    /** Initialize your data structure here. */
    Node* root;
    Trie() {
        root=new Node();
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Node* p=root;
        for(int i=0;i<word.size();i++)        
        {
            int ind=word[i]-'a';
            if(p->is_leaf) break;
            if(!p->next[ind]) p->next[ind]=new Node();
            p=p->next[ind];
            
        }
        p->is_leaf=1;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Node* p=find(word);
        return p && p->is_leaf; //has to end with a leaf node
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Node* p=find(prefix);
        return p; //does not have to end with a leaf node
    }
    
    Node* find(string word)
    {
        Node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int ind=word[i]-'a';
            if(p->next[ind]==0) return 0;
            p=p->next[ind];
        }
        return p;
    }
    Node* get_root() {return root;}
};
bool cmp(string& a,string &b) {return a.length()<b.length() || (a.length()==b.length() && a<b);}
class Solution {
public:
    string replaceWords(vector<string>& dict, string sentence) {
        Trie t;
        //sort the dict
        sort(dict.begin(),dict.end(),cmp);
        for(int i=0;i<dict.size();i++) t.insert(dict[i]);
        //split the sentence into vector strings
        string newstr;
        string word;
        Node* root=t.get_root();
        Node* p=root;
        int len=sentence.size();
        for(int i=0;i<len;)
        {
            char c=sentence[i];
            //cout<<i<<" ";
            if(c==' ') //a word is done
            {
                newstr+=word+' ';
                p=root;
                word.clear(); //reset
            }
            else
            {
                if(p->next[c-'a'])
                {
                    word+=c;
                    p=p->next[c-'a'];
                    //cout<<"n";
                }
                else //no match stop here
                {
                    if(p->is_leaf) //matched
                    {
                        //cout<<"m";
                        newstr+=word;
                        //need to jump to next word
                        while(++i<len && sentence[i]!=' ');
                    }
                    else
                    {
                        word+=c;
                        while(++i<len && sentence[i]!=' ') word+=sentence[i];
                        newstr+=word;
                        //cout<<'u';
                    }
                    newstr+=sentence[i];
                    p=root;
                    word.clear();
                }
            }
            i++;
            if(i==len) newstr+=word;
                
        }
        return newstr;
    }
};
```
### 676	Implement Magic Dictionary		Medium	
a list of dictionary words. Given a word and if we modify exactly one letter, it will match
one approach: while we build the dictionary we replace each letter with $ and add into it. when check, we replace each letter with $, any string match then success
or just remove that char.
```cpp
    unordered_map<string,set<string>> mydict;
    MagicDictionary() {
        
    }
    
    /** Build a dictionary through a list of words */
    void buildDict(vector<string> dict) {
        for(int i=0;i<dict.size();i++) 
        {
            for(int j=0;j<dict[i].size();j++)
            {
                string s=dict[i];
                s[j]='$';
                mydict[s].insert(dict[i]);
            }
        }
    }
    
    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */
    bool search(string word) {
        //try replace the word 
        for(int i=0;i<word.size();i++)
        {
            string s=word;
            s[i]='$';
            //if match one
            if(mydict.count(s) && (!mydict[s].count(word) || (mydict[s].size()>1))) return 1;//need check other matches
        }
        return 0;
    }
```
	
### 781	Rabbits in Forest		Medium	
In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.

Return the minimum number of rabbits that could be in the forest.

If x+1 rabbits have same color, then we get x+1 rabbits who all answer x.
now n rabbits answer x.
If n % (x + 1) == 0, we need n / (x + 1) groups of x + 1 rabbits. (different color group)
If n % (x + 1) != 0, we need n / (x + 1) + 1 groups of x + 1 rabbits. 

the number of groups is math.ceil(n / (x + 1)) and it equals to (n + x) / (x + 1) , which is more elegant.

```cpp
    int numRabbits(vector<int>& answers) {
        unordered_map<int, int> c;
        for (int i : answers) c[i]++;
        int res = 0;
        for (auto i : c) res += (i.second + i.first) / (i.first + 1) * (i.first + 1);
        return res;
    }
```
	
### 694	Number of Distinct Islands 	Medium	
locked

### 981	Time Based Key-Value Store		Medium	
Create a timebased key-value store class TimeMap, that supports two operations.

### 1. set(string key, string value, int timestamp)

Stores the key and value, along with the given timestamp.
### 2. get(string key, int timestamp)

Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.
If there are multiple such values, it returns the one with the largest timestamp_prev.
If there are no values, it returns the empty string ("").

```cpp
    unordered_map<string, map<int, string>> m;
    void set(string key, string value, int timestamp) {
      m[key].insert({ timestamp, value });
    }
    string get(string key, int timestamp) {
      auto it = m[key].upper_bound(timestamp);
      return it == m[key].begin() ? "" : prev(it)->second;
    }    
    TimeMap() {
        
    }
```
    
### 454	4Sum II		Medium	
### 4 lists of numbers choose one from each array a+b+c+d=target
reduce 4 into 2
```cpp
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        //approach build a map of A+B
        unordered_map<int,int> sumcount,sumcount2;
        for(int i=0;i<A.size();i++)
        {
            for(int j=0;j<B.size();j++)
                sumcount[A[i]+B[j]]++;
        }
        for(int i=0;i<C.size();i++)
        {
            for(int j=0;j<D.size();j++)
                sumcount2[-C[i]-D[j]]++;
        }

        int res=0;
        for(auto it=sumcount.begin();it!=sumcount.end();it++)
        {
            if(sumcount2.count(it->first))
                res+=it->second*sumcount2[it->first];
        }
        return res;
    }
```
	

### 939	Minimum Area Rectangle		Medium	
the rectangle parallels to the axis xy
step 1: group points using x coordinate, y sorted
step 2: iterate to see current x can form a rectangle with previous x (has a same y)
step 3: get the y intersect
step 4: compare the min rect area.

```cpp
    int minAreaRect(vector<vector<int>>& points) {
        //sort(points.begin(),points.end(),comp);
        map<int,set<int>> mp;
        for(int i=0;i<points.size();i++) mp[points[i][0]].insert(points[i][1]);
        auto it=mp.begin();
        it++;
        int minarea=INT_MAX;
        for(;it!=mp.end();it++)
        {
            //check if it can form any rectangle with previous x
            int x=it->first;
            for(auto it1=mp.begin();it1!=it;it1++)
            {
                if(it1->second.size()<2) continue; //must have at least two y points
                vector<int> intersect;
                int x1=it1->first;
                //set_intersection(mp[x].begin(),mp[x].end,mp[x1].begin(),mp[x1].end(),back_inserter(intersect));
                for(auto it2=mp[x].begin();it2!=mp[x].end();it2++)
                    if(mp[x1].count(*it2)) intersect.push_back(*it2);
                if(intersect.size()<2) continue;
                //choose the min delta from the set
                sort(intersect.begin(),intersect.end());
                int mindy=intersect[1]-intersect[0];
                for(int i=2;i<intersect.size();i++) mindy=min(mindy,intersect[i]-intersect[i-1]);
                minarea=min(minarea,(x-x1)*mindy);
            }
        }
        return minarea==INT_MAX?0:minarea;
    }
```	
### 249	Group Shifted Strings 	Medium	
locked
### 554	Brick Wall		Medium	
There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks.

The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.

If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.

this is a interval problem.
we store all the junction position in hashmap. position vs occurance.
we get the most common junctions
note the last one does not count.

```cpp
    int leastBricks(vector<vector<int>>& wall) {
        //we save all the junctions for each layer in map
        unordered_map<int,int> mp;
        int maxcomm=0;
        for(int i=0;i<wall.size();i++)
        {
            for(int j=0;j<wall[i].size()-1;j++) //2 does not work
            {
                if(j) wall[i][j]+=wall[i][j-1];
                mp[wall[i][j]]++;
                maxcomm=max(maxcomm,mp[wall[i][j]]);
            }
        }
        return wall.size()-maxcomm;
    }
```	
### 244	Shortest Word Distance II 	Medium	
locked
### 49	Group Anagrams		Medium	
sorted as the key

### 718	Maximum Length of Repeated Subarray		Medium	
similar to longest common substr
dp
```cpp
    int findLength(vector<int>& A, vector<int>& B) {
        //longest common substring
        int m=A.size(),n=B.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1)); 
        //dp[i, j] represents the longest common subarray between A[0..i-1] and B[0...j-1] 
        //boundary: dp[0][0]=0, 0th row and 0th column all zero
        int max0=0;
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(A[i-1]==B[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                //else dp[i][j]=0;
                max0=max(max0,dp[i][j]);
            }
        }
        return max0;
    }
```	

### 692	Top K Frequent Words		Medium	
Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.
can approached using trie, node add frequency
hashmap with pq is more straightforward
```cpp
struct cmp
{
   bool operator()(const pair<string,int>&a, const pair<string,int>& b)  
   {
       return a.second<b.second ||(a.second==b.second && a.first>b.first);
   }
};
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        //calculate histogram of each words and sort these words
        unordered_map<string,int> wmap;
        for(int i=0;i<words.size();i++) wmap[words[i]]++;
        priority_queue<pair<string,int>,vector<pair<string,int>>,cmp> pq(wmap.begin(),wmap.end());
        vector<string> vs(k);
        for(int i=0;i<k;i++) {vs[i]=pq.top().first;pq.pop();}
        return vs;
    }
};
```

### 325	Maximum Size Subarray Sum Equals k 	Medium	

	
### 974	Subarray Sums Divisible by K		Medium	
hashmap to record the remainder or not using hashmap
```cpp
    int subarraysDivByK(vector<int>& A, int K) {
        A[0]=(A[0]%K+K)%K;
        for(int i=1;i<A.size();i++) 
        {
            A[i]+=A[i-1];
            A[i]=(A[i]%K+K)%K;
        }
        //copy(A.begin(),A.end(),ostream_iterator<int>(cout," "));
        sort(A.begin(),A.end());
        
        int ans=0,cnt=0;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]==0) ans++;
            if(i && A[i]==A[i-1]) cnt++,ans+=cnt;
            else cnt=0;
        }
        return ans;
    }
```
### 36	Valid Sudoku		Medium	
each row, each colum, each 3x3 subbox, contains 1-9 exactly once
check if not used, then use it.
```cpp
    bool isValidSudoku(vector<vector<char>>& board) {
        int size=board.size();
        //row, col, and 3x3 subgrid needs to be checked
        vector<int> rcount(size,0);
        vector<int> ccount(size,0);
        vector<int> gridcount(size,0);
        
        for(int r=0;r<size;r++)
        {
            for(int c=0;c<size;c++)
            {
                char mc=board[r][c];
                if(mc!='.')
                {
                    //9bits to record the number filled
                    //first check if the number is already used
                    int n=mc-'0';
                    int gridnum=r/3*3+c/3; //
                    if(get_bit(rcount[r],n) || get_bit(ccount[c],n) || get_bit(gridcount[gridnum],n))
						return 0;
                    set_bit(rcount[r],n);
                    set_bit(ccount[c],n);
                    set_bit(gridcount[gridnum],n);
                }
            }
        }
        return 1;
    }
    void set_bit(int& mask,int n)
    {
        mask |= 1<<n;
    }
    int get_bit(int mask,int n)
    {
        return mask & (1<<n);
    }
```	
### 380	Insert Delete GetRandom O(1)		Medium	
see design
### 525	Contiguous Array		Medium	
Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.
approach: consider it as -1 1 series, accumulate sum would be the same if between range sum is 0
store the sum vs the index.
```cpp
int findMaxLength(vector<int>& nums) {
    //approach: convert to -1 1 series, if the sum is the same as before, it is the length, cumsum!
    map<int, int> myMap;
    map<int, int>::iterator it;
    int sum = 0;
    int maxLen = 0;
    myMap[0] = -1;
    for (int i = 0; i < nums.size(); i++)
    {
        sum += (nums[i] == 0) ? -1 : 1;
        it = myMap.find(sum); 
        if (it != myMap.end())
            maxLen = max(maxLen, i - it->second);
        else
            myMap[sum] = i;
    }
    return maxLen;
}
```

### 560	Subarray Sum Equals K		Medium	
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.
```cpp
    int subarraySum(vector<int>& nums, int k) {
        int cum=0; // cumulated sum
        map<int,int> rec; // prefix sum recorder
        int cnt = 0; // number of found subarray
        rec[0]++; // to take into account those subarrays that begin with index 0
        for(int i=0;i<nums.size();i++){
            cum += nums[i];
            cnt += rec[cum-k];
            rec[cum]++;
        }
        return cnt;
    }
```	
### 966	Vowel Spellchecker		Medium	
see string

### 314	Binary Tree Vertical Order Traversal 	Medium	
see tree

### 299	Bulls and Cows		Medium	
You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.

Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. 

Please note that both secret number and friend's guess may contain duplicate digits.

note matched shall be subtracted.

```cpp
    string getHint(string secret, string guess) {
        //strategy: 
        //all numbers 0-9
        //count each number occurance in secret
        //if the number matches position and number, ++, corresponding occurance -- (cannot count twice)
        //calculate the number matches cases
        int count[10]={0};
        int count_a=0,count_b=0;
        for(int i=0;i<secret.size();i++) count[secret[i]-'0']++;
        //one interesting case 1122, 1222, the second one will increase count_b, but it is incorrect!!!
        for(int i=0;i<guess.size();i++)
        {
            if(secret[i]==guess[i]) 
			{
				count_a++;
				count[secret[i]-'0']--;
				if(count[secret[i]-'0']<0) count_b--;
			} //match number and position
            else if(count[guess[i]-'0']>0) 
			{
				count_b++;
				count[guess[i]-'0']--;
			} //only has the number, but position incorrect
        }
        return to_string(count_a)+"A"+to_string(count_b)+"B";
    }
```	
### 957	Prison Cells After N Days		Medium	
There are 8 prison cells in a row, and each cell is either occupied or vacant.

Each day, whether the cell is occupied or vacant changes according to the following rules:

If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.
Otherwise, it becomes vacant.
(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)

We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.

Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)

cycle detection using hashmap
```cpp
    vector<int> prisonAfterNDays(vector<int>& cells, int N) {
        //neigboring 0,0=>1 1,1=>0, otherwise =>0
        int n=cells.size();
        unordered_map<int,int> status;
        vector<int> curr(n);
        int period;
        for(int i=1;i<=N;)
        {
            int res=0;
            for(int j=1;j<n-1;j++)
            {
                int t=cells[j-1]+cells[j+1];
                curr[j]=t==1?0:1;
                res+=(curr[j]<<j);
            }
            if(status.count(res)) //we have a repeat pattern
            {
                period=i-status[res];
                int nskip=(N-i)/period*period;
                i+=nskip;
                i++;
            }
            else {status[res]=i;i++;}
            cells=curr;
        }
        return cells;
    }
```
	
### 930	Binary Subarrays With Sum		Medium	
In an array A of 0s and 1s, how many non-empty subarrays have sum S?
a window covering S 1s and calculate the front and after range to move (all 0 which can move freely)

```cpp
    int numSubarraysWithSum(vector<int>& A, int S) {
        //first need moving the window to contain S number of 1s
        vector<int> ones;
        ones.push_back(-1);
        for(int i=0;i<A.size();i++) if(A[i]) ones.push_back(i);
        ones.push_back(A.size());
        //if(ones.size()==2 && S==0)  return A.size()*(A.size()+1)/2;
        int ans=0;
        //does not work with all zeros
        for(int i=1;i<ones.size()-S;i++)
        {
            int front=0,after=0;
            front=ones[i]-ones[i-1];
            after=ones[i+S]-ones[i+S-1];
            //cout<<front<<" "<<after<<endl;
            if(S) ans+=front*after;
            else ans+=(front-1)*front/2;
        }
        return ans;
    }
```	
### 187	Repeated DNA Sequences		Medium	
All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

this uses direct hash for string.
### 10 chars may be able to hold in a integer
sliding window hash calculation

```cpp
    vector<string> findRepeatedDnaSequences(string s) {
        //approach: the 10 char string as key cost too much memory, need some manipulation
        //if it used as a 0 1 2 3, the maximum would be 10 digits, which needs unsigned int
        //linear scan
        //actually no counter is needed, so map is not needed
        vector<string> res;
        if(s.size()<11) return res;
        unordered_map<unsigned int,int> mp; 
        unsigned int num0=str2num(s);
        mp[num0]++;
        //mp.insert(num0);
        
        const unsigned int myconst=1000000000;
        for(int i=1;i<s.size()-9;i++)
        {
            char c=s[i+9];
            int digit=0;
            switch(c)
            {
                case 'C':digit=1;break;
                case 'G':digit=2;break;
                case 'T':digit=3;break;
            }
            num0=(num0%myconst)*10+digit;
            if(!mp.count(num0)) mp[num0]++;//mp.insert(num0);
            else
            {   
                mp[num0]++;
                if(mp[num0]==2)
                res.push_back(s.substr(i,10)); //cannot output same string multiple times
                
            }
        }
        return res;
        
    }
    unsigned int str2num(const string& s)
    {
        //10 chars only
        unsigned int res=0;
        for(int i=0;i<10;i++)
        {
            char c=s[i];
            int a=0;
            switch(c)
            {
                case 'A': a=0;break;
                case 'C': a=1;break;
                case 'G': a=2;break;
                case 'T': a=3;break;
            }
            res=res*10+a;
        }
        return res;
    }
```
	

### 274	H-Index		Medium	
### 954	Array of Doubled Pairs		Medium	
negative and positive shall be separated to treat, otherwise will cause problem
```cpp
    bool canReorderDoubled(vector<int>& A) {
        multiset<int> pos,neg;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]>=0) pos.insert(A[i]);
            else neg.insert(-A[i]);
        }
        if(pos.size()%2 || neg.size()%2) return 0;
        return checkpairs(pos) && checkpairs(neg);
     }
    bool checkpairs(multiset<int> ms)
    {
        auto it=ms.begin();
        while(ms.size())
        {
            it=ms.begin();
            auto it1=ms.upper_bound((*it)*2);
            --it1;
            if(it1!=ms.begin() && *it1==*it*2)
            {
                ms.erase(it1);
                ms.erase(ms.begin());
            }
            else return 0;
            
        }
        return 1;        
    }
```
	
### 987	Vertical Order Traversal of a Binary Tree		Medium	
see tree
### 356	Line Reflection 	Medium	
locked
### 18	4Sum		Medium	
two pointer or array
O(N^3)
```cpp
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> total;
        int n = nums.size();
        if(n<4)  return total;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n-3;i++)
        {
            if(i>0&&nums[i]==nums[i-1]) continue;
            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;
            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;
            for(int j=i+1;j<n-2;j++)
            {
                if(j>i+1&&nums[j]==nums[j-1]) continue;
                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;
                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;
                int left=j+1,right=n-1;
                while(left<right){
                    int sum=nums[left]+nums[right]+nums[i]+nums[j];
                    if(sum<target) left++;
                    else if(sum>target) right--;
                    else{
                        total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        do{left++;}while(nums[left]==nums[left-1]&&left<right);
                        do{right--;}while(nums[right]==nums[right+1]&&left<right);
                    }
                }
            }
        }
        return total;
    }
```
	
### 3	Longest Substring Without Repeating Characters		Medium	
Given a string, find the length of the longest substring without repeating characters.
this is a highly rated question.
```cpp
int lengthOfLongestSubstring(string s) {
        vector<int> dict(256, -1); //char vs the index
        int maxLen = 0, start = -1;
        for (int i = 0; i != s.length(); i++) {
            if (dict[s[i]] > start) //dict returns >=0 so it supports the first and check if contains
                start = dict[s[i]];
            dict[s[i]] = i;
            maxLen = max(maxLen, i - start);
        }
        return maxLen;
    }
```

### 355	Design Twitter		Medium	
see design

### 138	Copy List with Random Pointer		Medium	
similar to clone graph id to node and node to id
```cpp
    Node* copyRandomList(Node* head) {
        //hashmap to save the node 
        unordered_map<Node*,int> nodeid;
        unordered_map<int,Node*> idnode;
        Node* p=head;
        int id=0;
        while(p)
        {
            nodeid[p]=id++;
            p=p->next;
        }
        p=head;
        Node* newhead=0,*pnode=0;
        id=0;
        while(p)
        {
            Node* tmp=new Node(p->val,NULL,NULL);
            if(!newhead) pnode=newhead=tmp;
            else {pnode->next=tmp;pnode=pnode->next;}
            idnode[id++]=tmp;
            p=p->next;
            //pnode=pnode->next;
        }
        //cout<<"OK"<<endl;
        p=head,pnode=newhead;
        while(p)
        {
            int id;
            if(p->random==0) pnode->random=0;
            else
            {
                id=nodeid[p->random];
                pnode->random=idnode[id];
            }
            p=p->next,pnode=pnode->next;
        }
        return newhead;
    }
```
	

### 288	Unique Word Abbreviation 	Medium	
locked

### 166	Fraction to Recurring Decimal		Medium	
see math

## hard

### 895	Maximum Frequency Stack		Hard	
see stack, a very interesting problem

### 632	Smallest Range		Hard	
merge sort process, see string

### 159	Longest Substring with At Most Two Distinct Characters 	Hard	
locked
### 711	Number of Distinct Islands II 	Hard	
locked
### 770	Basic Calculator IV		Hard	

### 992	Subarrays with K Different Integers		Hard	
Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.

(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)

Return the number of good subarrays of A.

approach:
use three pointers, i for the left most, j for the mid, k for the right.
we maintain a hashmap to record the counters in the window
j to k is the smallest window containing k types of characters
i to k is the largest window containing k types of characters
when window contains more chars, we discard A[j] and move i and j to j+1
we keep shrinking [j,k] to make sure j k is the narrowest range.

```cpp
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int ans=0;
        int i=0,j=0,k=0;//use 3 pointers, i, j for the two left i<j
        unordered_map<int,int> mp; //number vs the occurance
        while(k<A.size())
        {
            mp[A[k]]++;
            if(mp.size()>K) {i=j+1;mp.erase(A[j]);} //A[k] must be different from A[j] so remove A[j] will make it K again
            if(j<i) j=i;
            if(mp.size()==K) 
            {
                while(mp[A[j]]>1) //we make sure the narrowest range [j, k]. the leftmost only has one.
				{
					mp[A[j]]--;
					if(mp[A[j]]==0) mp.erase(A[j]);
					j++;
				}
                ans+=j-i+1;
            }

            k++;
        }
        return ans;
    }
```	
for example [1,2,1,2,3] with k=2
i=0,j=0,k=0, we had 1:1
i=0,j=0,k=1, we had 1:1, 2:1, we found [1,2]
i=0,j=0,k=2, we had 1:2, 2:1, so we move j to 1, i=0,j=1,k=2 we had [2,1] and [1,2,1]
i=0,j=1,k=3, we had 1:1, 2:2, so we move j to 2, i=0,j=2,k=3, we had [1,2], [2,1,2],[1,2,1,2]
....

### 726	Number of Atoms		Hard	
chemical formula, output the atoms and counts in sorted order (by the atom name)
for example: "K4(ON(SO3)2)2"
save K:4 in stack
save O:1 N:1 in stack
save S:1 O:3 in stack
pop stack and *2
pop stack and *2
pop stack and *1

using a stack and recursive could be the possible way.
straightforward and easy to understand.
```cpp
    string countOfAtoms(string formula) {
		stack<map<string,int>> st;
		map<string,int> mp;
		int i=0,n=formula.size();
		while(i<n)
		{
			char c=formula[i++];
			if(c=='(') //( starting a stack
			{
				st.push(mp);//save previous result in stack
				mp.clear();
			}
			else if(c==')') //read the digits and perform multiply
			{
				int val=0;
				while(i<n && isdigit(formula[i])) val=val*10+formula[i++]-'0';
				if(!val) val=1;
				if(!st.empty())
				{
					map<string,int> mp0=st.top(); //t is a map
					st.pop();
                    //merge the two maps
					for(auto tt: mp) 
                        mp0[tt.first]+=tt.second*val;
                    mp=mp0;
				}
			}
			else //letters
			{
                
				int start=i-1;//since we perform i++ already
				while(i<n && islower(formula[i])) i++;
				string s=formula.substr(start,i-start);
                int val=0;
				while(i<n && isdigit(formula[i])) val=val*10+formula[i++]-'0';
				if(!val) val=1;
				mp[s]+=val;
			}
		}
		string ans;
		for(auto tt: mp)
		{
            ans+=tt.first;
            if(tt.second>1) ans+=to_string(tt.second);
		}
		return ans;
	}
```	
	
approach: top down method
step1: assuming we can solve the string from 0 and return a map of atom name vs its counter, then we know the answer.
step2: solve the problem with formula starting at index i and return a map<string,int>.  and we merge the result with previous
step3: 

```cpp
    string countOfAtoms(string formula) {
        string output;
        const int n = formula.size();
        int i = 0;
        map<string, int> counts = parseFormula(formula, i);
        for (pair<string, int> p : counts) 
        {
            output += p.first;
            if (p.second > 1) output += to_string(p.second);
        }
        return output;
    }

    //starting index use i as reference
    map<string, int> parseFormula(string& s, int& i) 
    {
        map<string, int> counts;
        const int n = s.size();
        while (i < n && s[i] != ')') 
        {
            map<string, int> cnts = parseUnit(s, i);
            merge(counts, cnts, 1);
        }
        return counts;
    }

    map<string, int> parseUnit(string& s, int& i) {
        map<string, int> counts;
        const int n = s.size();
        if (s[i] == '(') 
        {
            map<string, int> cnts = parseFormula(s, ++i); // ++i for '('
            int digits = parseDigits(s, ++i); // ++i for ')'
            merge(counts, cnts, digits);
        }
        else 
        {
            int i0 = i++; // first letter
            while (i < n && islower(s[i])) { i++; }
            string atom = s.substr(i0, i - i0);
            int digits = parseDigits(s, i);
            counts[atom] += digits;
        }
        return counts;
    }

    int parseDigits(string& s, int& i) 
    {
        int i1 = i;
        while (i < s.size() && isdigit(s[i])) { i++; }
        int digits = i == i1 ? 1 : stoi(s.substr(i1, i - i1));
        return digits;
    }

    void merge(map<string, int>& counts, map<string, int>& cnts, int times) 
    {
        for (pair<string, int> p : cnts) counts[p.first] += p.second * times;
    }
```	

### 340	Longest Substring with At Most K Distinct Characters 	Hard	
locked

### 37	Sudoku Solver		Hard	
each number has a row, col, and a grid. so first we need to exclude those impossibles
first solve those only one solution and keeps updating.
can use a 9 bit to indicate the status
straightforward backtracking solution
just try to put 1 to 9 for each cell and check if it is valid
```cpp
    void solveSudoku(vector<vector<char>>& board) {
		if(board.size()==0) return;
		solve(board);
    }
	bool solve(vector<vector<char>>& b)
	{
		int m=b.size(),n=b[0].size();
		for(int i=0;i<m;i++)
		{
			for(int j=0;j<n;j++)
			{
				if(b[i][j]=='.')
				{
					for(char c='1';c<='9';c++)
					{
						if(isValid(b,i,j,c))
						{
							b[i][j]=c;
							if(solve(b)) return 1;
							else b[i][j]='.';
						}
					}
				}
			}
        }
		return 0;
	}
	bool isValid(vector<vector<char>>& b,int row,int col,char c)
	{
		for(int i=0;i<9;i++)
		{
			if(b[i][col]!='.' && b[i][col]==c) return 0;
			if(b[row][i]!='.' && b[row][i]==c) return 0;
			int r0=3*(row/3)+i/3,c0=3*(col/3)+i%3;
			if(b[r0][c0]!='.' && b[r0][c0]==c) return 0;
		}
		return 1;
	}
```	
complexity O(9^n), n is number of blanks to fill.
although we can use hashmap to store row, col, and grid, we may reduce from 9 to like 4 or 5

improvements: use bits to record row, col and 3x3 grid.

### 1001	Grid Illumination		Hard	
On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 0 <= y < N has a lamp.

Initially, some number of lamps are on.  lamps[i] tells us the location of the i-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).

For the i-th query queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0.

After each query (x, y) [in the order given by queries], we turn off any lamps that are at cell (x, y) or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).)

Return an array of answers.  Each value answer[i] should be equal to the answer of the i-th query queries[i].

We use a hash map to record number of occurance of row, col, diag1 and diag2 diag1: r-c=const diag2: r+c=const each query will minus the row, col, diag1 and diag2 by 1

```cpp
    vector<int> gridIllumination(int N, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        unordered_map<int,int> rset,cset,diagset1,diagset2;
        unordered_set<string> lset;
        for(int i=0;i<lamps.size();i++)
        {
            int r=lamps[i][0],c=lamps[i][1];
            rset[r]++;cset[c]++;diagset1[r-c]++;diagset2[r+c]++;
            lset.insert(to_string(r)+","+to_string(c));
        }
        vector<int> ans;
        for(int i=0;i<queries.size();i++)
        {
            ans.push_back(query(N,queries[i][0],queries[i][1],rset,cset,diagset1,diagset2,lset));
        }
        return ans;
    }
  int query(int n,int r,int c,unordered_map<int,int>& rset,
            unordered_map<int,int>& cset,
            unordered_map<int,int>& dset1,
            unordered_map<int,int>& dset2,
            unordered_set<string>& lset)
  {
  //for i,j, row i and col j, diag1 r-c=i-j, diag2: r+c=i+j     
      int ans=rset.count(r) || cset.count(c) || dset1.count(r-c) || dset2.count(r+c);
      for(int i=-1;i<=1;i++)
      {
          for(int j=-1;j<=1;j++)
          {
              if(r+i<0 || r+i>=n || c+j<0 || c+j>=n) continue;
              int rr=r+i,cc=c+j;
              string s=to_string(r+i)+","+to_string(c+j);
              if(lset.count(s))
              {
                  lset.erase(s);
                  rset[rr]--;if(rset[rr]==0) rset.erase(rr);
                  cset[cc]--;if(cset[cc]==0) cset.erase(cc);
                  dset1[rr-cc]--;if(dset1[rr-cc]==0) dset1.erase(rr-cc);
                  dset2[rr+cc]--;if(dset2[rr+cc]==0) dset2.erase(rr+cc);
              }
          }
      }
      return ans;      
  }
```  
### 85	Maximal Rectangle		Hard	
see maximal histogram

### 358	Rearrange String k Distance Apart 	Hard	
locked

### 381	Insert Delete GetRandom O(1) - Duplicates allowed		Hard	
see design

### 710	Random Pick with Blacklist		Hard	
Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B.

Optimize it such that it minimizes the call to systems Math.random().

Note:

1 <= N <= 1000000000
0 <= B.length < min(100000, N)
[0, N) does NOT include N. See interval notation.

```cpp
    vector<int> bl;
    std::default_random_engine generator;
    std::uniform_int_distribution<int> distribution;
public:
    Solution(int N, vector<int> blacklist)
    {
        swap(bl, blacklist);
        sort(bl.begin(), bl.end());
        for (int i = 0, e = bl.size(); i < e; ++i)
            bl[i] -= i;
        
        distribution = std::uniform_int_distribution<int>(0, N - 1 - bl.size());
    }
    
    int pick() {
        auto r = distribution(generator);
        return r + (upper_bound(bl.begin(), bl.end(), r) - bl.begin());
    }
```
c++11 random generator engine, the c rand() generates 0 to 32767 random numbers.
Let's say sorted array M is the all valid numbers, and X is the actual generated random number. Duo to blacklist, it's index in M may be less. e.g.,
N = 7, B = [1, 4, 6], then M = [0, 2, 3, 5]. if X == 2, its index is 1 duo to 1 is black listed; if X is 5, its index is 3, duo to both 1 and 4 are black listed. However if X is 0, its index is still 0 has no blacklist number. Here, we know, the difference = X - its index == how many blacklist number <= X.
Now, use bl[i] to represent the index where it's reduced by i. After generate a random number as the index, add the difference back (using binary search, get the index in bl[] where first greater than the generated number), it's the actual answer.

### 336	Palindrome Pairs		Hard	
Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.
brutal force
```cpp
    vector<vector<int>> palindromePairs(vector<string>& words) {
        //brutal force approach: 
        vector<vector<int>> res;
        vector<int> item(2);
        for(int i=0;i<words.size();i++)
        {
            for(int j=0;j<words.size();j++)
            {
                if(i==j) continue;
                if(is_palindrome(words[i],words[j]))
                {
                    item[0]=i;item[1]=j;
                    res.push_back(item);
                }
            }
        }
        return res;
    }
    bool is_palindrome(const string& a, const string& b)
    {
        //concat a and b, however avoid make a string
        int la=a.size(),lb=b.size();
        int len=la+lb;
        int mid=len/2;
        for(int i=0;i<mid;i++)
        {
            //compare i and len-1-i
            char c,d;
            int j=len-1-i;
            c=(i<la)?a[i]:b[i-la];
            d=(j<la)?a[j]:b[j-la];
            if(c!=d) return 0;
        }
        return 1;
    }
```
can also be approached using trie.
check endwith (reverse)
we also need store extra information in the trie, for example the index of the word.
a list of index integers.

### 76	Minimum Window Substring		Hard	
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
sliding window using two pointers
```cpp
string minWindow(string s, string t) {
	unordered_map<char, int> mp;	// Statistic for count of char in t
	for (auto c : t) mp[c]++;
	// counter represents the number of chars of t to be found in s.
	int start = 0, end = 0, minStart = 0, minLen = INT_MAX;
	int slen = s.size(),tlen = t.size();
		
	while (end<slen) // Move end to find a valid window.
    {
		if (mp[s[end]]>0) tlen--;// If char in s exists in t, decrease counter
		mp[s[end]]--;// Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.
		end++;
		
		while (tlen == 0) // When we found a valid window, move start to find smaller window.
        {
			if(end-start<minLen) 
            {
				minStart=start;
				minLen=end-start;
			}
			mp[s[start]]++;
			
			if (mp[s[start]]>0) tlen++;// When char exists in t, increase counter.
			start++;
		}
	}
	if (minLen != INT_MAX)return s.substr(minStart, minLen);
	return "";
    }
```
	
### 30	Substring with Concatenation of All Words		Hard	
see string

### 1044 Longest Duplicate Substring		Hard
see string
	
### 149	Max Points on a Line		Hard	
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.
see math
