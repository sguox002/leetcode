### Problem Summary
Given a x, and use +-*/ to reach a target, with not using ().
Get the least number of operators

### approach
I have not get any solution on this. 
- / is rational divide and we can only get x/x
- any * is used to get x^n (using n *) and x/x can be considered x^0
- + is to combine the result for all the x^n
- - is a bit harder. 

A number can be composed sum(x^i) with 0 or 1 as the coefficient, which is the binary representation of an integer. 
for x-ary base, the coefficient could be from 0 to x-1.

It's obvious that the expression should be
C0*x^0 + C1*x^1 + ... + Cn*x^n
And there is only one way to get x^0 by x / x, and it's the only use for divide operation.
Then regard target as a x base number(for example, the 3 base form of 19 is 201)

So:
Consider about generating parts[i]*x^i, you can get it by two ways (you will never generate parts[i] * x^i by some expression other than x^i):
x^i + x^i + ... + x^i (parts[i] times)
x^(i+1) - x^i - x^i - ... - x^i (x - parts[i] times).

Thinking the problem using x-base problem is the key!

As a concrete example, say x = 5, target = 123. We either add 2 or subtract 3. This leaves us with a target of 120 or 125. If the target is 120, we can either add 5 or subtract 20, leaving us with a target of 100 or 125. If the target is 100, we can either add 25 or subtract 100, leaving us with a target of 125 or 0. If the target is 125, we subtract 125.

dp approach: dp[i, target]: i is the exponential, target is the target to solve.

we first calculate all the digits, add a 0 in the end since we may carry a flag (using subtract)
AiX^i: it needs Ai*i operators if using positive way
X^(i+1)-(X-Ai)X^i: if we process as negative,
If previous is pos, then it is i*Ai+pos[i-1]
if previous is neg, then it is i*Ai+neg[i-1]+i (there is a carry over)

If we use negative for current:
- we send a carry over to i+1
- current operators (x-Ai)*i
- if previous is positive, there is no carry over, (x-Ai)*i+pos[i-1]
- if previous is negative, there is a carry over, (x-Ai-1)*i+neg[i-1]

so the solution could be as below:
```cpp
    int leastOpsExpressTarget(int x, int target) {
        //dp: x-ary number to use least operations
        //n=sum(Ai*X^i) to use less operator need to compare x^(i+1) and x^i
        vector<int> digits;
        while(target) {digits.push_back(target%x);target/=x;}
        
        int n=digits.size();
        digits.push_back(0);//could add a carrier flag before the MSB
        vector<int> pos(n+1),neg(n+1);
        pos[0]=digits[0]*2;
        neg[0]=(x-digits[0])*2; //x^0=x/x use more operations
        for(int i=1;i<=n;i++)
        {
            //if use neg, we have a carrier flag to i
            //Aix^i: add Ai times, each with i multplication
            pos[i]=digits[i]*i+min(pos[i-1],neg[i-1]+i); 
            //AiX^i=x^(i+1)-(x-Ai)x^i
            neg[i]=min((x-digits[i])*i+pos[i-1],(x-digits[i]-1)*i+neg[i-1]);
        }
        return min(pos[n],neg[n])-1;
    }
```

Note:
- the boundary needs *2 since it can only be obtained x/x
- final result needs -1

