### Problem Summary
There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones.

A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.

### Analysis
1. K>1. other K has no solution
2. each time k piles reduce to 1 pile. so the number of pile must be able to divide by k-1
3. this is very similar to the burst balloon problem which is a typical dp problem.
assuming we choose ith element as the start, k is the length, it divides the left and right part. 
However, the subproblem needs cross the mid element. 
Similarly to the solution in burst balloon, we can think it in reversed way:
assuming starting i and ending j elements (some elements are already used) are the last action to merge

dp[l][i] represents the minimal cost to merge the piles in interval [i,i+l), here, we merge piles as much as possible. 
So, when l < 1+(K-1), we don't merge any piles, so dp[i][i+l] = 0; 
when 1+(K-1) <= l < 1+2(K - 1), we merge once; 
when 1+2(K-1) <= l < 1+3(K-1), we merge twice, and so on so forth.
Let's see for a certain interval length l, how can we get dp[l][i]. 
After all mergings, if we consider the leftmost pile in interval [i,i+l), then the status of this pile will show as below:

No merging happens in this pile, so it contains 1 original pile, let k = 1, then the cost is dp[k][i]+dp[l-k][i+k].
One merging happens in this pile, so it contains 1+(K-1) original piles, let k = 1+(K-1), then the cost is dp[k][i]+dp[l-k][i+k].
Two mergings happen in this pile, so it contains 1+2(K-1) original piles, let k = 1+2(K-1), then the cost is dp[k][i]+dp[l-k][i+k].
.......
When (l-1) mod (K-1)==0, we can see all piles in interval [i,i+l) can be finally merged into one pile, and the cost of the last merging is sum(stones[j]) for j in [i,i+l), regardless of the merging choices before the last one. And this "last cost" happens if and only if (l-1) mod (K-1)==0

```cpp
int mergeStones(vector<int>& stones, int K)
{
    int N = (int)stones.size();
    if((N - 1) % (K - 1)) return -1;
    
    vector<int> sum(N + 1, 0);
    for(int i = 0; i < N; i++) sum[i + 1] = sum[i] + stones[i];
    
    vector<vector<int> > dp(N + 1, vector<int>(N, 0));
    for(int l = K; l <= N; l++) //length
        for(int i = 0; i + l <= N; i++) //start position
        {
            dp[l][i] = 10000;
            for(int k = 1; k < l; k += K - 1) //
                dp[l][i] = min(dp[l][i], dp[k][i] + dp[l - k][i + k]);
            if((l - 1) % (K - 1) == 0) dp[l][i] += sum[i + l] - sum[i];
        }
    return dp[N][0];
}
```

The solution is hard to comprehend. k=1, 1+(K-1), 1+2*(K-1)....., we are looking for the min cost among all these possible choices:
dp[1+m*(k-1)][i] means the cost for the case where the left part can be merged to one pile at i (l-1)%(k-1)==0
dp[l-k][i+k] is the cost for the right part solution (merge to the left pile at i+k)
dp[l][i] then is the last merge where i to 1+m*(K-1) are all original piles (which is similar to the approach used in the burst balloon)

why we add the (l-1)%(K-1)==0 case? i.e l=1+m*(K-1) (the above loop does not finish the last merge) and the last merge is fixed.
so the approach is considering the subproblem starting at i with length l as the last step of merging.
