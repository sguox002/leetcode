a selection of problems
according to difficulty:
dp, greedy, tree, stack
heap, trie, graph
dfs, bfs, recursive, backtrack
hashmap, string, array, union-find

we are not covering math.


dp:
dp problem generally is hard if we cannot think it clear. The overlapping problems we need try dp first.
we need build intuition to commonly seen type of problems.

# familiar
70	Climbing Stairs	44.8%	Easy	
198	House Robber	41.2%	Easy	
121	Best Time to Buy and Sell Stock	48.0%	Easy	
338	Counting Bits	65.4%	Medium	
120	Triangle	40.4%	Medium	
64	Minimum Path Sum	48.1%	Medium	
62	Unique Paths	48.7%	Medium	
123	Best Time to Buy and Sell Stock III	34.5%	Hard	
303	Range Sum Query - Immutable	39.2%	Easy	
309	Best Time to Buy and Sell Stock with Cooldown	44.6%	Medium	
188	Best Time to Buy and Sell Stock IV	26.7%	Hard	
91	Decode Ways	22.7%	Medium	
264	Ugly Number II	37.1%	Medium	
746	Min Cost Climbing Stairs	48.0%	Easy	
714	Best Time to Buy and Sell Stock with Transaction Fee	51.2%	Medium	
213	House Robber II	35.5%	Medium	
63	Unique Paths II	33.6%	Medium	
931	Minimum Falling Path Sum	59.1%	Medium	
639	Decode Ways II	25.5%	Hard	
688	Knight Probability in Chessboard	45.3%	Medium	
935	Knight Dialer	41.8%	Medium	
351	Android Unlock Patterns 46.5%	Medium	
960	Delete Columns to Make Sorted III	53.3%	Hard	
576	Out of Boundary Paths	32.7%	Medium	
87	Scramble String	32.0%	Hard	
808	Soup Servings	38.0%	Medium	

# non-dp is more suitable:
410	Split Array Largest Sum	42.8%	Hard	-binary search
718	Maximum Length of Repeated Subarray	46.9%	Medium	 - binary search
698	Partition to K Equal Sum Subsets	43.2%	Medium	- backtrack
321	Create Maximum Number	25.8%	Hard	-greedy
1025 Divisor Game	64.3%	Easy	- greedy
392	Is Subsequence	47.4%	Easy	- greedy, two pointer
689	Maximum Sum of 3 Non-Overlapping Subarrays	44.3%	Hard	- two pointer
968	Binary Tree Cameras	35.7%	Hard	-greedy
1147	Longest Chunked Palindrome Decomposition	58.7%	Hard	-greedy
418	Sentence Screen Fitting 31.3%	Medium	-two pointer
1136	Parallel Courses 59.5%	Hard	-bfs
32	Longest Valid Parentheses	26.1%	Hard	-stack
523	Continuous Subarray Sum	24.2%	Medium - hashmap with index requirement
466	Count The Repetitions	27.5%	Hard	
this is very similar to 418, which can be solved usign two pointer
838	Push Dominoes	44.7%	Medium	
727	Minimum Window Subsequence 38.0%	Hard	
need some optimization using two pointer (in case a lot of first char matching...)
76. Minimum Window Substring (similar to 727, but not required the order)
898	Bitwise ORs of Subarrays	35.1%	Medium	
use set and or the set.
982	Triples with Bitwise AND Equal To Zero	54.3%	Hard
number of triples: first get two and and then check against it.
871	Minimum Number of Refueling Stops	29.8%	Hard	
heap or dp:

# need more work:
## knapsack
279	Perfect Squares	42.8%	Medium	
322	Coin Change	31.4%	Medium	
638	Shopping Offers	49.4%	Medium	
377	Combination Sum IV	43.8%	Medium	
416	Partition Equal Subset Sum	41.3%	Medium	
494	Target Sum	45.6%	Medium	
956	Tallest Billboard	38.7%	Hard	
474	Ones and Zeroes	40.2%	Medium
1049 Last Stone Weight II	40.1%	Medium	
1155	Number of Dice Rolls With Target Sum	50.0%	Medium	
1058 Minimize Rounding Error to Meet Target 39.7%	Medium	
879	Profitable Schemes	37.4%	Hard	

## 1d/2d array
generally use two direction updates, or reduce to 1d equivalent problem.
53	Maximum Subarray	44.3%	Easy	(connect or not with previous)
152	Maximum Product Subarray	29.8%	Medium	(min and max convert)
85	Maximal Rectangle	34.2%	Hard	(reduce to 1d or dp)
- do row by row, reduce to 1d histogram problem.  (using increasing stack, using the popped one as the highest rod)
- dp: maintain left,right, height row by row, all three variables dependent on previous row. complicated.
221	Maximal Square	33.8%	Medium	(1d stack, or two direction dp)
- dp, maintaining left and top length.
174	Dungeon Game	27.7%	Hard	- reverse direction
304	Range Sum Query 2D - Immutable	33.5%	Medium - similar prefix	
363	Max Sum of Rectangle No Larger Than K	35.5%	Hard	
- do it by row or column. get the sum from row i to row j. and then reduce to 1d, solve the problem in 1d.
1074 Number of Submatrices That Sum to Target	58.2%	Hard	
750	Number Of Corner Rectangles 65.1%	Medium	
1139	Largest 1-Bordered Square	43.1%	Medium	
- dfs
- reduce to 2 1d problem- along row or col.
764	Largest Plus Sign	44.0%	Medium	
135. candy
542. 01 matrix
1162. as far from land as possible

## palindrome
5	Longest Palindromic Substring	27.7%	Medium	- direct approach is more straightforward.
647	Palindromic Substrings	57.7%	Medium	
- dp[i,j]=self+dp[i,j-1]+dp[i+1,j]-dp[i+1,j-1] (number of pal-seq)
516	Longest Palindromic Subsequence	47.9%	Medium
- s[i]=s[j] d[i+1,j-1]+2, else max(dp[i+1,j],dp[i,j-1])

132	Palindrome Partitioning II	28.1%	Hard	
- use every position (even and odd) check if i-j to i+j, i-j+1 to i+j.
131. Palindrome Partitioning- backtracking.
***730	Count Different Palindromic Subsequences	39.7%	Hard	
very hard.
4 chars, abcd
length n.
 dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]

## string matching and edit distance
10	Regular Expression Matching	25.6%	Hard	
. match a single char, * matches zero or more of the preceding char

44	Wildcard Matching	23.2%	Hard	
? matches a single char, * matches any sequence of char (include empty)

72	Edit Distance	38.9%	Hard	
115	Distinct Subsequences	35.6%	Hard
similar to edit distance, diff char, delete, same char, delete or not delete
	
97	Interleaving String	28.6%	Hard	
712	Minimum ASCII Delete Sum for Two Strings	55.3%	Medium	

## sequence problems
413	Arithmetic Slices	56.2%	Medium	
300	Longest Increasing Subsequence	41.2%	Medium	
354	Russian Doll Envelopes	34.3%	Hard	
646	Maximum Length of Pair Chain	49.4%	Medium	
673	Number of Longest Increasing Subsequence	34.0%	Medium	
446	Arithmetic Slices II - Subsequence	30.8%	Hard	
978	Longest Turbulent Subarray	45.7%	Medium	
1027	Longest Arithmetic Sequence	49.4%	Medium	
1048 Longest String Chain	48.9%	Medium	
873	Length of Longest Fibonacci Subsequence	46.6%	Medium	
1092	Shortest Common Supersequence	48.3%	Hard	- longest common subsequence equiv.
1143	Longest Common Subsequence	58.4%	Medium	
1024 Video Stitching	47.0%	Medium	

## common recurrence problems
139	Word Break	36.2%	Medium	- breakable
140	Word Break II	27.9%	Hard	- get combinations (dfs) or backtracking
472	Concatenated Words	36.2%	Hard	- similar to 139
96	Unique Binary Search Trees	47.3%	Medium	- number of ways
95	Unique Binary Search Trees II	36.6%	Medium	- get all combinations
343	Integer Break	48.3%	Medium	- math or dp
256	Paint House 49.6%	Easy	- no ajacent same color, 3 colors
265	Paint House II 42.1%	Hard - no adjacent same color, k colors
dp[i,j] subproblem for number of house i, and last color is j.
276	Paint Fence 36.9%	Easy	
allows 2 adjacent same color, add a dimension with 2. we can use same and diff to represent the two states.
375	Guess Number Higher or Lower II	38.3%	Medium	
pick and number and divide into two subproblem
975	Odd Even Jump	46.2%	Hard	
reverse dp, and visited stored in a map
920	Number of Music Playlists	44.1%	Hard	
subproblem: dp[i,j] for i songs, and playlist len=l.
517	Super Washing Machines	37.0%	Hard	
passing and itself the max.
357	Count Numbers with Unique Digits	47.3%	Medium	
simple combinations, n digit
1012 Numbers With Repeated Digits	35.3%	Hard	
equivalent: number with unique digits up to N.
first get the k-digit and then solve from 10...0 to N.
740	Delete and Earn	46.5%	Medium	
similar to house robber if arranged in order.

837	New 21 Game	32.2%	Medium	
this is a more complicated version of climbing stairs.
813	Largest Sum of Averages	46.2%	Medium	
parition into <=K parts, this is similar to k transactions, we based on previous k-1 transactions and try to add one more split
983	Minimum Cost For Tickets	57.5%	Medium	
1day,7day,30 day specials. just compare which is cheaper dp[i]
552	Student Attendance Record II	33.7%	Hard	
1105 Filling Bookcase Shelves	55.0%	Medium	
either use current at the end of current shelf
or use it on a new layer.


## some 2d dp which is more understandable using separate status (generally for very limited status 2 or 3)
they are equivalent in any means.
903	Valid Permutations for DI Sequence	45.5%	Hard	
it has two states, so use up and down.
276	Paint Fence 36.9%	Easy	
no adjacent same color.
376	Wiggle Subsequence	38.0%	Medium	
longest wiggle subsequence, two states use up and down
801	Minimum Swaps To Make Sequences Increasing	35.5%	Medium	
either swap current or current previous
600	Non-negative Integers without Consecutive Ones	33.1%
two states, previous one is 0 or 1.

## two players
486	Predict the Winner	47.0%	Medium	
pick number from either end. divide into two subproblems.
464	Can I Win	27.7%	Medium	
draw from a pool of numbers, target sum.
number<20, so we can use bit status for the dp.
dp is 2d with win/lose two status. so we can name them separately.

877	Stone Game	62.0%	Medium	
similar to 486.
1140 Stone Game II	61.0%	Medium	
use suffix sum is better for this. top down or bottom up.



## shortest path visiting all nodes
847	Shortest Path Visiting All Nodes	47.8%	Hard	
a graph with edges (undirected), can visit multiple times.
dp[m,2^m] final answer is the min among all 0xffff... column
using bfs: if the edge can be used to relax the distance, then it is added into the queue.

943	Find the Shortest Superstring	38.6%	Hard	
create the distance between each pair, (directed graph)
equiv: find the shortest path visiting each node once. also need to be able to trackback.
similar dp[n,2^n]
visiting node j: get its previous state and use an edge k-j to relax i to j.

787	Cheapest Flights Within K Stops	35.8%	Medium	
from src to dest with at most k stops.
use the flight (edges) to relax the cost. repeat k times.

1066	Campus Bikes II 49.5%	Medium	
m people, n bikes, dp[m,2^n] for status
note answer lies in the column with m bits


## top down
312	Burst Balloons	48.2%	Hard	
top down+memoization, reverse thinking, burst a baloon with defined left and right boundary
and divide into two subproblems

546	Remove Boxes	38.9%	Hard	
divide into subproblem: 
group the leading k numbers and sub, 
solve other first and let them connect and remove.
664	Strange Printer	37.3%	Hard	
similar to 546. k does not count for score.

403	Frog Jump	36.8%	Hard	
current position, check if next position is reachable and then decide which to use

741	Cherry Pickup	30.6%	Hard	
two branch walk at the same time.

964	Least Operators to Express Number	41.2%	Hard	
use +/- to save, x-ary base problem

887	Super Egg Drop	25.0%	Hard	

650	2 Keys Keyboard	47.1%	Medium	
copy paste, kind of greedy
odd number: its max factor repeat
even number: mod by 2, add 2 operations, mod by 4 could be smaller
651	4 Keys Keyboard 51.1%	Medium	
type A, ctl-A, ctl-c, ctl-v
select the input and paste needs 3 operations, 
do not make copies, len=i need i operations
make copies: len=i, need at least i-3 operations
press n times, what is the max?

1130 Minimum Cost Tree From Leaf Values	58.7%	Medium	

361	Bomb Enemy 44.0%	Medium	

818	Race Car	35.8%	Hard	
1000 Minimum Cost to Merge Stones	34.3%	Hard	
1039 Minimum Score Triangulation of Polygon	42.9%	Medium	
467	Unique Substrings in Wraparound String	34.4%	Medium	

629	K Inverse Pairs Array	29.7%	Hard	
	
691	Stickers to Spell Word	39.0%	Hard	

471	Encode String with Shortest Length 45.6%	Hard	
940	Distinct Subsequences II	40.2%	Hard	

514	Freedom Trail	41.0%	Hard	
790	Domino and Tromino Tiling	36.5%	Medium	
1055	Shortest Way to Form String 58.8%	Medium	
568	Maximum Vacation Days 38.5%	Hard	
1125	Smallest Sufficient Team	44.4%	Hard	
967	Numbers With Same Consecutive Differences	37.6%	Medium	
902	Numbers At Most N Given Digit Set	28.9%	Hard	
656	Coin Path 27.2%	Hard	
1067	Digit Count in Range 37.4%	Hard	


# Tree
Tree problems are mostly:
traverse problem and apply some array tech in it.
the hard part in tree is:
- involve the pointer changes
- involve the traversal
- involve some other tech
pay special attention to:
how array tech used in tree.
how to achieve O(n) time to avoid O(N^2) time.

familiar
104	Maximum Depth of Binary Tree	61.7%	Easy	
226	Invert Binary Tree	59.2%	Easy	(flip left right)
617	Merge Two Binary Trees	70.9%	Easy	-superposition and add.
96	Unique Binary Search Trees	47.3%	Medium	-dp
108 Convert Sorted Array to Binary Search Tree	52.1%	Easy	-divide by half
100 Same Tree	50.5%	Easy	
101 Symmetric Tree	44.1%	Easy	
669	Trim a Binary Search Tree	60.8%	Easy	trim [L,R]
235	Lowest Common Ancestor of a Binary Search Tree	45.8%	Easy	
BST can compare values
236	Lowest Common Ancestor of a Binary Tree	38.9%	Medium	
find the node and judege the lca at the same time
107	Binary Tree Level Order Traversal II	47.9%	Easy	
102	Binary Tree Level Order Traversal	49.7%	Medium	
103	Binary Tree Zigzag Level Order Traversal	42.8%	Medium	
94	Binary Tree Inorder Traversal	57.9%	Medium	
144	Binary Tree Preorder Traversal	52.3%	Medium	
222	Count Complete Tree Nodes	35.8%	Medium	
199	Binary Tree Right Side View	49.0%	Medium	
257	Binary Tree Paths	46.9%	Easy	
437	Path Sum III	43.5%	Easy	
230	Kth Smallest Element in a BST	52.8%	Medium	
337	House Robber III	48.7%	Medium	
106	Construct Binary Tree from Inorder and Postorder Traversal	40.5%	Medium	
653	Two Sum IV - Input is a BST	53.1%	Easy	
98	Validate Binary Search Tree	26.1%	Medium	
145	Binary Tree Postorder Traversal	49.7%	Hard	
637	Average of Levels in Binary Tree	59.5%	Easy	
889	Construct Binary Tree from Preorder and Postorder Traversal	61.2%	Medium	
606	Construct String from Binary Tree	52.0%	Easy	
501	Find Mode in Binary Search Tree	40.0%	Easy	
872	Leaf-Similar Trees	63.8%	Easy	
1008	Construct Binary Search Tree from Preorder Traversal	73.3%	Medium	
530	Minimum Absolute Difference in BST	51.2%	Easy	
112	Path Sum	38.4%	Easy	
129	Sum Root to Leaf Numbers	43.4%	Medium	
582	Kill Process 57.0%	Medium	
589	N-ary Tree Preorder Traversal	68.5%	Easy	
783	Minimum Distance Between BST Nodes	50.9%	Easy
671	Second Minimum Node In a Binary Tree	43.1%	Easy	
590	N-ary Tree Postorder Traversal	68.5%	Easy	
987	Vertical Order Traversal of a Binary Tree	32.1%	Medium	
429	N-ary Tree Level Order Traversal	60.3%	Easy	
572	Subtree of Another Tree	42.0%	Easy	
700	Search in a Binary Search Tree	69.0%	Easy	
559	Maximum Depth of N-ary Tree	66.0%	Easy	
270	Closest Binary Search Tree Value 44.4%	Easy	
1022	Sum of Root To Leaf Binary Numbers	58.9%	Easy
105	Construct Binary Tree from Preorder and Inorder Traversal	42.6%	Medium	
938	Range Sum of BST	78.1%	Easy	[L,U]
538	Convert BST to Greater Tree	52.0%	Easy	
postorder, add prev to current, suffix sum.
111	Minimum Depth of Binary Tree	35.7%	Easy
894	All Possible Full Binary Trees	71.6%	Medium	
try all combinations, recursive. left and right nodes are odd number
404	Sum of Left Leaves	49.5%	Easy	
113	Path Sum II	41.8%	Medium	- regular dfs
652	Find Duplicate Subtrees	46.5%	Medium	
-post order traversal, hashmap
814	Binary Tree Pruning	71.7%	Medium	
post order pruning.
897	Increasing Order Search Tree	65.7%	Easy	
convert to linked list...reverse in order is best
426	Convert Binary Search Tree to Sorted Doubly Linked List 53.6%	Medium	
use a dummy for prev.
863	All Nodes Distance K in Binary Tree	49.4%	Medium	
graph with bfs
285	Inorder Successor in BST 35.7%	Medium	
binary search, if not found, return root.
701	Insert into a Binary Search Tree	76.6%	Medium	
add the node in the first leaf position. 
515	Find Largest Value in Each Tree Row	58.4%	Medium	
508	Most Frequent Subtree Sum	55.2%	Medium	
255	Verify Preorder Sequence in Binary Search Tree 44.1%	Medium	
298	Binary Tree Longest Consecutive Sequence 44.6%	Medium	
dfs to count.
272	Closest Binary Search Tree Value II 46.1%	Hard
k values closet to target. using pq. to store the absolute diff.
1110	Delete Nodes And Return Forest	63.2%	Medium	
951	Flip Equivalent Binary Trees	64.7%	Medium	
1026	Maximum Difference Between Node and Ancestor	61.0%	Medium	
use similar approach in array, previous min and max.

1104	Path In Zigzag Labelled Binary Tree	70.3%	Medium	
get the last layer and dtermine its sequence get to right
and then use parent-child relation and then get it back.
965	Univalued Binary Tree	66.9%	Easy	
993	Cousins in Binary Tree	52.2%	Easy	
549	Binary Tree Longest Consecutive Sequence II 44.8%	Medium	
bfs
1145	Binary Tree Coloring Game	46.0%	Medium
greedy, counting nodes
988	Smallest String Starting From Leaf	45.2%	Medium	
try dfs to get each path and reverse to get the min

## need pay attention
297 Serialize and Deserialize Binary Tree	42.1%	Hard
to string and string to tree node.
	
124 Binary Tree Maximum Path Sum	30.7%	Hard	
connect left right or not connect
similar 1d array max subarray sum. at the same time decide if connect.

654	Maximum Binary Tree	76.8%	Medium	
build from array. heap such as set built this way.

99	Recover Binary Search Tree	35.4%	Hard	
inorder search to find possible one or two reversed pairs

173 Binary Search Tree Iterator	49.9%	Medium	
use O(1) time and O(h) space so stack is necessary.

95	Unique Binary Search Trees II	36.7%	Medium	-recursive.
114	Flatten Binary Tree to Linked List	43.6%	Medium	
postorder traversal.
449	Serialize and Deserialize BST	48.3%	Medium	
450	Delete Node in a BST	40.5%	Medium	
if no left, promote right
if no right, promote left
if has left and right, swap the root with the right leftmost node
delete that node
be careful: cannot directly return it, but need to update the root->left and root->right
** 510	Inorder Successor in BST II 54.2%	Medium	
only know the node, with child and parent.
similar to linked list problem only know the node.
in order: left, root, right
if p has right child, find the right leftmost node
if p has no right child, need go up to the parent.
662	Maximum Width of Binary Tree	39.5%	Medium
dfs using parent-child relation in binary tree
bfs avoid integer overflow.
	
366	Find Leaves of Binary Tree 66.9%	Medium	
this is tricky. 
leaf we return level 0. 
and we build an vector.

971	Flip Binary Tree To Match Preorder Traversal	43.3%	Medium	
check root, left and right, right and left to see if match.

998	Maximum Binary Tree II	61.5%	Medium	
>root->val put the whole tree as left branch
otherwise add in the right subtree

1028	Recover a Tree From Preorder Traversal	69.7%	Hard	
iterative stack from string.

742	Closest Leaf in a Binary Tree 40.1%	Medium	
build a graph and do bfs

536	Construct Binary Tree from String 45.9%	Medium	
expression evaluation using stack

776	Split BST 52.9%	Medium	
given target, break into <=target and > target.
root<=target: go to right, update root->right
else go to left, 

623	Add One Row to Tree	47.7%	Medium	
919	Complete Binary Tree Inserter	55.7%	Medium
using array to store full binary tree, so insert is add at the end

333	Largest BST Subtree 33.6%	Medium	
similar to find the longest sorted subarray inorder traversal
or: max of left <root < min of its right and get the length

666	Path Sum IV 53.1%	Medium	
use 3 digit to represent x,y in full tree.
use a matrix to represent.

663	Equal Tree Partition 38.3%	Medium	
parition into two parts sum = target
postorder to get subtree sum and using hashmap
check total sum/2 frequency.

1120	Maximum Average Subtree 60.5%	Medium
count nodes and sum at the same time.

## O(N) solution
110 Balanced Binary Tree	41.5%	Easy	
get depth and compare difference at the same time.

1123	Lowest Common Ancestor of Deepest Leaves	64.5%	Medium	
get the depth and max depth at the same time and check if we reach the deepest level.

543	Diameter of Binary Tree	47.3%	Easy	
longest path. 
get the left and right longest path
and get the diameter at the same time. 

687	Longest Univalue Path	34.3%	Easy	
similarly we need use O(N) to get two information
longest univalue path in left and right
and add it to get the max
it needs two information: longest path starting at the root, and longest path inside
116	Populating Next Right Pointers in Each Node	38.9%	Medium	
bfs with a dummy can simplify. 
helper calculate the max len ending at root.

117	Populating Next Right Pointers in Each Node II	35.2%	Medium	
bfs with dummy using prev. similar to linked list

979	Distribute Coins in Binary Tree	67.7%	Medium	
similar to wash machine. 
using postorder, get the coins passing from left and right to root.
calculate the coin to be passed away
calculate the number of pass at the same time.
	
250	Count Univalue Subtrees 49.8%	Medium	
bottom up or postorder
see a subtree univalue and add it.

563	Binary Tree Tilt	47.2%	Easy	
tilt=absol diff between lsum and rsum. 
O(N): get the sum in helper and calculate tilt.

156	Binary Tree Upside Down 51.8%	Medium	
no right subtree only right leaf
pointer relations.
root becomes right leaf node.

513	Find Bottom Left Tree Value	59.1%	Medium	
find the first node in the last row. 
Bfs is fine.
recursive O(N^2) is simple
O(N): get the depth and do dfs. the first node with max depth.
or the last node right,root,left.
the first node with max depth.

865	Smallest Subtree with all the Deepest Nodes	57.1%	Medium	
O(N^2) usign get depth
O(N): get the depth and the needed information
O(N) is also a memoization of O(N^2) version
a memoization version is easy to implement but generally use more space
O(N) & O(1):
get left depth and right depth
get maxdepth
if left==right==maxdepth we found it.
it is important for leaf to return the h instead of 0

545	Boundary of Binary Tree 35.8%	Medium	
counter clockwise order
pretty tricky:

834	Sum of Distances in Tree	40.4%	Hard	
pretty hard problem. 

655	Print Binary Tree	52.5%	Medium	

1130	Minimum Cost Tree From Leaf Values	58.7%	Medium	

431	Encode N-ary Tree to Binary Tree 64.8%	Hard	

428	Serialize and Deserialize N-ary Tree 55.0%	Hard	


684	Redundant Connection	52.8%	Medium	
undirected. using union find to find cycles

685	Redundant Connection II	31.1%	Hard	
directed, using union find 
- has a cycle
- has two parents
- first loop then two parents
- first two parents and then loop
pretty tricky.


968	Binary Tree Cameras	35.7%	Hard	
from bottom up, so post order, using greedy

# heap
## familar
23	Merge k Sorted Lists	35.6%	Hard	
215	Kth Largest Element in an Array	49.3%	Medium	
295	Find Median from Data Stream	38.0%	Hard	
347	Top K Frequent Elements	56.1%	Medium	
378	Kth Smallest Element in a Sorted Matrix	50.4%	Medium	
actually is 1d.
451	Sort Characters By Frequency	56.9%	Medium	
692	Top K Frequent Words	46.7%	Medium	
778	Swim in Rising Water	48.6%	Hard	- binary search
857	Minimum Cost to Hire K Workers	48.1%	Hard	
871	Minimum Number of Refueling Stops	29.8%	Hard	
973	K Closest Points to Origin	61.5%	Medium	
1054	Distant Barcodes	39.3%	Medium
264	Ugly Number II	37.1%	Medium	
factor 2,3,5, can also use pq.
313	Super Ugly Number	42.3%	Medium	
can still 
239	Sliding Window Maximum	39.0%	Hard
montonic deque, when the k-w is on the front, pop it.
index queue.
253	Meeting Rooms II 43.4%	Medium	
-interval with prefix sum
818	Race Car	35.8%	Hard	-dp
703	Kth Largest Element in a Stream	46.9%	Easy	
1046	Last Stone Weight	62.0%	Easy	


## less familiar
719	Find K-th Smallest Pair Distance	29.6%	Hard	
- binary search after sort. O(Nlogn) counting O(N^2)
- heap: generate all the difference and put in heap, not preferred.

373	Find K Pairs with Smallest Sums	34.3%	Medium	
two sorted list. will create a table with sorted order
786	K-th Smallest Prime Fraction	40.5%	Hard
a sorted table
note: pq will accept duplicates so we need avoid pushing same element multiple times
otherwise it will produce incorrect results.
using visited hashset to solve this
-corner case: both are empty, one is empty, k > m*n.

358	Rearrange String k Distance Apart 33.3%	Hard	
hashmap count the chars, distance >=k
put the map pairs into pq
get k elements from the pq, update the count
then put them back into pq.
similar to 767

659	Split Array into Consecutive Subsequences	41.2%	Medium	
- reversed interval problem. using hashmap.
- hashmap to get histogram, from small to larger
for the number: 
if need the num, --need[num], ++need[num+1]
else (not need it), freq[num+1],freq[num+2] has
--freq[num+1], --freq[num+2], ++need[num+3]
- using heap: 
	- when number = top+1, keep going
	- when number = top, start a new interval
	- when number > top+1, we need wrap up the previous interval
	
767	Reorganize String	43.5%	Medium	
no ajacent be the same
pop two and update and then push in again if not zero.


502	IPO	38.4%	Hard	
<=k projects, each project has net profit pi and min capital requirement Wi.
Initial capital W.
the idea: push the project with capital requirment <=W into pq. choose the largest profit
and then increase W, add again other project <=W. sort it to enable binary search

743	Network Delay Time	43.3%	Medium	
shortest distane to other node from K. and choose the max.
dijkstra: 
pq: from k. add those edges which reduces the dist[v] using these edges
787	Cheapest Flights Within K Stops	35.8%	Medium	
similar to 743
-dp or dijkstra using heap
dp using the edge to relax the distance.
other approach include dfs, bfs, bellman-ford, dijkstra

***864	Shortest Path to Get All Keys	37.0%	Hard	
-dp or dijkstra using heap
. empty, # wall, @ starting point, lower letter: keys, upper letter: locks
a lock can be walked over if we have the key.
return the min moves to acquire all keys.
use bfs.
bit to indicate the keys.
note: since they are multiple paths to reach the same position. we cannot set visit directly
this is very important for bfs, we need check that.
also do not change the char in the grid, since we still need them
- ie. when the queue has several field, we need include the visited all the information
using above measures cannot solve the problem since each node can be visited multiple times
very useful.

759	Employee Free Time 62.2%	Hard	
understand the problem, each person has a list of interval times.
this is like a k-list common interval problem. -->k list interval merge problem.
for each person the intervals are non overlapped.
heap can be used:
the earliest start time, add all those start time < current endinng
when adding a new interval, we need update the current ending
and thus we have the common free time interval
- another approach use interval start++ and end --
save all prefix=0 segment.
this is so far the simplest approach.

218	The Skyline Problem	32.2%	Hard	
seems an interval problem and then form the skyline.
brutal foce: from the left to right we sample each point value and the remove those same y intervals
-using the event add and removal method
	- the event add x vs h, the event removal x vs -h. (using multiset to add same)
	(actually we set add as -h and removal as +h)
	- maintain a min heap on the height. (multiset)
	- the tricky part: when we see a negative we insert into the min heap. else we remove i.
	- and we use the highest as our current height.
		

355	Design Twitter	27.9%	Medium	
postTweet--add into data and save into data structure user id vs his news
getNewsFeed(user)-- get the newest 10 by himself or he followed-- that is where the heap uses.
similar to n-list merge.
follow
unfollow

407	Trapping Rain Water II	39.7%	Hard	
using min heap pq;
first push the 4 boundary cells into pq. cell include height and i, j.
- contribution when the outside smallest > current
- then we push the max(outside smallest, curr) into queue (the higher will block the rain)
- similar to bfs.

882	Reachable Nodes In Subdivided Graph	38.6%	Hard	
each edge is subdivided into different number of nodes
return the number of nodes you can reach in M moves.
- build the graph using subnode number as weight
- use a min heap -pq (store distance vs dest nodes from 0)
- then try all its child, get the new dist to child, record used moves
- relax the distance and push to pq.
still has problem on it.

# binary search
## familiar: 
50	 Pow(x, n)	28.4%	Medium	
167	 Two Sum II - Input array is sorted	51.1%	Easy	
153	 Find Minimum in Rotated Sorted Array	43.4%	Medium	
154	 Find Minimum in Rotated Sorted Array II	39.7%	Hard	
with duplicates
33	 Search in Rotated Sorted Array	33.1%	Medium	
81	 Search in Rotated Sorted Array II	32.7%	Medium	
with duplicates, based on 154.
349	 Intersection of Two Arrays	56.1%	Easy	
350	 Intersection of Two Arrays II	48.7%	Easy	
29	 Divide Two Integers	16.2%	Medium	
240	 Search a 2D Matrix II	41.2%	Medium	
74	 Search a 2D Matrix	35.1%	Medium	
69	 Sqrt(x)	31.9%	Easy	
162	 Find Peak Element	41.7%	Medium	
35	 Search Insert Position	41.1%	Easy	
378	 Kth Smallest Element in a Sorted Matrix	50.4%	Medium	
300	 Longest Increasing Subsequence	41.2%	Medium	
278	 First Bad Version	30.9%	Easy	
34	 Find First and Last Position of Element in Sorted Array	34.0%	Medium	
374	 Guess Number Higher or Lower	40.1%	Easy	
230	 Kth Smallest Element in a BST	52.8%	Medium	
852	 Peak Index in a Mountain Array	70.0%	Easy	
475	 Heaters	32.1%	Easy	
392	 Is Subsequence	47.4%	Easy	
367	 Valid Perfect Square	40.3%	Easy	
270	 Closest Binary Search Tree Value 44.4%	Easy	
1064	 Fixed Point 76.9%	Easy	
1060	 Missing Element in Sorted Array 54.4%	Medium	
1095	 Find in Mountain Array	34.1%	Hard	
1150	 Check If a Number Is Majority Element in a Sorted Array 68.5%	Easy
222	 Count Complete Tree Nodes	35.8%	Medium	
287	 Find the Duplicate Number	50.7%	Medium	
410	 Split Array Largest Sum	42.8%	Hard	
718	 Maximum Length of Repeated Subarray	46.9%	Medium	
longest common subarray problem
354	 Russian Doll Envelopes	34.3%	Hard	
dp is more suitable
209	 Minimum Size Subarray Sum	35.4%	Medium	
sliding window is more suitable
454	 4Sum II	51.2%	Medium	
has 4 lists. a+b+c+d=0 combine 2 and 2, then check equal
363	 Max Sum of Rectangle No Larger Than K	35.5%	Hard	
using kadane algorithm and reduces to 1d array problem.
528	 Random Pick with Weight	43.0%	Medium	
math, prefix sum.
981	 Time Based Key-Value Store	51.4%	Medium	
352	 Data Stream as Disjoint Intervals	44.1%	Hard	
can use ++/-- with seen ignored. (otherwise will messup)
merge becomes really simple.
719	 Find K-th Smallest Pair Distance	29.6%	Hard	
see  heap
174	 Dungeon Game	27.7%	Hard	
dp or similar to swimming 
441	 Arranging Coins	38.5%	Easy	
658	 Find K Closest Elements	38.5%	Medium	
sort using abs diff.
1011	 Capacity To Ship Packages Within D Days	53.8%	Medium	
binary search best
862	 Shortest Subarray with Sum at Least K	22.5%	Hard	
778	 Swim in Rising Water	48.6%	Hard	
786	 K-th Smallest Prime Fraction	40.5%	Hard	
875	 Koko Eating Bananas	46.8%	Medium	

## need to improve
4	 Median of Two Sorted Arrays	27.1%	Hard
two sorted array binary search: divide and conquer

327	 Count of Range Sum	33.3%	Hard	
range sum in [lower, upper]. 
prefix sum and using it for divide and conquer.
divide by half, and use right - left to get the count <lower and <=upper
merge sort.

315	 Count of Smaller Numbers After Self	38.9%	Hard	

887	 Super Egg Drop	25.0%	Hard	
493	 Reverse Pairs	23.5%	Hard	

1111	 Maximum Nesting Depth of Two Valid Parentheses Strings	65.3%	Medium	


275	 H-Index II	35.7%	Medium	

911	 Online Election	47.8%	Medium	
1044	 Longest Duplicate Substring	22.6%	Hard	
483	 Smallest Good Base	34.4%	Hard	
644	 Maximum Average Subarray II 29.4%	Hard	
436	 Find Right Interval	43.3%	Medium	
710	 Random Pick with Blacklist	32.0%	Hard	
774	 Minimize Max Distance to Gas Station 42.8%	Hard	
704	 Binary Search	49.0%	Easy	
497	 Random Point in Non-overlapping Rectangles	36.0%	Medium	
302	 Smallest Rectangle Enclosing Black Pixels 49.8%	Hard	
702	 Search in a Sorted Array of Unknown Size 60.6%	Medium	
668	 Kth Smallest Number in Multiplication Table	42.6%	Hard	
744	 Find Smallest Letter Greater Than Target	44.4%	Easy	
878	 Nth Magical Number	25.8%	Hard	
1157	 Online Majority Element In Subarray	31.2%	Hard	
927	 Three Equal Parts	30.9%	Hard	
793	 Preimage Size of Factorial Zeroes Function	39.2%	Hard	







