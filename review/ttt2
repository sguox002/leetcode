a selection of problems
according to difficulty:
dp, greedy, tree, stack
heap, trie, graph
dfs, bfs, recursive, backtrack
hashmap, string, array, union-find

we are not covering math.


dp:
dp problem generally is hard if we cannot think it clear. The overlapping problems we need try dp first.
we need build intuition to commonly seen type of problems.

# familiar
70	Climbing Stairs	44.8%	Easy	
198	House Robber	41.2%	Easy	
121	Best Time to Buy and Sell Stock	48.0%	Easy	
338	Counting Bits	65.4%	Medium	
120	Triangle	40.4%	Medium	
64	Minimum Path Sum	48.1%	Medium	
62	Unique Paths	48.7%	Medium	
123	Best Time to Buy and Sell Stock III	34.5%	Hard	
303	Range Sum Query - Immutable	39.2%	Easy	
309	Best Time to Buy and Sell Stock with Cooldown	44.6%	Medium	
188	Best Time to Buy and Sell Stock IV	26.7%	Hard	
91	Decode Ways	22.7%	Medium	
264	Ugly Number II	37.1%	Medium	
746	Min Cost Climbing Stairs	48.0%	Easy	
714	Best Time to Buy and Sell Stock with Transaction Fee	51.2%	Medium	
213	House Robber II	35.5%	Medium	
63	Unique Paths II	33.6%	Medium	
931	Minimum Falling Path Sum	59.1%	Medium	
639	Decode Ways II	25.5%	Hard	
688	Knight Probability in Chessboard	45.3%	Medium	
935	Knight Dialer	41.8%	Medium	
351	Android Unlock Patterns 46.5%	Medium	
960	Delete Columns to Make Sorted III	53.3%	Hard	
576	Out of Boundary Paths	32.7%	Medium	
87	Scramble String	32.0%	Hard	
808	Soup Servings	38.0%	Medium	

# non-dp is more suitable:
410	Split Array Largest Sum	42.8%	Hard	-binary search
718	Maximum Length of Repeated Subarray	46.9%	Medium	 - binary search
698	Partition to K Equal Sum Subsets	43.2%	Medium	- backtrack
321	Create Maximum Number	25.8%	Hard	-greedy
1025 Divisor Game	64.3%	Easy	- greedy
392	Is Subsequence	47.4%	Easy	- greedy, two pointer
689	Maximum Sum of 3 Non-Overlapping Subarrays	44.3%	Hard	- two pointer
968	Binary Tree Cameras	35.7%	Hard	-greedy
1147	Longest Chunked Palindrome Decomposition	58.7%	Hard	-greedy
418	Sentence Screen Fitting 31.3%	Medium	-two pointer
1136	Parallel Courses 59.5%	Hard	-bfs
32	Longest Valid Parentheses	26.1%	Hard	-stack
523	Continuous Subarray Sum	24.2%	Medium - hashmap with index requirement
466	Count The Repetitions	27.5%	Hard	
this is very similar to 418, which can be solved usign two pointer
838	Push Dominoes	44.7%	Medium	
727	Minimum Window Subsequence 38.0%	Hard	
need some optimization using two pointer (in case a lot of first char matching...)
76. Minimum Window Substring (similar to 727, but not required the order)
898	Bitwise ORs of Subarrays	35.1%	Medium	
use set and or the set.
982	Triples with Bitwise AND Equal To Zero	54.3%	Hard
number of triples: first get two and and then check against it.
871	Minimum Number of Refueling Stops	29.8%	Hard	
heap or dp:

# need more work:
## knapsack
279	Perfect Squares	42.8%	Medium	
322	Coin Change	31.4%	Medium	
638	Shopping Offers	49.4%	Medium	
377	Combination Sum IV	43.8%	Medium	
416	Partition Equal Subset Sum	41.3%	Medium	
494	Target Sum	45.6%	Medium	
956	Tallest Billboard	38.7%	Hard	
474	Ones and Zeroes	40.2%	Medium
1049 Last Stone Weight II	40.1%	Medium	
1155	Number of Dice Rolls With Target Sum	50.0%	Medium	
1058 Minimize Rounding Error to Meet Target 39.7%	Medium	
879	Profitable Schemes	37.4%	Hard	

## 1d/2d array
generally use two direction updates, or reduce to 1d equivalent problem.
53	Maximum Subarray	44.3%	Easy	(connect or not with previous)
152	Maximum Product Subarray	29.8%	Medium	(min and max convert)
85	Maximal Rectangle	34.2%	Hard	(reduce to 1d or dp)
- do row by row, reduce to 1d histogram problem.  (using increasing stack, using the popped one as the highest rod)
- dp: maintain left,right, height row by row, all three variables dependent on previous row. complicated.
221	Maximal Square	33.8%	Medium	(1d stack, or two direction dp)
- dp, maintaining left and top length.
174	Dungeon Game	27.7%	Hard	- reverse direction
304	Range Sum Query 2D - Immutable	33.5%	Medium - similar prefix	
363	Max Sum of Rectangle No Larger Than K	35.5%	Hard	
- do it by row or column. get the sum from row i to row j. and then reduce to 1d, solve the problem in 1d.
1074 Number of Submatrices That Sum to Target	58.2%	Hard	
750	Number Of Corner Rectangles 65.1%	Medium	
1139	Largest 1-Bordered Square	43.1%	Medium	
- dfs
- reduce to 2 1d problem- along row or col.
764	Largest Plus Sign	44.0%	Medium	
135. candy
542. 01 matrix
1162. as far from land as possible

## palindrome
5	Longest Palindromic Substring	27.7%	Medium	- direct approach is more straightforward.
647	Palindromic Substrings	57.7%	Medium	
- dp[i,j]=self+dp[i,j-1]+dp[i+1,j]-dp[i+1,j-1] (number of pal-seq)
516	Longest Palindromic Subsequence	47.9%	Medium
- s[i]=s[j] d[i+1,j-1]+2, else max(dp[i+1,j],dp[i,j-1])

132	Palindrome Partitioning II	28.1%	Hard	
- use every position (even and odd) check if i-j to i+j, i-j+1 to i+j.
131. Palindrome Partitioning- backtracking.
***730	Count Different Palindromic Subsequences	39.7%	Hard	
very hard.
4 chars, abcd
length n.
 dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]

## string matching and edit distance
10	Regular Expression Matching	25.6%	Hard	
. match a single char, * matches zero or more of the preceding char

44	Wildcard Matching	23.2%	Hard	
? matches a single char, * matches any sequence of char (include empty)

72	Edit Distance	38.9%	Hard	
115	Distinct Subsequences	35.6%	Hard
similar to edit distance, diff char, delete, same char, delete or not delete
	
97	Interleaving String	28.6%	Hard	
712	Minimum ASCII Delete Sum for Two Strings	55.3%	Medium	

## sequence problems
413	Arithmetic Slices	56.2%	Medium	
300	Longest Increasing Subsequence	41.2%	Medium	
354	Russian Doll Envelopes	34.3%	Hard	
646	Maximum Length of Pair Chain	49.4%	Medium	
673	Number of Longest Increasing Subsequence	34.0%	Medium	
446	Arithmetic Slices II - Subsequence	30.8%	Hard	
978	Longest Turbulent Subarray	45.7%	Medium	
1027	Longest Arithmetic Sequence	49.4%	Medium	
1048 Longest String Chain	48.9%	Medium	
873	Length of Longest Fibonacci Subsequence	46.6%	Medium	
1092	Shortest Common Supersequence	48.3%	Hard	- longest common subsequence equiv.
1143	Longest Common Subsequence	58.4%	Medium	
1024 Video Stitching	47.0%	Medium	

## common recurrence problems
139	Word Break	36.2%	Medium	- breakable
140	Word Break II	27.9%	Hard	- get combinations (dfs) or backtracking
472	Concatenated Words	36.2%	Hard	- similar to 139
96	Unique Binary Search Trees	47.3%	Medium	- number of ways
95	Unique Binary Search Trees II	36.6%	Medium	- get all combinations
343	Integer Break	48.3%	Medium	- math or dp
256	Paint House 49.6%	Easy	- no ajacent same color, 3 colors
265	Paint House II 42.1%	Hard - no adjacent same color, k colors
dp[i,j] subproblem for number of house i, and last color is j.
276	Paint Fence 36.9%	Easy	
allows 2 adjacent same color, add a dimension with 2. we can use same and diff to represent the two states.
375	Guess Number Higher or Lower II	38.3%	Medium	
pick and number and divide into two subproblem
975	Odd Even Jump	46.2%	Hard	
reverse dp, and visited stored in a map
920	Number of Music Playlists	44.1%	Hard	
subproblem: dp[i,j] for i songs, and playlist len=l.
517	Super Washing Machines	37.0%	Hard	
passing and itself the max.
357	Count Numbers with Unique Digits	47.3%	Medium	
simple combinations, n digit
1012 Numbers With Repeated Digits	35.3%	Hard	
equivalent: number with unique digits up to N.
first get the k-digit and then solve from 10...0 to N.
740	Delete and Earn	46.5%	Medium	
similar to house robber if arranged in order.

837	New 21 Game	32.2%	Medium	
this is a more complicated version of climbing stairs.
813	Largest Sum of Averages	46.2%	Medium	
parition into <=K parts, this is similar to k transactions, we based on previous k-1 transactions and try to add one more split
983	Minimum Cost For Tickets	57.5%	Medium	
1day,7day,30 day specials. just compare which is cheaper dp[i]
552	Student Attendance Record II	33.7%	Hard	
1105 Filling Bookcase Shelves	55.0%	Medium	
either use current at the end of current shelf
or use it on a new layer.


## some 2d dp which is more understandable using separate status (generally for very limited status 2 or 3)
they are equivalent in any means.
903	Valid Permutations for DI Sequence	45.5%	Hard	
it has two states, so use up and down.
276	Paint Fence 36.9%	Easy	
no adjacent same color.
376	Wiggle Subsequence	38.0%	Medium	
longest wiggle subsequence, two states use up and down
801	Minimum Swaps To Make Sequences Increasing	35.5%	Medium	
either swap current or current previous
600	Non-negative Integers without Consecutive Ones	33.1%
two states, previous one is 0 or 1.

## two players
486	Predict the Winner	47.0%	Medium	
pick number from either end. divide into two subproblems.
464	Can I Win	27.7%	Medium	
draw from a pool of numbers, target sum.
number<20, so we can use bit status for the dp.
dp is 2d with win/lose two status. so we can name them separately.

877	Stone Game	62.0%	Medium	
similar to 486.
1140 Stone Game II	61.0%	Medium	
use suffix sum is better for this. top down or bottom up.



## shortest path visiting all nodes
847	Shortest Path Visiting All Nodes	47.8%	Hard	
a graph with edges (undirected), can visit multiple times.
dp[m,2^m] final answer is the min among all 0xffff... column
using bfs: if the edge can be used to relax the distance, then it is added into the queue.

943	Find the Shortest Superstring	38.6%	Hard	
create the distance between each pair, (directed graph)
equiv: find the shortest path visiting each node once. also need to be able to trackback.
similar dp[n,2^n]
visiting node j: get its previous state and use an edge k-j to relax i to j.

787	Cheapest Flights Within K Stops	35.8%	Medium	
from src to dest with at most k stops.
use the flight (edges) to relax the cost. repeat k times.

1066	Campus Bikes II 49.5%	Medium	
m people, n bikes, dp[m,2^n] for status
note answer lies in the column with m bits


## top down
312	Burst Balloons	48.2%	Hard	
top down+memoization, reverse thinking, burst a baloon with defined left and right boundary
and divide into two subproblems

546	Remove Boxes	38.9%	Hard	
divide into subproblem: 
group the leading k numbers and sub, 
solve other first and let them connect and remove.
664	Strange Printer	37.3%	Hard	
similar to 546. k does not count for score.

403	Frog Jump	36.8%	Hard	
current position, check if next position is reachable and then decide which to use

741	Cherry Pickup	30.6%	Hard	
two branch walk at the same time.

964	Least Operators to Express Number	41.2%	Hard	
use +/- to save, x-ary base problem

887	Super Egg Drop	25.0%	Hard	

650	2 Keys Keyboard	47.1%	Medium	
copy paste, kind of greedy
odd number: its max factor repeat
even number: mod by 2, add 2 operations, mod by 4 could be smaller
651	4 Keys Keyboard 51.1%	Medium	
type A, ctl-A, ctl-c, ctl-v
select the input and paste needs 3 operations, 
do not make copies, len=i need i operations
make copies: len=i, need at least i-3 operations
press n times, what is the max?

1130 Minimum Cost Tree From Leaf Values	58.7%	Medium	

361	Bomb Enemy 44.0%	Medium	

818	Race Car	35.8%	Hard	
1000 Minimum Cost to Merge Stones	34.3%	Hard	
1039 Minimum Score Triangulation of Polygon	42.9%	Medium	
467	Unique Substrings in Wraparound String	34.4%	Medium	

629	K Inverse Pairs Array	29.7%	Hard	
	
691	Stickers to Spell Word	39.0%	Hard	

471	Encode String with Shortest Length 45.6%	Hard	
940	Distinct Subsequences II	40.2%	Hard	

514	Freedom Trail	41.0%	Hard	
790	Domino and Tromino Tiling	36.5%	Medium	
1055	Shortest Way to Form String 58.8%	Medium	
568	Maximum Vacation Days 38.5%	Hard	
1125	Smallest Sufficient Team	44.4%	Hard	
967	Numbers With Same Consecutive Differences	37.6%	Medium	
902	Numbers At Most N Given Digit Set	28.9%	Hard	
656	Coin Path 27.2%	Hard	
1067	Digit Count in Range 37.4%	Hard	


# Tree
Tree problems are mostly:
traverse problem and apply some array tech in it.
the hard part in tree is:
- involve the pointer changes
- involve the traversal
- involve some other tech
pay special attention to:
how array tech used in tree.
how to achieve O(n) time to avoid O(N^2) time.

familiar
104	Maximum Depth of Binary Tree	61.7%	Easy	
226	Invert Binary Tree	59.2%	Easy	(flip left right)
617	Merge Two Binary Trees	70.9%	Easy	-superposition and add.
96	Unique Binary Search Trees	47.3%	Medium	-dp
108 Convert Sorted Array to Binary Search Tree	52.1%	Easy	-divide by half
100 Same Tree	50.5%	Easy	
101 Symmetric Tree	44.1%	Easy	
669	Trim a Binary Search Tree	60.8%	Easy	trim [L,R]
235	Lowest Common Ancestor of a Binary Search Tree	45.8%	Easy	
BST can compare values
236	Lowest Common Ancestor of a Binary Tree	38.9%	Medium	
find the node and judege the lca at the same time
107	Binary Tree Level Order Traversal II	47.9%	Easy	
102	Binary Tree Level Order Traversal	49.7%	Medium	
103	Binary Tree Zigzag Level Order Traversal	42.8%	Medium	
94	Binary Tree Inorder Traversal	57.9%	Medium	
144	Binary Tree Preorder Traversal	52.3%	Medium	
222	Count Complete Tree Nodes	35.8%	Medium	
199	Binary Tree Right Side View	49.0%	Medium	
257	Binary Tree Paths	46.9%	Easy	
437	Path Sum III	43.5%	Easy	
230	Kth Smallest Element in a BST	52.8%	Medium	
337	House Robber III	48.7%	Medium	
106	Construct Binary Tree from Inorder and Postorder Traversal	40.5%	Medium	
653	Two Sum IV - Input is a BST	53.1%	Easy	
98	Validate Binary Search Tree	26.1%	Medium	
145	Binary Tree Postorder Traversal	49.7%	Hard	
637	Average of Levels in Binary Tree	59.5%	Easy	
889	Construct Binary Tree from Preorder and Postorder Traversal	61.2%	Medium	
606	Construct String from Binary Tree	52.0%	Easy	
501	Find Mode in Binary Search Tree	40.0%	Easy	
872	Leaf-Similar Trees	63.8%	Easy	
1008	Construct Binary Search Tree from Preorder Traversal	73.3%	Medium	
530	Minimum Absolute Difference in BST	51.2%	Easy	
112	Path Sum	38.4%	Easy	
129	Sum Root to Leaf Numbers	43.4%	Medium	
582	Kill Process 57.0%	Medium	
589	N-ary Tree Preorder Traversal	68.5%	Easy	
783	Minimum Distance Between BST Nodes	50.9%	Easy
671	Second Minimum Node In a Binary Tree	43.1%	Easy	
590	N-ary Tree Postorder Traversal	68.5%	Easy	
987	Vertical Order Traversal of a Binary Tree	32.1%	Medium	
429	N-ary Tree Level Order Traversal	60.3%	Easy	
572	Subtree of Another Tree	42.0%	Easy	
700	Search in a Binary Search Tree	69.0%	Easy	
559	Maximum Depth of N-ary Tree	66.0%	Easy	
270	Closest Binary Search Tree Value 44.4%	Easy	
1022	Sum of Root To Leaf Binary Numbers	58.9%	Easy
105	Construct Binary Tree from Preorder and Inorder Traversal	42.6%	Medium	
938	Range Sum of BST	78.1%	Easy	[L,U]
538	Convert BST to Greater Tree	52.0%	Easy	
postorder, add prev to current, suffix sum.
111	Minimum Depth of Binary Tree	35.7%	Easy
894	All Possible Full Binary Trees	71.6%	Medium	
try all combinations, recursive. left and right nodes are odd number
404	Sum of Left Leaves	49.5%	Easy	
113	Path Sum II	41.8%	Medium	- regular dfs
652	Find Duplicate Subtrees	46.5%	Medium	
-post order traversal, hashmap
814	Binary Tree Pruning	71.7%	Medium	
post order pruning.
897	Increasing Order Search Tree	65.7%	Easy	
convert to linked list...reverse in order is best
426	Convert Binary Search Tree to Sorted Doubly Linked List 53.6%	Medium	
use a dummy for prev.
863	All Nodes Distance K in Binary Tree	49.4%	Medium	
graph with bfs
285	Inorder Successor in BST 35.7%	Medium	
binary search, if not found, return root.
701	Insert into a Binary Search Tree	76.6%	Medium	
add the node in the first leaf position. 
515	Find Largest Value in Each Tree Row	58.4%	Medium	
508	Most Frequent Subtree Sum	55.2%	Medium	
255	Verify Preorder Sequence in Binary Search Tree 44.1%	Medium	
298	Binary Tree Longest Consecutive Sequence 44.6%	Medium	
dfs to count.
272	Closest Binary Search Tree Value II 46.1%	Hard
k values closet to target. using pq. to store the absolute diff.
1110	Delete Nodes And Return Forest	63.2%	Medium	
951	Flip Equivalent Binary Trees	64.7%	Medium	
1026	Maximum Difference Between Node and Ancestor	61.0%	Medium	
use similar approach in array, previous min and max.

1104	Path In Zigzag Labelled Binary Tree	70.3%	Medium	
get the last layer and dtermine its sequence get to right
and then use parent-child relation and then get it back.
965	Univalued Binary Tree	66.9%	Easy	
993	Cousins in Binary Tree	52.2%	Easy	
549	Binary Tree Longest Consecutive Sequence II 44.8%	Medium	
bfs
1145	Binary Tree Coloring Game	46.0%	Medium
greedy, counting nodes
988	Smallest String Starting From Leaf	45.2%	Medium	
try dfs to get each path and reverse to get the min

## need pay attention
297 Serialize and Deserialize Binary Tree	42.1%	Hard
to string and string to tree node.
	
124 Binary Tree Maximum Path Sum	30.7%	Hard	
connect left right or not connect
similar 1d array max subarray sum. at the same time decide if connect.

654	Maximum Binary Tree	76.8%	Medium	
build from array. heap such as set built this way.

99	Recover Binary Search Tree	35.4%	Hard	
inorder search to find possible one or two reversed pairs

173 Binary Search Tree Iterator	49.9%	Medium	
use O(1) time and O(h) space so stack is necessary.

95	Unique Binary Search Trees II	36.7%	Medium	-recursive.
114	Flatten Binary Tree to Linked List	43.6%	Medium	
postorder traversal.
449	Serialize and Deserialize BST	48.3%	Medium	
450	Delete Node in a BST	40.5%	Medium	
if no left, promote right
if no right, promote left
if has left and right, swap the root with the right leftmost node
delete that node
be careful: cannot directly return it, but need to update the root->left and root->right
** 510	Inorder Successor in BST II 54.2%	Medium	
only know the node, with child and parent.
similar to linked list problem only know the node.
in order: left, root, right
if p has right child, find the right leftmost node
if p has no right child, need go up to the parent.
662	Maximum Width of Binary Tree	39.5%	Medium
dfs using parent-child relation in binary tree
bfs avoid integer overflow.
	
366	Find Leaves of Binary Tree 66.9%	Medium	
this is tricky. 
leaf we return level 0. 
and we build an vector.

971	Flip Binary Tree To Match Preorder Traversal	43.3%	Medium	
check root, left and right, right and left to see if match.

998	Maximum Binary Tree II	61.5%	Medium	
>root->val put the whole tree as left branch
otherwise add in the right subtree

1028	Recover a Tree From Preorder Traversal	69.7%	Hard	
iterative stack from string.

742	Closest Leaf in a Binary Tree 40.1%	Medium	
build a graph and do bfs

536	Construct Binary Tree from String 45.9%	Medium	
expression evaluation using stack

776	Split BST 52.9%	Medium	
given target, break into <=target and > target.
root<=target: go to right, update root->right
else go to left, 

623	Add One Row to Tree	47.7%	Medium	
919	Complete Binary Tree Inserter	55.7%	Medium
using array to store full binary tree, so insert is add at the end

333	Largest BST Subtree 33.6%	Medium	
similar to find the longest sorted subarray inorder traversal
or: max of left <root < min of its right and get the length

666	Path Sum IV 53.1%	Medium	
use 3 digit to represent x,y in full tree.
use a matrix to represent.

663	Equal Tree Partition 38.3%	Medium	
parition into two parts sum = target
postorder to get subtree sum and using hashmap
check total sum/2 frequency.

1120	Maximum Average Subtree 60.5%	Medium
count nodes and sum at the same time.

## O(N) solution
110 Balanced Binary Tree	41.5%	Easy	
get depth and compare difference at the same time.

1123	Lowest Common Ancestor of Deepest Leaves	64.5%	Medium	
get the depth and max depth at the same time and check if we reach the deepest level.

543	Diameter of Binary Tree	47.3%	Easy	
longest path. 
get the left and right longest path
and get the diameter at the same time. 

687	Longest Univalue Path	34.3%	Easy	
similarly we need use O(N) to get two information
longest univalue path in left and right
and add it to get the max
it needs two information: longest path starting at the root, and longest path inside
116	Populating Next Right Pointers in Each Node	38.9%	Medium	
bfs with a dummy can simplify. 
helper calculate the max len ending at root.

117	Populating Next Right Pointers in Each Node II	35.2%	Medium	
bfs with dummy using prev. similar to linked list

979	Distribute Coins in Binary Tree	67.7%	Medium	
similar to wash machine. 
using postorder, get the coins passing from left and right to root.
calculate the coin to be passed away
calculate the number of pass at the same time.
	
250	Count Univalue Subtrees 49.8%	Medium	
bottom up or postorder
see a subtree univalue and add it.

563	Binary Tree Tilt	47.2%	Easy	
tilt=absol diff between lsum and rsum. 
O(N): get the sum in helper and calculate tilt.

156	Binary Tree Upside Down 51.8%	Medium	
no right subtree only right leaf
pointer relations.
root becomes right leaf node.

513	Find Bottom Left Tree Value	59.1%	Medium	
find the first node in the last row. 
Bfs is fine.
recursive O(N^2) is simple
O(N): get the depth and do dfs. the first node with max depth.
or the last node right,root,left.
the first node with max depth.

865	Smallest Subtree with all the Deepest Nodes	57.1%	Medium	
O(N^2) usign get depth
O(N): get the depth and the needed information
O(N) is also a memoization of O(N^2) version
a memoization version is easy to implement but generally use more space
O(N) & O(1):
get left depth and right depth
get maxdepth
if left==right==maxdepth we found it.
it is important for leaf to return the h instead of 0

545	Boundary of Binary Tree 35.8%	Medium	
counter clockwise order
pretty tricky:
doing dfs:
first do left side, the boundary needs to be saved
inner side use flag to control if added to buffer
right side using postorder traversal. 
root, left right, root then we can do the both.


834	Sum of Distances in Tree	40.4%	Hard	
pretty hard problem. 

655	Print Binary Tree	52.5%	Medium	

1130	Minimum Cost Tree From Leaf Values	58.7%	Medium	

431	Encode N-ary Tree to Binary Tree 64.8%	Hard	

428	Serialize and Deserialize N-ary Tree 55.0%	Hard	


684	Redundant Connection	52.8%	Medium	
undirected. using union find to find cycles

685	Redundant Connection II	31.1%	Hard	
directed, using union find 
- has a cycle
- has two parents
- first loop then two parents
- first two parents and then loop
pretty tricky.


968	Binary Tree Cameras	35.7%	Hard	
from bottom up, so post order, using greedy

# heap
## familar
23	Merge k Sorted Lists	35.6%	Hard	
215	Kth Largest Element in an Array	49.3%	Medium	
295	Find Median from Data Stream	38.0%	Hard	
347	Top K Frequent Elements	56.1%	Medium	
378	Kth Smallest Element in a Sorted Matrix	50.4%	Medium	
actually is 1d.
451	Sort Characters By Frequency	56.9%	Medium	
692	Top K Frequent Words	46.7%	Medium	
778	Swim in Rising Water	48.6%	Hard	- binary search
857	Minimum Cost to Hire K Workers	48.1%	Hard	
871	Minimum Number of Refueling Stops	29.8%	Hard	
973	K Closest Points to Origin	61.5%	Medium	
1054	Distant Barcodes	39.3%	Medium
264	Ugly Number II	37.1%	Medium	
factor 2,3,5, can also use pq.
313	Super Ugly Number	42.3%	Medium	
can still 
239	Sliding Window Maximum	39.0%	Hard
montonic deque, when the k-w is on the front, pop it.
index queue.
253	Meeting Rooms II 43.4%	Medium	
-interval with prefix sum
818	Race Car	35.8%	Hard	-dp
703	Kth Largest Element in a Stream	46.9%	Easy	
1046	Last Stone Weight	62.0%	Easy	


## less familiar
719	Find K-th Smallest Pair Distance	29.6%	Hard	
- binary search after sort. O(Nlogn) counting O(N^2)
- heap: generate all the difference and put in heap, not preferred.

373	Find K Pairs with Smallest Sums	34.3%	Medium	
two sorted list. will create a table with sorted order
786	K-th Smallest Prime Fraction	40.5%	Hard
a sorted table
note: pq will accept duplicates so we need avoid pushing same element multiple times
otherwise it will produce incorrect results.
using visited hashset to solve this
-corner case: both are empty, one is empty, k > m*n.

358	Rearrange String k Distance Apart 33.3%	Hard	
hashmap count the chars, distance >=k
put the map pairs into pq
get k elements from the pq, update the count
then put them back into pq.
similar to 767

659	Split Array into Consecutive Subsequences	41.2%	Medium	
- reversed interval problem. using hashmap.
- hashmap to get histogram, from small to larger
for the number: 
if need the num, --need[num], ++need[num+1]
else (not need it), freq[num+1],freq[num+2] has
--freq[num+1], --freq[num+2], ++need[num+3]
- using heap: 
	- when number = top+1, keep going
	- when number = top, start a new interval
	- when number > top+1, we need wrap up the previous interval
	
767	Reorganize String	43.5%	Medium	
no ajacent be the same
pop two and update and then push in again if not zero.


502	IPO	38.4%	Hard	
<=k projects, each project has net profit pi and min capital requirement Wi.
Initial capital W.
the idea: push the project with capital requirment <=W into pq. choose the largest profit
and then increase W, add again other project <=W. sort it to enable binary search

743	Network Delay Time	43.3%	Medium	
shortest distane to other node from K. and choose the max.
dijkstra: 
pq: from k. add those edges which reduces the dist[v] using these edges
787	Cheapest Flights Within K Stops	35.8%	Medium	
similar to 743
-dp or dijkstra using heap
dp using the edge to relax the distance.
other approach include dfs, bfs, bellman-ford, dijkstra

***864	Shortest Path to Get All Keys	37.0%	Hard	
-dp or dijkstra using heap
. empty, # wall, @ starting point, lower letter: keys, upper letter: locks
a lock can be walked over if we have the key.
return the min moves to acquire all keys.
use bfs.
bit to indicate the keys.
note: since they are multiple paths to reach the same position. we cannot set visit directly
this is very important for bfs, we need check that.
also do not change the char in the grid, since we still need them
- ie. when the queue has several field, we need include the visited all the information
using above measures cannot solve the problem since each node can be visited multiple times
very useful.

759	Employee Free Time 62.2%	Hard	
understand the problem, each person has a list of interval times.
this is like a k-list common interval problem. -->k list interval merge problem.
for each person the intervals are non overlapped.
heap can be used:
the earliest start time, add all those start time < current endinng
when adding a new interval, we need update the current ending
and thus we have the common free time interval
- another approach use interval start++ and end --
save all prefix=0 segment.
this is so far the simplest approach.

218	The Skyline Problem	32.2%	Hard	
seems an interval problem and then form the skyline.
brutal foce: from the left to right we sample each point value and the remove those same y intervals
-using the event add and removal method
	- the event add x vs h, the event removal x vs -h. (using multiset to add same)
	(actually we set add as -h and removal as +h)
	- maintain a min heap on the height. (multiset)
	- the tricky part: when we see a negative we insert into the min heap. else we remove i.
	- and we use the highest as our current height.
		

355	Design Twitter	27.9%	Medium	
postTweet--add into data and save into data structure user id vs his news
getNewsFeed(user)-- get the newest 10 by himself or he followed-- that is where the heap uses.
similar to n-list merge.
follow
unfollow

407	Trapping Rain Water II	39.7%	Hard	
using min heap pq;
first push the 4 boundary cells into pq. cell include height and i, j.
- contribution when the outside smallest > current
- then we push the max(outside smallest, curr) into queue (the higher will block the rain)
- similar to bfs.

882	Reachable Nodes In Subdivided Graph	38.6%	Hard	
each edge is subdivided into different number of nodes
return the number of nodes you can reach in M moves.
- build the graph using subnode number as weight
- use a min heap -pq (store distance vs dest nodes from 0)
- then try all its child, get the new dist to child, record used moves
- relax the distance and push to pq.
still has problem on it.

# binary search
## familiar: 
50	 Pow(x, n)	28.4%	Medium	
167	 Two Sum II - Input array is sorted	51.1%	Easy	
153	 Find Minimum in Rotated Sorted Array	43.4%	Medium	
154	 Find Minimum in Rotated Sorted Array II	39.7%	Hard	
with duplicates
33	 Search in Rotated Sorted Array	33.1%	Medium	
81	 Search in Rotated Sorted Array II	32.7%	Medium	
with duplicates, based on 154.
349	 Intersection of Two Arrays	56.1%	Easy	
350	 Intersection of Two Arrays II	48.7%	Easy	
29	 Divide Two Integers	16.2%	Medium	
240	 Search a 2D Matrix II	41.2%	Medium	
74	 Search a 2D Matrix	35.1%	Medium	
69	 Sqrt(x)	31.9%	Easy	
162	 Find Peak Element	41.7%	Medium	
35	 Search Insert Position	41.1%	Easy	
378	 Kth Smallest Element in a Sorted Matrix	50.4%	Medium	
300	 Longest Increasing Subsequence	41.2%	Medium	
278	 First Bad Version	30.9%	Easy	
34	 Find First and Last Position of Element in Sorted Array	34.0%	Medium	
374	 Guess Number Higher or Lower	40.1%	Easy	
230	 Kth Smallest Element in a BST	52.8%	Medium	
852	 Peak Index in a Mountain Array	70.0%	Easy	
475	 Heaters	32.1%	Easy	
392	 Is Subsequence	47.4%	Easy	
367	 Valid Perfect Square	40.3%	Easy	
270	 Closest Binary Search Tree Value 44.4%	Easy	
1064	 Fixed Point 76.9%	Easy	
1060	 Missing Element in Sorted Array 54.4%	Medium	
1095	 Find in Mountain Array	34.1%	Hard	
1150	 Check If a Number Is Majority Element in a Sorted Array 68.5%	Easy
222	 Count Complete Tree Nodes	35.8%	Medium	
287	 Find the Duplicate Number	50.7%	Medium	
410	 Split Array Largest Sum	42.8%	Hard	
718	 Maximum Length of Repeated Subarray	46.9%	Medium	
longest common subarray problem
354	 Russian Doll Envelopes	34.3%	Hard	
dp is more suitable
209	 Minimum Size Subarray Sum	35.4%	Medium	
sliding window is more suitable
454	 4Sum II	51.2%	Medium	
has 4 lists. a+b+c+d=0 combine 2 and 2, then check equal
363	 Max Sum of Rectangle No Larger Than K	35.5%	Hard	
using kadane algorithm and reduces to 1d array problem.
528	 Random Pick with Weight	43.0%	Medium	
math, prefix sum.
981	 Time Based Key-Value Store	51.4%	Medium	
352	 Data Stream as Disjoint Intervals	44.1%	Hard	
can use ++/-- with seen ignored. (otherwise will messup)
merge becomes really simple.
719	 Find K-th Smallest Pair Distance	29.6%	Hard	
see  heap
174	 Dungeon Game	27.7%	Hard	
dp or similar to swimming 
441	 Arranging Coins	38.5%	Easy	
658	 Find K Closest Elements	38.5%	Medium	
sort using abs diff.
1011	 Capacity To Ship Packages Within D Days	53.8%	Medium	
binary search best
862	 Shortest Subarray with Sum at Least K	22.5%	Hard	
778	 Swim in Rising Water	48.6%	Hard	
786	 K-th Smallest Prime Fraction	40.5%	Hard	
875	 Koko Eating Bananas	46.8%	Medium	
911	 Online Election	47.8%	Medium	
store winner vs time.
436	 Find Right Interval	43.3%	Medium	
sort and find the lower_bound...
704	 Binary Search	49.0%	Easy	
497	 Random Point in Non-overlapping Rectangles	36.0%	Medium	
first random pick a rect using the area as the weight
then generate a random point inside the rect.
702	 Search in a Sorted Array of Unknown Size 60.6%	Medium	
just use int-max as the upper bound (index). 
668	 Kth Smallest Number in Multiplication Table	42.6%	Hard	
use binary search and count method
744	 Find Smallest Letter Greater Than Target	44.4%	Easy	
927	 Three Equal Parts	30.9%	Hard	
divide the binary string and so that the three numbsers are the same.
do not have to use binary search, but use direct approach

## need to improve
4	 Median of Two Sorted Arrays	27.1%	Hard
two sorted array binary search: divide and conquer

327	 Count of Range Sum	33.3%	Hard	
range sum in [lower, upper]. 
prefix sum and using it for divide and conquer.
divide by half, and use right - left to get the count <lower and <=upper
merge sort.

315	 Count of Smaller Numbers After Self	38.9%	Hard	

887	 Super Egg Drop	25.0%	Hard	
493	 Reverse Pairs	23.5%	Hard	

1111	 Maximum Nesting Depth of Two Valid Parentheses Strings	65.3%	Medium	


275	 H-Index II	35.7%	Medium	


1044	 Longest Duplicate Substring	22.6%	Hard
allows overlap.
using binary search to fix the sliding window and store in hashmap
	
483	 Smallest Good Base	34.4%	Hard	
binary search
644	 Maximum Average Subarray II 29.4%	Hard	
the max average and min average is the max and min element in the array
then we can search in the range to see
subarray length>=k.
the extra complexity is the window size >=k.
we are adding prefix from 0 to i
and also maintain a prefix from 0 to i-k.
then we can check if it is possible to get a diff >= max average
(prefix_i-prefix_j)/(i-j)<average
-> prefix_i-prefix_j<average*(i-j)
-> so we can subtract the target each time.

710	 Random Pick with Blacklist	32.0%	Hard	
numbers from [0 N], with blacklists
remap blacklist to the end of the array and reduce the array size.
then if rand() hit the blacklist redirect it to original position

774	 Minimize Max Distance to Gas Station 42.8%	Hard	
add K gas stations so that the max distance is minimized
reverse think: given a max distance, how many stations to be added.

302	 Smallest Rectangle Enclosing Black Pixels 49.8%	Hard	

878	 Nth Magical Number	25.8%	Hard
binary search and count the <= the mid.
lowest is min(A,B), largest is lcm(A,B)*N.
given a mid value, we can count the number before it.
	
1157	 Online Majority Element In Subarray	31.2%	Hard	
not optimized:
create a hashmap number vs index+cnt
then check all numbers using binary search
note using unordered_map<int,map<int,int>> will cause more memory and time.
use unordered_map<int,vector<int>> will be more compact.
need optimization:
1. sort according to the cnt, check largest first. no need check <threshold cases
2. random pick 

793	 Preimage Size of Factorial Zeroes Function	39.2%	Hard	
f(x) is the number of trailing 0s for x!.
find the number of x which f(x)=K.
simple math:
when see a 5, we add a zero, 
when see a 5^2, we add two zeros
....
count 0s for a given number x is easy, recursive or dp.
then we use binary search to find the count is K.
binary search is often used:
- if direct approach is not good, try given the condition
- if need to solve from low to high such as swimming...
- basically there are only 5 or 0 two answers.


# stack
## familiar
20	Valid Parentheses	37.1%	Easy	
155	Min Stack	38.3%	Easy	
150	Evaluate Reverse Polish Notation	33.1%	Medium	
173	Binary Search Tree Iterator	49.9%	Medium	
94	Binary Tree Inorder Traversal	58.0%	Medium	
232	Implement Queue using Stacks	44.5%	Easy	
103	Binary Tree Zigzag Level Order Traversal	42.8%	Medium	
682	Baseball Game	61.6%	Easy	
144	Binary Tree Preorder Traversal	52.3%	Medium	
636	Exclusive Time of Functions	49.2%	Medium	
225	Implement Stack using Queues	40.4%	Easy	
145	Binary Tree Postorder Traversal	49.8%	Hard	
856	Score of Parentheses	57.3%	Medium	
- support * and +.
1021	Remove Outermost Parentheses	75.1%	Easy	
use counter to find the matched pair, and inside is added
272	Closest Binary Search Tree Value II 46.1%	Hard	
71	Simplify Path	29.4%	Medium	
255	Verify Preorder Sequence in Binary Search Tree 44.1%	Medium	
844	Backspace String Compare	46.5%	Easy	
975	Odd Even Jump	46.3%	Hard	- dp
331	Verify Preorder Serialization of a Binary Tree	39.0%	Medium	
1047	Remove All Adjacent Duplicates In String	63.8%	Easy	
1124	Longest Well-Performing Interval	31.0%	Medium	
1003	Check If Word Is Valid After Substitutions	52.6%	Medium	
using dq is a bit more convenient to remove abc.
921	Minimum Add to Make Parentheses Valid	70.5%	Medium	
remove all valid pairs. top is ) need to add 1. (since ) is not added

## monotonic stack
739	Daily Temperatures	60.4%	Medium	
42	Trapping Rain Water	44.2%	Hard	
84	Largest Rectangle in Histogram	32.0%	Hard	
85	Maximal Rectangle	34.3%	Hard	
316	Remove Duplicate Letters	33.2%	Hard	
496	Next Greater Element I	60.3%	Easy	
503	Next Greater Element II	51.8%	Medium	
402	Remove K Digits	26.9%	Medium	
907	Sum of Subarray Minimums	28.8%	Medium	
- each number can be min, using stack to find next greater element in left and right
- one stack is enough to get left and right.
456	132 Pattern	27.5%	Medium	
735	Asteroid Collision	39.0%	Medium	
946	Validate Stack Sequences	58.3%	Medium	

1130	Minimum Cost Tree From Leaf Values	58.6%	Medium	
array is the leaf nodes, 0 or 2 child.
non leaf node is the product of the largest value in its subtree.
return the smallest possible sum.
- dp: dp[i,j] cost for interval i to j.
split it into left and right: dp[i,k],dp[k+1,j]
max(A[i..k])*max(A[k+1..j])
equivalent problem:
Given an array A, choose two neighbors in the array a and b,
we can remove the smaller one min(a,b) and the cost is a * b.
What is the minimum cost to remove the whole array until only one left?
a<b, cost a*b so we need minimize b.
that is a*min(left,right)
Just find the next greater element in the array, on the left and one right.
Refer to 1019. Next Greater Node In Linked List
use array or stack, add a int-max to avoid empty stack.
1019	Next Greater Node In Linked List	57.0%	Medium	
901	Online Stock Span	50.7%	Medium	
1063	Number of Valid Subarrays 73.1%	Hard
subarray leftmost element is <= all other elements
equivalent to find the left next larger elements

## recursive expression evaluation
341	Flatten Nested List Iterator	48.9%	Medium	
394	Decode String	45.9%	Medium	
224	Basic Calculator	33.6%	Hard	
770	Basic Calculator IV	45.7%	Hard	
385	Mini Parser	32.3%	Medium	
772	Basic Calculator III 42.1%	Hard	
726	Number of Atoms	45.5%	Hard	
439	Ternary Expression Parser 54.0%	Medium	
591	Tag Validator	33.4%	Hard	
880	Decoded String at Index	23.5%	Medium	

895	Maximum Frequency Stack	57.1%	Hard	
- hashmap vs stacks
1066	Campus Bikes II 49.6%	Medium	- pq, shortest distance with status.

# backtrack
## familiar
22	Generate Parentheses	56.5%	Medium	
17	Letter Combinations of a Phone Number	42.6%	Medium	
39	Combination Sum	50.1%	Medium	
all unique combinations.
79	Word Search	32.1%	Medium	-dfs
93	Restore IP Addresses	32.2%	Medium	
-brutal force
140	Word Break II	28.0%	Hard	
- dfs or backtrack.

1079	Letter Tile Possibilities	75.2%	Medium	
use histogram and then backtrack.
44	Wildcard Matching	23.2%	Hard -dp	
980	Unique Paths III	71.2%	Hard	
401	Binary Watch	45.7%	Easy	
212	Word Search II	29.7%	Hard	-trie
216	Combination Sum III	52.6%	Medium	
k numbers
784	Letter Case Permutation	58.4%	Easy	
each letter has lower case and uppercase two choices
126	Word Ladder II	18.5%	Hard	-bfs
526	Beautiful Arrangement	55.3%	Medium	-divide and conquer
357	Count Numbers with Unique Digits	47.3%	Medium
simple math
211	Add and Search Word - Data structure design	31.4%	Medium	- trie
40	Combination Sum II	43.0%	Medium	
target sum, each number can only be used once. contain duplicates
sort and skip duplicated.
351	Android Unlock Patterns 46.5%	Medium- dfs
425	Word Squares 45.1%	Hard	- trie + backtrack
1087	Brace Expansion 59.5%	Medium	- recursive with stack

## need pay attention:
46	Permutations	56.8%	Medium	
get all permutation: swap a[i] with a[start]

47	Permutations II	41.7%	Medium	
sort and skip processed identical.

37	Sudoku Solver	38.3%	Hard	
solve board, try 1 to 9 put into the empty spacem and check if it is valid

51	N-Queens	40.8%	Hard	
similar to 37, try each position and check if it is valid

52	N-Queens II	53.2%	Hard	
get the number of solutions
check all cols and increment the row.

78	Subsets	54.5%	Medium	
all power set, icluding empty.
90	Subsets II	43.3%	Medium	
contain duplicates
sort and then do backtracking
this is exactly the same as 1079. using hashmap
only difference is 1079 for permutations, this for combinations.
use sort and if the current number is same as previous we shall skip it
since the previous has already covered all the combinations.

89	Gray Code	46.5%	Medium	
reflect code. growing: 0->1 reflect the previous and change the highest bit.
	
306	Additive Number	28.6%	Medium	
typical trial and back. or brutal force
similar to sudoku or n-queen, try all combinations of the first two number
first number can go to half length
second number can go to remaining half length
and then do the backtracking
we shall do string add (it could be over limit)
842	Split Array into Fibonacci Sequence	35.2%	Medium	
similar to 306

131	Palindrome Partitioning	42.2%	Medium	
all possible combinations
typical backtracking.
267	Palindrome Permutation II 34.2%	Medium
return all palindromic permuation. 
form the histogram and use only half of it to get the permutation.

266. Palindrome Permutation- just check the histogram
77	Combinations	49.2%	Medium	
combinationof k numbers from 1 to n. C(n,k)
k-1 and i+1 
60	Permutation Sequence	33.9%	Medium	
kth permutation sequence... use math.
n! total
1 fixed at first position, we have (n-1)!
....
these numbers can be calculated directly.
using / and % shall pay attention to base.



320	Generalized Abbreviation 49.3%	Medium	


*** 291	Word Pattern II 41.5%	Hard	
check if follows the same pattern
trial and error
pattern = "abab", str = "redblueredblue"
a:2, b:2
so a can match up to (n-2)/2, b can match up to (n-2)/2
or brutal force, just do map and see if both reaches the end
try all possible length to match current char
if c exisit in pmap, check if s=mp[c]
else check s exist, check if c=mp[s]
insert the map
backtrack
if fail, erase the map
	
996	Number of Squareful Arrays	47.7%	Hard	
adjacent pairs adds up to a square. return the number of permutations
idea: 
get each number's histogram, the count only contributes the number
put all the unique pairs into hashmap <first number, all candidates>
then do backtrack

691	Stickers to Spell Word	39.0%	Hard	
-dp is the fastest. ???

254	Factor Combinations 44.8%	Medium	
get all combinations:
every time we get two factors:
(i,n/i) is an answer, then we use n/i as a subproblem


294	Flip Game II 48.7%	Medium	
++ change to --. 
lose or win. store all win status.

411	Minimum Unique Word Abbreviation 35.1%	Hard	
1088	Confusing Number II 36.6%	Hard
return number of confusing numbers, using backtrack
idea: check all permutations using 01689. (not combination)
permutation means you can reuse the same number. reversed number shall not equal to original number


# dfs
## familiar:
200	 Number of Islands	42.5%	Medium	
108	 Convert Sorted Array to Binary Search Tree	52.2%	Easy	
695	 Max Area of Island	58.3%	Medium	
959	 Regions Cut By Slashes	62.7%	Medium	
547	 Friend Circles	54.6%	Medium	
133	 Clone Graph	27.9%	Medium	- hash and dfs
207	 Course Schedule	38.9%	Medium	- detect cycle
329	 Longest Increasing Path in a Matrix	40.7%	Hard	- with memoization
947	 Most Stones Removed with Same Row or Column	54.4%	Medium	
690	 Employee Importance	54.7%	Easy	
130	 Surrounded Regions	23.7%	Medium	
542	 01 Matrix	36.5%	Medium	 -dp or bfs
417	 Pacific Atlantic Water Flow	38.1%	Medium	
638	 Shopping Offers	49.4%	Medium	- dp
733	 Flood Fill	51.6%	Easy	
664	 Strange Printer	37.3%	Hard	- dp
210	 Course Schedule II	35.9%	Medium	 -bfs
785	 Is Graph Bipartite?	44.3%	Medium	
721	 Accounts Merge	41.9%	Medium	- union find
778	 Swim in Rising Water	48.6%	Hard	 - binary search
841	 Keys and Rooms	61.0%	Medium	-bfs with status
472	 Concatenated Words	36.2%	Hard	-dp
491	 Increasing Subsequences	42.7%	Medium	 -dp
756	 Pyramid Transition Matrix	52.6%	Medium	-dfs
694	 Number of Distinct Islands 52.1%	Medium	
711	 Number of Distinct Islands II 47.0%	Hard	 -- 8 transform
934	 Shortest Bridge	44.5%	Medium	- get two islands and find the shortest distance
323	 Number of Connected Components in an Undirected Graph 52.7%	Medium	
261	 Graph Valid Tree 40.3%	Medium	
737	 Sentence Similarity II 43.9%	Medium	-union find
576	 Out of Boundary Paths	32.7%	Medium	
439	 Ternary Expression Parser 54.0%	Medium	-evaluate expression
1034	 Coloring A Border	42.9%	Medium	
473	 Matchsticks to Square	36.4%	Medium	-dp
827	 Making A Large Island	43.7%	Hard	-union find
839	 Similar String Groups	35.3%	Hard	-union find
1020	 Number of Enclaves	54.6%	Medium	
1059	 All Paths from Source Lead to Destination 45.1%	Medium	 -dfs with cycle detection
1136	 Parallel Courses 59.6%	Hard	 -bfs


743	 Network Delay Time	43.3%	Medium	- shortest distance
924	 Minimize Malware Spread	40.6%	Hard	- shortest distance
301	 Remove Invalid Parentheses	40.0%	Hard	
339	 Nested List Weight Sum 69.2%	Easy	
364	 Nested List Weight Sum II 58.7%	Medium	
679	 24 Game	43.5%	Hard	
489	 Robot Room Cleaner 65.6%	Hard	
332	 Reconstruct Itinerary	32.3%	Medium	
753	 Cracking the Safe	47.5%	Hard	
529	 Minesweeper	54.0%	Medium	
749	 Contain Virus	41.6%	Hard	
928	 Minimize Malware Spread II	39.4%	Hard	
490	 The Maze 48.3%	Medium	
488	 Zuma Game	39.7%	Hard	
802	 Find Eventual Safe States	44.9%	Medium	
685	 Redundant Connection II	31.0%	Hard	
505	 The Maze II 44.9%	Medium	
514	 Freedom Trail	41.1%	Hard	
886	 Possible Bipartition	41.3%	Medium	
499	 The Maze III 37.9%	Hard	
531	 Lonely Pixel I 57.8%	Medium	
533	 Lonely Pixel II 46.5%	Medium	
851	 Loud and Rich	48.6%	Medium	
1061	 Lexicographically Smallest Equivalent String 62.6%	Medium	


# bfs
## familiar
200	 Number of Islands	42.5%	Medium	
279	 Perfect Squares	42.8%	Medium	
127	 Word Ladder	25.1%	Medium	
126	 Word Ladder II	18.5%	Hard	- bfs with parent
133	 Clone Graph	27.9%	Medium	
207	 Course Schedule	38.9%	Medium	
690	 Employee Importance	54.7%	Easy	
130	 Surrounded Regions	23.7%	Medium	
542	 01 Matrix	36.5%	Medium	
417	 Pacific Atlantic Water Flow	38.1%	Medium	
909	 Snakes and Ladders	35.1%	Medium	
210	 Course Schedule II	35.9%	Medium
785	 Is Graph Bipartite?	44.3%	Medium	
675	 Cut Off Trees for Golf Event	31.5%	Hard	
994	 Rotting Oranges	46.4%	Easy	
934	 Shortest Bridge	44.5%	Medium	
323	 Number of Connected Components in an Undirected Graph 52.7%	Medium	
261	 Graph Valid Tree 40.3%	Medium	
854	 K-Similar Strings	34.7%	Hard	
1036	 Escape a Large Maze	35.1%	Hard	
1162	 As Far from Land as Possible	36.7%	Medium
773	 Sliding Puzzle	53.6%	Hard	
301	 Remove Invalid Parentheses	40.0%	Hard	
864	 Shortest Path to Get All Keys	37.0%	Hard	- with status
1091	 Shortest Path in Binary Matrix	36.5%	Medium	
286	 Walls and Gates 50.2%	Medium	- similar, edge the same, multple begins the bfs the same.
752	 Open the Lock	47.0%	Medium	
everytime change one char. 


407	 Trapping Rain Water II	39.7%	Hard -2d with heap bfs
529	 Minesweeper	54.0%	Medium
	
743	 Network Delay Time	43.3%	Medium	-shortest distance to other nodes with weight. (weight cannot use bfs but use pq to relax)
	
847	 Shortest Path Visiting All Nodes	47.8%	Hard	-shortest distance to visit all nodes. edge are the same. can use bfs but needs to store status)
317	 Shortest Distance from All Buildings 38.6%	Hard	
it needs the min sum of shortest distance to all the building.
we can do bfs for each building one time by one time,
we can also do bfs at the same time. storing the information in the higher 8 bits.
787	 Cheapest Flights Within K Stops	35.8%	Medium	- edges are weighted. pq bfs or dp.

913	 Cat and Mouse	29.0%	Hard	


490	 The Maze 48.3%	Medium	- regular bfs, just need to travel along a direction until blocked.
505	 The Maze II 44.9%	Medium	-shortest distance from src to dest, so actually the edge length is weighted here. need use bfs to relax the distance
499	 The Maze III 37.9%	Hard	
on the way, if there is a hole it will be trapped. and need output the steps.
the min distance to get trapped. several shortest distance we need use the lex smallest
udlr: we will try dlru sequence.
use pq with a new node structure, compare with dist, if dist the same, compare with string
approach: pop the top node, and update the distance and add to the pq.
similar to 505, the edge is weighted.
then the first one which see the hole is the answer.

815	 Bus Routes	40.5%	Hard	
build a map for each station, vs number of routes
more similar to bfs in graph.

1129	 Shortest Path with Alternating Colors	36.0%	Medium	
two bfs, start with color 0 or start with color 1.
using even number for color 0 and odd number for color 1.

shortest distance problem
- edge are equal, and no repeat, regular bfs
- edge are equal, need parents, need treat same node with different parents different, modified bfs
- edge are equal, can revisit to shorten distance, bfs with status, and reduce distance
- edge are weighted, need use pq to relax the distance, until there is no more relaxed
pq focus on finding shortest path with weighted eges, queue focus on layers
when for relaxing edges (find all shortest distance from one to all others) queue and pq can be both useful.

# two pointers
## familiar
11	 Container With Most Water	46.1%	Medium	
42	 Trapping Rain Water	44.3%	Hard	- stack
344	 Reverse String	63.8%	Easy	
15	 3Sum	24.6%	Medium	
141	 Linked List Cycle	37.8%	Easy	
3	 Longest Substring Without Repeating Characters	28.7%	Medium	-moving window with hashmap.
283	 Move Zeroes	54.9%	Easy	
88	 Merge Sorted Array	36.6%	Easy	
16	 3Sum Closest	45.8%	Medium	
26	 Remove Duplicates from Sorted Array	41.6%	Easy	
234	 Palindrome Linked List	36.8%	Easy	
27	 Remove Element	45.4%	Easy	
167	 Two Sum II - Input array is sorted	51.1%	Easy	
349	 Intersection of Two Arrays	56.1%	Easy	
76	 Minimum Window Substring	31.6%	Hard	--hashmap
28	 Implement strStr()	32.7%	Easy	
287	 Find the Duplicate Number	50.7%	Medium	
18	 4Sum	31.3%	Medium	
142	 Linked List Cycle II	33.1%	Medium	
19	 Remove Nth Node From End of List	34.5%	Medium	
345	 Reverse Vowels of a String	42.0%	Easy	
763	 Partition Labels	71.8%	Medium	
hashmap to record the last occurance.
75	 Sort Colors	43.0%	Medium	
125	 Valid Palindrome	32.0%	Easy	
86	 Partition List	38.1%	Medium	
457	 Circular Array Loop	27.9%	Medium	
350	 Intersection of Two Arrays II	48.7%	Easy	
904	 Fruit Into Baskets	41.8%	Medium	
-sliding window
61	 Rotate List	27.8%	Medium	
80	 Remove Duplicates from Sorted Array II	41.1%	Medium	
977	 Squares of a Sorted Array	71.8%	Easy	
844	 Backspace String Compare	46.5%	Easy	
925	 Long Pressed Name	44.5%	Easy
986	 Interval List Intersections	63.7%	Medium	
632	 Smallest Range Covering Elements from K Lists	48.7%	Hard	
min heap, similar to k-list merge.
424	 Longest Repeating Character Replacement	44.7%	Medium	
equivalent to longest sliding window with <=k different chars.
159	 Longest Substring with At Most Two Distinct Characters 47.6%	Hard	
hashmap
532	 K-diff Pairs in an Array	30.2%	Easy	
sort and find.
259	 3Sum Smaller 45.4%	Medium	
838	 Push Dominoes	44.7%	Medium	
360	 Sort Transformed Array 47.1%	Medium	
881	 Boats to Save People	44.4%	Medium	
1093	 Statistics from a Large Sample	43.5%	Medium	
567	 Permutation in String	38.9%	Medium	
fixed sliding window, histogram the same.
524	 Longest Word in Dictionary through Deleting	46.4%	Medium	
from longest: check if subsequence.
487	 Max Consecutive Ones II 47.1%	Medium	
flip <=1 times.
1004	 Max Consecutive Ones III	54.3%	Medium	
change up to k values
923	 3Sum With Multiplicity	34.3%	Medium	
merge all duplicates and use simple math
930	 Binary Subarrays With Sum	39.1%	Medium	
sliding window with S ones. add 0 or more 0s front or after
845	 Longest Mountain in Array	34.8%	Medium	
left side up length and right side up length, two directions

30	 Substring with Concatenation of All Words	24.0%	Hard	
209	 Minimum Size Subarray Sum	35.4%	Medium	
713	 Subarray Product Less Than K	37.3%	Medium	
723	 Candy Crush 64.1%	Medium	
992	 Subarrays with K Different Integers	45.0%	Hard	
number of subarrays with exactly k integers.
3 pointers, the longest window and the shortest window satisfying the condition

828	 Unique Letter String	40.9%	Hard	
dp with hash...

826	 Most Profit Assigning Work	36.3%	Medium
difficulty, ability, profit
each person can assign at most one job
a job can be used multiple times.
find the job person can do with largest profit.
		
# graph
## similar
399	Evaluate Division	48.3%	Medium	-dfs
959	Regions Cut By Slashes	62.7%	Medium	 -dfs
133	Clone Graph	27.9%	Medium	-hashmap + dfs
207	Course Schedule	38.9%	Medium	-dfs cycle detection
210	Course Schedule II	35.9%	Medium	-bfs with incoming 0
785	Is Graph Bipartite?	44.3%	Medium	
323	Number of Connected Components in an Undirected Graph 52.7%	Medium	
261	Graph Valid Tree 40.3%	Medium	
997	Find the Town Judge	49.5%	Easy	
839	Similar String Groups	35.3%	Hard	-union find
990	Satisfiability of Equality Equations	40.9%	Medium	-union find
1129	Shortest Path with Alternating Colors	36.0%	Medium	-bfs
1162	As Far from Land as Possible	36.8%	Medium	-bfs or dp
1059	All Paths from Source Lead to Destination 45.2%	Medium	-dfs with cycle
1136	Parallel Courses 59.6%	Hard	
1102	Path With Maximum Minimum Value 43.9%	Medium	- binary search
765	Couples Holding Hands	52.1%	Hard	-greedy
310	Minimum Height Trees	30.6%	Medium	
684	Redundant Connection	52.8%	Medium	
1042	Flower Planting With No Adjacent	47.9%	Easy	


269	Alien Dictionary 31.9%	Hard
similar to course schedule II, keep adding source nodes.
	
332	Reconstruct Itinerary	32.3%	Medium	
backtrack: 
1043	Partition Array for Maximum Sum	62.6%	Medium	
partition and change to max in the subarray. return the largest sum
actually sum(max*size)
dp with pq. 

743	Network Delay Time	43.3%	Medium	
841	Keys and Rooms	61.0%	Medium	

928	Minimize Malware Spread II	39.4%	Hard
	
802	Find Eventual Safe States	44.9%	Medium	

996	Number of Squareful Arrays	47.7%	Hard	

685	Redundant Connection II	31.1%	Hard	
854	K-Similar Strings	34.7%	Hard	
swap exactly k times to make the string equal.
return the smallest k.
using bfs.

1135	Connecting Cities With Minimum Cost 51.3%	Medium	
sort and then union-find

1153	String Transforms Into Another String 28.2%	Hard	
need a extra space for the swapping
mapping cannot be change

444	Sequence Reconstruction 20.6%	Medium	
uniqueness of topological sort
If a topological sort has the property that all pairs of consecutive vertices in the sorted order are connected by edges, then these edges form a directed Hamiltonian path in the DAG. If a Hamiltonian path exists, the topological sort order is unique; no other order respects the edges of the path. Conversely, if a topological sort does not form a Hamiltonian path, the DAG will have two or more valid topological orderings, for in this case it is always possible to form a second valid ordering by swapping two consecutive vertices that are not connected by an edge to each other. Therefore, it is possible to test in linear time whether a unique ordering exists, and whether a Hamiltonian path exists, despite the NP-hardness of the Hamiltonian path problem for more general directed graphs (Vernet & Markenzon 
- every edge shall be a subsequence in org
- every two consecutive elements in org shall be a direct edge in seqs
check these two conditions

# union-find
128	Longest Consecutive Sequence	42.4%	Hard	
130	Surrounded Regions	23.7%	Medium	
200	Number of Islands	42.5%	Medium	
261	Graph Valid Tree 40.3%	Medium	
305	Number of Islands II 41.4%	Hard	
323	Number of Connected Components in an Undirected Graph 52.7%	Medium	
399	Evaluate Division	48.3%	Medium	
547	Friend Circles	54.6%	Medium	
684	Redundant Connection	52.8%	Medium	
685	Redundant Connection II	31.1%	Hard	
721	Accounts Merge	41.9%	Medium	
737	Sentence Similarity II 43.9%	Medium	
765	Couples Holding Hands	52.1%	Hard	
778	Swim in Rising Water	48.6%	Hard	
803	Bricks Falling When Hit	29.2%	Hard	
839	Similar String Groups	35.3%	Hard	
924	Minimize Malware Spread	40.6%	Hard	
928	Minimize Malware Spread II	39.4%	Hard	
947	Most Stones Removed with Same Row or Column	54.4%	Medium	
952	Largest Component Size by Common Factor	26.7%	Hard	
959	Regions Cut By Slashes	62.7%	Medium	
990	Satisfiability of Equality Equations	40.9%	Medium	
1061	Lexicographically Smallest Equivalent String 62.7%	Medium	
1101	The Earliest Moment When Everyone Become Friends 63.9%	Medium	
1102	Path With Maximum Minimum Value 44.0%	Medium	
1135	Connecting Cities With Minimum Cost 51.3%	Medium

# array
array concept can apply to tree and 2d ..

## familiar
1	Two Sum	44.4%	Easy	-hash
18	4Sum	31.3%	Medium	
53	Maximum Subarray	44.3%	Easy	-dp
121	Best Time to Buy and Sell Stock	48.0%	Easy	
561	Array Partition I	69.8%	Easy	-math, sort
169	Majority Element	53.7%	Easy	-voting
122	Best Time to Buy and Sell Stock II	52.8%	Easy	-dp
66	Plus One	41.6%	Easy	
283	Move Zeroes	54.9%	Easy	-two pointer first forward, then backward
88	Merge Sorted Array	36.6%	Easy	-two pointer
26	Remove Duplicates from Sorted Array	41.6%	Easy	
217	Contains Duplicate	53.0%	Easy	-xor
27	Remove Element	45.4%	Easy	
118	Pascal's Triangle	47.4%	Easy -dp	
167	Two Sum II - Input array is sorted	51.1%	Easy	
448	Find All Numbers Disappeared in an Array	54.0%	Easy	
219	Contains Duplicate II	35.8%	Easy	-value same, index diff<=K.
268	Missing Number	49.1%	Easy	
697	Degree of an Array	51.2%	Easy	
189	Rotate Array	31.1%	Easy	
832	Flipping an Image	73.2%	Easy	
905	Sort Array By Parity	72.7%	Easy	
35	Search Insert Position	41.1%	Easy	
119	Pascal's Triangle II	44.8%	Easy	
746	Min Cost Climbing Stairs	48.0%	Easy	
628	Maximum Product of Three Numbers	46.4%	Easy	
566	Reshape the Matrix	59.2%	Easy	
766	Toeplitz Matrix	62.4%	Easy	
867	Transpose Matrix	63.9%	Easy	
665	Non-decreasing Array	19.5%	Easy	
661	Image Smoother	49.3%	Easy	
414	Third Maximum Number	29.4%	Easy	-o(n)
922	Sort Array By Parity II	67.3%	Easy	
605	Can Place Flowers	31.2%	Easy	
509	Fibonacci Number	66.7%	Easy	
724	Find Pivot Index	41.6%	Easy	
888	Fair Candy Swap	56.9%	Easy	
1010	Pairs of Songs With Total Durations Divisible by 60	45.8%	Easy	
747	Largest Number At Least Twice of Others	40.8%	Easy	
830	Positions of Large Groups	48.1%	Easy	
896	Monotonic Array	55.6%	Easy	
624	Maximum Distance in Arrays 37.7%	Easy	
914	X of a Kind in a Deck of Cards	33.9%	Easy	
1013	Partition Array Into Three Parts With Equal Sum	56.0%	Easy	
1089	Duplicate Zeros	59.0%	Easy	-two pointer
1086	High Five 74.8%	Easy	
989	Add to Array-Form of Integer	44.1%	Easy	
1064	Fixed Point 76.7%	Easy	
1128	Number of Equivalent Domino Pairs	44.5%	Easy	
1099	Two Sum Less Than K 61.4%	Easy	
1018	Binary Prefix Divisible By 5	46.8%	Easy	
941	Valid Mountain Array	35.3%	Easy	
1085	Sum of Digits in the Minimum Number 73.9%	Easy	
1133	Largest Unique Number 69.0%	Easy	
1160	Find Words That Can Be Formed by Characters	71.5%	Easy	
1150	Check If a Number Is Majority Element in a Sorted Array 68.4%	Easy	


11	Container With Most Water	46.1%	Medium	-two pointer both end
42	Trapping Rain Water	44.3%	Hard	-stacks
15	3Sum	24.6%	Medium	- two pointer
238	Product of Array Except Self	56.2%	Medium	-both end
229	Majority Element II	32.8%	Medium	-voting
56	Merge Intervals	36.4%	Medium	-two pointer
16	3Sum Closest	45.8%	Medium	-two pointer
85	Maximal Rectangle	34.3%	Hard	-dp, or reduce to 1d stack
48	Rotate Image	50.1%	Medium	-math
31	Next Permutation	30.9%	Medium	-reverse
152	Maximum Product Subarray	29.8%	Medium	-dp.
41	First Missing Positive	29.5%	Hard	-keeping swap to correct position
128	Longest Consecutive Sequence	42.4%	Hard	-union-find
33	Search in Rotated Sorted Array	33.1%	Medium	-binary search
289	Game of Life	47.1%	Medium	
54	Spiral Matrix	31.1%	Medium	-boundary
153	Find Minimum in Rotated Sorted Array	43.4%	Medium	-binary search
39	Combination Sum	50.2%	Medium	-backtrack
79	Word Search	32.1%	Medium	-dfs
442	Find All Duplicates in an Array	62.0%	Medium	-mark seen
621	Task Scheduler	46.1%	Medium	-totally depends on the max freq tasks
287	Find the Duplicate Number	50.7%	Medium	-one appear twice
120	Triangle	40.4%	Medium	
64	Minimum Path Sum	48.2%	Medium	
78	Subsets	54.5%	Medium	-backtrack
228	Summary Ranges	36.6%	Medium	-using interval add/removal or brutal force
695	Max Area of Island	58.3%	Medium	-dfs
560	Subarray Sum Equals K	42.7%	Medium	-hash
59	Spiral Matrix II	47.8%	Medium	-a bit tricky, 4 boundary reflection
62	Unique Paths	48.8%	Medium	-dp
105	Construct Binary Tree from Preorder and Inorder Traversal	42.6%	Medium	
717	1-bit and 2-bit Characters	49.2%	Easy	
123	Best Time to Buy and Sell Stock III	34.5%	Hard	
55	Jump Game	32.5%	Medium	-to see if you can get to the end
45	Jump Game II	28.6%	Hard	-min number of steps, bfs
73	Set Matrix Zeroes	40.6%	Medium	
950	Reveal Cards In Increasing Order	72.1%	Medium	-reverse deque
280	Wiggle Sort 61.5%	Medium	-inorder, sort and swap
75	Sort Colors	43.0%	Medium	-count sort
84	Largest Rectangle in Histogram	32.0%	Hard	-stack
162	Find Peak Element	41.7%	Medium	-binary search
457	Circular Array Loop	27.9%	Medium	-value is step and direction
380	Insert Delete GetRandom O(1)	43.5%	Medium	
34	Find First and Last Position of Element in Sorted Array	34.0%	Medium	
126	Word Ladder II	18.5%	Hard	--bfs
216	Combination Sum III	52.6%	Medium	-backtrack
57	Insert Interval	31.6%	Hard	
154	Find Minimum in Rotated Sorted Array II	39.7%	Hard	
80	Remove Duplicates from Sorted Array II	41.1%	Medium	
718	Maximum Length of Repeated Subarray	46.9%	Medium	-dp, longest common
106	Construct Binary Tree from Inorder and Postorder Traversal	40.6%	Medium	
667	Beautiful Arrangement II	52.4%	Medium	
209	Minimum Size Subarray Sum	35.4%	Medium	(sum>=target)
81	Search in Rotated Sorted Array II	32.7%	Medium	
74	Search a 2D Matrix	35.1%	Medium	
277	Find the Celebrity 37.8%	Medium	
714	Best Time to Buy and Sell Stock with Transaction Fee	51.2%	Medium	
907	Sum of Subarray Minimums	28.8%	Medium	-stack find next-greater
974	Subarray Sums Divisible by K	46.4%	Medium	
90	Subsets II	43.4%	Medium	-contain duplicates, not permutation.
1002	Find Common Characters	65.6%	Easy	
243	Shortest Word Distance 58.2%	Easy	
485	Max Consecutive Ones	55.4%	Easy	
835	Image Overlap	53.6%	Medium	
611	Valid Triangle Number	45.9%	Medium	
1074	Number of Submatrices That Sum to Target	57.8%	Hard	-kadane
63	Unique Paths II	33.6%	Medium	
565	Array Nesting	53.3%	Medium	---longest cycle. cyclic linking.
1051	Height Checker	68.9%	Easy	
713	Subarray Product Less Than K	37.3%	Medium	
977	Squares of a Sorted Array	71.8%	Easy	-two pointer
723	Candy Crush 4.1%	Medium	---just simulate the crush process, mark negative and then move positive forward.
581	Shortest Unsorted Continuous Subarray	30.4%	Easy	
969	Pancake Sorting	62.3%	Medium	
163	Missing Ranges 23.4%	Medium	
643	Maximum Average Subarray I	40.1%	Easy	-sliding window fixed
40	Combination Sum II	43.0%	Medium	-backtrack
769	Max Chunks To Make Sorted	52.3%	Medium	-two pointer or sort and compare
755	Pour Water 41.5%	Medium	--hard understand.
689	Maximum Sum of 3 Non-Overlapping Subarrays	44.3%	Hard	-two ends
1031	Maximum Sum of Two Non-Overlapping Subarrays	54.9%	Medium	
670	Maximum Swap	40.3%	Medium	-swap at most one time two digits to get max number. swap with its right max.
719	Find K-th Smallest Pair Distance	29.6%	Hard	- heap
795	Number of Subarrays with Bounded Maximum	43.9%	Medium	max in [L,R], convert to two <= problem. and accumulate..
674	Longest Continuous Increasing Subsequence	44.7%	Easy	
495	Teemo Attacking	52.6%	Medium	-interval merge... can use add/removal
1040	Moving Stones Until Consecutive II	48.6%	Medium	--equivalent sliding point with min empty spaces
532	K-diff Pairs in an Array	30.2%	Easy	
1011	Capacity To Ship Packages Within D Days	53.8%	Medium	-binary search
999	Available Captures for Rook	66.0%	Easy	
259	3Sum Smaller 45.4%	Medium	
1014	Best Sightseeing Pair	50.3%	Medium	-two way
381	Insert Delete GetRandom O(1) - Duplicates allowed	32.4%	Hard	
775	Global and Local Inversions	39.7%	Medium	
873	Length of Longest Fibonacci Subsequence	46.7%	Medium	
849	Maximize Distance to Closest Person	41.4%	Easy	
1122	Relative Sort Array	66.5%	Easy	
840	Magic Squares In Grid	36.0%	Easy	
985	Sum of Even Numbers After Queries	62.6%	Easy	
891	Sum of Subsequence Widths	29.7%	Hard	-sort, A[i] we have 2^i combinations smaller than it. and n-i-1 bigger than it.
792	Number of Matching Subsequences	44.3%	Medium	- a lot of words and string is very long, so need preprocess, and store the char's index position and binary search
562	Longest Line of Consecutive One in Matrix 44.1%	Medium	-4 direction dfs...
729	My Calendar I	48.2%	Medium	
644	Maximum Average Subarray II 29.4%	Hard	-binary search for double
918	Maximum Sum Circular Subarray	32.5%	Medium	-max and min for non-circular
1035	Uncrossed Lines	51.8%	Medium	-dp
825	Friends Of Appropriate Ages	37.5%	Medium	
870	Advantage Shuffle	43.2%	Medium	-greedy
945	Minimum Increment to Make Array Unique	43.4%	Medium	-math
1109	Corporate Flight Bookings	47.8%	Medium	-interval add/removal
962	Maximum Width Ramp	42.5%	Medium	- find left and right min/max....
782	Transform to Chessboard	39.9%	Hard	-greedy
1007	Minimum Domino Rotations For Equal Row	48.9%	Medium	-greedy
370	Range Addition 61.0%	Medium	
768	Max Chunks To Make Sorted II	46.6%	Hard	-sort or use two way min/max...
245	Shortest Word Distance III 53.9%	Medium	-have duplicate words in dict. save the index.
900	RLE Iterator	50.9%	Medium	
978	Longest Turbulent Subarray	45.8%	Medium	-dp or direct approach using sign changes.
926	Flip String to Monotone Increasing	50.3%	Medium	-01 greedy
915	Partition Array into Disjoint Intervals	43.8%	Medium	-two way min/max
1052	Grumpy Bookstore Owner	52.9%	Medium	-sliding window
548	Split Array with Equal Sum 43.8%	Medium	- with three anchors, using hashset to store sum.
1053	Previous Permutation With One Swap	47.1%	Medium	-similar to next_permutation
1157	Online Majority Element In Subarray	31.3%	Hard	-map value vs index array
1146	Snapshot Array	30.8%	Medium	-
531	Lonely Pixel I 57.8%	Medium	
533	Lonely Pixel II 46.5%	Medium	
954	Array of Doubled Pairs	35.0%	Medium	
1144	Decrease Elements To Make Array Zigzag	41.1%	Medium	-decrease only to make even position > or< its neighbors.  two choices: make odd smaller or make even smaller.
1152	Analyze User Website Visit Pattern 37.1%	Medium	
-problem unclear, 3 sequence is sorted by time of visit. find the sequence by most user.
equivalent: find the most common subsequence among all user visited sites. user visit n sites, the 3 sequence would be C(n,3)
1151	Minimum Swaps to Group All 1's Together 56.3%	Medium -sliding window = number of 1s
4	Median of Two Sorted Arrays	27.1%	Hard	

# greedy
## familiar
44	Wildcard Matching	23.2%	Hard	-dp
45	 Jump Game II	28.6%	Hard	-dp
55	 Jump Game	32.5%	Medium	-dp
122	 Best Time to Buy and Sell Stock II	52.8%	Easy	-dp
135	 Candy	29.1%	Hard	 -dp, left and right
253	 Meeting Rooms II 43.4%	Medium	-interval
316	 Remove Duplicate Letters	33.2%	Hard	-stack
321	 Create Maximum Number	25.8%	Hard	-merge sort
330	 Patching Array	33.6%	Hard	-greedy
358	 Rearrange String k Distance Apart 33.3%	Hard	-heap
392	 Is Subsequence	47.4%	Easy	-two pointer, greedy
630	 Course Schedule III	32.4%	Hard	-bfs
714	 Best Time to Buy and Sell Stock with Transaction Fee	51.2%	Medium	-dp
757	 Set Intersection Size At Least Two	37.0%	Hard	-interval merging...
759	 Employee Free Time 62.2%	Hard	-interval add/removal
763	 Partition Labels	71.8%	Medium	
765	 Couples Holding Hands	52.1%	Hard	
767	 Reorganize String	43.5%	Medium	
860	 Lemonade Change	50.7%	Easy	
861	 Score After Flipping Matrix	70.4%	Medium	
874	 Walking Robot Simulation	32.7%	Easy	-dfs
881	 Boats to Save People	44.4%	Medium	
910	 Smallest Range II	24.5%	Medium	
921	 Minimum Add to Make Parentheses Valid	70.5%	Medium	
927	 Three Equal Parts	30.9%	Hard	
936	 Stamping The Sequence	35.6%	Hard	
944	 Delete Columns to Make Sorted	69.3%	Easy	
948	 Bag of Tokens	39.5%	Medium	
955	 Delete Columns to Make Sorted II	32.1%	Medium	
1057	 Campus Bikes 58.6%	Medium	
1058	 Minimize Rounding Error to Meet Target 39.7%	Medium	
1046	 Last Stone Weight	62.1%	Easy	

134	 Gas Station	34.7%	Medium	
376	 Wiggle Subsequence	38.0%	Medium	-greedy
402	 Remove K Digits	26.9%	Medium	-greedy
406	 Queue Reconstruction by Height	60.6%	Medium	-greedy
435	 Non-overlapping Intervals	41.8%	Medium -greedy	
452	 Minimum Number of Arrows to Burst Balloons	47.1%	Medium	-greedy, interval
455	 Assign Cookies	48.7%	Easy	
484	 Find Permutation 58.3%	Medium	
502	 IPO	38.4%	Hard -greedy	
621	 Task Scheduler	46.1%	Medium	-greedy
649	 Dota2 Senate	37.9%	Medium	-greedy
651	 4 Keys Keyboard 51.1%	Medium	-dp
659	 Split Array into Consecutive Subsequences	41.2%	Medium	-reverse interval, or use needed and having hashmap
738	 Monotone Increasing Digits	42.5%	Medium	-<=N digits increasing., from right to left we find the last decreasing one, and change all right to 9
842	 Split Array into Fibonacci Sequence	35.2%	Medium	
870	 Advantage Shuffle	43.2%	Medium	
984	 String Without AAA or BBB	34.4%	Medium	-recursive
991	 Broken Calculator	41.1%	Medium	-math
995	 Minimum Number of K Consecutive Bit Flips	47.9%	Hard	
1005	 Maximize Sum Of Array After K Negations	50.0%	Easy	
1007	 Minimum Domino Rotations For Equal Row	49.0%	Medium	
1055	 Shortest Way to Form String 58.9%	Medium	
1029	 Two City Scheduling	54.3%	Easy	-math, greedy
1053	 Previous Permutation With One Swap	47.1%	Medium	
1090	 Largest Values From Labels	57.4%	Medium	
1094	 Car Pooling	57.7%	Medium	-interval
1111	 Maximum Nesting Depth of Two Valid Parentheses Strings	65.5%	Medium

# bits
## familiar
136	 Single Number	61.1%	Easy	-xor
461	 Hamming Distance	70.6%	Easy	-
371	 Sum of Two Integers	50.8%	Easy -xor and shift
169	 Majority Element	53.8%	Easy	-The bits in the majority are just the majority bits of all numbers.
191	 Number of 1 Bits	44.4%	Easy	
137	 Single Number II 46.8%	Medium	
338	 Counting Bits	65.4%	Medium	-dp
260	 Single Number III	57.9%	Medium	
78	 Subsets	54.5%	Medium --2^n bit 0 or bit 1 try all combinations	
268	 Missing Number	49.1%	Easy	 
187	 Repeated DNA Sequences	36.7%	Medium	-convert to 4-ary numbers
476	 Number Complement	62.7%	Easy	
190	 Reverse Bits	32.5%	Easy	
231	 Power of Two	42.2%	Easy	
389	 Find the Difference	53.5%	Easy	-strings, same to find single
401	 Binary Watch	45.7%	Easy	
318	 Maximum Product of Word Lengths	49.0%	Medium	
784	 Letter Case Permutation	58.4%	Easy	-backtrack or bit (has two states can use bit operations)
393	 UTF-8 Validation	36.3%	Medium	
342	 Power of Four	40.6%	Easy	
751	 IP to CIDR 60.4%	Easy	

320	 Generalized Abbreviation 49.3%	Medium	
477	 Total Hamming Distance	49.4%	Medium	
693	 Binary Number with Alternating Bits	58.3%	Easy	
1131	 Maximum of Absolute Value Expression	51.4%	Medium	-remove the absolute into 4 status
405	 Convert a Number to Hexadecimal	42.3%	Easy	
756	 Pyramid Transition Matrix	52.6%	Medium	
898	 Bitwise ORs of Subarrays	35.1%	Medium	
762	 Prime Number of Set Bits in Binary Representation	60.1%	Easy	
397	 Integer Replacement	31.8%	Medium	
411	 Minimum Unique Word Abbreviation 35.1%	Hard	
1125	 Smallest Sufficient Team	44.2%	Hard -use bit, much clear
201	 Bitwise AND of Numbers Range	36.4%	Medium	
421	 Maximum XOR of Two Numbers in an Array	51.6%	Medium	
using trie to stores bits. always satisfy the high bit first.
or from high bit to low bit, keeping divide into two sections. the idea is similar to trie.
note: using bitset to separate can also be a choice, but need to keep previous step partition.

unsolved:
755	 Pour Water    		41.5%	Medium	
427	 Construct Quad Tree    		58.1%	Medium	
420	 Strong Password Checker    		16.6%	Hard	
591	 Tag Validator    		33.3%	Hard	
361	 Bomb Enemy    		44.0%	Medium	
913	 Cat and Mouse    		29.0%	Hard	
770	 Basic Calculator IV    		45.6%	Hard	
751	 IP to CIDR    		60.4%	Easy	
558	 Quad Tree Intersection    		41.8%	Easy	
320	 Generalized Abbreviation    		49.3%	Medium	
411	 Minimum Unique Word Abbreviation    		35.2%	Hard
527	 Word Abbreviation    		51.2%	Hard	
308	 Range Sum Query 2D - Mutable    		32.8%	Hard	



470	 Implement Rand10() Using Rand7()    		45.3%	Medium	-math problem
roll once 1/7, roll again 1/49 so we can get 1/49 probability
and then get rid of 40 to 48.   then %10

439	 Ternary Expression Parser    		54.0%	Medium	
recursion using stack, expression evaluation

568	 Maximum Vacation Days    		38.5%	Hard	
dp problem...

708	 Insert into a Cyclic Sorted List    		29.9%	Medium	

588	 Design In-Memory File System    		41.2%	Hard	
file system is tree structure, files are leaf nodes
using trie or n-ary tree.
trie store the contents and leaf.

555	 Split Concatenated Strings    		40.5%	Medium	
form a loop, each single word can reverse or not reverse
cut at a position and it is a single string
find the max string.
the idea: all other strings shall be max. only the cut position string may be different
consider two cases for each string as cut.

469	 Convex Polygon    		35.8%	Medium	
math problem. cross product of continuous 3 point shall >=0 or <=0 always
or change sign. note need to be closed loop. 

749	 Contain Virus    		41.5%	Hard	

488	 Zuma Game    		39.7%	Hard	

440	 K-th Smallest in Lexicographical Order    		26.9%	Hard	

