## dp
837. New 21 Game
this is a extension of climing stairs
with a sliding window to the next stairs.

871. min number of refueling stops
this can using bfs like approach
dp[t] is the max distance using t refuelings (or bfs layers)
we update the dp[t] using its covered nodes.

873. length of longest fib subsequence
A[i]=A[j]+A{k]


877. stone game
a stone is removed and it reduces a subproblem.
so we can use recursive or dp approach.
but this problem can also be solved using greedy since it has several constraints.

887. super egg drop
subproblem: break or not break

903. valid permutation for DI sequence
if char is D, then previous shall be smaller dp[i,j]=sum(dp[i,k]) k>j.
dp[i,j]: valid permutation for subproblem array length=i and ending at j.
it is not so easy to get the subproblem.

913 cat and mouse

920 number of music playlist
N songs, L songs in list.
every song can shall be played at least once.
a song can be played only if k other songs have been played.
dp: subproblem i songs with j different songs.
Think one step before the last one, there are only cases for the answer of dp[i][j]
case 1 (the last added one is new song): listen i - 1 songs with j - 1 different songs, then the last one is definitely new song with the choices of N - (j - 1).
Case 2 (the last added one is old song): listen i - 1 songs with j different songs, then the last one is definitely old song with the choices of j
if without the constraint of K, the status equation will be
dp[i][j] = dp[i-1][j-1] * (N - (j-1)) + dp[i-1][j] * j

If with the constaint of K, there are also two cases
Case 1: no changes since the last added one is new song. Hence, there is no conflict
Case 2: now we don't have choices of j for the last added old song. It should be updated j - k because k songs can't be chosed from j - 1 to j - k. However, if j <= K, this case will be 0 because only after choosing K different other songs, old song can be chosen.

if (j > k)
dp[i][j] = dp[i-1][j-1] * (N- (j-1)) + dp[i-1][j] * (j-k)
else
dp[i][j] = dp[i-1][j-1] * (N- (j-1))


931. min falling path sum
simple dp

940 distinct subsequence II
ending with different char.

115. Distinct Subsequences
find in S the subsequence=T.
edit distance.

960. Delete Columns to Make Sorted III
delete columns and make each row sorted
equivalent to longest increasing subsequence but with n arrays.
955. Delete Columns to Make Sorted II
delete columns columns shall be sorted.
do not need dp.

964. least operators to express number
x based 

975. odd even jump
do it from right. 
visited forms a map and use binary search.

983. min cost for tickets
one day, 7 day and 30 day pass.
for ith day, we can use single day, 7 day or 30 day

1000 min cost to merge stones
merge K consecutive piles into one pile, cost is equal to the k sum

1027. Longest Arithmetic Sequence
dp using difference and i.


1035. Uncrossed lines
equivalent: longest common subsequence


1105. Filling Bookcase Shelves
thickness and height
shelf width.
book order cannot be changed.
return the min height
a book i with Wi and Hi can be placed in kth layer.
the shelf height is decided by the max height.
this is similar to group the array and min the sum of the max.
so the idea is: for group i, either is belongs to previous group or to next group
group is constrained by the width.
if book i, belongs to previous group, then we need to update the max.
if book i, starts a new group, then we need to update the new height.
dp[i] is the min height for the first i books.

1092. Shortest Common Supersequence
need convert to equivalent problems:
find the longest common subsequences
and then build the min supersequence
similar to longest common subsequence length, but we shall use string directly to avoid trace back.

1062. Longest Repeating Substring
direct approach: using O(N^2) to build all the substrings, TLE
dp approach: we only compare one char since previous compare is done.

1044. Longest Duplicate Substring
follow up on 1062, repeated string can overlap.
binary search + direct hash.

1048. longest string chain
common dp practice

1043. Partition Array for Maximum Sum
element can be attached to previous group or itself become a new group
dp with heap.

1039. Minimum Score Triangulation of Polygon
dp with i,j,k O(N^3) to split into one triangle and two subproblems


### knapsack
879. Profitable Schemes
G people, profit p, 
input: profit[i], group[i]. people cannot be repeatedly used.
knapsack.


956. tallest billboard
each element has three options: choose to A, choose to B, or not used
target: sum=0


1058. Minimize Rounding Error to Meet Target
each element can use ceil or floor (+ or -)
so the sum max would be all ceil and sum min is all floor.
it is equivalent to: choose from two arrays to sum to a target
return the smallest rounding error! (since we may have multiple choices)
only has 3 decimals
greedy: we can get number floors and number of ceils. then sort the decimals accoring to the errors

nth_element: partial sort to get the sorted position element.

1049. Last Stone Weight II
smash the stone: equal: both destroyed. smaller destroyed and remaining y-x.
convert to equivalent:
some elements are negative and some are positive, and the sum of positive shall be >= negative sum.
knapsack problem

1046. Last Stone Weight
choose heaviest and smash. this is heap.

### shortest distance problem
847. shortest path visiting all nodes
bit mask status, starting nodes, ....
bfs..
dijkstra...


864. shortest path to get all keys


882. Reachable Nodes In Subdivided Graph
subdivide the edges: we use the original graph, and use subdivided as weight

943. find the shortest superstring
equivalent: make AB the distance, and then find the shortest distance to visit each node once.
- use all words
- build a graph matrix. 
- use dp to find the shortest distance (2d, with status and node) and also path information for tracing back.


## think simple using computer way.
970. powerful integers
just try brutal force loops

982. Triples with Bitwise AND Equal To Zero
triple reduce to N^2 two element bitwise
and then add another.

1103. Distribute Candies to People
it is just a 1 to n and arranged in rows, so do not use those complicated methods
but just use iteration and %

1089. duplicate zeros
in place: two pointer and imagine we are using sufficient memory.

1071. greatest common divisor of strings
using same principle working for numbers.
by subtracting the common.

## two pointer
844. backspace string compare
using stack is trivial
using two pointer from right to left is a bit tricky.

845. longest mountain in array
from left to right: get the length of up
from right to left: get the length of up
tricky

881. boats to save people
greedy using two pointers.
combine the person with the greatest weight and lightest weight.

915. Partition Array into Disjoint Intervals
left side < right side
min size of left side.
get lmax and rmin. and find the first one when lmax<rmin.

923. 3Sum With Multiplicity
using hashmap to record the frequency of each number.
if 3 numbers from 1 set: C(n,3)
if 3 numbers from 2 set: C(m,2)*C(n,1)
if 3 numbers from 3 set: C(i,1)*c(j,1)*C(k,1)


925. long pressed names
two pointer compare

926. Flip String to Monotone Increasing
binary string: left all 0 right all 1
find all positions to be the pivot and get the number of flips


962. Maximum Width Ramp
lmin for the left
and rmax for the right
greedy approach

977 squares of sorted array
two pointer: min may becomes max.

1014. Best sightseeing pair
lmax of A[i]+i and rmax of A[j]-j.

1031 max sum of two non-overlapping subarrays
lmax and rmax from both side



## recursive
984. string without AAA or BBB
base cases: A=0 B=0
when A>B AAB+subproblems
when A==B AB+subproblems


1088. Confusing Number II
return the confusing numbers in [1,N]
approach 1: backtracking, will use a lot of time
approach 2: recursive by adding previous solution 1+xx+1, 8+xx+8, 6+xx+9,9+xx+6
similar to Strobogrammatic Number II, but it only requires length<=n.



## Array
825. Friends Of Appropriate Ages
three conditions: 

826. most profit assigning work
difficulty vs profit
worker ability
for each difficulty level: we find the max profit.
sort the difficulty vs profit.


833. Find And Replace in String
note two cases:
- we shall do it from right to left to avoid index changes
- input is not sorted
- need to first match the substring before replace.

853. Car Fleet
using the time calculated and change to its previous slow and then calculate the group num
direct approach

880. Decoded String at Index
decoded times. and find kth char.
this is quite tricky: we need to track the length until k. and then reverse back to the char. 
if the char is digit, then we need to go back again.


885. spiral matrix III
direction is 112233445566....
only those inside the matrix will be recorded
expanding spiral
54. Spiral Matrix
visiting in spiral order: shrinking spiral
59. Spiral Matrix II
fill the spiral: shrinking spiral.

890. find and replace pattern
from right to left.

912. sort an array.
merge sort
quick sort
bubble sort

916. Word Subsets
use 26 char array instead of hashmap to save time.

918. max sum circular subarray
this is follow up for 1d array.
1d array: if the previous sum <0 we begin a new segment. and find the max.
to avoid circular array: we find the subarray max and min. then get the max of the two answers.

1131. maximum of absolute value expression
first need to remove the abs.
|a[i]-b[j]|+|b[i]-a[j]|+|i-j|, we have 8 combinations (3 +/- selections)
a[i]-b[j]+b[i]-a[j]+i-j  --> [a[i]+b[i]+i]-[a[j]+b[j]+j]
a[i]-b[j]+b[i]-a[j]+j-i --> [a[i]+b[i]-i]-[a[j]+b[j]-j]
a[i]-b[j]+a[j]-b[i]+i-j --> [a[i]-b[i]+i]-[a[j]-b[j]+j]
a[i]-b[j]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
b[j]-a[i]+b[i]-a[j]+i-j --> -[a[i]+b[i]+i]+[a[j]+b[j]+j]
b[j]-a[i]+b[i]-a[j]+j-i --> -[a[i]+b[i]-i]+[a[j]+b[j]-j]
b[j]-a[i]+a[j]-b[i]+i-j --> -[a[i]-b[i]+i]+[a[j]-b[j]+j]
b[j]-a[i]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
then we separate i and j, it is actually 4 cases
we find the min and max and get the max-min


## stack & deque
828. unique letter string
using hashmap with stack.
if a char is smaller and we still have the char in later, then we can safely remove that char in the stack.

838. push dominoes
- add a L on the left and R on the right.
- several patterns LxxxL, LxxxR,RxxxL,RxxxR
- stack approach: 

901. online stock span
typical monotonic stack

907. Sum of Subarray Minimums
brutal force: for each number we get it as the min and expand left and right
- stack: using two stacks to record the previous smaller and next smaller.
	use same previous less one from left to right, one from right to left.
	one stack is sufficient to find both left and right.
	
921. Minimum Add to Make Parentheses Valid
using stack:
if paired, popped. 
if ) and has no match ans++ 
if ( no match they are in the stack

946. validate stack sequence
simulate the stack, a number shall be pushed first before popped

950. reveal card in increasing order.
reveres the process using deque. 

1003. check if word is valid after substitutions
simple stack or deque problem

1006 clumsy factorial
using stack for expression evaluation.
similar to calculator without ()

1019. next freater element in linked list
typical stack problem: montonic

1021. remove outmost parenthesis
using stack or using counters

1130. Minimum Cost Tree From Leaf Values
the array order cannot be changed.
- equivalent: remove the smaller at the cost A[i]*A[j]
- greedy: to min A[i]*A[j] need combine A[i] with its next larger.
- using stack to store a sorted sequence (sorted is a simple greedy)

1081. Smallest Subsequence of Distinct Characters
same as eliminate duplicates
to keep it smaller, when a small char comes, need to replace char in stack.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

1028. Recover a Tree From Preorder Traversal
using iterative stack

### using stack to evalute expression
856. score of parentheses
support A+B and 2*A, two operations


## bfs
841. Keys and Rooms
if we can unlock all the rooms


854. k-similar strings
two anagrams A and B, return the smallest k.
using bfs each time we swap one pair.

909. snakes and ladders
this is a very good bfs question. layer concept.
- convert 2d to 1d array to avoid value-index conversion
- next layer is all the nodes it can go in the next step. including 1 to 6 and ladder.

1024. video stitching
using bfs like to cover the max distance.


1129. Shortest Path with Alternating Colors
- from 0 to all other nodes
- using bfs to get the shortest distance
- the distance can be greater than n since we may need to come back
- form a graph (adjacent matrix) data structure needs 0 for blue and 1 for red
- have two options: first start blue or start red
- we can use simple structure for adj matrix (*2 for blue *2+1 for red)
- self connected edge cannot be ignored since it will be able to connect the path.
- perform two bfs.
* the simple data structure for adj makes the problem a lot simpler.
* using dfs are not good for this. always try bfs first for shortest distance problems.

1102. Path With Maximum Minimum Value
this is similar to the swimming in rising water.
it asks for the min value along the path where all those smaller elements are not passable and there is only one path.
so it is a binary search with a bfs problem

1091. Shortest Path in Binary Matrix
8 directions with 0 and 1 (1 blocked). return the shortest path from top left to bottom right
regular bfs


## dfs
851. loud and rich
dfs

886. possible partition
this is very similar to check bipartition
- we do not need to build adjacency matrix, using edge is fine
- we can use color as the visited array
785. Is Graph Bipartite?

934. shortest bridge
- first find the two islands using dfs
- find the smallest distance between the two islands

935. Knight Dialer
using dp or dfs/recursive

959. regions cut by slashes
need upsample and do the dfs

967. Numbers With Same Consecutive Differences
dfs: try +k and -k. not above 9.

980. Unique Paths III
-1 obstacles, 0: empty, 1 source, 2 target
it requires to walk on every empty cell exactly once. 
return number of path
it needs two requirements: walk on every cell, and reach the end.
just regular dfs.
63. Unique Paths II
number of paths, using dp is faster (with obstacles)
62. Unique Paths
dp or pure math.


996. number of squareful arrays
neighboring elements sum is a square.
return the number of permutations.
build the graph (for each element its neighboring)
and then dfs.


1020. number of enclaves
common dfs

1125. Smallest Sufficient Team
- most important: convert the required skills into bits and simple the problem using dfs.
- non-required skills are ignored.
- do a O(N^2) loop and eliminate those people with same skills, or a subset of skills

1059. All Paths from Source Lead to Destination
- lead to other nodes
- lead to infinite cycle

dfs with cycle detection
using 3 states: visited, not visited, visiting.

1036. Escape a Large Maze
two dfs: block the source, block the target
dfs distance > the block size, then we are outside.

1034. coloring a border
dfs using negative color, restore inner side


## backtracking
842. Split Array into Fibonacci Sequence

## counting in array.
891. Sum of Subsequence Widths
subsequence width= max-min in the subsequence
- only care about max and min, so order does not matter so we can sort to see if it is simpler.
- with A[i] as the min and A[j] as the max, all the elements in the range [i+1,j-1] can be used or not used.

898 bitwise ors of subarray
the idea: save previous results in hash set. and use A[i] to or all previous results
for A[i]
A[i]
A[i],A[i-1]
A[i],A[i-1],A[i-2]...
basically this is a brutal force approach.
but the complexity is O(N), why? since we only have 32 bits

902. Numbers At Most N Given Digit Set
giving n digits (not including 0), find number of integers <=N.
equivalent: assume N has k digits, it can be divided into:
1 digit to k-1 digits, this can be computed using permutation.
1000..0 to N with k digits. this can also be computed using permutation


1012. numbers with repeated digits
equivalent: numbers without repeated digits.

1128. Number of Equivalent Domino Pairs
this is common seen counting in array using hashmap
keep adding the previous occurences
equivalent to 1+2+3+...+k 

1124. Longest Well-Performing Interval
- >8 convert to 1, <=8 convert to -1.
- prefix sum. 
	if prefix[i]>0 then all previous are good.
	if prefix[i]<0 then we need to find previous smaller one
	
1099. Two Sum Less Than K
common practice: sort the visited elements in a map/set and then use binary search to find the elements

560. Subarray Sum Equals K
similar to 1099. 1d

1074. Number of Submatrices That Sum to Target
using tech in 560 and reduce to 1d problem

1067. Digit Count in Range
given a digit d in [0,9], return the number of occurences in [low,high].
- we can get [1, high]-[1,low], high low can be converted to number of digits
same length of digits shall be counted carefully.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

	
## interval problems
850. rectangle area II
this is a very good question on 2d interval
- add a rectangle and remove a rectangle, (x,y,value)
- sort using x.
- calculate the area along all x. (using prefix sum in the 1d interval problem).


855. exam room
direct approach: recording the seats and find the largest interval
849. Maximize Distance to Closest Person
very similar to 855.

986. interval list intersection
two sorted list of intervals, find the intersection.
apply two pointer and check if two intervals intersect.


1109. Corporate Flight Bookings
- add an event and remove an event using map for positive and negatives
- prefix sum to get the results.

1094. car pooling
add passenger and unload passenger


	
## Tree
834. sum of distances in tree.
return the sum of each node to all other node's distance.
this is a hard graph problem. 
- converting tree into graph
- 

862. all nodes distance K in binary tree.
build a graph from the tree and then bfs from the given node.
adj matrix: map<int,vector<int>>

865. smallest subtree with all the deepest nodes
or the lowest common ancestor for all the deepest nodes
O(N^2) using depth
O(N): get the left and right depth, and:
Hleft==Hright, root
left<right, go to right with d-1

236. Lowest Common Ancestor of a Binary Tree
O(N^2): find p and q repeatedly and return 0,1,2,3
O(N): do the find and return the same time
if node==p || node==q, return node
get left lowest common ancestor
get right lowest common ancestor

1123. Lowest Common Ancestor of Deepest Leaves
similar to 865. 
O(N^2) get depth for each node and return the ancestor
O(N): get the depth and the ancestor at the same time.


872. leaf similar trees
traverse and get the leaf array

889. construct binary tree from preorder and postorder
pre: root, left, right
post: left, right, root
so basically find the root and left subtree and right subtree

894. all possible full binary trees
this is a simple recursive problem with left: 1,3,5,7,.... 


897. increasing order search tree
BST-linked list (in place)
using right,root,left might be easier with a helper pointer prev.

919. Complete Binary Tree Inserter
this is very interesting using array to implement a tree.


938. Range Sum of BST
easy

951. flip equivalent binary tree
left-left & right-right
left-right & right-left

958. check completeness of a binary tree.
- bfs approach: when we see a null node, there shall have no nodes after
- dfs approach: left depth is always>=right depth. (preorder).

965. univalued binary tree.
passing the root value to subtree

968 binary tree cameras
greedy: put the camera on the parent, so it can cover children and parents.
using status to reflect if the root is monitored or not.
do it from bottom to root.

971. Flip Binary Tree To Match Preorder Traversal
array is a binary tree (some subtrees flipped) preorder traversal
first match the node, and then match left/right or right/left.

979. distribute coins in binary tree

also similar to the washing machine. the abs(diff) is the coins up/down the root.

987. Vertical Order Traversal of a Binary Tree
record depth, and x, and value
there are overlaps (same position)
preorder:
then sort according to requirements.

988. Smallest String Starting From Leaf
simple dfs, when reaching leaf, reverse the results.

993. cousins in binary tree
only need to keep the parent information and depth information


654. max binary tree
build from array: max as the root, left is left subtree, right is right subtree
heap. (used for map, set data structure, pq uses complete full binary tree).

998. max binary tree II
append a number to the array, and return the max binary tree
- empty and it shall be the root
- > root, it shall be the root, original root shall be its left
- <root, it shall go to the right

1008. construct binary search tree from preorder traversal
BST, preorder, the root is always the first and divide by left and right
using upper_bound

1022. sum of root to leaf binary number
preorder/dfs/recursive

1026. max difference between node and ancestor
preorder and find the min and max of all prefix.

1028. Recover a Tree From Preorder Traversal
iterative stack

1038. Binary Search Tree to Greater Sum Tree
reverse inorder traversal
similar to array's suffix sum


1123. Lowest Common Ancestor of Deepest Leaves
O(N^2) is easy
O(N): first find the left depth and right depth of the root one pass. second pass find the node with depth-1.
O(N) single pass: get the depth and the node at the same time.

1120. Maximum Average Subtree
average: need to get the sum and number of nodes.
using postorder traversal, we get the sum and number of nodes for its left/right subtree and then get the results for the root.

1110. Delete Nodes And Return Forest
when a node is to br removed, we need update its parent and child becomes another tree
do not forget the root when it is not removed.
google phone screen

1104. Path In Zigzag Labelled Binary Tree
full tree, the node from leaf to parent is n/2 and apply the zigzag relation.

1080. Insufficient Nodes in Root to Leaf Paths
all path passing the node sum<limit.
O(N): the limit - val. if leaf<limit, return null, the left and right both returns null, then the root is also removed.

## greedy
861. score after flipping matrix
greedy: keep the leftmost bits as 1 then keep the num of 1s in each column >= num of 0s.

870. advantage shuffle
greedy: use weakest to match the one we cannot beat. using the weakest one who can beat.

910. smallest range II
add +k -k
greedy: equivalent to add 0 or 2k.
from left to right, add 2k to see if we can reduce the difference.
908. smallest range I
add a number between [-K,K]. so we can reduce the range by 2K to 0


932. beautiful array
A[k]*2!=A[i]+A[j]
starting from [1].
left odd and right even. expand.
[1]
[1,2]
[1,3,2,4]
[1,5,3,7,2,6,4,8]
.....

936. Stamping The Sequence
reverse from target to source
using greedy match.

942. DI string match
use two end meet. D choose the max, I choose the min


945. min increment to make array unique.
sort first and add 1.

948. Bag of Tokens
greedy: use the point for max power and use least power to gain points

949. largest time for given digits.
from the right, if we have larger digits, choose it.
otherwise, choose the smallest.

969. Pancake Sorting
greedy: flip the min to the top, repeat.

991. broken calculator
only support *2 and -1. 
min number of operations from x to y.
we can also do from y to x, and is more clear. /2 +1

995 min number of k consecutive bit flips
min number of flips needed to make it all 1.
greedy: turn the left most bit 0.

1005. max sum of array after k negations
greedy: try to negate those negatives. after that, we need compare the last negated negative with the smallest original positive

1007. min domino rotations for equal row.
either all rotate to a[0]
either all rotate to b[0]
do it one by one, do not involve two things. do it simple way.


1025 divisor game
greedy: odd/even

1029. two city scheduling
greedy 1: send all to A and then send those most saving to B.

1053. Previous Permutation With One Swap
to make it smaller with one swap.
greedy: find the first peak from right to left, and swap with leftmost element in its right < peak.

1042. Flower Planting With No Adjacent
garden has no more than 3 neighbors
greedy: make a graph and chose available color

1041 robot bounded in circle
greedy: try a whole cycle or more cycles. repeat 4 times and we would be able to do it.
common practice: rotation


## heap
857. min cost to hire k workers
quality, wage expectation, ....
this is quite tricky: 
the pay ratio shall be the highest ratio, and the total is proportional to the total quality.
so use a heap to remove those largest quality to see if we can reduce the cost.



973. k closest points to original
heap

1121. Divide Array Into Increasing Sequences
greedy: choose K increasing subsequences from the most frequent one
just like to get rid of a layer from the mountain and until it is flat

1090. Largest Values From Labels
values, labels
limited K from each labels
return the max sum
it is natually using heap.
first store the values vs label in a sorted map from larger to smaller.

1086. High Five
top five scores, using minheap to keep only 5 scores.

1066. Campus Bikes II
N workers and M bikes.
min manhattan distance and lowest index bike.
need work on it.

1057. Campus Bikes
sorting all combinations.

1054. Distant Barcodes
rearrange so that no neighboring are the same
using heap to arrange the two most common words

## trie
1032 stream of characters
matching with the prefix, startwith




## union find
827. making a large island.
- union find and merge to several islands
- try all 0 cell and to see if we can connect to its neighboring islands
- get the size (it may connect multiple islands)

839. Similar String Groups
typical union-find

924. Minimize Malware Spread
return the first node which can minimize the infected nodes by removing it from initial list.
ie, assuming the node is not affected.
- parent node - the initial nodes, find the one with largest size

928. Minimize Malware Spread II
initial list: remove one infected nodes and disconnect its neighbors.
union find in a reverse way: 
build the disjoint set without the infected
add one by one by disable the node only and add all other nodes, and check which one forms the largest number of elements.
we are not doing merge but only count the number of sets to be union and count the number


947. most stones removed with same row or column
use dfs or union-find, similar to number of islands

952. Largest Component Size by Common Factor
connect the numbers when they share a factor.
use prime factorization for each element.


990. Satisfiability of Equality Equations
use == relation and merge them and use != to check them

1101. The Earliest Moment When Everyone Become Friends
union and find the earliest time that unites as one group

1061. Lexicographically Smallest Equivalent String
union and use each group's parent.


## sliding window
904. fruit into baskets
equivalent: longest window which contains <= 2 kind of trees

927. three equal parts
binary array: leading zeros and trailing zeros, need to have the same pattern

930. Binary Subarrays With Sum
find the window contains S number of 1s, and then the left and right 0s.
we can store all the 1s position and do sliding window on it.

978. longest turbulent subarray
we can use simple counting of +- sign
similar to sliding window.

992. subarrays with k different integers
subarray contains exactly k different integers.

sliding window using hashmap

1004. Max Consecutive Ones III
change up to k 0 to 1. longest subarrays
equivalent to find the longest window with at most k 0s
487. Max Consecutive Ones II
flip at most one 0 to 1. 
equivalent to longest window with <=1 zeros inside
485. Max Consecutive Ones
max window of consecutive ones

1100. Find K-Length Substrings With No Repeated Characters
sliding window with win=K and using hashmap to add a new char and remove old char.

1055. Shortest Way to Form String
copy source (by deleting some chars) to get target.
using sliding window matches.

1052. grumpy bookstore owner
convert to equivalent sliding window with most grumpy which <= k.

1040. Moving Stones Until Consecutive II
equivalent: find the window with min vacancies.


## binary search
852. peak index in a mountain array
simple binary search: using A[m]<A[m+1]

875. koko eating bananas
equivalent: search and count binary search typical

878. Nth magical number
equivalent: binary search and count, and then get the solution.
min(A,B), max:N*lcm(A,B)

981. Time Based Key-Value Store
time value
get: give a timestamp, return the t<=timestamp. (closest)
binary search using upper_bound

1011. capacity to ship packages within D days
binary search to find the capacity

1095. find in mountain array
fidn the peak
find in left and then find in right

1060. Missing Element in Sorted Array
kth missing elements in sorted array.
using the first element (subtract all the element with it) and then we know:
nums[i]-nums[0]-i is the number of missing number.
must be familiar with tech to convert to equivalent simple problems.

## hashmap
846. hand of straights
it needs some tricks, use a map to get its neigbors

874. Walking Robot Simulation
left/right rotation and find the max distance.
with obstacles.

893. Groups of Special-Equivalent Strings
the description is odd, but it is equivalent:
the odd index and even index string shall be equal so we build a common key

929. Unique email address
some simple string operations and hash

937. reorder log files
make sure using multimap to avoid key the same and log get lost.

953. verifying an alien dictionary
both mapped to a known order

957. prison cells after n days
hash to record the status and find the period

963. Minimum Area Rectangle II
rectangle is on the circle. using the circle center and diameter as the hash.
939. Minimum Area Rectangle
rect is along x and y axis. more similar to 2d intervals
using hash for x and y and divide and conquer.

966. Vowel Spellchecker
first exact match
second, case ignore match
third: vowel misspell.

997 find the town judge
the guy knows nobody but all knows him.

1001 grid illumination
row, col, diag, anti-diag
lights


1010. Pairs of songs with total duration divisible by 60.

1122. Relative Sort Array
sort using arr2. (using hashmap and count sort)

1072. Flip Columns For Maximum Number of Equal Rows
need convert to equivalent problem:
flip the column. we are actually looking for the same pattern for all the rows

## parsing a string or expression evaluation
this is where recursive approach most powerful.

1106. Parsing A Boolean Expression
- single t or f.
- ! use true & the result, and use true & the result, or use false | the results
- the , can be ignored and do recursively

1096. Brace Expansion II
using stack and recursion
default operation: union using ,
to avoid duplicate using hashset
stack of hashset
1087. Brace Expansion
return all combinations
there are no nested braces. so just connect them using dfs


## Misc
1111. Maximum Nesting Depth of Two Valid Parentheses Strings
min the max(depth(A),depth(B))
we try to make depth a and depth b similar to minimize
Basically, ( is 1 point, ) is -1 point.
We try to keep total points of two groups even,
by distributing parentheses alternatively.

The good part of this solution is that,
we actually need no extra variable to record anything.

1023. camelcase matching
1016. binary string with substring representing 1 to N.
brutal force searching

954. Array of Doubled Pairs
negative and positive two parts
sort and from smallest.

906 super palindrome
direct approach: 
odd and even, determine the range of the solution
and try its square and see if it is also a palindrome.

899. Orderly Queue
move the first k letters to end.
k==1
k>1 swap, when having two more positions it is equivalent to swap.

### count sort

1093. Statistics from a Large Sample
this is already count sorted results, each element has a count and without restoring the sequence, we need to find the element
prefix sum of the counters and find the element.

900 RLE iterator
this is similar idea: count and the array value and then search.


### combination and permutations
1079. Letter Tile Possibilities
- dfs and eliminate duplicates and using permutation.

### math problem
829. consecutive numbers sum
just check brute force: if it can be decomposed to : x,x+1,x+2....x+i.

836. rectangle overlap
835. image overlap
max of two left
min of two right

848. shifting letters
- %26 circular
- prefix sum

858. Mirror Reflection
mirror reflection is equivalent as modular operation
hence we unwrap the reflection.

866. Prime Palindrome
just try all possible palindrome: all even palindrome are divisible by 11, so can be ignored.

869. reordered power of 2
just try the 32 numbers.

883. projection area of 3d shapes

892. surface area of 3d shapes
common practice: only check with previous shapes and remove the covered surface areas.

1073. adding two negabinary numbers
using & and >>

1018. binary prefix divisible by 5
%5 and accumulate

1017. convert to base -2
using & and >>

1015. smallest integer divisible by K.
digits are all 1. using pigeon hole principle.
and %K and accumulate

1009. complement of base 10 integer
change binary bits from 0 to 1

974. Subarray Sums Divisible by K
prefix sum %K (also note for negatives)
and then count sort.

972. equal rational number
expand the number till double precision

## linked-list
876. middle of the linked list.
slow and fast.


## design
895. max frequency stack
the idea: for each frequency build a stack: hash: frequency vs stack
value - frequency
freq - stack.


## trivial
1119. Remove Vowels from a String
1118. Number of Days in a Month
leap year is: %4==0 %100==0 && %400==0
1108. Defanging an IP Address
replace . with [.]
1085. Sum of Digits in the Minimum Number
1078. Occurrences After Bigram
just understand the problem correctly.
1065. Index Pairs of a String
1064. Fixed Point
A[i]==i binary search
1056. confusing number
1051. Height checker
1047. Remove All Adjacent Duplicates In String
simple stack problem
1037. valid boomerang
1030. matrix cells in distance order
1002. find common characters
999. available captures for rook
994. rotting oranges
one step bfs
989. add to array form of integer
985. sum of even numbers after queries
961. n-repeated element in size 2n array
majority or hashmap
933. number of recent calls
922. sort array by parity II
917. reverse only letters
914. x of a kind in a deck of cards
gcd
905. sort array by parity
896. monotonic array
888. Fair Candy Swap
simple math and set.
884. uncommon words from two sentences
868. binary gap
867. transpose matrix
860. lemonade change
859. Buddy Strings
swap only two letters in A so that A==B
840. magic squares in grid
832. flipping an image
831. masking personal information
830. positions of large group: simple two pointer
824. goat latin











