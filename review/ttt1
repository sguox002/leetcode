## dp
221. maximal square.
the idea: get the longest left 1s and up longest 1st
and then the min of the two
reduced to 1d: get the min of the two direction
if top and left are 1: then dp[i]=dp[i-1] (i,i) vs (i-1,i-1)


542. 01 matrix
do it like 1d array, from left to right and then right to left to update the distance.

256. paint house
n houses with 3 different colors, no adjacent color, each color with different costs. find the min cost
dp: if i-1 house is painted with color 0, then i house can be colored with 1 or 2
dp[i][0] color with red
dp[i][1] color with green
dp[i][2] color wth blue

265. paint house II
k colors.
if previous house is painted with color k, then 
dp[i][j]=min(dp[i-1][k])+cost[i][j] k!=j.
base: 0 houses all costs=0
initial it as INT_MAX
skip when previous is not zero and color the same
O(mn^2)
optimize: reduce 2d dp 1d and reduce complexity from O(mn^2) to O(mn)

276. paint fences
it asks the number of painting ways
with k colors
<=2 adjacent fence can have the same color.
we have same and diff two choices
same[i]=diff[i-1]
diff[i]=(k-1)*(same[i-1]+diff[i-1]) we have k-1 choices



300. longest increasing subsequence

309. best time to buy and sell stocks with cooldown

313. super ugly number
dp for n ugly primes
312. burst balloons
consider from the last condition first and get clear subproblem definition
264. ugly number II
nth ugly number with only 2,3,5 prime factors

263. Ugly number
check if it is a ugly number


337. house robber III
in a tree
using memoization
similar: 198. house robber, in 1d array
213. house robber II, in circular array

338 counting bits
from 0 to n, counting set bits in each number.
f[i]=f[i/2]+(i%2)
i&(i-1) drops the LSB
f[i]=f[i&(i-1)]+1


351. Android unlock patterns
the key observations:
4 corners are the same (1379)
(2468) are the same
skippable: 2,4,6,8,5
354. Russian Doll envelopes
similar: longest increasing subsequence

361. bomb enemy

it is hard to think it as dp problem.
i think it is union find problem

brutal force: a W will separate the row and column into two parts
loop all rows
	loop the row
	see a W or the leftmost: reset row counter
	count number of E until hit W.
	
	
368. Largest Divisible Subset
sort and use dp

376. wiggle subsequence
find the longest wiggle subsequence (not subarray)
use up and down, interleaving
280. wiggle sort
unsorted array, rearrange so that a[0]<=a[1]>=a[2]<=a[3]>=a[4]...
in-place O(1), and O(N) complexity
O(N), odd position violates, even position violates and swap.
approach II. sort and swap.
324. wiggle sort II.
unsorted array, rearrange so that a[0]<a[1]>a[2]<a[3]>a[4]...
idea: using the median value parition into two parts (left and right) and then choose one from left and one from right
the difficulty is how to find the median.
using nth element to find the median
and then arrange the array into three parts <median ==median and >median
this we can use 3 pointer to arrange. 
A[j]<med, swap(A[i++],A[j++])
A[j]>med, swap(A[j],A[k--]) note j cannot move formward since we need do another compare
A[j]==med, j++

for example:
3,1,2,4,3,5,4,1, med=3
3,
check 1: 1,3,2,4,3,5,4,1
check 2, 1,2,3,4,3,5,4,1
check 4: 1,2,3,1,3,5,4,4
check 1: 1,2,1,3,3,5,4,4
check 3:
check 5: 1,2,1,3,3,4,5,4
done

then rearrange into wiggle form. 
for n%2==0, arrange it into even, right part into odd positions
for n%2==1, arrange n/2+1 into even, 
this is also tricky to do inplace:
1,2,1,3,3,4,5,4 i=0, j=4
move 3 to position 1:
1,3,2,1,3,4,5,4
move 4 to position 3:
1,3,2,4,1,3,5,4
move 5 to position 5
1,3,2,4,1,5,3,4
but this is not O(n).


1139. Largest 1-Bordered Square
record each position's left and top 1's length
and then check at each position the longest square can form

1143. longest common subsequence
simple dp

1140. Stone Game II
M=1 initially
x in the range [1,2M]
after that M=max(M,x)
overlapping problems
if A choose x, remaining problem is [x,n] with M=max(x,M), x=[1,2M]
return max A can get.
A+B=tsum
max A-B
need 2d dp: 
dp[i,j] represents the max stone A can get starting at i with M=j.
dp[i,j]=max(suffix[i]-dp[i+x][max(j,x)] x in the range [1,2j]


403. Frog Jump
frog can jump k-1,k,k+1, k is previous step
this can be solved using recursive approach
pretrim: when neigboring elements > i, then cannot reach

446. arithmetic slices II-subsequence
dp: using vector of map since diff is not in limited range
413. Arithmetic Slices
return the number of slices
dp[i]: once we find 3, we add previous dp.

464. can I win.
choose from 1 to n, and add to a target, whoever get >=target wins
two players play optimally.
a number cannot be reused.
use bit to indicate if it is used.
use win and lose for memoization
top down recursive approach.

471. Encode String with Shortest Length
encode it into k[str], it adds k and []
encode must make the string shorter.
string i,j can be encode into shorter string.
"abbbabbbcabbbabbbc"
abbb repeat twice, 2[abbb]c2[abbb]c.
and this can be encoded again as 2[2[abbb]c]
recursive (top down could be easier?)
any good way to detect the repeating pattern?

dfs: (recursive approach)
using from 0 to i and see if we have repeat
check if encoded string is shorter
update.


472. Concatenated Words
a list of dictionary words find all strings which can be concatenated by other strings in the dictionary
-. only longer string can do this
-. solve the string using previous smaller strings.
-. mark all the positions and concat. (dp problem)
this also can be done using dfs/backtracking.

486. Predict the Winner
classical subproblems
two player take turns: using a-b.

514. Freedom Trail
dp[k,j] ring position and code

517. Super Washing Machines
subtract the average
passing all loads (negative or positive) to left
and the passing max or the single machines load, max

516. Longest Palindromic Subsequence
approach 1: find the longest common subsequence between s and rs (reversed)- edit distance
approach 2: check dp[i,j] ..


568. maximize vaction days
N cities
flights[i][j] represents airline between city i and j. 0 means no flights
k weeks to travel
take flights at most once per day
only take flights on Monday morning
days[i,j] vacation days in the city i and week j.
initil position in city 0 on Monday.
flights=
[0,1,1]
[1,0,1]
[1,1,0]
days
[1,3,1]
[6,0,3]
[3,3,3]
week 0 flight to city 1, take 6 days vacation
week 1 flight to city 2, take 3 days vacation
week 2 stays at city 2, take 3 days vacation

days = [
[7,0,0],
[0,7,0],
[0,0,7]]
week 0: 7 days at city 0
week 1: 7 days at city 1
week 2: 7 days at city 2

dp[i,j] represents the max days in week i at city j.
dp[i,j]=max(dp[i-1,k]+days[j][i]
i only depends on i-1, so space complexity can be reduced.


546. remove boxes


551 student attendenace record I.
552 student attendance record II
dp: valid without A, and then add A any position.

583. Delete Operation for Two Strings
edit distance problem

600. Non-negative Integers without Consecutive Ones
use two dp array dp0 ending with 0, dp1 ending with 1
need to remove the extra where >=N.

629. k inverse pairs array
array 1 to n, find the number of permuations which have exactly k inverse pairs
recurrence relation dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-i]
if we put n as the last number then all the k inverse pair should come from the first n-1 numbers
if we put n as the second last number then there's 1 inverse pair involves n so the rest k-1 comes from the first n-1 numbers


634. Find the Derangement of An Array
array 1 to n.
a permutation where none of the element is in its original position
count the number of derangement.
we have n! permutations.
1 can be put any position except 0.
2 can be put any position except 1.
...
dp[0]=1 []
dp[1]=0 [1]
dp[2]=1 [1,2]

dp[n]=(n-1)*(dp[n-1]+dp[n-2])


639. decode ways II
combine with previous digit or on its own.


646. max length of pair chain
similar to max increasing subsequence

647. palindromic substrings
count how many palindrome substring
using dynamic: dp[i,j]=dp[i+1,j]+dp[i,j-1]-dp[i-1,j-1]
must make sure the inside is palindrome.

712. min ascii delete sum for two strings

714. best time to buy and sell stocks with transaction fee
121. best time to buy and sell stock
allows at most one transaction
dp[i]=max(dp[i-1],price[i]-price[j])
note: do not accumulate.

651. 4 keys keyboard
A, ctrl-a, ctrl-c,ctl-v.
for N times, max number of A can be printed.
dp[i] = max(dp[i], dp[i-j]*(j-1)) j in [3, i)

650. 2 Keys Keyboard
copy all and paste all.
dp[i-1]=dp[j-1]+i/j

656. coin path
A: index from 1, -1: you cannot jump, A[i] is the cost.
integer B: the largest step you can jump. i+1,i+2...i+B.
return the jump path using min cost.
if multiple path exist, return the lexico smallest.
[1,2,4,-1,2], jump 2.
do it from right to left and then we can always choose the leftmost solution
note: there are multiple paths in the solution. so we need use linked-list searching for the path.
path[i] is the next position of i.

553. strange printer
similar to removing box

718. Maximum Length of Repeated Subarray
larget common subarray or substring.

730. count different palindromic subsequences
only have abcd.
dp[i][x] is for the subproblem length=i and ending with x.


740. delete and earn
similar to robber, using bins to store.

741. cherry pickup
two branches to walk simultaneously.


764. Largest Plus Sign
brutal force to search at each position
dp: 4 direction growing.

790. Dominio and Tromino tiling
using two types of shape to reach 2*N shape.

799. champagne tower
surplus goes to i+1,j and i+1,j+1

801. Minimum Swaps To Make Sequences Increasing
two arrays, swap A[i] B[i]
return the min numbers of swaps to make both increasing.
swap & noswap
A[i]>A[i-1] && B[i]>B[i-1]
if we swap, we also need swap i-1.
if no swap, then i-1 also no swap

A[i]>B[i-1] && B[i]>A[i-1]
if we swap i, we shall not swap i-1
if we not swap i, we shall swap i-1



808. Soup Servings
this can be recursive or dp.

813. Largest Sum of Averages
parition into <=k groups
score: the sum of average of each group
return the largest score.
dp[i,j] is for array length i and divide into k groups
we check previous to see A[i] to A[j] is a added group and get the max.


818. race car

837. New 21 Game
this is a extension of climing stairs
with a sliding window to the next stairs.

871. min number of refueling stops
this can using bfs like approach
dp[t] is the max distance using t refuelings (or bfs layers)
we update the dp[t] using its covered nodes.

873. length of longest fib subsequence
A[i]=A[j]+A{k]


877. stone game
a stone is removed and it reduces a subproblem.
so we can use recursive or dp approach.
but this problem can also be solved using greedy since it has several constraints.

887. super egg drop
subproblem: break or not break

903. valid permutation for DI sequence
if char is D, then previous shall be smaller dp[i,j]=sum(dp[i,k]) k>j.
dp[i,j]: valid permutation for subproblem array length=i and ending at j.
it is not so easy to get the subproblem.

913 cat and mouse

920 number of music playlist
N songs, L songs in list.
every song can shall be played at least once.
a song can be played only if k other songs have been played.
dp: subproblem i songs with j different songs.
Think one step before the last one, there are only cases for the answer of dp[i][j]
case 1 (the last added one is new song): listen i - 1 songs with j - 1 different songs, then the last one is definitely new song with the choices of N - (j - 1).
Case 2 (the last added one is old song): listen i - 1 songs with j different songs, then the last one is definitely old song with the choices of j
if without the constraint of K, the status equation will be
dp[i][j] = dp[i-1][j-1] * (N - (j-1)) + dp[i-1][j] * j

If with the constaint of K, there are also two cases
Case 1: no changes since the last added one is new song. Hence, there is no conflict
Case 2: now we don't have choices of j for the last added old song. It should be updated j - k because k songs can't be chosed from j - 1 to j - k. However, if j <= K, this case will be 0 because only after choosing K different other songs, old song can be chosen.

if (j > k)
dp[i][j] = dp[i-1][j-1] * (N- (j-1)) + dp[i-1][j] * (j-k)
else
dp[i][j] = dp[i-1][j-1] * (N- (j-1))


931. min falling path sum
simple dp

940 distinct subsequence II
ending with different char.

115. Distinct Subsequences
find in S the subsequence=T.
edit distance.

960. Delete Columns to Make Sorted III
delete columns and make each row sorted
equivalent to longest increasing subsequence but with n arrays.
955. Delete Columns to Make Sorted II
delete columns columns shall be sorted.
do not need dp.

964. least operators to express number
x based 

975. odd even jump
do it from right. 
visited forms a map and use binary search.

983. min cost for tickets
one day, 7 day and 30 day pass.
for ith day, we can use single day, 7 day or 30 day

1000 min cost to merge stones
merge K consecutive piles into one pile, cost is equal to the k sum

1027. Longest Arithmetic Sequence
dp using difference and i.


1035. Uncrossed lines
equivalent: longest common subsequence


1105. Filling Bookcase Shelves
thickness and height
shelf width.
book order cannot be changed.
return the min height
a book i with Wi and Hi can be placed in kth layer.
the shelf height is decided by the max height.
this is similar to group the array and min the sum of the max.
so the idea is: for group i, either is belongs to previous group or to next group
group is constrained by the width.
if book i, belongs to previous group, then we need to update the max.
if book i, starts a new group, then we need to update the new height.
dp[i] is the min height for the first i books.

1092. Shortest Common Supersequence
need convert to equivalent problems:
find the longest common subsequences
and then build the min supersequence
similar to longest common subsequence length, but we shall use string directly to avoid trace back.

1062. Longest Repeating Substring
direct approach: using O(N^2) to build all the substrings, TLE
dp approach: we only compare one char since previous compare is done.

1044. Longest Duplicate Substring
follow up on 1062, repeated string can overlap.
binary search + direct hash.

1048. longest string chain
common dp practice

1043. Partition Array for Maximum Sum
element can be attached to previous group or itself become a new group
dp with heap.

1039. Minimum Score Triangulation of Polygon
dp with i,j,k O(N^3) to split into one triangle and two subproblems


### knapsack
1155. Number of Dice Rolls With Target Sum
dice with f faces, dp knapsack with repeat.
can optimize using 1d dp space

377. combination sum IV
no duplicates, allow repetive use.
return the number of combinations
dp[i] represents the number of combinations for target i.

dp[i]+=dp[i-num[i]], climbing stairs.
39. Combination Sum
find all unique combinations, input has no duplicates.
allows repeated using the same number.
backtracking using the same position

40. Combination Sum II
allow using only once
backtracking with advance the position

216. combination sum III
giving k numbers sums to target n.
numbers from 1 to 9
unique solutions
backtracking with k numbers in 1-9

474. ones and zeros
you have m 0s and n 1s, and a list of 01 strings
return the max number of words can be chosen.
dp[i,j]=max(dp[i,j],dp[i-mk][j-nk]  mk and nk is the number of 0s and 1s in string k.

494. target sum
using +/- to reach a target
a+b=tsum
a-b=target
it is a variation of knapsack.
note: the 1d optimization is from 2d dp problem.

518. coin change 2
dp[i]+=dp[i-c] for all combinations
322. coin change
min number of coins
pick or not pick the coin
allows repeatition


416. partition equal subset sum
- no need 2d but using 1d
- using vector<int> to get the sum
- return target=sum/2
base condition: sum=0, all true, not selecting any of it.

2d approach using bool:
dp[i-1][j] || dp[i-1][j-nums[i-1]]
base: target=0 for all dp[i][0]=1
then we can optimize it in space. (using reverse looping)

698. Partition to K Equal Sum Subsets
backtracking: 

other similar problem: 
minimize the difference sum of the two parts. maxmize the one group sum bound by tsum/2
the input has negatives: shift to all positives

548. Split Array with Equal Sum
triplet (i,j,k) cut it into 4 segments, left, right, mid1, mid2
so we can start from left and right, check if we can get a target sum.
tsum=4*psum+A[x]+A[y]+A[z].
prefix sum from left. and try all combinations (fix x and z).
suffix sum from right.

638. shopping offers
combine the price and the quantity
need to match both exactly.

823. binary trees with factors
equivalent: all nodes shall be from the array, so combinations shall be a[i], a[j] has a common factor



879. Profitable Schemes
G people, profit p, 
input: profit[i], group[i]. people cannot be repeatedly used.
knapsack.


956. tallest billboard
each element has three options: choose to A, choose to B, or not used
target: sum=0


1058. Minimize Rounding Error to Meet Target
each element can use ceil or floor (+ or -)
so the sum max would be all ceil and sum min is all floor.
it is equivalent to: choose from two arrays to sum to a target
return the smallest rounding error! (since we may have multiple choices)
only has 3 decimals
greedy: we can get number floors and number of ceils. then sort the decimals accoring to the errors

nth_element: partial sort to get the sorted position element.

1049. Last Stone Weight II
smash the stone: equal: both destroyed. smaller destroyed and remaining y-x.
convert to equivalent:
some elements are negative and some are positive, and the sum of positive shall be >= negative sum.
knapsack problem

1046. Last Stone Weight
choose heaviest and smash. this is heap.

### shortest distance problem
317. Shortest Distance from All Buildings
matrix: 0 empty land, 1, building, 2, obstacles
find an empty place which has shortest distance to all building.
building and obstacles cannot pass.
using bfs: 
either from building to empty cells or empty cells to building
a single bfs will get those reachable cells, with the shortest distance to building i.
non-reachable are discarded.
and then accumulate the distance
note:
first time just assign the distance
later we use a tmp map to store current time dist (must occur in previous)
and then accumulate the results back.

743. Network Delay Time
bellman algorithm: loop over all nodes and using all edges to relax the distance

787. Cheapest Flights Within K Stops
can use dp to relax: loop over k times and using the edges to relax the distance.


847. shortest path visiting all nodes
bit mask status, starting nodes, ....
bfs..
dijkstra...


864. shortest path to get all keys


882. Reachable Nodes In Subdivided Graph
subdivide the edges: we use the original graph, and use subdivided as weight

943. find the shortest superstring
equivalent: make AB the distance, and then find the shortest distance to visit each node once.
- use all words
- build a graph matrix. 
- use dp to find the shortest distance (2d, with status and node) and also path information for tracing back.


## think simple using computer way.
970. powerful integers
just try brutal force loops

982. Triples with Bitwise AND Equal To Zero
triple reduce to N^2 two element bitwise
and then add another.

1103. Distribute Candies to People
it is just a 1 to n and arranged in rows, so do not use those complicated methods
but just use iteration and %

1089. duplicate zeros
in place: two pointer and imagine we are using sufficient memory.

1071. greatest common divisor of strings
using same principle working for numbers.
by subtracting the common.

## two pointer
259. 3sum smaller
find the number of triplets with sum<target
reduce to O(N^2)

15. 3sum 
triplet sum==target (0)
3 pointers

16. 3sum closest
similar to 3sum


392. is subsequence

457. circular array loop
positive: go forward num step
negative: move backward num step
array is a cycle.
determine if there is a cycle
approach: check each element as start, using hashset to store seen.
mark non cycle elements to 0 and ignore them.

524. Longest Word in Dictionary through Deleting
loop for each word
for each word, using two pointer

763. Partition Labels
each char appears only in one part.
this is also a bfs like approach:
we record each char's last index
everytime we see a char, we update our max range(like bfs)
if our max range==current char's last position, we got a partition.

795. Number of Subarrays with Bounded Maximum
[L,R]
sliding window: 
pre: the sliding window left, 
low: 
maxp: 
A[i] in the range [L,R], i-pre+1
A[i]<L && L<=maxp:  low-pre+1
A[i]>R: reset low, pre, maxp.
still complicated
another approach:
convert to find <=R and <=L-1 two subproblem.
then it is much simpler, it is common practice for range problems.

809. expressive words
using two pointer to match and counter each char's repeat times.


844. backspace string compare
using stack is trivial
using two pointer from right to left is a bit tricky.

845. longest mountain in array
from left to right: get the length of up
from right to left: get the length of up
tricky

881. boats to save people
greedy using two pointers.
combine the person with the greatest weight and lightest weight.

915. Partition Array into Disjoint Intervals
left side < right side
min size of left side.
get lmax and rmin. and find the first one when lmax<rmin.

923. 3Sum With Multiplicity
using hashmap to record the frequency of each number.
if 3 numbers from 1 set: C(n,3)
if 3 numbers from 2 set: C(m,2)*C(n,1)
if 3 numbers from 3 set: C(i,1)*c(j,1)*C(k,1)


925. long pressed names
two pointer compare

926. Flip String to Monotone Increasing
binary string: left all 0 right all 1
find all positions to be the pivot and get the number of flips


962. Maximum Width Ramp
lmin for the left
and rmax for the right
greedy approach

977 squares of sorted array
two pointer: min may becomes max.

1014. Best sightseeing pair
lmax of A[i]+i and rmax of A[j]-j.

1031 max sum of two non-overlapping subarrays
lmax and rmax from both side



## recursive
241. Different Ways to Add Parentheses
+-* add different parenthesis and get all possible results.
divide and conquer
() can be added in before and after numbers
so use recursive and combine results

when 
246. Strobogrammatic Number
check if a number is strobogrammatric. (look the same when rotated 180 degree)
upside down, and left to right.
247. Strobogrammatic Number II
find all Strobogrammatic number that are of length n.
idea: build from smaller solutions
n=0 {}
n=1, 0,1,8
n=2, by adding {1,1},{8,8},{9,6},{6,9} based on n=0
n=3, by adding {1,1},{8,8},{9,6},{6,9} based on n=1
248. Strobogrammatic Number III
given a range [low,high] and find the number of Strobogrammatic Number in the range.
- equivalent to: number(high)-number(low-1), we already know get the number for length n.
for example 123, we can get length=1, and 2 ie 1 to 99.
then we have 101,111,...
dp[0]=1, dp[1]=3, dp[2]=5, dp[i]=dp[i-2]*5

- dfs: generate all the numbers in the range.


805. split array with same average
- split the array into two parts by moving into two lists, so order does not matter.
- assume we have m for list 1, and n for list 2. Sum(A)/m=Sum(B)/n with Sum(A)+Sum(B)=tsum, m+n=len.
- we get Sa=tsum*m/len. Sa must be an integer, so tsum*m%len==0
- now it reduces to combination sum.

984. string without AAA or BBB
base cases: A=0 B=0
when A>B AAB+subproblems
when A==B AB+subproblems


1088. Confusing Number II
return the confusing numbers in [1,N]
approach 1: backtracking, will use a lot of time
approach 2: recursive by adding previous solution 1+xx+1, 8+xx+8, 6+xx+9,9+xx+6
similar to Strobogrammatic Number II, but it only requires length<=n.



## Array & string
214. shortest palindrome
adding characters in the front of a string.
brutal force: from the end to left we check each substr to end and see if it is a palindrome. the first one is the shortest
will get TLE

- O(N)- KMP
- recursive: 
228. Summary Ranges
group continuous number
better use two pointer
pay attention to the last segment. 
also: pay attention to overflow.


169. Majority Element
find > n/2
- using hashmap O(N) space
- voting algorithm O(1) space

229. Majority Element II
using two voting
two passes to make sure candidates are valid
1150. Check If a Number Is Majority Element in a Sorted Array
>n/2
check the target's lower and upper boundary


238. product of array except self
left and right product from both direction

266. Palindrome Permutation
check if a string can form a palindrome
allow only one group of odd

267. Palindrome Permutation II
return all possible palindrome permutation
backtracking.
count each number occurance, if there is a odd, it must be in the middle.
remaining is half of these characters for the left.
note it is not limited as lower case english letters.

315 count smaller numbers after self
easy for brutal force O(N^2)
merge sort, hard to understand.

327. Count of Range Sum
[low,upper], count the number of subarray sum in the range.
- brutal force. trivial
- merge sort
* get the prefix sum (convert to prefix[i]-prefix[j] in the range
* divide and conquer, 
divide by half: left and right, check right elements to left elements and count the diff in the range
(this we preserve the i>j requirement)
(in range can be equivalent to one < problem and one less equal problem)
divide until only 1 element left, then merge.
inplace_merge(low,mid,high) using compare to sort.
merge sort is not trivial:

void merge_sort(Iter first,Iter last){
	if(last-first<=1) return; //no element
	Iter mid=first+(last-first)/2;
	merge_sort(first,mid);
	merge_sort(mid,last);
	inplace_merge(first,mid,last);
}

373. Find K Pairs with Smallest Sums
two sorted lists and find k-pairs
this is very similar to find the kth element in matrix with rows sorted.
using a pq to store its neighboring cells to explore.

378. kth smallest element in a sorted matrix
nxn matrix, rows sorted, cols sorted.
find the kth element
binary search in the range [smallest, largest]
and count the elements smaller than the target

1138. Alphabet Board Path
this does not need bfs with path tracing
but use manhanton distance is fine

388. Longest Absolute File Path
\n directory end
\t: indent, number of \t is the level
file with .extension

390. Elimination Game
from left to right, remove the first and every one after
then reverse direction
find the last number remaining
simulate the process. 
ajust the head, step, and direction
everytime the remaining will be cut by half.

418. sentence screen fitting
how many number of repeats can fit.
treat it as 1d, concat the array into one string.
- first char in each row cannot be a space, minus 1
- a word cannot be break into two halves
- last char could: add extra spaces or remove one space
using a start pointer, change a line add ncols
first char is space, advance a char in string (using % for repeating)
first char is not space and previous line char is also not a space, then we need go back.



419. Battleships in a Board
xxx
- it has space in either end
- it is horizontal or vertical

454. 4sum II
four lists, A[i]+B[j]+C[k]+D[l]=0
A[i]+B{j] first, C[k]+D[l] first
reduces to 2 sum
18. 4sum
one array find a+b+c+d=0
sort and using O(N^3) two pointer


466. Count The Repetitions
S1=[s1,n1]
S2=[s2,n2]
find the max M such that [S2,M] can be obtained from S1.
approach: repeat pattern
use two pointer to find s2 in S1, then record, the position and find reocurrance and skip
very tricky using the two pointer.
record i0%m, i0 and nmatch
period=i0-mp[i0%m][0]
nmatch=match-mp[i0%m][1]


467. Unique Substrings in Wraparound String
neigboring char difference is 1 or 25
find the number of unique string.
ending with different char and different length.


468. validate ip address
ipv4 and ipv6
simple string manipulations

475. heaters
sort house and heater's position
the closet heater to the house shall cover it. 
approach 1: cover the left from left to right, cover right from right to left, similar to distribute candies
approach 2: find each heater's max radius.

481. magical string
the count of contiguous '1' or '2' will get the string itself.
return the length=n magical string
starting with 1,2,2...

521. longest uncommon subsequence I
two strings
longer string cannot be the subsequence of shorter ones.
522. longest uncommon subsequence II
multiple strings
sort using length. the unique longest string 

532. K-diff Pairs in an Array
sort and find the difference=k pairs.

533. lonely pixel II
this is again in matrix to find pattern problem.
row R and col c has exactly N black pixels.

531. Lonely Pixel I
same row and col does not have other black pixels.
we can count the black pixel in each row and col.


555. Split Concatenated Strings
a list of strings: each string can reverse or not reverse.
string order cannot be altered.
forming a loop and cut at any places
get the max string.
- first, need compare if we shall reverse the string or not.
- second, we need check where to cut the get the largest.
approach 1: dfs, try reverse/no reverse two options and then check every cut position
approach 2: bfs, 
assuming we cut at sj (inside), it will generate two substr:
s0,s1.....sj....sn.
sj_post,....sn s0,s1....sj_pre
so we need max sj+1....sn and s0 to sj-1.
sj can be reversed or not reversed
the approach:
find the max string for each input string
try all possible cut position and get the max.
note

560. Subarray Sum Equals K
prefix sum so that subarray sum reduces to subtraction.
then we can use loop to find prefx+k.
or using map and add the count.
this is a highly rated question

564. Find the Closest Palindrome
the closest palindrome can be < the number or > the number
same length or less, up to 999xxxx9
longer length: 10xxxx01
so we just find all these palindrome numbers and sort using the number and choose the difference smallest.


605. can place flower
add the end 0 and 1 to avoid ending process


611. Valid Triangle Number
a+b>c so just find the upper bound

616. add bold tag in string
using bool array to indicate the char to be bold
and automatically merge

624. max distance in array
k sorted array, find the max absolute difference among different arrays.
we set the min as a[0][0] and max as a[0].back()
then we update the min and max using array i. and get the max diff.
get the max diff first since we cannot get the diff from the same array, ie. we use all previous.
this is a bit tricky.

658. Find K Closest Elements
find the k closest number abs(num-x)
sorted using abs(num-x) using comparator objector

748. Shortest Completing Word
using hashmap to record the occurance of each char (convert to lower)
and check if the word contains the map.
need to return the first, so using stable_sort (when equal the order is not changed)

750. Number Of Corner Rectangles
this is very tricky. 
check for rect with 4 corners all '1'
idea: 
- for ith row, we check all previous row to see how many cols are 1
- the number of rects are then cnt*(cnt-1)/2

1139. Largest 1-Bordered Square
need to find the largest square.
idea: similar to dp approach
- count the horizontal length of 1s and vertical length of 1s
- then we use the min of veritcal and horizontal as the square length and check the other two horizontal and vertical


758. bold words in string
it says easy, but actually not.
bold all keywords in the string.
using a bool array and set it.

761. special binary strings
special binary string: num0s==num1s, each prefix num1s>=num0s.
equivalent: need to break the string into special binsry strings and sort.
11011000
1(10)(1100)0
swap the first and 2nd special binary string.
also equivalent to valid parenthesis.
the key is '1'+specialstring+'0'

760. Find Anagram Mappings
this is for numbers. combine the index and sort (making them same order)

777. swap adjacent in LR string
R go to the right, L goes to left
R and L are bound by the LR.
so just need to count the x between L R and see the changes.

782. transform to chessboard
we can swap rows, swap columns
return the min number of swaps to make it a chessboard
- need to calculate how many rows are same or xor with row 0
- need to calculate how many cols are same or xor same with column 0
- then we reduce it to a row and a col of numbers

792. Number of Matching Subsequences
a list of words, return number of words which is a subsequence of S.
store the char with index in hashmap.
and then do each word matching: 

794. valid tic-tac-toe
3x3 count row, col, diag, diagr



798. Smallest Rotation with Highest Score
Get point
Each time when we rotate, we make index 0 to index N-1, then we get one more point.
We know that for sure, so I don't need to record it.

Lose point
(i - A[i] + N) % N is the value of K making A[i]'s index just equal to A[i].
For example, If A[6] = 1, then K = (6 - A[6]) % 6 = 5 making A[6] to index 1 of new array.
So when K=5, we get this point for A[6]
Then if K is bigger when K = (i - A[i] + 1) % N, we start to lose this point, making our score -= 1
All I have done is record the value of K for all A[i] where we will lose points.

807. Max Increase to Keep City Skyline
seen from left the max cannot be changed
seen from bottom, the max cannot be changed.
each element is bound by the two max.

816. ambiguous coordinates
approach:
- loop to divide into two half
- each part add 0 or 1 decimal 
- check valid.

820. shortest encoding of words
sort by length
and shorter would be a part of longer string
store all suffix of the string into hash set.


822. card flipping games
smallest number, flipping the card and the front is not in its front.
those back and front the same, put into hashset.
we check back and front to get the min number.


825. Friends Of Appropriate Ages
three conditions: 

826. most profit assigning work
difficulty vs profit
worker ability
for each difficulty level: we find the max profit.
sort the difficulty vs profit.


833. Find And Replace in String
note two cases:
- we shall do it from right to left to avoid index changes
- input is not sorted
- need to first match the substring before replace.

853. Car Fleet
using the time calculated and change to its previous slow and then calculate the group num
direct approach

880. Decoded String at Index
decoded times. and find kth char.
this is quite tricky: we need to track the length until k. and then reverse back to the char. 
if the char is digit, then we need to go back again.


885. spiral matrix III
direction is 112233445566....
only those inside the matrix will be recorded
expanding spiral
54. Spiral Matrix
visiting in spiral order: shrinking spiral
59. Spiral Matrix II
fill the spiral: shrinking spiral.

498. Diagonal Traverse
idea: hit the wall and rebounce
need take care of 4 corners.
dir: 0 and 1.



890. find and replace pattern
from right to left.

912. sort an array.
merge sort
quick sort
bubble sort

916. Word Subsets
use 26 char array instead of hashmap to save time.

918. max sum circular subarray
this is follow up for 1d array.
1d array: if the previous sum <0 we begin a new segment. and find the max.
to avoid circular array: we find the subarray max and min. then get the max of the two answers.

1131. maximum of absolute value expression
first need to remove the abs.
|a[i]-b[j]|+|b[i]-a[j]|+|i-j|, we have 8 combinations (3 +/- selections)
a[i]-b[j]+b[i]-a[j]+i-j  --> [a[i]+b[i]+i]-[a[j]+b[j]+j]
a[i]-b[j]+b[i]-a[j]+j-i --> [a[i]+b[i]-i]-[a[j]+b[j]-j]
a[i]-b[j]+a[j]-b[i]+i-j --> [a[i]-b[i]+i]-[a[j]-b[j]+j]
a[i]-b[j]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
b[j]-a[i]+b[i]-a[j]+i-j --> -[a[i]+b[i]+i]+[a[j]+b[j]+j]
b[j]-a[i]+b[i]-a[j]+j-i --> -[a[i]+b[i]-i]+[a[j]+b[j]-j]
b[j]-a[i]+a[j]-b[i]+i-j --> -[a[i]-b[i]+i]+[a[j]-b[j]+j]
b[j]-a[i]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
then we separate i and j, it is actually 4 cases
we find the min and max and get the max-min

### cyclic linking
442. Find All Duplicates in an Array
elements are from 1 to n. some appear twice
find all appear twice.
using cyclic linking and mark those seen as negative (using cyclic linking)
once we see the negative, it is a seen candidate.

565. array nesting.
find the longest cycle in the array containing 0 to n-1


## stack & deque
316. remove duplicate letters
using hashmap and monotonic stack

402. remove k digits
remove k digits to make the number smallest
using stack to maintain a increasing sequence, remove stack top if it is larger than current.

456. 132 pattern
the idea using stack: we can have 3 number comparing.
from right to left and keeps a monotonic decreasing stack.
i<j<k, a[i]<a[k]<a[j]: that is to find a peak pattern.
when we found num[i]>top, we found one relation s3<s2
[3, 1, 4, 2]
push 2 in stack: [2]
4>2, s3=2, pop and push 4, [4]
1<s3, s1=1, s1<s3<s2. 
the stack stores the right max.

334. Increasing Triplet Subsequence
123 pattern
first update the left min (s1)
if num>min=> S2
if num>s2 then we found the sequence.

556. Next Greater Element III
same digits used and get the next greater number.
next_permutation: equivalent
503. Next Greater Element II
circular array: find the next greater element
using stack to store one copy of the array first
496. Next Greater Element I
two arrays: one array is subset of another array. same as find greater element for each element in the same array.
using stack.

636. Exclusive time of functions
using stack, need to subtract the other function's time


739. Daily Temperatures
stack to find next greater element

755. Pour Water
hard to understand the problem.

828. unique letter string
using hashmap with stack.
if a char is smaller and we still have the char in later, then we can safely remove that char in the stack.

838. push dominoes
- add a L on the left and R on the right.
- several patterns LxxxL, LxxxR,RxxxL,RxxxR
- stack approach: 

901. online stock span
typical monotonic stack

907. Sum of Subarray Minimums
brutal force: for each number we get it as the min and expand left and right
- stack: using two stacks to record the previous smaller and next smaller.
	use same previous less one from left to right, one from right to left.
	one stack is sufficient to find both left and right.
	
921. Minimum Add to Make Parentheses Valid
using stack:
if paired, popped. 
if ) and has no match ans++ 
if ( no match they are in the stack

946. validate stack sequence
simulate the stack, a number shall be pushed first before popped

950. reveal card in increasing order.
reveres the process using deque. 

1003. check if word is valid after substitutions
simple stack or deque problem

1006 clumsy factorial
using stack for expression evaluation.
similar to calculator without ()

1019. next freater element in linked list
typical stack problem: montonic

1021. remove outmost parenthesis
using stack or using counters

1130. Minimum Cost Tree From Leaf Values
the array order cannot be changed.
- equivalent: remove the smaller at the cost A[i]*A[j]
- greedy: to min A[i]*A[j] need combine A[i] with its next larger.
- using stack to store a sorted sequence (sorted is a simple greedy)

1081. Smallest Subsequence of Distinct Characters
same as eliminate duplicates
to keep it smaller, when a small char comes, need to replace char in stack.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

1028. Recover a Tree From Preorder Traversal
using iterative stack

### expression evaluation using stack
227. Basic Calculator II
support +-*/ and spaces
using stack, stringstream add a + in the begin and after to avoid special treatment
772. Basic Calculator III
+-*/ and ()
224. Basic Calculator
+-()


385. Mini Parser
"[123,[456,[789]]]": a nested integer, 123 and a nested list [45,6, [789]]

deserialize the nested integer
using stringstream to process the input
using the string to build the nested integer
341. flatten nested list iterator
design an iterator to flatten the nested integer.
- first the nested integer is a vector of nested integer
- a nested integer itself is another vector
- so we need use stack to push/pop until we reach an integer.
- maintaining a begin and a end iterator, every time we see a nested integer
we push the begin and end then iterator til the end, and then popped.
similar:
339. nest list weight sum
depth from root to leaf
364. nested list weight sum II
depth count from leaf to root

394. Decode string
s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".

439. Ternary Expression Parser
"F?1:T?4:5", recursive first evaluate T?4:5 get 4
then evaluate F?1:4 get 4

591. tag validator

640. solve the equation
include x, +- and coefficient, numbers
and we want to reduce lhs and rhs into ax+b format.

726. number of atoms
using map in the stack. similar approach for expression evaluation (nested)

856. score of parentheses
support A+B and 2*A, two operations

772. Basic Calculator III
including +-*/() and space.
ignore spaces

770. basic calculator IV
expressions... symbolic programming calculator




## bfs
269. Alien Dictionary
unknown order sequence, but given a list of sorted words
from the sorted words we can get a directed graph
similar to course schedule II, we can do a topological sorting
bfs.

301. Remove Invalid Parentheses
although this can be done using dfs, bfs is more straightforward since bfs gives the min distance.
the approach:
if valid then we cannot go to next layer but only finish the current layer
next layer we only remove one ( or ) and push them into queue.
- bad: it blindly remove the ( and use set to avoid duplicates and could be cost.

330. Patching Array
a sorted array and integer n, add/patch some numbers so that n can be reached using sum of some elements
bfs like:
using the element what is the farthest number can reach
[1,3], n=6
1 can reach 1.
cannot reach 2, add 2
1,2: can reach 3
1,2,3: can reach 6 (4,5 is included)


339. Nested List Weight Sum
nested list is hard to understand. 
an integer is a leaf node
an integer list is a larger depth
[[1,1],2,[1,1]] 4 1s in depth 2, one 2 in depth 1
[1,[4,[6]]] 1 in depth 1, 4 in depth 2, 6 in depth 3.
using bfs to add the weight sum.

364. Nested List Weight Sum II
similar to 339, but the depth is reversed
we find the max depth first (similar to a tree)
and then reverse the bfs.

433. Minimum Genetic Mutation
from star to end, min change (everytime change just one)
similar to the word ladder.

490. The Maze
maze: the boundary are all walls, 0 empty space and 1 wall.
from start to destination, check if it can stop at destination.
the ball will run along the direction and will only change direction when hit a wall.
505. The maze II
find the shortest distance. (number of empty space travelled)
if cannot stop return -1;
in this question, we need the path.
one way: store the parent information inside the queue. note has to use pointer.
one way: using pq. dijkstra algorithm
why the first way fails? because it still bases on the layer structure, but here each layer has different distance. we need to relax it.
499. The Maze III
add a hole position. now the destination is the hole 
the ball will drop into the hole if passing it.
asks: shortest distance, and lex smallest path. (LRUD)
similar to II, we need add a path string so that we can restore the path.
dijkstra is very similar to bfs but using pq to replace q.


542. 01 Matrix
this is a good bfs. 
the first layer is those 1s around 0. 
the 2nd layer is those attached to those cells in the queue
if the value is the level, it is processed
otherwise we need to push to queue.
the layer concept is not that clear, but it is a very good bfs problem.

573. squirrel simulation
squirrel in one position, tree in one position, and several nuts in other places
squirrel get the nut one by one and put under the tree.
squirrel position-closest nut->tree->closet nut->tree.....
lesson: bfs is overkill, using manhatton distance
Proof: Let the minimum distance from each nut to the tree be a_1, ..., a_n and 
let the minimum distance from each nut to the initial squirrel position be b_1, ..., b_n. 
Note that the minimum distance between two positions in the matrix is determined by their Manhattan distance.

Then, if the squirrel were to start at the tree, then the minimum total distance required to collect all the nuts is 2a_1 + ... + 2a_n. 
However, since the squirrel starts elsewhere, we just need to substitute one of the 2a_i terms with a_i + b_i. 
Or equivalently, we replace one of the a_i terms in the sum with b_i. 
To minimize the total sum value at the end, we choose i that maximizes a_i - b_i.


similar problem: 1138. alpha board path.


752. Open the Lock
with deadends
0000 to target
same thing from target to 0000
layer: each digit +1 or -1


773. sliding puzzle
convert the 2x3 board to string, 0 represents the empty slot.
target is 123450
bfs to push all possible swaps


815. bus routes
each bus route is a circle
from one station to another. 
one a route: we have some stations connect other routes.
bfs to reach the destination.
- reconstruct the routes to a map: station vs route.
- visited using hashset
- queue store the route number and station number



841. Keys and Rooms
if we can unlock all the rooms


854. k-similar strings
two anagrams A and B, return the smallest k.
using bfs each time we swap one pair.

909. snakes and ladders
this is a very good bfs question. layer concept.
- convert 2d to 1d array to avoid value-index conversion
- next layer is all the nodes it can go in the next step. including 1 to 6 and ladder.

1024. video stitching
using bfs like to cover the max distance.


1129. Shortest Path with Alternating Colors
- from 0 to all other nodes
- using bfs to get the shortest distance
- the distance can be greater than n since we may need to come back
- form a graph (adjacent matrix) data structure needs 0 for blue and 1 for red
- have two options: first start blue or start red
- we can use simple structure for adj matrix (*2 for blue *2+1 for red)
- self connected edge cannot be ignored since it will be able to connect the path.
- perform two bfs.
* the simple data structure for adj makes the problem a lot simpler.
* using dfs are not good for this. always try bfs first for shortest distance problems.

1102. Path With Maximum Minimum Value
this is similar to the swimming in rising water.
it asks for the min value along the path where all those smaller elements are not passable and there is only one path.
so it is a binary search with a bfs problem
note: binary search often cause infinite loop (does not work for two elements). It is interesting to use l+1<r and use l=m and r=m.


1091. Shortest Path in Binary Matrix
8 directions with 0 and 1 (1 blocked). return the shortest path from top left to bottom right
regular bfs
Note: need check start/end position first.

## dfs
302. Smallest Rectangle Enclosing Black Pixels
dfs to find the minx,maxx, miny and maxy, then the rect is defined
interesting, this can be approached using binary search.
we can condense the matrix into one single row and one single column. and then use binary search to find the 4 boundaries.

200. number of islands
simple dfs

305. Number of Islands II
addLand, then return number of islands after the operation
union find is more suitable for the dynamic changes.

329. longest increasing path in a matrix
dfs with memoization

399. evaluate division
a/b, b/c....

417. Pacific Atlantic Water Flow
top and left boundary belongs to pacific
bottom and right belongs to atlantic
using left and top dfs and mark them as 1
using right and bottom dfs and mark them as 2 (or)
return all those marked as 3.

465. optimal account balancing
add up the debts and everyone has a balance
if the debt is 0, then drop the person from consideration.
brutal force to get the min.


488. zuma game
4 colors: RGBW
Given a row of balls on table and some balls in hand.
remove balls when >=3 same color balls together.
return min balls needed.
??

489. robot room cleaner
simulate the dfs.
store visited info into a hashmap 2d matrix


529. minesweeper


547. friend circle
simple dfs

562. Longest Line of Consecutive One in Matrix
this seeks for vertical, horizontal, diag, anti-diag 4 types of dfs.

576. out of boundary paths
number of paths
out of boundary +1
inside: +0


582. kill process
using map to assemble all the children, forming a tree relation
then dfs

695. max area of island

694. number of distinct island
only translational


711. number of distinct island
it supports translation, roation and reflection
dfs to get the coordinate for an island, and then perform all possible rotations/reflections
and find the canonical representation by sorting

749. Contain Virus
cell 0 is unaffected, cell 1 is affected.
wall installed on boundary.
each day you can only block one region.
so basically, we need to find the region with the most neighbors and install walls
and the other region will grow and we get the next and install walls.


785. is graph bipartite
giving a list of edges
- we don't need to build the graph
- use only color for both visited and color assigned
- dfs on the edges.

802. find eventual safe states
- dfs
- if meet 0, all nodes on the path will be set zero

851. loud and rich
dfs

886. possible partition
this is very similar to check bipartition
- we do not need to build adjacency matrix, using edge is fine
- we can use color as the visited array
785. Is Graph Bipartite?

934. shortest bridge
- first find the two islands using dfs
- find the smallest distance between the two islands

935. Knight Dialer
using dp or dfs/recursive

959. regions cut by slashes
need upsample and do the dfs

967. Numbers With Same Consecutive Differences
dfs: try +k and -k. not above 9.

980. Unique Paths III
-1 obstacles, 0: empty, 1 source, 2 target
it requires to walk on every empty cell exactly once. 
return number of path
it needs two requirements: walk on every cell, and reach the end.
just regular dfs.
63. Unique Paths II
number of paths, using dp is faster (with obstacles)
62. Unique Paths
dp or pure math.


996. number of squareful arrays
neighboring elements sum is a square.
return the number of permutations.
build the graph (for each element its neighboring)
and then dfs.


1020. number of enclaves
common dfs

1125. Smallest Sufficient Team
- most important: convert the required skills into bits and simple the problem using dfs.
- non-required skills are ignored.
- do a O(N^2) loop and eliminate those people with same skills, or a subset of skills

1059. All Paths from Source Lead to Destination
- lead to other nodes
- lead to infinite cycle

dfs with cycle detection
using 3 states: visited, not visited, visiting.

1036. Escape a Large Maze
two dfs: block the source, block the target
dfs distance > the block size, then we are outside.

1034. coloring a border
dfs using negative color, restore inner side


## backtracking
254. Factor Combinations
find all combinations of a number
from the smallest factor 2 to sqrt(n). once we determined the first, the second is a subproblem
a bit tricky:
start from 2 (n, start, ....)
end case: n<start
n%i==0 then add i and n/i into current vector, and then add to answer
pop the n/i and keep going smaller.

loop from 2 to sqrt(n): so the current factor is always smallest.
backtrack: start from i, instead of 2 again. 


293. Flip Game
flip ++ to -- until no one can move.
return all possible next states

294. Flip Game II
determine if the start player can win.
backtracking all the starting options
- straightforward backtracking is simple
- need use memoization...note before win[s]=1, we need first restore it (it is the solution for s not for t)

473. matchsticks to square
this is to divide the array into 4 parts to target sum
using backtracking
once the stick is used, put them in visited.

491. Increasing Subsequences
find all possible increasing subsequences
regular backtracking

526. Beautiful Arrangement
index from 1 to N: either A[i]%i==0 or i%A[i]==0
return the number of beautiful arrangement.
- first construct the array from 1 to N. (which is one beautiful arrangement.)
- loop over each element and swap with the end

667. Beautiful Arrangement II
n: 1 to n.
k: need |a1-a2|, ....|a(n-1)-a(n)| has excatly k distinct numbers
correctly understand: it does not ask for there are k numbers between, but asks for the difference is k numbers
greedy: 1,k+1,2,k.....and then all difference is 1.
so difference is k,k-1,k-2.....1,1,1,..1

756. Pyramid Transition Matrix
get all the combinations and backtracking to next layer.

784. letter case permutation
typical backtracking,

797. All Paths From Source to Target
classical backtracking

842. Split Array into Fibonacci Sequence

## counting in array.
891. Sum of Subsequence Widths
subsequence width= max-min in the subsequence
- only care about max and min, so order does not matter so we can sort to see if it is simpler.
- with A[i] as the min and A[j] as the max, all the elements in the range [i+1,j-1] can be used or not used.

898 bitwise ors of subarray
the idea: save previous results in hash set. and use A[i] to or all previous results
for A[i]
A[i]
A[i],A[i-1]
A[i],A[i-1],A[i-2]...
basically this is a brutal force approach.
but the complexity is O(N), why? since we only have 32 bits

902. Numbers At Most N Given Digit Set
giving n digits (not including 0), find number of integers <=N.
equivalent: assume N has k digits, it can be divided into:
1 digit to k-1 digits, this can be computed using permutation.
1000..0 to N with k digits. this can also be computed using permutation


1012. numbers with repeated digits
equivalent: numbers without repeated digits.

1128. Number of Equivalent Domino Pairs
this is common seen counting in array using hashmap
keep adding the previous occurences
equivalent to 1+2+3+...+k 

1124. Longest Well-Performing Interval
- >8 convert to 1, <=8 convert to -1.
- prefix sum. 
	if prefix[i]>0 then all previous are good.
	if prefix[i]<0 then we need to find previous smaller one
	
1099. Two Sum Less Than K
common practice: sort the visited elements in a map/set and then use binary search to find the elements

560. Subarray Sum Equals K
similar to 1099. 1d array problem

1074. Number of Submatrices That Sum to Target
using tech in 560 and reduce to 1d problem

363. Max Sum of Rectangle No Larger Than K
<=K, we can use similar approach as in 1074.
1d array: how to find max sum <=K?
using hashmap to find the lower bound.
O(m^2*nlogn) complexity
so when m>>n, we need use column based algorithm

1067. Digit Count in Range
given a digit d in [0,9], return the number of occurences in [low,high].
- we can get [1, high]-[1,low], high low can be converted to number of digits
same length of digits shall be counted carefully.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

	
## interval problems
252. meeting room
give a list of interval, check if one can attend all.
253. meeting room II
find the number of conference rooms needed.

352. Data Stream as Disjoint Intervals

370. Range Addition
add a number to a range
using + - a number to the start and end.
then prefix sum.

436. find right interval
for each interval find if there is a right interval
this is very similar to the stack problem of next greater element
but this is for interval
also can use binary search tree to optimize.
435. non-overlapping interval
find the min number of interval to remove.
greedy: 
convert to equivalent: max number of non-overlapped intervals.
sort the interval using the end. use the leftmost end first, and find larget non-overlapped region
greedy is: make the end smaller to have more regions.

452. min number of arrows to burst balloons
sort the interval
similar to bfs: the leftmost end shall be the first shot position, and all those with start<=this will be eliminated

495. teemo attacking
attacked and then poison for a duration.
using bfs-like method to eliminate the overlaps.
accumulate the poison time at the same time.

554. Brick Wall
similar to interval problem.
we accumulate the length and store in hashmap and the max one is the position.
do not include the last position.

715. range module
addrange: merge to previous intervals
queryrange: check if the range is tracked
removerange: remove the range.
approach 1: using event add/removal
approach 2: merge interval.



732. My Calendar III
interval [start,end) half close half open
k-booking
similarly using ++/-- and prefix sum

731. My Calendar II
triple booking. similar approach as 732
729. My Calendar I
double booking, similar as 732.

757. Set Intersection Size At Least Two
the intersection shall contain at least two elements from each interval.
- sort the intervals according to the end.
- get two elements from the first ..

759. Employee Free Time
similar adding/removing an event.
and then prefix to find if we have common

850. rectangle area II
this is a very good question on 2d interval
- add a rectangle and remove a rectangle, (x,y,value)
- sort using x.
- calculate the area along all x. (using prefix sum in the 1d interval problem).


855. exam room
direct approach: recording the seats and find the largest interval
849. Maximize Distance to Closest Person
very similar to 855.

986. interval list intersection
two sorted list of intervals, find the intersection.
apply two pointer and check if two intervals intersect.


1109. Corporate Flight Bookings
- add an event and remove an event using map for positive and negatives
- prefix sum to get the results.

1094. car pooling
add passenger and unload passenger

	
## Tree
222. Count Complete Tree Nodes
O(N^2) using depth and count
for complete tree:
the left depth is the left edge
the right depth is right's left edge so getting depth would be reduced to O(logn)
O(logn*logn)

226. invert binary tree
postorder: invert left and right and then swap left and right

230 kth smallest element in a BST.

236. Lowest Common Ancestor of a Binary Tree
O(N)
if current node==p or q return it
left subtree find pq
right subtree find pq
if left find one and right find one, we get the root
otherwise left or right
235. Lowest Common Ancestor of a Binary Search Tree
check the value 
and then goes to left or right

250. count univalue substree
postorder is more suitable
if left is univalue and right is univalue, and count univalue subtree
so we need to do two things: check if valid, count the number of univalue subtree
the condition shall:
if left then check left vs root
if right then check right vs root


257. binary tree path
simple preorder or dfs

255. verify preorder sequence in BST
root, left, right sequence.
using root to divide into left and right recursively.
leftmax<root<rightmin


297. serialize and deserialize binary tree

298. Binary Tree Longest Consecutive Sequence
path from parent to child only.
preorder traversal.

310 min height trees
actually this is a graph problem
choose any node as the root and get the min height
remove the leaf nodes layer by layer.

314. Binary Tree Vertical Order Traversal
recursive in order traversal with x and y information and then stable sort

333. largest BST subtree
equivalent to find the longest sorted segment in a 1d array.
since we are looking for the node, it is a bit different from that.
inorder will lose the root information.
postorder will be more suitable:
find the leftmax and rightmin. if root>leftmax and root<rightmin, then it is a valid bst subtree.
(also another way to validate the BST.)
also need count the number of nodes in the left and right subtree.

331. verify preorder serialization of a binary tree
observation: each node has two nodes (either number or #) 
- approach 1: count in degree and out degree.
a non null node has 1 in degree and 2 out degreen nodes has 2n out degrees, and n-1 in degrees. 
so for each node -1, and +2

1145. binary tree coloring game
greedy: we can place the node on parent, left, or right child
depending which has >n/2 nodes

426. convert binary search tree to sorted doubly linked list
inorder traversal
use dummy and prev.

429. n-ary tree level order traversal
simple

428. serialize and deserialize n-ary tree
encode: root+ number of child+child
decode: using stringstream

431. Encode N-ary Tree to Binary Tree
encode it into a binary tree
put the first child into left and other children into the first child's right.

440. kth smallest in lexi order
n-ary tree traversal
0 has child 1,2,3,4,5,6,7,8,9
1 has child 10,11....19
2 has child 20.....29
10 has child 100,101.....109
preorder traversal will give the order.
need first determine the layer.

similar 386. Lexicographical Numbers
this can be generated using greedy.
1,10,100...
when overlimit, 1001,....

450. delete node in a bst
search the node and delete it.
delete a node we shall cover its parent and left/right child
- node is a leaf, just return null.
- node has left only, bring its left up
- node has right only, bring its right up
- node has both left and right, bring the leftmost leaf in the right branch.
if it is the root: 
449. serialize and deserialize BST.
using stringstream


124. Binary Tree Maximum Path Sum
there are a few similar questions on this.
-. similar to 1d array. if previous sum<0, then we are not connecting it
-. for tree. we are looking for the subtree parent-child path sum (since only it can be used to connect root and right)
-. during the traversal, we also update the max path sum (by connecting left and right)
112. path sum
from root to leaf (preorder)
113. path sum II
find all root to leaf path sum equal target.
backtracking.
437. path sum III
path does not need to start from root or end at leaf. 
path needs going down.
this is similar to find the subarray sum to target. using hashmap (prefix sum)



501. Find Mode in Binary Search Tree
modes: most frequent elements

508. Most Frequent Subtree Sum
post order traversal and hash map

510. inorder succrssor in BST II
node has parent, left and right.
if node has right, go to the leftmost in the right branches
if node has no right, need go to its parent
285. Inorder Successor in BST
there is no parent field in node.
binary search.

513. Find Bottom Left Tree Value
using depth O(N^2) is straightforward.
from O(N^2) to O(N) people often refer it as memoization, while traversal, store the results
idea: keeping the depth, when leaf is found and depth > stored max depth, we update the answer
using preorder, the left is always found first.

515. find largest value in each tree row
traversal

530. min absolute difference in BST.
similar to array problem.

536. Construct Binary Tree from String
this is a expression evalulation or stack problem
or recursive problem.

538. convert bst to greater tree
suffix sum

543. Diameter of Binary Tree
diameter: left +root+right (the longest path between any two nodes)
O(N^2) approach: left depth+right depth vs max(left diameter, right diameter).
O(N) approach: record the diameter while searching for depth

545. boundary of binary tree
counter-clockwise direction, output the nodes
left bound
bottom
right bound

node.left is left bound if node is left bound;
node.right could also be left bound if node is left bound && node has no right child;
Same applys for right bound;
if node is left bound, add it before 2 child - pre order;
if node is right bound, add it after 2 child - post order;
A leaf node that is neither left or right bound belongs to the bottom line;


549. binary tree longest consecutive sequence II.
have ascending and descending two directions.
we return the pair of length
at the root, we connect ascending or descending.
path includes passing the parent node.

298. Binary Tree Longest Consecutive Sequence
path only involve parent-child relation
only ascending order.

559. max depth of n-ary tree

563. Binary Tree Tilt
tilt: absolute difference between the sum of subtree and right subtree.
O(N^2): postorder to get the tilt with helper to get the subtree sum.
O(N): we need save some information
get the sum of a subtree and find the tilt.
this is similar to memoization while doing traversal.

572. Subtree of Another Tree
helper is_sametree
but it is O(N^2)
using serialization and check if the shorter one is a substring using preorder traversal.

590. n-ary tree postorder traversal
589. n-ary tree preorder traversal

606. Construct String from Binary Tree
a kind of serialization
if does not have right no ()
if does not have left but have right need add ()


617. merge two binary trees
simple: if both null, null
either is null, return it
both is not null, return sum

623. add one row to tree
need use bfs to add nodes
get to the previous layer and create new nodes and connect


637. average of levels in binary tree
simple

652. Find Duplicate Subtrees
using hashmap, serialize the tree for each node.
we have to use root+left+right and store in map.


653. Two sum, input is BST
just follow two sum in array

654. Maximum Binary Tree
this is actually the heap.
recursively choose the max and divide into left and right

655. Print Binary Tree
arrange each node's position

662. Maximum Width of Binary Tree
full binary.
dfs. child is always 2*n,2*n+1


663. Equal Tree Partition
remove one edge and make the two subtree the same sum.
just similar to array, we do in order traversal and put the sum of all subtrees into hashmap
then we check if the sum is even and half sum exist.
if sum==0, then we check number of 0.


666. Path Sum IV
the tree is represented as an array.
each number: first digit is the depth, second digit is the level position, 3rd digit is the value.
using full tree storing in an array, (non-existent node all 0)
while building the array we can accumulate the sum till the leaf.

700 search in BST-linked
701 insert into a BST.
insert to the leaf

742. Closest Leaf in a Binary Tree
given a target key, find the nearest leaf. (means min number of edges).
it is equivalent to find the node, and then get the smallest depth leaf node.
- preorder search to get the node
- bfs to search, return the first seen leaf node.
- what if it is already the leaf? we need go back to parent and then go down.
it is also similar to the lowest common ancestor.

another approach: convert the tree into graph and then use bfs
- dfs to build the relation
- bfs to find the node.

776. split BST
given a target value, split it into two subtree:
one tree has nodes <= target
one tree has nodes > target
keep most the structure of the original tree
- if root<=target, its right may contain some nodes <=target. and it is a subproblem
 [less,greater]=subproblem
 less attached to root->right, and the smaller shall be the root.
 greater 
 it is very tricky: the greater is then attached to root's parent's left.
 
 
779. K-th Symbol in Grammar
first row 0, then 0->01 and 1->10
this is a full binary tree.

783. Minimum Distance Between BST Nodes
apparently in order traversal, min diff only occurs between neighboring numbers

814. binary tree pruning
removing subtree with all zero.
post-traversal: get its left and right, and check if it is leaf and 0 node, return null.


834. sum of distances in tree.
return the sum of each node to all other node's distance.
this is a hard graph problem. 
- converting tree into graph
- 

862. all nodes distance K in binary tree.
build a graph from the tree and then bfs from the given node.
adj matrix: map<int,vector<int>>

865. smallest subtree with all the deepest nodes
or the lowest common ancestor for all the deepest nodes
O(N^2) using depth
O(N): get the left and right depth, and:
Hleft==Hright, root
left<right, go to right with d-1

236. Lowest Common Ancestor of a Binary Tree
O(N^2): find p and q repeatedly and return 0,1,2,3
O(N): do the find and return the same time
if node==p || node==q, return node
get left lowest common ancestor
get right lowest common ancestor

1123. Lowest Common Ancestor of Deepest Leaves
similar to 865. 
O(N^2) get depth for each node and return the ancestor
O(N): get the depth and the ancestor at the same time.


872. leaf similar trees
traverse and get the leaf array

889. construct binary tree from preorder and postorder
pre: root, left, right
post: left, right, root
so basically find the root and left subtree and right subtree

894. all possible full binary trees
this is a simple recursive problem with left: 1,3,5,7,.... 


897. increasing order search tree
BST-linked list (in place)
using right,root,left might be easier with a helper pointer prev.

919. Complete Binary Tree Inserter
this is very interesting using array to implement a tree.


938. Range Sum of BST
easy

951. flip equivalent binary tree
left-left & right-right
left-right & right-left

958. check completeness of a binary tree.
- bfs approach: when we see a null node, there shall have no nodes after
- dfs approach: left depth is always>=right depth. (preorder).

965. univalued binary tree.
passing the root value to subtree

968 binary tree cameras
greedy: put the camera on the parent, so it can cover children and parents.
remove all covered nodes and repeat again
from bottom to up, but we are not removing the covered nodes in real.
do it postorder traversal so we can get from bottom up.
0: leaf not covered
1: with a camera on it
2: covered.

using status to reflect if the root is monitored or not.
do it from bottom to root.

971. Flip Binary Tree To Match Preorder Traversal
array is a binary tree (some subtrees flipped) preorder traversal
first match the node, and then match left/right or right/left.

979. distribute coins in binary tree

also similar to the washing machine. the abs(diff) is the coins up/down the root.

987. Vertical Order Traversal of a Binary Tree
record depth, and x, and value
there are overlaps (same position)
preorder:
then sort according to requirements.

988. Smallest String Starting From Leaf
simple dfs, when reaching leaf, reverse the results.

993. cousins in binary tree
only need to keep the parent information and depth information


654. max binary tree
build from array: max as the root, left is left subtree, right is right subtree
heap. (used for map, set data structure, pq uses complete full binary tree).

998. max binary tree II
append a number to the array, and return the max binary tree
- empty and it shall be the root
- > root, it shall be the root, original root shall be its left
- <root, it shall go to the right

1008. construct binary search tree from preorder traversal
BST, preorder, the root is always the first and divide by left and right
using upper_bound

1022. sum of root to leaf binary number
preorder/dfs/recursive

1026. max difference between node and ancestor
preorder and find the min and max of all prefix.

1028. Recover a Tree From Preorder Traversal
iterative stack

1038. Binary Search Tree to Greater Sum Tree
reverse inorder traversal
similar to array's suffix sum


1123. Lowest Common Ancestor of Deepest Leaves
O(N^2) is easy
O(N): first find the left depth and right depth of the root one pass. second pass find the node with depth-1.
O(N) single pass: get the depth and the node at the same time.

1120. Maximum Average Subtree
average: need to get the sum and number of nodes.
using postorder traversal, we get the sum and number of nodes for its left/right subtree and then get the results for the root.

1110. Delete Nodes And Return Forest
when a node is to br removed, we need update its parent and child becomes another tree
do not forget the root when it is not removed.
google phone screen

1104. Path In Zigzag Labelled Binary Tree
full tree, the node from leaf to parent is n/2 and apply the zigzag relation.

1080. Insufficient Nodes in Root to Leaf Paths
all path passing the node sum<limit.
O(N): the limit - val. if leaf<limit, return null, the left and right both returns null, then the root is also removed.
it is not so easy:
when a leaf node < limit, return null, else return itself
otherwise, check its left and right
if left and right are removed, 


## greedy
306. additive number
this is equivalent to 842. split array into fib sequence 
using iteration to max length allowed for the first and second number then decide the whole array
can use backtracking

321. Create Maximum Number
choose from two lists
- try all combinations (i,j) i from list 1 and j from list 2 with i+j=k.
greedy: choose the max from m-(i-1).
and then merge from two lists.

1147. longest chunked palindrome decomposition
find the shortest string head=tail, and reduce the problem
recursive

397. Integer Replacement
/2 +1 -1 three operations
min number of operations
even number /2
odd number: if +1 %4==0 then +1, else -1

406. Queue Reconstruction by Height
each pair is [height, k] k is number of person taller in front of him
so sort: height descending order, k in ascending order
insert the less tall person one by one. the position is fixed
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
sort as [7,0],[7,1],[6,1],[5,0][,[5,2],[4,4]
the array grows as: (current always <= all elements)
[7,0]
[7,0],[7,1]
[7,0],[6,1],[7,1]
[5,0],[7,0],[6,1],[7,1]
[5,0],[7,0],[6,1],[5,2],[7,1]
[5,0],[7,0],[6,1],[5,2],[4,4],[7,1]

462. Minimum Moves to Equal Array Elements II
a move: select an element +1 or -1
target: all element becomes the same
greedy: sort and get the median position, similar to best meeting point.
453. Minimum Moves to Equal Array Elements
a move: make n-1 element +1.
assuming final results is t: n*t=tsum+(n-1)*m

484. Find Permutation
DI string for 1 to n. find the lex smallest permutation matching the DI string.
For example, given IDIIDD we start with sorted sequence 1234567
Then for each k continuous D starting at index i we need to reverse [i, i+k] portion of the sorted sequence.
IDIIDD
1234567 // sorted
1324765 // answer



544. Output Contest Matches
strongest vs the weakest.
1,2,3,4,5,6,7,8
first round: (1,8),(2,7),(3,6),(4,5) pairs
second round: ((1,8),(4,5)),((2,7),(3,6))
do this until only two teams.
a simple while loop (divide by 2 every time).


561. array partition I
sum of min of pairs to be min. 
sort and simple math.

575. Distribute Candies
distribute candies between brother and sister, what the max kinds of candies sister can get.
half of the candies, num types of the candies. whichever is min, 
621 task schedule
greedy: find the most common task and arrange in a period of (n+1) task
if there are multiple most common task we need add one extra for each.
finally ans shall be >= number of tasks



649 dota2 senate
greedy to ban the immediate person and move the senate to the end.
using queue.

665. Non-decreasing Array
modify at most 1 element.
This problem is like a greedy problem. 
When you find nums[i-1] > nums[i] for some i, you will prefer to change nums[i-1]'s value, 
since a larger nums[i] will give you more risks that you get inversion errors after position i. 
But, if you also find nums[i-2] > nums[i], then you have to change nums[i]'s value instead, 
or else you need to change both of nums[i-2]'s and nums[i-1]'s values.


738. Monotone Increasing Digits
given N, find the largest number with increasing digit <=N.
approach:
from right to left, find the first position where A[i]<A[i-1].
and then change all digits in its right to '9'

754. reach a number
can go left or right. min number to reach the number
- go above the number
- if difference is even, make half the negative
- if difference is odd, then go another step, and negative

765. couples holding hands
greedy: we divide all numbers by 2, so the couples share the same number
we swap once we see difference. every time we at least fix one pair. without causing less.

775. global and local inversions
needs all global inversions==local inversions

789. escape the ghost
whoever reach the target who will win.

810. chalkboard xor game
remove one number, if the remaining bit xor ==0, then he loses.
we can get the xor of all numbers first.
if xor is 0, then alice win
if xor not 0, then it means we have at least two different numbers, then we can erase any number different from xor, and won't lost
even number length will win.

861. score after flipping matrix
greedy: keep the leftmost bits as 1 then keep the num of 1s in each column >= num of 0s.

870. advantage shuffle
greedy: use weakest to match the one we cannot beat. using the weakest one who can beat.

910. smallest range II
add +k -k
greedy: equivalent to add 0 or 2k.
from left to right, add 2k to see if we can reduce the difference.
908. smallest range I
add a number between [-K,K]. so we can reduce the range by 2K to 0


932. beautiful array
A[k]*2!=A[i]+A[j]
starting from [1].
left odd and right even. expand.
[1]
[1,2]
[1,3,2,4]
[1,5,3,7,2,6,4,8]
.....
divide and conquer
divide into odd and even
even divide by 2 multiples and 4 multiples
4 multiple divide by 4 multiples and 8 multiples


936. Stamping The Sequence
reverse from target to source
using greedy match.

942. DI string match
use two end meet. D choose the max, I choose the min


945. min increment to make array unique.
sort first and add 1.

948. Bag of Tokens
greedy: use the point for max power and use least power to gain points

949. largest time for given digits.
from the right, if we have larger digits, choose it.
otherwise, choose the smallest.

969. Pancake Sorting
greedy: flip the min to the top, repeat.

991. broken calculator
only support *2 and -1. 
min number of operations from x to y.
we can also do from y to x, and is more clear. /2 +1

995 min number of k consecutive bit flips
min number of flips needed to make it all 1.
greedy: turn the left most bit 0.

1005. max sum of array after k negations
greedy: try to negate those negatives. after that, we need compare the last negated negative with the smallest original positive

1007. min domino rotations for equal row.
either all rotate to a[0]
either all rotate to b[0]
do it one by one, do not involve two things. do it simple way.


1025 divisor game
greedy: odd/even

1029. two city scheduling
greedy 1: send all to A and then send those most saving to B.

1053. Previous Permutation With One Swap
to make it smaller with one swap.
greedy: find the first peak from right to left, and swap with leftmost element in its right < peak.

1042. Flower Planting With No Adjacent
garden has no more than 3 neighbors
greedy: make a graph and chose available color

1041 robot bounded in circle
greedy: try a whole cycle or more cycles. repeat 4 times and we would be able to do it.
common practice: rotation


## heap
215. kth largest element in an array
using pq.
pq is faster than set. (pq used full binary tree, set use tree structure).

239. Sliding Window Maximum
using a dq
the front is the current max
from back to front is sorted.
when a new elements comes, pop those elements smaller than it.
pop the front element if it is out of the window.
(storing the index)

347. top k frequent elements
358. Rearrange String k Distance Apart
using the heap and arrange k chars and repeat.
once we need the char but we don't have it from the heap, we cannot make the arrangement.

407. Trapping Rain Water II
2d cell: store the i,j pair
heap: do it like bfs, but only with the max next layer.
42. Trapping Rain Water
1d cell, using monotonic stack.
using the current bar, poped stack bar, bar on the top.
two bounary and one is the low for containing water.

502. IPO
project number <=k.
given a list of projects with capital needed and profit.
initial capital is W.
return the max final capital.
greedy: using W find the most profitable project with capital <=W.
binary search the capital , heap to find the max profit.


630 course schedule III
the idea: greedy choice: sort the courses according to the closing time, always choose the closing time earlier to ensure more courses taken
using the heap to remove the longest courses in the pq.
207. course schedule
if we can complete
approach 1: using topology sort, remove source nodes the layer by layer.
approach 2: dfs/topological sort, with cycle detection. (have 3 states)

210. course schedule II
output the complete order.

1136. parallel courses
[x,y] x is the prerequisite of y.
each semester you can study any number of courses.
return the min number of semesters
very similar to above problem.
note using map<int,set<int>> will use longer time (logn)
need optimize
- use vector<unordered_set> can pass oj.


632 smallest range
k lists, find the smallest range includes at least one number from each of the list
inuition: similar to merge sort, we store each head element in pq, and pop the smallest and take the followed one from the same list.
we are looking for the max and min.


857. min cost to hire k workers
quality, wage expectation, ....
this is quite tricky: 
the pay ratio shall be the highest ratio, and the total is proportional to the total quality.
so use a heap to remove those largest quality to see if we can reduce the cost.



973. k closest points to original
heap

1121. Divide Array Into Increasing Sequences
greedy: choose K increasing subsequences from the most frequent one
just like to get rid of a layer from the mountain and until it is flat

1090. Largest Values From Labels
values, labels
limited K from each labels
return the max sum
it is natually using heap.
first store the values vs label in a sorted map from larger to smaller.

1086. High Five
top five scores, using minheap to keep only 5 scores.

1066. Campus Bikes II
N workers and M bikes.
min manhattan distance and lowest index bike.
need work on it.

1057. Campus Bikes
sorting all combinations.

1054. Distant Barcodes
rearrange so that no neighboring are the same
using heap to arrange the two most common words
767. reorganize string
same to 1054

## trie
336. Palindrome Pairs
- brutal force: try all combinations and check if the combination is plaind
- trie approach: 
we need to store in the trie node:
*. is_end to indicate the word is done
*. the word index so it shall be a vector of index
- store the words in reverse order in trie.
- using the words to search in the trie.
if begin matches, then we check the remaining part is valid



425. word squares
using trie and backtracking.
422. valid word square

642. Design Search Autocomplete System
add a count in the node.

648. replace words
replace the word with prefix in the dictionary
build the trie using the dictionary 
and then find if it starts with.

745. prefix and suffix search
words[i] has weight i.
search(prefix, suffix) return the word with max weight.
smart solution using one trie.
by adding suffix together with the orginal
for example apple:
apple$apple, pple$apple, ple$apple,le$apple,e$apple
when query we just need to query suffix$prefix and check which one starts with this.
weight i: each node contains the max weight (if we iterate from smaller to larger, it is automatically updated.
be sure to add the empty suffix.

1032 stream of characters
matching with the prefix, startwith




## union find
261. graph valid tree
check whether the graph with edges make a tree
use eges to merge the nodes, 
- there is no cycle, edge two nodes have the same parents
- n nodes n-1 edges

323. Number of Connected Components in an Undirected Graph
- using the edge to merge nodes
- another approach: form a graph and do dfs.
721. Accounts Merge

737. Sentence Similarity II
a-b is similar then b-a is also similar
a-b similar, b-c similar, then a,b,c are similar
sentense similar: number of words are the same, 

data structure: map<string,int> as parent
self cooked union-find has defects: can only merge the current group to previous, but cannot merge the previous 
group into even previous group
using int for parent are not good.
- for each pair, set its parent to itself
- merge inside pair words

734. Sentence Similarity
similarity is not transferrable. only is symmetric.
data structure is important: 
each string can belong to multiple index group, two words are similar or not, they shall have same index/


["a","very","delicious","meal"]
["one","really","delicious","dinner"]
[["great","good"],["extraordinary","good"],["well","good"],["wonderful","good"],["excellent","good"],["fine","good"],["nice","good"],
["any","one"],["some","one"],["unique","one"],["the","one"],["an","one"],["single","one"],["a","one"],
["truck","car"],["wagon","car"],["automobile","car"],["auto","car"],["vehicle","car"],
["entertain","have"],["drink","have"],["eat","have"],["take","have"],
["fruits","meal"],["brunch","meal"],["breakfast","meal"],["food","meal"],["dinner","meal"],["super","meal"],["lunch","meal"],["possess","own"],["keep","own"],["have","own"],["extremely","very"],["actually","very"],["really","very"],["super","very"]]


803. Bricks Falling When Hit
- only those connected to top will not falling
- we set all the hit bricks to 0
- add these bricks one by one and do union
- the difference of bricks connected to top is the bricks to falling


827. making a large island.
- union find and merge to several islands
- try all 0 cell and to see if we can connect to its neighboring islands
- get the size (it may connect multiple islands)

839. Similar String Groups
typical union-find

924. Minimize Malware Spread
return the first node which can minimize the infected nodes by removing it from initial list.
ie, assuming the node is not affected.
- parent node - the initial nodes, find the one with largest size

928. Minimize Malware Spread II
initial list: remove one infected nodes and disconnect its neighbors.
union find in a reverse way: 
build the disjoint set without the infected
add one by one by disable the node only and add all other nodes, and check which one forms the largest number of elements.
we are not doing merge but only count the number of sets to be union and count the number


947. most stones removed with same row or column
use dfs or union-find, similar to number of islands

952. Largest Component Size by Common Factor
connect the numbers when they share a factor.
use prime factorization for each element.


990. Satisfiability of Equality Equations
use == relation and merge them and use != to check them

1101. The Earliest Moment When Everyone Become Friends
union and find the earliest time that unites as one group

1061. Lexicographically Smallest Equivalent String
union and use each group's parent.


## sliding window
1156. Swap For Longest Repeated Character Substring
the idea is sliding window with at most one different char, and there must be another char outside the window
however implementation is not easy. why is hard since I am not clear the details steps



340. Longest Substring with At Most K Distinct Characters
using hashmap to record number of different chars in a window

424. Longest Repeating Character Replacement
with k replaces
sliding window with at most k other chars.

480. sliding window median
sliding window max/min using dq
sliding window median is much harder.
approach 1: using one max heap for left, and one min heap for right
so the median can be computed with the top elements of the two heap.
old element moving out of window: since it maybe inside the heap, we need to ignore them.
approach 2: similar to brutal force. maintainng the k elements in a multiset and apply sliding window.


713. Subarray Product Less Than K
similarly, if the window is k then we have k*(k+1)/2 
and we just add the count ending at current number and keeps growing the window

727. Minimum Window Subsequence
find the min substring which T is a subsequence of it.
if there are multiple answer, return the first one. (leftmost)
using two pointer match we can get the sliding window.
it is not efficient when there are a lot of first char.
need some optimizations: we check from right to left and see next jumping position

    string minWindow(string S, string T) {
        int m=S.size(),n=T.size();
        int si=0,ti=0,len=m,start=-1;
        while(si<m){
            if(S[si]==T[ti]){
                if(++ti == n) {
                    //check feasibility from left to right
                    int end=si+1;
                    //check optimization from right to left
                    while(--ti>=0){
                        while(S[si--]!=T[ti]);
                    }
                    si++,ti++;
                    //record the current smallest candidate
                    if(end-si<len){
                        len=end-si;
                        start=si;
                    }
                }
            }
            si++;
        }
        return start==-1?"":S.substr(start,len);
    }
another approach: dp
dp[i,j] stores the starting index of the substring T[0..i] and S[0...j]
similar to edit distance, with just jump
after get all combinations and then we check the smallest


904. fruit into baskets
equivalent: longest window which contains <= 2 kind of trees

927. three equal parts
binary array: leading zeros and trailing zeros, need to have the same pattern

930. Binary Subarrays With Sum
find the window contains S number of 1s, and then the left and right 0s.
we can store all the 1s position and do sliding window on it.

978. longest turbulent subarray
we can use simple counting of +- sign
similar to sliding window.

992. subarrays with k different integers
subarray contains exactly k different integers.

sliding window using hashmap

1004. Max Consecutive Ones III
change up to k 0 to 1. longest subarrays
equivalent to find the longest window with at most k 0s
487. Max Consecutive Ones II
flip at most one 0 to 1. 
equivalent to longest window with <=1 zeros inside
485. Max Consecutive Ones
max window of consecutive ones

1100. Find K-Length Substrings With No Repeated Characters
sliding window with win=K and using hashmap to add a new char and remove old char.

1055. Shortest Way to Form String
copy source (by deleting some chars) to get target.
using sliding window matches.

1052. grumpy bookstore owner
convert to equivalent sliding window with most grumpy which <= k.

1040. Moving Stones Until Consecutive II
equivalent: find the window with min vacancies.


## binary search
74. Search a 2D Matrix
2d matrix actually sorted like a 1d matrix. so we can treat it as 1d
another approach: start from the bottom left element, so we only have 1 choice every step
240. Search a 2D Matrix II
rows are sorted, columns are sorted
use the bottom left as the root and treat it similar to a BST.


374. Guess number higher or lower
simple binary search problem
375. Guess Number Higher or Lower II
guess x and it is wrong then you need pay x.
min money to guarantee win.
minmax problem.
guess x and it divides into two subproblems.--dp.

410. Split Array Largest Sum
split into m subarrays, minimize the largest subarray sum
binary search: smallest largest sum: max element,
largest sum: the whole array sum
binary search: given a target sum, check number of parts

483. Smallest Good Base
integer n: using base m it can be represented as 1111...1
n is a long, up to 10^18
one idea: the representation of n for base 2 is longest, and do binary search
other: direct math. for n the longest length is log(n)/log(2). using some simple math.

540. single element in a sorted array
using binary search and count and we can find the one

702. Search in a Sorted Array of Unknown Size
assuming r=INT_MAX

644. maximum average subarray II
window size >=k.
equivalent: max average is the max element, min average is the min element
so we can use binary search (double) and find the k.
for double: right-left>eps, l=mid,r=mid

643. maximum average subarray I.
fixed window size k.
719. Find K-th Smallest Pair Distance
the absolute difference between pairs is between 0 and A[n]-A[0]
using a difference we count how many is less than it

774. Minimize Max Distance to Gas Station
given a list of station position in a row, add k more station so that the max distance is minimized.
observation: for a distance, if we add one, it reduces to d/2
if we add 2, it shall reduce to d/2 (but if we add based on previous result, we will get d/2)
so we need think it globally.

we can convert it to equivalent binary search problem:
the max distance is max, min distance can be 0
equivalent: using max distance D, how many stations we shall add.


778. swim in rising water
check the first time when connected.
using binary search

1044. Longest Duplicate Substring
follow up on 1062, repeated string can overlap.
binary search + direct hash.


786. kth smallest prime fraction
the is an upper triangle prime fraction
row: descending order
cols: ascending order.
so we start from the first row, last col. and push its neighborings into heap.


793. Preimage Size of Factorial Zeroes Function
factorial number of zeros is a staircase increasing function.
what we want to find is the k-zeros how many x.
this is equivalent to find the equal-range of x.


852. peak index in a mountain array
simple binary search: using A[m]<A[m+1]

875. koko eating bananas
equivalent: search and count binary search typical

878. Nth magical number
equivalent: binary search and count, and then get the solution.
min(A,B), max:N*lcm(A,B)

981. Time Based Key-Value Store
time value
get: give a timestamp, return the t<=timestamp. (closest)
binary search using upper_bound

1011. capacity to ship packages within D days
binary search to find the capacity

1095. find in mountain array
fidn the peak
find in left and then find in right

1060. Missing Element in Sorted Array
kth missing elements in sorted array.
using the first element (subtract all the element with it) and then we know:
nums[i]-nums[0]-i is the number of missing number.
must be familiar with tech to convert to equivalent simple problems.
```cpp
    int missingElement(vector<int>& nums, int k) {
        //binary search
        int l=0,r=nums.size();
        while(l<r){
            int m=l+(r-l)/2;
            if(nums[m]-nums[0]-m>=k) r=m;
            else l=m+1;
        }
        return l+nums[0]+k-1;
    }
```	

## hashmap
217 contains duplicate
convert to hashset and check if size is reduced
219. contains duplicate II
with index different <=k.
on the fly to check the index difference of same number
220. contains duplicate III
value difference <=t, and index difference <=k.
using sorted map for previous visited elements and binary search to find the element
(only keep the values inside the k window).


243. Shortest Word Distance
return the word distance in a list
word vs its list of index

244. Shortest Word Distance II
similar to 243

245. Shortest Word Distance III
may contain inside a group distance.

249. Group Shifted Strings
note it is cycle shift.
convert each string back to abc....
for example: abc, bcd, xyz,yza, they belongs to the same group.

1153. String Transforms Into Another String
one observation: directly map and if same char mapped to different char return 0
other: we need at least one unused char for swapping.

299. bulls and cows
we need first match bulls and change the hashmap and then match the cows


311. sparse matrix multiplication
using hashmap to record the value, i, j and then perform the matrix multiplication

325. Maximum Size Subarray Sum Equals k
using hashmap to save the prefix sum vs index (first index for that sum)
and then find the longest subarray.

1146. snapshot array
using map<snapid,map<int,int>> to record the status

391. perfect rectangle
overlapped rectangle
check there is no overlap
-. area=total area
-. outside corner points appear only one time
- inner side points appear even times

438. Find All Anagrams in a String
similar:
min window substring

451. Sort Characters By Frequency
similar to count sort
using hashmap

523. Continuous Subarray Sum
subarray size>=2
adds up to multiple of k.

prefix sum and same remainder
k=0 case.

525. contiguous array
01 array, longest substr with equal number of 0 and 1
consider 0 as -1, we are looking for the longest subarray with sum=0
prefix sum with same number.

567. Permutation in String
check if a string contains the permutation of another string
using hashmap to check if the hashmap> the other hashmap.

594. Longest Harmonious Subsequence
max and min difference is exactly one.
sort the array using map
and then from the smallest try to get the longest

599. Minimum Index Sum of Two Lists
record the string vs index
find the intersection

609. Find Duplicate File in System
using file content as the key and name as value

659. Split Array into Consecutive Subsequences
get the frequency of each number
and then count required and used.
pretty tricky.

769. Max Chunks To Make Sorted
compare with sorted
then check if hash is the same
768. Max Chunks To Make Sorted II
same to 769, but with duplicate in the hash so use multiset


791. custom sort string
S is sorted using some criteria, sort T using the same criteria.
in S, each char only appears once.
so we just use count sorting, and that is.

846. hand of straights
it needs some tricks, use a map to get its neigbors

874. Walking Robot Simulation
left/right rotation and find the max distance.
with obstacles.

893. Groups of Special-Equivalent Strings
the description is odd, but it is equivalent:
the odd index and even index string shall be equal so we build a common key

929. Unique email address
some simple string operations and hash

937. reorder log files
make sure using multimap to avoid key the same and log get lost.

953. verifying an alien dictionary
both mapped to a known order

957. prison cells after n days
hash to record the status and find the period

963. Minimum Area Rectangle II
rectangle is on the circle. using the circle center and diameter as the hash.
939. Minimum Area Rectangle
rect is along x and y axis. more similar to 2d intervals
using hash for x and y and divide and conquer.

966. Vowel Spellchecker
first exact match
second, case ignore match
third: vowel misspell.

997 find the town judge
the guy knows nobody but all knows him.

1001 grid illumination
row, col, diag, anti-diag
lights


1010. Pairs of songs with total duration divisible by 60.

1122. Relative Sort Array
sort using arr2. (using hashmap and count sort)

1072. Flip Columns For Maximum Number of Equal Rows
need convert to equivalent problem:
flip the column. we are actually looking for the same pattern for all the rows

## parsing a string or expression evaluation
this is where recursive approach most powerful.

1106. Parsing A Boolean Expression
- single t or f.
- ! use true & the result, and use true & the result, or use false | the results
- the , can be ignored and do recursively

1096. Brace Expansion II
using stack and recursion
default operation: union using ,
to avoid duplicate using hashset
stack of hashset
1087. Brace Expansion
return all combinations
there are no nested braces. so just connect them using dfs


## Misc

423. Reconstruct Original Digits from English
appear only in single number
appear twice...
combined
z, only in zero
w: only in two
u: only in four
x: only in six
g: only in eight



527. Word Abbreviation
- first char+ num abbreviated+last char
- if cannot get less, no abbreviation
- cannot have the same abbrviation, increase the prefix until it is unique
direct approach: create all abbreviation and increase prefix for conflict
other approaches: create trie to resolve conflicts
abbr-list of words



722. remove comments
aproach 1: regex
appraoch 2: remove // and /* */ for multiline


723. candy crush
find all those candy to crush, and marking them as negative and move forward

751. ip to cidr

788. rotated digits
rotate each digit individually.
brutal force is fine to loop each number.

796. Rotate String
we double the string and see if we can find the other string inside.

800. Similar RGB Color
find the r,g,b and the shortest rr,gg,bb


1111. Maximum Nesting Depth of Two Valid Parentheses Strings
min the max(depth(A),depth(B))
we try to make depth a and depth b similar to minimize
Basically, ( is 1 point, ) is -1 point.
We try to keep total points of two groups even,
by distributing parentheses alternatively.

The good part of this solution is that,
we actually need no extra variable to record anything.

1023. camelcase matching
1016. binary string with substring representing 1 to N.
brutal force searching

954. Array of Doubled Pairs
negative and positive two parts
sort and from smallest.

906 super palindrome
direct approach: 
odd and even, determine the range of the solution
and try its square and see if it is also a palindrome.

899. Orderly Queue
move the first k letters to end.
k==1
k>1 swap, when having two more positions it is equivalent to swap.

### count sort

1093. Statistics from a Large Sample
this is already count sorted results, each element has a count and without restoring the sequence, we need to find the element
prefix sum of the counters and find the element.

900 RLE iterator
this is similar idea: count and the array value and then search.


### combination and permutations
1079. Letter Tile Possibilities
- dfs and eliminate duplicates and using permutation.

### gray code
753. Cracking the Safe
reflection code.
2^k: base k reflection code, 
- loop 2^k
- reflect and change the last digit

## divide and conquer
395. Longest Substring with At Least K Repeating Characters
each char in the string must appear >=k times.
using a hashmap, find the first char which appears <k times
divide it into two parts: left and right
base: if find one<k, recursive, otherwise, return the whole string

beautiful array
divide and conquer.
divide into odd and even
[1,2,3,4,5,6,7,8]
- divide to [1,3,5,7], [2,4,6,8] (bit0=0/1)
- divide [1,3,5,7] into two sets (bit1=0/1)
  [1,5],[3,7]


### math problem
223. Rectangle Area
two overlaps

233. Number of Digit One
count total number of digit 1 from 1 to n.
this generally shall use log(n) algorithm, process digit by digit
current digit >1
current digit ==1
current digit <1
and it divides into left and right then we calculate the 1s

1154. day of the year
leap year %400==0 ||(%100!=0 && %4==0)

258. add digits
modular property: add digits repeatedly. 
296. best meeting point
median, idea from 1d.
median is often used for many problems

295. find median from data stream
using two heaps.

319. bulb switch
odd times, even times, and factors

335. self crossing
only the previous 3 directions matters

343. integer break
it can also be a dynamic problem
2*2=4
choose 3 first until to 4

356. line reflection
first arrange the points in x and y sorted order.
then we get max_x and min_x
the reflection line shall be in the mid.
then we check y make sure they are paired
357. count numbers with unique digit
n digits: 9*9*8*7*...

360. sort transformed array
sorted array, apply ax^2+bx+c.
x can be considered x coordinate
y=ax^2+bx+c, could be a down parabolic or up shape. 
a=0 case
a>0 case
a<0 case
use two pointer both end.

365. water and jug problem

372. super pow
calculate a^b%1337
digit by digit... log(n).

382. Linked List Random Node
eahc node shall have the same probability.
https://leetcode.com/problems/linked-list-random-node/discuss/85659/Brief-explanation-for-Reservoir-Sampling


384. shuffle an array
random shuffle-std function
    for (i = n-1; i > 0; --i) {
        swap(first[i], first[std::rand() % (i+1)]);
		
389. find the difference
two string, one string = permuation of the other string + another letter.
find the different one
xor of the two string


396. rotate function
F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].
find the max.
derive the recurrence relation:
F(k)-F(k-1)=Sum(A)-nA(n-k)

398. random pick index
given a target number, return the index randomly (with duplicate)
You have a file consisting of characters. The characters in the file can be read sequentially, but the length of the file is unknown. How do you pick a character so that every character in the file has equal probability of being chosen?

For this problem we can take algorithm like this:

Draw the 1st char. If there is a second char, then we will hold 1st char by prob = 1/2, and replace the 1st char to 2nd char with prob = 1/2. After this step we suppose that the char is X now.

After then, if there is 3rd char, then we will hold the X with prob = 2/3 and replace X to 3rd char with prob = 1/3. Why do they hold the same prob to be picked?
Because:
Obviously, Prob(the 3rd char is picked) = 1/3;
Prob(the 2nd char is picked) = 1 * 1/2 * 2/3 = 1/3;
Prob(the 1st char is picked) = 1 * 1/2 * 2/3 = 1/3;

So we can say that when we now has n chars and there is still another char in the file, we can pick the other char with prob= 1/(n+1), also keep original char with prob = n/(n+1), then we can secure each char is picked with same prob = 1/(n+1), because prob = 1 * 1/2 * 2/3 * ···· * n/(n+1) = 1/(n+1).


458. poor pig.
x-base problem

463. island perimeter
try each grid and check if it attaches with upper and left grid.

469. a list of points to check if the polygon is convex.
in the plane, (x,y).
three points we find the cross product.

470. implement rand10 using rand7.
rand7 generate 1 to 7 uniformly
rand10 generate 1 to 10 uniformly
use rand7() generate number between 0 to 48
7*(rand7()-1)+rand7()-1 (cannot just use 7*rand7, it will generate only 7 numbers)
when it is in the range [40,48] we regenerate, so we get random number [0,39]
-question: why cannt use other multiple?
1/49+9/49*1/49+(9/49)^2*1/49+...
=1/49*(1+9/49+(9/49)^2+.....)
=1/49*49/40
=1/40
- question: why 49? it must be n^b.
- question: how to improve the efficiency?

478. generate random point in a circle
angle from -pi to pi
r from 0 to 1, 
x=rcos(a)
y=rsin(a)
x^2+y^2=r^2
do random along angle and radius direction. note r direction need use sqrt(r).

479. Largest Palindrome Product
n digit, from 10000 to 99999
brutal force check n digit*ndigit will get 2n digits.

477. Total Hamming Distance
hamming distance is total different bits.
O(N) solution: divide it into two sets 
and then choose one from each set.

492. construct the rectangle
L>=W, L*W=A. 
min the L, W difference.
find the two factors which are closest.

493. reverse pairs
i<j and nums[i]>2*nums[j]
there are indices and values at the same time.
if we sort with index, or using map.
find the element < num/2 log(n)
find the elements with index > j takes O(n)
better approach using binary search tree.

504. base 7.

497. random point in non-overlapping rectangles
first random pick a rectangle, and then random generate a point inisde the rect.
note the area of the rectangle is a weight on the rectangle
note: the area shall cover the boundary, otherwise it will be incorrect (since it covers both boundary).


519. random flip matrix
all 0 in 2d matrix, randomly choose a 0 and flip to 1.
store flipped position in hashmap
update the size
random number hits the flipped:
 Fisher–Yates shuffle.
 generate random from 0 to n : m
swap m and n
decrease n
1,2,3,4,5,6,7,8
first roll: 6, 1,2,3,4,5,8,7 (swap 8 and 6)
2nd roll: 2, 1,7,3,4,5,8 (swap 2 and 7)
3rd roll: 6,  1,7,3,4,5 (last one no swap)
4th roll: 1,  5,7,3,4

(brutal force: used one we skip and until we get the right position)

528. radom pick with weight
prefix sum of the weight and then random pick using binary search

537. complex number multiplication
simple.

539. Minimum Time Difference
find the two time difference
if it is over half a day, then add a day
unwrap


553. optimal division

587. Erect the Fence
convex hull algorithm, gift wrapping 


592. fraction addition and subtraction


593. valid square
6 lengths 4 are the same and 2 are the same

625. min factorization
factorization of the number, and the digit product=num
factorization always get a pair.
and the factor can be decomposed again into smaller numbers until we get one digit number
so it becomes a recursive.
- shortest number of digits---
- choose the smallest factor between [2,9] for example 15=3*5
We only need to pick the largest factor in [2, 9] each time and put it to the front of current result. (So that the first pick is put at the least significant digit).
Why it works?
Lets forget about how we put the digits for a moment. If we just pick the largest factor in [2, 9] every time, we can guarantee the result has the shortest length (least digits).
Now if we have the shortest length, the way to make this number smallest is to put the largest one to the least significant.


710. random pick with blacklist

645. set mismatch
array 1 to n , and one number is converted to other number.
that is: one number missing and one number duplicates
find the two numbers.
using xor: suppose duplicate is a, and missing is b, then we get a^b
if we find the duplicate, and problem solved.
using the hashmap to count.
or check all seen element to negative.

660. Remove 9
removing all numbers containing 9
equivalent: 9-base problem and we get the nth number.

780. reaching a point
from (sx,sy) to (tx,ty) by transforming (x,x+y) or (x+y,y)
- from target to source is the same
- transform (x,y-x) or (x-y,y)
- the transform must be tx-sx % x==0 or ty-sy % x==0

781. Rabbits in forest
- different answers cannot be the same group
- same answer could be one group but could also be another group (when there are more rabits answering)


829. consecutive numbers sum
just check brute force: if it can be decomposed to : x,x+1,x+2....x+i.

836. rectangle overlap
835. image overlap
max of two left
min of two right

848. shifting letters
- %26 circular
- prefix sum

858. Mirror Reflection
mirror reflection is equivalent as modular operation
hence we unwrap the reflection.

866. Prime Palindrome
just try all possible palindrome: all even palindrome are divisible by 11, so can be ignored.

869. reordered power of 2
just try the 32 numbers.

883. projection area of 3d shapes

892. surface area of 3d shapes
common practice: only check with previous shapes and remove the covered surface areas.

1073. adding two negabinary numbers
using & and >>

1018. binary prefix divisible by 5
%5 and accumulate

1017. convert to base -2
using & and >>

1015. smallest integer divisible by K.
digits are all 1. using pigeon hole principle.
and %K and accumulate

1009. complement of base 10 integer
change binary bits from 0 to 1

974. Subarray Sums Divisible by K
prefix sum %K (also note for negatives)
and then count sort.

972. equal rational number
expand the number till double precision

# bits
231. power of two

136 single element
find the one appear once. using xor

137 single element II
every element appear three times except one appear once.
bit operations: add each single bit and %3. the remaining is the bit of that occurs only once.

use true table and karough map.


260 single number III
two numbers appear once and all other appear twice
xor and then choose a bit different divide into two sets and then apply the find single element


318. Maximum Product of Word Lengths
product of two words length which shares no common letters
convert chars to bits, and share problem is solved.

342. power of 4
1 bit are all on even bits

371. Sum of Two Integers
not allowed to use + -.
xor for addition
(a&b)<<1 for carrier flag
convert to carrier add the xor.


393. UTF-8 Validation
start with 110, need one followed
start with 1110, need 2 followed
start with 11110, need 3 followed

411. Minimum Unique Word Abbreviation
a string has a ist of abbreviations
given a string, return the min length abbrevaitons
the abbreviation cannot conflict with the list.
length of string <21.
use bit to represent the abbreviations.
word:
word, 0000
1ord: 1000
2rd:  1100
w3:   0111
a number is consider 1 length
a char is considered 1 length
a32bc: length=4, a,b,c,32
in binary format: neighboring 1s are considered as 1 length
for [00101,10001] the mask is 00001, means keep the last char, "4e"
abbreviation to binary
binary to abbreviation
count the length


421. Maximum XOR of Two Numbers in an Array
32 bits and separate in two halves
and decide the final results of each bit.

## graph
1135. Connecting Cities With Minimum Cost
two problems:
- if the cities can be formed one group
- the smallest costs connect any pair of cities (max min)
union-find: 
sort by cost
loop over edges, if union(city1,city2) add the cost.


444. Sequence Reconstruction
connect the sequence (overlap the same)
[1,2],[1,3],[2,3]
[1,2] connect with [2,3] we get [1,2,3]
[1,2],[1,3] can build 1,2,3 or 1,3,2 (building is a bit different:
a,b->c if a and b are both subsequence of c.)
asks: - if we can - if it is the only one.
This question can be simplified to three conditions:
similar to course schedule I/II.
using topological sort.
graph can be represented as vector<unordered_set> to record the outcoming edges
the last node shall be a source node. and step by step to strip the source node
and we can build the sequence.


TopSort order exists
Whether the TopSort order is the only one (Uniqueness of Topological sort, Hamilton path, see https://en.wikipedia.org/wiki/Topological_sorting#Uniqueness).如果不是，那么说明有些pair只有偏序关系，没有全序关系，这样不能完全确定元素之间的顺序
the only top sort order constructed should be equal to the org.
index == org.length (check condition 3) && index == map.size() (check all the vertex in the graph has been visited, so the top sort order exists, check condition 1)

How to check only one order? queue.size() should always be one, then only one element at a time has indegree to be 0, so you only have one choice (check condition 2)


similar:
943. find the shortest superstring
1092. shortest common supersequence

## linked-list
234. palindrome linked list

237. delete node in a linked list

328. odd even linked list
traverse the list and save into two lists and then connect

369. plus one lined list

430. flattern a multilevel doubly linked list

445. Add Two Numbers II
reverse list and add, and then reverse

708. insert into a cyclic sorted list
- empty list, insert and linked to itself
- value is between prev and next.
- all values are the same and insert any where


725. split linked list in parts
k in each parts.
just use similar ideas in array

817. linked list components
return number of groups given an array
store array in hashset, and check one by one to see if they are in the hashset

876. middle of the linked list.
slow and fast.


## design

225. implement stack using queues

232. implement queue using stacks

251. Flatten 2D Vector
2d vector flatten. simple, similar to nested integer but more straightforward

348. design tic-tac-toe
use +1 for player A, -1 for player B.
hashmap to validate the board.

352. data stream as disjoint intervals
stores the interval as a sorted intervals (set)
every time add a val, start and end are the val
find the lower_bound and check if it can merge with previus interval

353. Design snake game
the snake eats the food and grows by one.
the snake eat the food and occupy the tail previous position.
using a deque for that.

355. design twitter
postTweet(user,tweetID)
getNewFeed(user)
follow(followerID,followeeID)
unfollow(followerID,followeeID)

data structure:
a vector to store the user-news pairs
a hashmap to map the user vs news id (index in the array)
a hashmap to map the user vs its followers


359. logger rate limiter
each message shall be prinited if and only if it is not printed in last 10 seconds
using a map, once it is printed, we add its timestamp by 10 second
only if the ts> timestamp, it wll be printed.

362. design hit counters
count the number of hits in the past 5 mins
deque to maintain the hits in time.
pop those > 5 mins


379. design phone directory
hashset to store used unused


380. Insert Delete GetRandom O(1)
using a vector and a hashmap for the index
swap to end
381. Insert Delete GetRandom O(1) - Duplicates allowed
using a vector to store data
a hashmap of value vs a collection of index

432. All O`one Data Structure
inc/dec/getmaxkey/getminkey
design a matrix like data structure.
each row: contains a list of keys and a value
and a key to row iterator and list iterator map for O(1) access


460 LFU cache
freq vs list
key vs value,freq
key vs list interator for O(1) operation
read/write 

146. LRU Cache
list of pair key-value
map: key vs list iterator for O(1)
read/write


535 encode and decode tinyURL
using 0-9A-Za-z total 62 chars to get a 6 char long string.
using random 62 mod

588. design in-memory file system
ls: list files and directories
mkdir: 
addContentToFile: create/append contents to file
readContentFromFile: 

this is a file tree structure.
using trie. or n-ary tree structure.

604 design compressed string iterator
similar to the count and array using binary search and prefix sum

622. design circular queue
using vector and head, tail

631. design excel sum formula
row from 1 to 26
col from A to Z
set: set the value at row and col
get: get the value at row col
sum: sum(r,c,numbers) sum the numbers and set the value at row col
the trick is when one element is changed, the formula shall be applied to the cells again.



635. design log storage system
store the log with timestamp.
retrieve using granuity
using multimap to store to accept duplicate key.
using binary search

642. design search auto-complete system
see trie.
641 design circular deque
using vector, head tail pointer


895. max frequency stack
the idea: for each frequency build a stack: hash: frequency vs stack
value - frequency
freq - stack.

716. max stack
using two stacks. 
the only trick is: popmax, we need find the element and pop and save all those elements and put back.

707. design linked list
706 design hashmap
705. design hashset

# binary index tree or segement tree
308. range sum query 2d-mutable

307. range sum query - mutable

## trivial
1119. Remove Vowels from a String
1118. Number of Days in a Month
leap year is: %4==0 %100==0 && %400==0
1108. Defanging an IP Address
replace . with [.]
1085. Sum of Digits in the Minimum Number
1078. Occurrences After Bigram
just understand the problem correctly.
1065. Index Pairs of a String
1064. Fixed Point
A[i]==i binary search
1056. confusing number
1051. Height checker
1047. Remove All Adjacent Duplicates In String
simple stack problem
1037. valid boomerang
1030. matrix cells in distance order
1002. find common characters
999. available captures for rook
994. rotting oranges
one step bfs
989. add to array form of integer
985. sum of even numbers after queries
961. n-repeated element in size 2n array
majority or hashmap
933. number of recent calls
922. sort array by parity II
917. reverse only letters
914. x of a kind in a deck of cards
gcd
905. sort array by parity
896. monotonic array
888. Fair Candy Swap
simple math and set.
884. uncommon words from two sentences
868. binary gap
867. transpose matrix
860. lemonade change
859. Buddy Strings
swap only two letters in A so that A==B
840. magic squares in grid
832. flipping an image
831. masking personal information
830. positions of large group: simple two pointer
824. goat latin
819. most common word
821. shortest distance to a character.
two passes: first get the shortest distance to its left and then get the distance to its right.
812. largest triangle area
sorted
811. subdomain visit count
simple hash
804. unique morse code words
simple hash
766. toeplitz matrix
762. prime number of set bits in binary representation
747. largest number at least twice of others
get the largest and second largest using one pass.
746. min cost climbing stairs
simple dp
744. Find Smallest Letter Greater Than Target
sorted char list, using upper_bound
733. flood fill
simple dfs
724. Find Pivot Index
left sum=right sum, and it is a simple both end problem
720. longest word in dictionary
661. image smoother
need use a new image
657. robot returning to origin.
UDRL without rotation
717. 1 bit and 2 bit characters
two pointer: see 1 jump 2, see 0 jump 1
709. to lower case
704. binary search
703. kth largest elment in a stream
simple heap
633. sum of seuare numbers
brutal force
628. max product of three numbers
598. range addition
all operations is from [0,0] to [i,j] so there are fixed overlaps
566. reshape the matrix
557. Reverse Words in a String III
509. fib number
507. perfect number
n=sum(its divisor except itself)
506 relative ranks
sort with index
482. license key formating
415. add strings
414. third max number
single loop to get the max,2nd max and 3rd max.
412. fizzbuzz
409. Longest Palindrome
count, palindrome only supports 1 char with odd number
405. convert number to hex
404. sum of left leaves
401. binary watch
400. nth digit
387. first unique character in string
two pass using hashmap

367. valid perfect square
1137. nth triboncii number 
similar to fib number
1133. largest unique number
map with greater
1134. armstrong number
k digits number = sum(digit^k)
350 intersection of two arrays II
keep duplicates,hashmap, once matched, --
349. intersection of two arrays
no duplicates
346. moving average from data stream
345. reverse vowels of a string
344. reverse string



knowledge
- random_shuffle
loop from back and swap with previous random
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits<RandomIt>::difference_type i, n;
    n = last - first;
    for (i = n-1; i > 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
        // rand() % (i+1) isn't actually correct, because the generated number
        // is not uniformly distributed for most values of i. A correct implementation
        // will need to essentially reimplement C++11 std::uniform_int_distribution,
        // which is beyond the scope of this example.
    }
}

- pascal triangle each number is C(n,m)

amazon
* two sum: hashmap
* Longest Substring Without Repeating Characters
hashmap to store char's index
one pass to get the window length
* string to integer
using stringstream
* container with most water
two pointer
* integer to roman
0-9
10-90
100-900
1000-3000
* roman to integer
right to left.
*. 3sum
two pointer, unique triplets, sort
*. 3sum closest
two pointer, sort, tsum<target, make it larger, else make it smaller
* strstr: match
* rotate image
* group anagrams
*. min window substr
hashmap with two pointer
*. compare version number
using stringstream, default 0
* product array except self
left and right product
* missing number
xor
*. integer to english
every hundred
1-19
20-90
others are the same
*. first unique char
hashmap
* valid parentheses- stack,counter
*. most common word, hashmap
*. reorder log files
using multimap, key could be the same
*. trapping rain water
using stack
*. add two numbers-linked list
*. merge two sorted list
*. reverse nodes in k groups.
a bit tricky, reverse need return both the head and tail.
* copy list with random pointer
hashmap node-id, id-node
*. reverse linked list
*. merge k sorted list
using a min heap
*. valid bst
*. symmetric. compare left right
*. binary tree level order traversal
bfs
recursive
*. binary tree zigzag traversal
*. binary tree max path sum
O(N) solve the left parent to child, right parent to child
and using 1d array max subarray sum, if leftsum<0 ignore left.
*. word ladder II
bfs with path traceback.
*. word ladder- bfs
*. number of islands-dfs
*. course schedule- cycle detection using topological sort.
*. course schedule II- topology sort, layer by layer
*. lowerest common ancestor
O(N)
*. diameter of binary tree
longest path. 
left longest path, right longest path
add the node.
*. cutoff trees for golf event
bfs
*. flood fill
dfs
*. letter combination of phone number
dfs.
*. generate parentheses
dfs/recursive
*. word search
dfs. avoid repeatedly visit, change and restore
*. word search II
using trie and dfs search
*. median of two sorted arrays
binary search in 4 sections
*. search in rotated sorted array
find the pivot and then treat it as a sorted array from pivot
*. merge interval
*. two sum II-bst
*. kth largest element in an arrays
min heap
*. meeting room II
++ --
*. top k frequent element
heap
* k closest pointts to origin
heap
*. longest palindrome substring
dp, substring
*. max subarray
dp: local max, gmax
*. best time to buy and sell stocks
dp[i]=max(dp[i-1],price[i]-price[j)
* word break
check every position
* coin change
*. lRU cache
*. min stack
* find median from data stream
two pq, push to left or right or replace the median.
*. serialize and deserialize binary tree
* design search auto complete
* design tic-tac-toe
*. max freq stack
*. reverse integer
*. partion labels
bfs like approach
*. prison cells after n days

Mock: on site
* roman to integer
* lca of a binary tree
* word ladder
* median from stream

* symmetric tree
* snake and ladders
convert to 1d, and layer add, bfs
* word break-dp
* word break II
- dp+dfs
- top down recursive is also fine. maybe simpler. with memoization.

* best time to buy and sell stock
* binary tree zigzag level order traversal
* number of islands
* lru cache

* missing elements in sorted array- binary search
* uncrossed lines - dp
* number of submatrices sums to target
- reduce to 1d problem

* game of life
* shortest path in binary matrix- bfs
* path with max min value - binary search

* course schedule - remove source nodes layer by layer
* course schedule II- similar approach
* binary tree max path sum- tricky

online:
* most common word
* cut off trees for golf event

* two sum
* prison cells after n days

* rect overlap
* partition label

* two sum-bst
* greatest common divisor of strings

* moving average from stream
* number of equivalent domino pairs

phone interveiw
* first unique char in a string
* reverse linked list
* search in rotated sorted array
note: binary search if l=m, will have two element infinite loop problem.

* valid bst
* add two numbers
* product of array except self

* valid parentheses
* min stack
* group anagrams

* flood fill
* insufficient nodes in root to leaf path


interviewing.io:

8/9/2019

Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

Example 1:
Input:nums = [1,1,1], k = 2
Output: 2

1060. Missing Element in Sorted Array
Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array.

 

Example 1:

Input: A = [4,7,9,10], K = 1
Output: 5
Explanation: 
The first missing number is 5.

8/10/2019
There is a fence with n posts, each post can be painted with one of the k colors.

You have to paint all the posts such that no more than two adjacent fence posts have the same color.

Return the total number of ways you can paint the fence.

n=3,k=2, answer=6
n=10,k=5, answer=7348480


Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

mock
Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.

The distance between two adjacent cells is 1.

[[0,0,0],
 [0,1,0],
 [1,1,1]]
 
 
 Output:
[[0,0,0],
 [0,1,0],
 [1,2,1]]
 
 first, update all those neighboring to 0 (non zero elements)
 if they are close to 0, return 1, otherwise add to queue. that is the first layer
 
another approach: dp
check its top and left  (first pass)
then check its bottom and right from other direction (second pass)
boundary: make it large.

just similar to 1d array left and right min distance problem.
[[1,0,1,1,0,0,1,0,0,1],
[0,1,1,0,1,0,1,0,1,1],
[0,0,1,0,1,0,0,1,0,0],
[1,0,1,0,1,1,1,1,1,1],
[0,1,0,1,1,0,0,0,0,1],
[0,0,1,0,1,1,1,0,1,0],
[0,1,0,1,0,1,0,0,1,1],
[1,0,0,0,1,1,1,1,0,1],
[1,1,1,1,1,1,1,0,1,0],
[1,1,1,1,0,1,0,0,1,1]]


























