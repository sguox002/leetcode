## dp
920 number of music playlist
N songs, L songs in list.
every song can shall be played at least once.
a song can be played only if k other songs have been played.
dp: subproblem i songs with j different songs.
Think one step before the last one, there are only cases for the answer of dp[i][j]
case 1 (the last added one is new song): listen i - 1 songs with j - 1 different songs, then the last one is definitely new song with the choices of N - (j - 1).
Case 2 (the last added one is old song): listen i - 1 songs with j different songs, then the last one is definitely old song with the choices of j
if without the constraint of K, the status equation will be
dp[i][j] = dp[i-1][j-1] * (N - (j-1)) + dp[i-1][j] * j

If with the constaint of K, there are also two cases
Case 1: no changes since the last added one is new song. Hence, there is no conflict
Case 2: now we don't have choices of j for the last added old song. It should be updated j - k because k songs can't be chosed from j - 1 to j - k. However, if j <= K, this case will be 0 because only after choosing K different other songs, old song can be chosen.

if (j > k)
dp[i][j] = dp[i-1][j-1] * (N- (j-1)) + dp[i-1][j] * (j-k)
else
dp[i][j] = dp[i-1][j-1] * (N- (j-1))


931. min falling path sum
simple dp

940 distinct subsequence II
ending with different char.

115. Distinct Subsequences
find in S the subsequence=T.
edit distance.

960. Delete Columns to Make Sorted III
delete columns and make each row sorted
equivalent to longest increasing subsequence but with n arrays.
955. Delete Columns to Make Sorted II
delete columns columns shall be sorted.
do not need dp.

964. least operators to express number
x based 

975. odd even jump
do it from right. 
visited forms a map and use binary search.

983. min cost for tickets
one day, 7 day and 30 day pass.
for ith day, we can use single day, 7 day or 30 day

1000 min cost to merge stones
merge K consecutive piles into one pile, cost is equal to the k sum

1027. Longest Arithmetic Sequence
dp using difference and i.


1035. Uncrossed lines
equivalent: longest common subsequence


1105. Filling Bookcase Shelves
thickness and height
shelf width.
book order cannot be changed.
return the min height
a book i with Wi and Hi can be placed in kth layer.
the shelf height is decided by the max height.
this is similar to group the array and min the sum of the max.
so the idea is: for group i, either is belongs to previous group or to next group
group is constrained by the width.
if book i, belongs to previous group, then we need to update the max.
if book i, starts a new group, then we need to update the new height.
dp[i] is the min height for the first i books.

1092. Shortest Common Supersequence
need convert to equivalent problems:
find the longest common subsequences
and then build the min supersequence
similar to longest common subsequence length, but we shall use string directly to avoid trace back.

1062. Longest Repeating Substring
direct approach: using O(N^2) to build all the substrings, TLE
dp approach: we only compare one char since previous compare is done.

1044. Longest Duplicate Substring
follow up on 1062, repeated string can overlap.
binary search + direct hash.

1048. longest string chain
common dp practice

1043. Partition Array for Maximum Sum
element can be attached to previous group or itself become a new group
dp with heap.

1039. Minimum Score Triangulation of Polygon
dp with i,j,k O(N^3) to split into one triangle and two subproblems


### knapsack
956. tallest billboard
each element has three options: choose to A, choose to B, or not used
target: sum=0


1058. Minimize Rounding Error to Meet Target
each element can use ceil or floor (+ or -)
so the sum max would be all ceil and sum min is all floor.
it is equivalent to: choose from two arrays to sum to a target
return the smallest rounding error! (since we may have multiple choices)
only has 3 decimals
greedy: we can get number floors and number of ceils. then sort the decimals accoring to the errors

nth_element: partial sort to get the sorted position element.

1049. Last Stone Weight II
smash the stone: equal: both destroyed. smaller destroyed and remaining y-x.
convert to equivalent:
some elements are negative and some are positive, and the sum of positive shall be >= negative sum.
knapsack problem

1046. Last Stone Weight
choose heaviest and smash. this is heap.

### shortest distance problem
943. find the shortest superstring
equivalent: make AB the distance, and then find the shortest distance to visit each node once.
- use all words
- build a graph matrix. 
- use dp to find the shortest distance (2d, with status and node) and also path information for tracing back.


## think simple using computer way.
970. powerful integers
just try brutal force loops

982. Triples with Bitwise AND Equal To Zero
triple reduce to N^2 two element bitwise
and then add another.

1103. Distribute Candies to People
it is just a 1 to n and arranged in rows, so do not use those complicated methods
but just use iteration and %

1089. duplicate zeros
in place: two pointer and imagine we are using sufficient memory.

1071. greatest common divisor of strings
using same principle working for numbers.
by subtracting the common.

## two pointer
915. Partition Array into Disjoint Intervals
left side < right side
min size of left side.
get lmax and rmin. and find the first one when lmax<rmin.

923. 3Sum With Multiplicity
using hashmap to record the frequency of each number.
if 3 numbers from 1 set: C(n,3)
if 3 numbers from 2 set: C(m,2)*C(n,1)
if 3 numbers from 3 set: C(i,1)*c(j,1)*C(k,1)


925. long pressed names
two pointer compare

926. Flip String to Monotone Increasing
binary string: left all 0 right all 1
find all positions to be the pivot and get the number of flips


962. Maximum Width Ramp
lmin for the left
and rmax for the right
greedy approach

977 squares of sorted array
two pointer: min may becomes max.

1014. Best sightseeing pair
lmax of A[i]+i and rmax of A[j]-j.

1031 max sum of two non-overlapping subarrays
lmax and rmax from both side



## recursive
984. string without AAA or BBB
base cases: A=0 B=0
when A>B AAB+subproblems
when A==B AB+subproblems


1088. Confusing Number II
return the confusing numbers in [1,N]
approach 1: backtracking, will use a lot of time
approach 2: recursive by adding previous solution 1+xx+1, 8+xx+8, 6+xx+9,9+xx+6
similar to Strobogrammatic Number II, but it only requires length<=n.



## Array
912. sort an array.
merge sort
quick sort
bubble sort

916. Word Subsets
use 26 char array instead of hashmap to save time.

918. max sum circular subarray
this is follow up for 1d array.
1d array: if the previous sum <0 we begin a new segment. and find the max.
to avoid circular array: we find the subarray max and min. then get the max of the two answers.

1131. maximum of absolute value expression
first need to remove the abs.
|a[i]-b[j]|+|b[i]-a[j]|+|i-j|, we have 8 combinations (3 +/- selections)
a[i]-b[j]+b[i]-a[j]+i-j  --> [a[i]+b[i]+i]-[a[j]+b[j]+j]
a[i]-b[j]+b[i]-a[j]+j-i --> [a[i]+b[i]-i]-[a[j]+b[j]-j]
a[i]-b[j]+a[j]-b[i]+i-j --> [a[i]-b[i]+i]-[a[j]-b[j]+j]
a[i]-b[j]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
b[j]-a[i]+b[i]-a[j]+i-j --> -[a[i]+b[i]+i]+[a[j]+b[j]+j]
b[j]-a[i]+b[i]-a[j]+j-i --> -[a[i]+b[i]-i]+[a[j]+b[j]-j]
b[j]-a[i]+a[j]-b[i]+i-j --> -[a[i]-b[i]+i]+[a[j]-b[j]+j]
b[j]-a[i]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
then we separate i and j, it is actually 4 cases
we find the min and max and get the max-min


## stack & deque
921. Minimum Add to Make Parentheses Valid
using stack:
if paired, popped. 
if ) and has no match ans++ 
if ( no match they are in the stack

946. validate stack sequence
simulate the stack, a number shall be pushed first before popped

950. reveal card in increasing order.
reveres the process using deque. 

1003. check if word is valid after substitutions
simple stack or deque problem

1006 clumsy factorial
using stack for expression evaluation.
similar to calculator without ()

1019. next freater element in linked list
typical stack problem: montonic

1021. remove outmost parenthesis
using stack or using counters

1130. Minimum Cost Tree From Leaf Values
the array order cannot be changed.
- equivalent: remove the smaller at the cost A[i]*A[j]
- greedy: to min A[i]*A[j] need combine A[i] with its next larger.
- using stack to store a sorted sequence (sorted is a simple greedy)

1081. Smallest Subsequence of Distinct Characters
same as eliminate duplicates
to keep it smaller, when a small char comes, need to replace char in stack.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

1028. Recover a Tree From Preorder Traversal
using iterative stack



## bfs
1024. video stitching
using bfs like to cover the max distance.


1129. Shortest Path with Alternating Colors
- from 0 to all other nodes
- using bfs to get the shortest distance
- the distance can be greater than n since we may need to come back
- form a graph (adjacent matrix) data structure needs 0 for blue and 1 for red
- have two options: first start blue or start red
- we can use simple structure for adj matrix (*2 for blue *2+1 for red)
- self connected edge cannot be ignored since it will be able to connect the path.
- perform two bfs.
* the simple data structure for adj makes the problem a lot simpler.
* using dfs are not good for this. always try bfs first for shortest distance problems.

1102. Path With Maximum Minimum Value
this is similar to the swimming in rising water.
it asks for the min value along the path where all those smaller elements are not passable and there is only one path.
so it is a binary search with a bfs problem

1091. Shortest Path in Binary Matrix
8 directions with 0 and 1 (1 blocked). return the shortest path from top left to bottom right
regular bfs


## dfs
934. shortest bridge
- first find the two islands using dfs
- find the smallest distance between the two islands

935. Knight Dialer
using dp or dfs/recursive

959. regions cut by slashes
need upsample and do the dfs

967. Numbers With Same Consecutive Differences
dfs: try +k and -k. not above 9.

980. Unique Paths III
-1 obstacles, 0: empty, 1 source, 2 target
it requires to walk on every empty cell exactly once. 
return number of path
it needs two requirements: walk on every cell, and reach the end.
just regular dfs.
63. Unique Paths II
number of paths, using dp is faster (with obstacles)
62. Unique Paths
dp or pure math.


996. number of squareful arrays
neighboring elements sum is a square.
return the number of permutations.
build the graph (for each element its neighboring)
and then dfs.


1020. number of enclaves
common dfs

1125. Smallest Sufficient Team
- most important: convert the required skills into bits and simple the problem using dfs.
- non-required skills are ignored.
- do a O(N^2) loop and eliminate those people with same skills, or a subset of skills

1059. All Paths from Source Lead to Destination
- lead to other nodes
- lead to infinite cycle

dfs with cycle detection
using 3 states: visited, not visited, visiting.

1036. Escape a Large Maze
two dfs: block the source, block the target
dfs distance > the block size, then we are outside.

1034. coloring a border
dfs using negative color, restore inner side




## counting in array.
1012. numbers with repeated digits
equivalent: numbers without repeated digits.

1128. Number of Equivalent Domino Pairs
this is common seen counting in array using hashmap
keep adding the previous occurences
equivalent to 1+2+3+...+k 

1124. Longest Well-Performing Interval
- >8 convert to 1, <=8 convert to -1.
- prefix sum. 
	if prefix[i]>0 then all previous are good.
	if prefix[i]<0 then we need to find previous smaller one
	
1099. Two Sum Less Than K
common practice: sort the visited elements in a map/set and then use binary search to find the elements

560. Subarray Sum Equals K
similar to 1099. 1d

1074. Number of Submatrices That Sum to Target
using tech in 560 and reduce to 1d problem

1067. Digit Count in Range
given a digit d in [0,9], return the number of occurences in [low,high].
- we can get [1, high]-[1,low], high low can be converted to number of digits
same length of digits shall be counted carefully.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

	
## interval problems
986. interval list intersection
two sorted list of intervals, find the intersection.
apply two pointer and check if two intervals intersect.


1109. Corporate Flight Bookings
- add an event and remove an event using map for positive and negatives
- prefix sum to get the results.

1094. car pooling
add passenger and unload passenger


	
## Tree
919. Complete Binary Tree Inserter
this is very interesting using array to implement a tree.


938. Range Sum of BST
easy

951. flip equivalent binary tree
left-left & right-right
left-right & right-left

958. check completeness of a binary tree.
- bfs approach: when we see a null node, there shall have no nodes after
- dfs approach: left depth is always>=right depth. (preorder).

965. univalued binary tree.
passing the root value to subtree

968 binary tree cameras
greedy: put the camera on the parent, so it can cover children and parents.
using status to reflect if the root is monitored or not.
do it from bottom to root.

971. Flip Binary Tree To Match Preorder Traversal
array is a binary tree (some subtrees flipped) preorder traversal
first match the node, and then match left/right or right/left.

979. distribute coins in binary tree

also similar to the washing machine. the abs(diff) is the coins up/down the root.

987. Vertical Order Traversal of a Binary Tree
record depth, and x, and value
there are overlaps (same position)
preorder:
then sort according to requirements.

988. Smallest String Starting From Leaf
simple dfs, when reaching leaf, reverse the results.

993. cousins in binary tree
only need to keep the parent information and depth information


654. max binary tree
build from array: max as the root, left is left subtree, right is right subtree
heap. (used for map, set data structure, pq uses complete full binary tree).

998. max binary tree II
append a number to the array, and return the max binary tree
- empty and it shall be the root
- > root, it shall be the root, original root shall be its left
- <root, it shall go to the right

1008. construct binary search tree from preorder traversal
BST, preorder, the root is always the first and divide by left and right
using upper_bound

1022. sum of root to leaf binary number
preorder/dfs/recursive

1026. max difference between node and ancestor
preorder and find the min and max of all prefix.

1028. Recover a Tree From Preorder Traversal
iterative stack

1038. Binary Search Tree to Greater Sum Tree
reverse inorder traversal
similar to array's suffix sum


1123. Lowest Common Ancestor of Deepest Leaves
O(N^2) is easy
O(N): first find the left depth and right depth of the root one pass. second pass find the node with depth-1.
O(N) single pass: get the depth and the node at the same time.

1120. Maximum Average Subtree
average: need to get the sum and number of nodes.
using postorder traversal, we get the sum and number of nodes for its left/right subtree and then get the results for the root.

1110. Delete Nodes And Return Forest
when a node is to br removed, we need update its parent and child becomes another tree
do not forget the root when it is not removed.
google phone screen

1104. Path In Zigzag Labelled Binary Tree
full tree, the node from leaf to parent is n/2 and apply the zigzag relation.

1080. Insufficient Nodes in Root to Leaf Paths
all path passing the node sum<limit.
O(N): the limit - val. if leaf<limit, return null, the left and right both returns null, then the root is also removed.

## greedy
932. beautiful array
A[k]*2!=A[i]+A[j]
starting from [1].
left odd and right even. expand.
[1]
[1,2]
[1,3,2,4]
[1,5,3,7,2,6,4,8]
.....

936. Stamping The Sequence
reverse from target to source
using greedy match.

942. DI string match
use two end meet. D choose the max, I choose the min


945. min increment to make array unique.
sort first and add 1.

948. Bag of Tokens
greedy: use the point for max power and use least power to gain points

949. largest time for given digits.
from the right, if we have larger digits, choose it.
otherwise, choose the smallest.

969. Pancake Sorting
greedy: flip the min to the top, repeat.

991. broken calculator
only support *2 and -1. 
min number of operations from x to y.
we can also do from y to x, and is more clear. /2 +1

995 min number of k consecutive bit flips
min number of flips needed to make it all 1.
greedy: turn the left most bit 0.

1005. max sum of array after k negations
greedy: try to negate those negatives. after that, we need compare the last negated negative with the smallest original positive

1007. min domino rotations for equal row.
either all rotate to a[0]
either all rotate to b[0]
do it one by one, do not involve two things. do it simple way.


1025 divisor game
greedy: odd/even

1029. two city scheduling
greedy 1: send all to A and then send those most saving to B.

1053. Previous Permutation With One Swap
to make it smaller with one swap.
greedy: find the first peak from right to left, and swap with leftmost element in its right < peak.

1042. Flower Planting With No Adjacent
garden has no more than 3 neighbors
greedy: make a graph and chose available color

1041 robot bounded in circle
greedy: try a whole cycle or more cycles. repeat 4 times and we would be able to do it.
common practice: rotation


## heap
973. k closest points to original
heap

1121. Divide Array Into Increasing Sequences
greedy: choose K increasing subsequences from the most frequent one
just like to get rid of a layer from the mountain and until it is flat

1090. Largest Values From Labels
values, labels
limited K from each labels
return the max sum
it is natually using heap.
first store the values vs label in a sorted map from larger to smaller.

1086. High Five
top five scores, using minheap to keep only 5 scores.

1066. Campus Bikes II
N workers and M bikes.
min manhattan distance and lowest index bike.
need work on it.

1057. Campus Bikes
sorting all combinations.

1054. Distant Barcodes
rearrange so that no neighboring are the same
using heap to arrange the two most common words

## trie
1032 stream of characters
matching with the prefix, startwith




## union find
924. Minimize Malware Spread
return the first node which can minimize the infected nodes by removing it from initial list.
ie, assuming the node is not affected.
- parent node - the initial nodes, find the one with largest size

928. Minimize Malware Spread II
initial list: remove one infected nodes and disconnect its neighbors.
union find in a reverse way: 
build the disjoint set without the infected
add one by one by disable the node only and add all other nodes, and check which one forms the largest number of elements.
we are not doing merge but only count the number of sets to be union and count the number


947. most stones removed with same row or column
use dfs or union-find, similar to number of islands

952. Largest Component Size by Common Factor
connect the numbers when they share a factor.
use prime factorization for each element.


990. Satisfiability of Equality Equations
use == relation and merge them and use != to check them

1101. The Earliest Moment When Everyone Become Friends
union and find the earliest time that unites as one group

1061. Lexicographically Smallest Equivalent String
union and use each group's parent.


## sliding window
927. three equal parts
binary array: leading zeros and trailing zeros, need to have the same pattern

930. Binary Subarrays With Sum
find the window contains S number of 1s, and then the left and right 0s.
we can store all the 1s position and do sliding window on it.

978. longest turbulent subarray
we can use simple counting of +- sign
similar to sliding window.

992. subarrays with k different integers
subarray contains exactly k different integers.

sliding window using hashmap

1004. Max Consecutive Ones III
change up to k 0 to 1. longest subarrays
equivalent to find the longest window with at most k 0s
487. Max Consecutive Ones II
flip at most one 0 to 1. 
equivalent to longest window with <=1 zeros inside
485. Max Consecutive Ones
max window of consecutive ones

1100. Find K-Length Substrings With No Repeated Characters
sliding window with win=K and using hashmap to add a new char and remove old char.

1055. Shortest Way to Form String
copy source (by deleting some chars) to get target.
using sliding window matches.

1052. grumpy bookstore owner
convert to equivalent sliding window with most grumpy which <= k.

1040. Moving Stones Until Consecutive II
equivalent: find the window with min vacancies.


## binary search
981. Time Based Key-Value Store
time value
get: give a timestamp, return the t<=timestamp. (closest)
binary search using upper_bound

1011. capacity to ship packages within D days
binary search to find the capacity

1095. find in mountain array
fidn the peak
find in left and then find in right

1060. Missing Element in Sorted Array
kth missing elements in sorted array.
using the first element (subtract all the element with it) and then we know:
nums[i]-nums[0]-i is the number of missing number.
must be familiar with tech to convert to equivalent simple problems.

## hashmap
929. Unique email address
some simple string operations and hash

937. reorder log files
make sure using multimap to avoid key the same and log get lost.

953. verifying an alien dictionary
both mapped to a known order

957. prison cells after n days
hash to record the status and find the period

963. Minimum Area Rectangle II
rectangle is on the circle. using the circle center and diameter as the hash.
939. Minimum Area Rectangle
rect is along x and y axis. more similar to 2d intervals
using hash for x and y and divide and conquer.

966. Vowel Spellchecker
first exact match
second, case ignore match
third: vowel misspell.

997 find the town judge
the guy knows nobody but all knows him.

1001 grid illumination
row, col, diag, anti-diag
lights


1010. Pairs of songs with total duration divisible by 60.

1122. Relative Sort Array
sort using arr2. (using hashmap and count sort)

1072. Flip Columns For Maximum Number of Equal Rows
need convert to equivalent problem:
flip the column. we are actually looking for the same pattern for all the rows

## parsing a string or expression evaluation
this is where recursive approach most powerful.

1106. Parsing A Boolean Expression
- single t or f.
- ! use true & the result, and use true & the result, or use false | the results
- the , can be ignored and do recursively

1096. Brace Expansion II
using stack and recursion
default operation: union using ,
to avoid duplicate using hashset
stack of hashset
1087. Brace Expansion
return all combinations
there are no nested braces. so just connect them using dfs


## Misc
1111. Maximum Nesting Depth of Two Valid Parentheses Strings
min the max(depth(A),depth(B))
we try to make depth a and depth b similar to minimize
Basically, ( is 1 point, ) is -1 point.
We try to keep total points of two groups even,
by distributing parentheses alternatively.

The good part of this solution is that,
we actually need no extra variable to record anything.

1023. camelcase matching
1016. binary string with substring representing 1 to N.
brutal force searching

954. Array of Doubled Pairs
negative and positive two parts
sort and from smallest.


### count sort
1093. Statistics from a Large Sample
this is already count sorted results, each element has a count and without restoring the sequence, we need to find the element
prefix sum of the counters and find the element.

### combination and permutations
1079. Letter Tile Possibilities
- dfs and eliminate duplicates and using permutation.

### math problem
1073. adding two negabinary numbers
using & and >>

1018. binary prefix divisible by 5
%5 and accumulate

1017. convert to base -2
using & and >>

1015. smallest integer divisible by K.
digits are all 1. using pigeon hole principle.
and %K and accumulate

1009. complement of base 10 integer
change binary bits from 0 to 1

974. Subarray Sums Divisible by K
prefix sum %K (also note for negatives)
and then count sort.

972. equal rational number
expand the number till double precision

## trivial
1119. Remove Vowels from a String
1118. Number of Days in a Month
leap year is: %4==0 %100==0 && %400==0
1108. Defanging an IP Address
replace . with [.]
1085. Sum of Digits in the Minimum Number
1078. Occurrences After Bigram
just understand the problem correctly.
1065. Index Pairs of a String
1064. Fixed Point
A[i]==i binary search
1056. confusing number
1051. Height checker
1047. Remove All Adjacent Duplicates In String
simple stack problem
1037. valid boomerang
1030. matrix cells in distance order
1002. find common characters
999. available captures for rook
994. rotting oranges
one step bfs
989. add to array form of integer
985. sum of even numbers after queries
961. n-repeated element in size 2n array
majority or hashmap
933. number of recent calls
922. sort array by parity II
917. reverse only letters
914. x of a kind in a deck of cards
gcd











