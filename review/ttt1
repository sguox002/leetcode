## dp
583. Delete Operation for Two Strings
edit distance problem

600. Non-negative Integers without Consecutive Ones
use two dp array dp0 ending with 0, dp1 ending with 1
need to remove the extra where >=N.

629. k inverse pairs array
array 1 to n, find the number of permuations which have exactly k inverse pairs
recurrence relation dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-i]
if we put n as the last number then all the k inverse pair should come from the first n-1 numbers
if we put n as the second last number then there's 1 inverse pair involves n so the rest k-1 comes from the first n-1 numbers


634. Find the Derangement of An Array
array 1 to n.
a permutation where none of the element is in its original position
count the number of derangement.
we have n! permutations.
1 can be put any position except 0.
2 can be put any position except 1.
...
dp[0]=1 []
dp[1]=0 [1]
dp[2]=1 [1,2]

dp[n]=(n-1)*(dp[n-1]+dp[n-2])


639. decode ways II
combine with previous digit or on its own.


646. max length of pair chain
similar to max increasing subsequence

647. palindromic substrings
count how many palindrome substring
using dynamic: dp[i,j]=dp[i+1,j]+dp[i,j-1]-dp[i-1,j-1]
must make sure the inside is palindrome.

712. min ascii delete sum for two strings

714. best time to buy and sell stocks with transaction fee

651. 4 keys keyboard
A, ctrl-a, ctrl-c,ctl-v.
for N times, max number of A can be printed.
dp[i] = max(dp[i], dp[i-j]*(j-1)) j in [3, i)

650. 2 Keys Keyboard
copy all and paste all.
dp[i-1]=dp[j-1]+i/j

656. coin path
A: index from 1, -1: you cannot jump, A[i] is the cost.
integer B: the largest step you can jump. i+1,i+2...i+B.
return the jump path using min cost.
if multiple path exist, return the lexico smallest.
[1,2,4,-1,2], jump 2.
do it from right to left and then we can always choose the leftmost solution
note: there are multiple paths in the solution. so we need use linked-list searching for the path.
path[i] is the next position of i.

553. strange printer
similar to removing box

718. Maximum Length of Repeated Subarray
larget common subarray or substring.

730. count different palindromic subsequences
only have abcd.
dp[i][x] is for the subproblem length=i and ending with x.


740. delete and earn
similar to robber, using bins to store.

741. cherry pickup
two branches to walk simultaneously.


764. Largest Plus Sign
brutal force to search at each position
dp: 4 direction growing.

790. Dominio and Tromino tiling
using two types of shape to reach 2*N shape.

799. champagne tower
surplus goes to i+1,j and i+1,j+1

801. Minimum Swaps To Make Sequences Increasing
two arrays, swap A[i] B[i]
return the min numbers of swaps to make both increasing.
swap & noswap
A[i]>A[i-1] && B[i]>B[i-1]
if we swap, we also need swap i-1.
if no swap, then i-1 also no swap

A[i]>B[i-1] && B[i]>A[i-1]
if we swap i, we shall not swap i-1
if we not swap i, we shall swap i-1



808. Soup Servings
this can be recursive or dp.

813. Largest Sum of Averages
parition into <=k groups
score: the sum of average of each group
return the largest score.
dp[i,j] is for array length i and divide into k groups
we check previous to see A[i] to A[j] is a added group and get the max.


818. race car

837. New 21 Game
this is a extension of climing stairs
with a sliding window to the next stairs.

871. min number of refueling stops
this can using bfs like approach
dp[t] is the max distance using t refuelings (or bfs layers)
we update the dp[t] using its covered nodes.

873. length of longest fib subsequence
A[i]=A[j]+A{k]


877. stone game
a stone is removed and it reduces a subproblem.
so we can use recursive or dp approach.
but this problem can also be solved using greedy since it has several constraints.

887. super egg drop
subproblem: break or not break

903. valid permutation for DI sequence
if char is D, then previous shall be smaller dp[i,j]=sum(dp[i,k]) k>j.
dp[i,j]: valid permutation for subproblem array length=i and ending at j.
it is not so easy to get the subproblem.

913 cat and mouse

920 number of music playlist
N songs, L songs in list.
every song can shall be played at least once.
a song can be played only if k other songs have been played.
dp: subproblem i songs with j different songs.
Think one step before the last one, there are only cases for the answer of dp[i][j]
case 1 (the last added one is new song): listen i - 1 songs with j - 1 different songs, then the last one is definitely new song with the choices of N - (j - 1).
Case 2 (the last added one is old song): listen i - 1 songs with j different songs, then the last one is definitely old song with the choices of j
if without the constraint of K, the status equation will be
dp[i][j] = dp[i-1][j-1] * (N - (j-1)) + dp[i-1][j] * j

If with the constaint of K, there are also two cases
Case 1: no changes since the last added one is new song. Hence, there is no conflict
Case 2: now we don't have choices of j for the last added old song. It should be updated j - k because k songs can't be chosed from j - 1 to j - k. However, if j <= K, this case will be 0 because only after choosing K different other songs, old song can be chosen.

if (j > k)
dp[i][j] = dp[i-1][j-1] * (N- (j-1)) + dp[i-1][j] * (j-k)
else
dp[i][j] = dp[i-1][j-1] * (N- (j-1))


931. min falling path sum
simple dp

940 distinct subsequence II
ending with different char.

115. Distinct Subsequences
find in S the subsequence=T.
edit distance.

960. Delete Columns to Make Sorted III
delete columns and make each row sorted
equivalent to longest increasing subsequence but with n arrays.
955. Delete Columns to Make Sorted II
delete columns columns shall be sorted.
do not need dp.

964. least operators to express number
x based 

975. odd even jump
do it from right. 
visited forms a map and use binary search.

983. min cost for tickets
one day, 7 day and 30 day pass.
for ith day, we can use single day, 7 day or 30 day

1000 min cost to merge stones
merge K consecutive piles into one pile, cost is equal to the k sum

1027. Longest Arithmetic Sequence
dp using difference and i.


1035. Uncrossed lines
equivalent: longest common subsequence


1105. Filling Bookcase Shelves
thickness and height
shelf width.
book order cannot be changed.
return the min height
a book i with Wi and Hi can be placed in kth layer.
the shelf height is decided by the max height.
this is similar to group the array and min the sum of the max.
so the idea is: for group i, either is belongs to previous group or to next group
group is constrained by the width.
if book i, belongs to previous group, then we need to update the max.
if book i, starts a new group, then we need to update the new height.
dp[i] is the min height for the first i books.

1092. Shortest Common Supersequence
need convert to equivalent problems:
find the longest common subsequences
and then build the min supersequence
similar to longest common subsequence length, but we shall use string directly to avoid trace back.

1062. Longest Repeating Substring
direct approach: using O(N^2) to build all the substrings, TLE
dp approach: we only compare one char since previous compare is done.

1044. Longest Duplicate Substring
follow up on 1062, repeated string can overlap.
binary search + direct hash.

1048. longest string chain
common dp practice

1043. Partition Array for Maximum Sum
element can be attached to previous group or itself become a new group
dp with heap.

1039. Minimum Score Triangulation of Polygon
dp with i,j,k O(N^3) to split into one triangle and two subproblems


### knapsack
416. partition equal subset sum
- no need 2d but using 1d
- using vector<int> to get the sum
- return target=sum/2

2d approach using bool:
dp[i-1][j] || dp[i-1][j-nums[i-1]]
base: target=0 for all dp[i][0]=1
then we can optimize it in space. (using reverse looping)

698. Partition to K Equal Sum Subsets
backtracking: 

other similar problem: 
minimize the difference sum of the two parts. maxmize the one group sum bound by tsum/2
the input has negatives: shift to all positives

638. shopping offers
combine the price and the quantity
need to match both exactly.

823. binary trees with factors
equivalent: all nodes shall be from the array, so combinations shall be a[i], a[j] has a common factor



879. Profitable Schemes
G people, profit p, 
input: profit[i], group[i]. people cannot be repeatedly used.
knapsack.


956. tallest billboard
each element has three options: choose to A, choose to B, or not used
target: sum=0


1058. Minimize Rounding Error to Meet Target
each element can use ceil or floor (+ or -)
so the sum max would be all ceil and sum min is all floor.
it is equivalent to: choose from two arrays to sum to a target
return the smallest rounding error! (since we may have multiple choices)
only has 3 decimals
greedy: we can get number floors and number of ceils. then sort the decimals accoring to the errors

nth_element: partial sort to get the sorted position element.

1049. Last Stone Weight II
smash the stone: equal: both destroyed. smaller destroyed and remaining y-x.
convert to equivalent:
some elements are negative and some are positive, and the sum of positive shall be >= negative sum.
knapsack problem

1046. Last Stone Weight
choose heaviest and smash. this is heap.

### shortest distance problem

743. Network Delay Time
bellman algorithm: loop over all nodes and using all edges to relax the distance

787. Cheapest Flights Within K Stops
can use dp to relax: loop over k times and using the edges to relax the distance.


847. shortest path visiting all nodes
bit mask status, starting nodes, ....
bfs..
dijkstra...


864. shortest path to get all keys


882. Reachable Nodes In Subdivided Graph
subdivide the edges: we use the original graph, and use subdivided as weight

943. find the shortest superstring
equivalent: make AB the distance, and then find the shortest distance to visit each node once.
- use all words
- build a graph matrix. 
- use dp to find the shortest distance (2d, with status and node) and also path information for tracing back.


## think simple using computer way.
970. powerful integers
just try brutal force loops

982. Triples with Bitwise AND Equal To Zero
triple reduce to N^2 two element bitwise
and then add another.

1103. Distribute Candies to People
it is just a 1 to n and arranged in rows, so do not use those complicated methods
but just use iteration and %

1089. duplicate zeros
in place: two pointer and imagine we are using sufficient memory.

1071. greatest common divisor of strings
using same principle working for numbers.
by subtracting the common.

## two pointer
763. Partition Labels
each char appears only in one part.
this is also a bfs like approach:
we record each char's last index
everytime we see a char, we update our max range(like bfs)
if our max range==current char's last position, we got a partition.

795. Number of Subarrays with Bounded Maximum
[L,R]
sliding window: 
pre: the sliding window left, 
low: 
maxp: 
A[i] in the range [L,R], i-pre+1
A[i]<L && L<=maxp:  low-pre+1
A[i]>R: reset low, pre, maxp.
still complicated
another approach:
convert to find <=R and <=L-1 two subproblem.
then it is much simpler, it is common practice for range problems.

809. expressive words
using two pointer to match and counter each char's repeat times.


844. backspace string compare
using stack is trivial
using two pointer from right to left is a bit tricky.

845. longest mountain in array
from left to right: get the length of up
from right to left: get the length of up
tricky

881. boats to save people
greedy using two pointers.
combine the person with the greatest weight and lightest weight.

915. Partition Array into Disjoint Intervals
left side < right side
min size of left side.
get lmax and rmin. and find the first one when lmax<rmin.

923. 3Sum With Multiplicity
using hashmap to record the frequency of each number.
if 3 numbers from 1 set: C(n,3)
if 3 numbers from 2 set: C(m,2)*C(n,1)
if 3 numbers from 3 set: C(i,1)*c(j,1)*C(k,1)


925. long pressed names
two pointer compare

926. Flip String to Monotone Increasing
binary string: left all 0 right all 1
find all positions to be the pivot and get the number of flips


962. Maximum Width Ramp
lmin for the left
and rmax for the right
greedy approach

977 squares of sorted array
two pointer: min may becomes max.

1014. Best sightseeing pair
lmax of A[i]+i and rmax of A[j]-j.

1031 max sum of two non-overlapping subarrays
lmax and rmax from both side



## recursive
805. split array with same average
- split the array into two parts by moving into two lists, so order does not matter.
- assume we have m for list 1, and n for list 2. Sum(A)/m=Sum(B)/n with Sum(A)+Sum(B)=tsum, m+n=len.
- we get Sa=tsum*m/len. Sa must be an integer, so tsum*m%len==0
- now it reduces to combination sum.

984. string without AAA or BBB
base cases: A=0 B=0
when A>B AAB+subproblems
when A==B AB+subproblems


1088. Confusing Number II
return the confusing numbers in [1,N]
approach 1: backtracking, will use a lot of time
approach 2: recursive by adding previous solution 1+xx+1, 8+xx+8, 6+xx+9,9+xx+6
similar to Strobogrammatic Number II, but it only requires length<=n.



## Array
605. can place flower
add the end 0 and 1 to avoid ending process


611. Valid Triangle Number
a+b>c so just find the upper bound

616. add bold tag in string
using bool array to indicate the char to be bold
and automatically merge

624. max distance in array
k sorted array, find the max absolute difference among different arrays.
we set the min as a[0][0] and max as a[0].back()
then we update the min and max using array i. and get the max diff.
get the max diff first since we cannot get the diff from the same array, ie. we use all previous.
this is a bit tricky.

658. Find K Closest Elements
find the k closest number abs(num-x)
sorted using abs(num-x) using comparator objector

748. Shortest Completing Word
using hashmap to record the occurance of each char (convert to lower)
and check if the word contains the map.
need to return the first, so using stable_sort (when equal the order is not changed)

750. Number Of Corner Rectangles
this is very tricky. 
check for rect with 4 corners all '1'
idea: 
- for ith row, we check all previous row to see how many cols are 1
- the number of rects are then cnt*(cnt-1)/2

1139. Largest 1-Bordered Square
need to find the largest square.
idea: similar to dp approach
- count the horizontal length of 1s and vertical length of 1s
- then we use the min of veritcal and horizontal as the square length and check the other two horizontal and vertical


758. bold words in string
it says easy, but actually not.
bold all keywords in the string.
using a bool array and set it.

761. special binary strings
special binary string: num0s==num1s, each prefix num1s>=num0s.
equivalent: need to break the string into special binsry strings and sort.
11011000
1(10)(1100)0
swap the first and 2nd special binary string.
also equivalent to valid parenthesis.
the key is '1'+specialstring+'0'

760. Find Anagram Mappings
this is for numbers. combine the index and sort (making them same order)

777. swap adjacent in LR string
R go to the right, L goes to left
R and L are bound by the LR.
so just need to count the x between L R and see the changes.

782. transform to chessboard
we can swap rows, swap columns
return the min number of swaps to make it a chessboard
- need to calculate how many rows are same or xor with row 0
- need to calculate how many cols are same or xor same with column 0
- then we reduce it to a row and a col of numbers

792. Number of Matching Subsequences
a list of words, return number of words which is a subsequence of S.
store the char with index in hashmap.
and then do each word matching: 

794. valid tic-tac-toe
3x3 count row, col, diag, diagr



798. Smallest Rotation with Highest Score
Get point
Each time when we rotate, we make index 0 to index N-1, then we get one more point.
We know that for sure, so I don't need to record it.

Lose point
(i - A[i] + N) % N is the value of K making A[i]'s index just equal to A[i].
For example, If A[6] = 1, then K = (6 - A[6]) % 6 = 5 making A[6] to index 1 of new array.
So when K=5, we get this point for A[6]
Then if K is bigger when K = (i - A[i] + 1) % N, we start to lose this point, making our score -= 1
All I have done is record the value of K for all A[i] where we will lose points.

807. Max Increase to Keep City Skyline
seen from left the max cannot be changed
seen from bottom, the max cannot be changed.
each element is bound by the two max.

816. ambiguous coordinates
approach:
- loop to divide into two half
- each part add 0 or 1 decimal 
- check valid.

820. shortest encoding of words
sort by length
and shorter would be a part of longer string
store all suffix of the string into hash set.


822. card flipping games
smallest number, flipping the card and the front is not in its front.
those back and front the same, put into hashset.
we check back and front to get the min number.


825. Friends Of Appropriate Ages
three conditions: 

826. most profit assigning work
difficulty vs profit
worker ability
for each difficulty level: we find the max profit.
sort the difficulty vs profit.


833. Find And Replace in String
note two cases:
- we shall do it from right to left to avoid index changes
- input is not sorted
- need to first match the substring before replace.

853. Car Fleet
using the time calculated and change to its previous slow and then calculate the group num
direct approach

880. Decoded String at Index
decoded times. and find kth char.
this is quite tricky: we need to track the length until k. and then reverse back to the char. 
if the char is digit, then we need to go back again.


885. spiral matrix III
direction is 112233445566....
only those inside the matrix will be recorded
expanding spiral
54. Spiral Matrix
visiting in spiral order: shrinking spiral
59. Spiral Matrix II
fill the spiral: shrinking spiral.

890. find and replace pattern
from right to left.

912. sort an array.
merge sort
quick sort
bubble sort

916. Word Subsets
use 26 char array instead of hashmap to save time.

918. max sum circular subarray
this is follow up for 1d array.
1d array: if the previous sum <0 we begin a new segment. and find the max.
to avoid circular array: we find the subarray max and min. then get the max of the two answers.

1131. maximum of absolute value expression
first need to remove the abs.
|a[i]-b[j]|+|b[i]-a[j]|+|i-j|, we have 8 combinations (3 +/- selections)
a[i]-b[j]+b[i]-a[j]+i-j  --> [a[i]+b[i]+i]-[a[j]+b[j]+j]
a[i]-b[j]+b[i]-a[j]+j-i --> [a[i]+b[i]-i]-[a[j]+b[j]-j]
a[i]-b[j]+a[j]-b[i]+i-j --> [a[i]-b[i]+i]-[a[j]-b[j]+j]
a[i]-b[j]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
b[j]-a[i]+b[i]-a[j]+i-j --> -[a[i]+b[i]+i]+[a[j]+b[j]+j]
b[j]-a[i]+b[i]-a[j]+j-i --> -[a[i]+b[i]-i]+[a[j]+b[j]-j]
b[j]-a[i]+a[j]-b[i]+i-j --> -[a[i]-b[i]+i]+[a[j]-b[j]+j]
b[j]-a[i]+a[j]-b[i]+j-i. --> [a[i]-b[i]-i]-[a[j]-b[j]-j]
then we separate i and j, it is actually 4 cases
we find the min and max and get the max-min


## stack & deque
636. Exclusive time of functions
using stack, need to subtract the other function's time


739. Daily Temperatures
stack to find next greater element

755. Pour Water
hard to understand the problem.

828. unique letter string
using hashmap with stack.
if a char is smaller and we still have the char in later, then we can safely remove that char in the stack.

838. push dominoes
- add a L on the left and R on the right.
- several patterns LxxxL, LxxxR,RxxxL,RxxxR
- stack approach: 

901. online stock span
typical monotonic stack

907. Sum of Subarray Minimums
brutal force: for each number we get it as the min and expand left and right
- stack: using two stacks to record the previous smaller and next smaller.
	use same previous less one from left to right, one from right to left.
	one stack is sufficient to find both left and right.
	
921. Minimum Add to Make Parentheses Valid
using stack:
if paired, popped. 
if ) and has no match ans++ 
if ( no match they are in the stack

946. validate stack sequence
simulate the stack, a number shall be pushed first before popped

950. reveal card in increasing order.
reveres the process using deque. 

1003. check if word is valid after substitutions
simple stack or deque problem

1006 clumsy factorial
using stack for expression evaluation.
similar to calculator without ()

1019. next freater element in linked list
typical stack problem: montonic

1021. remove outmost parenthesis
using stack or using counters

1130. Minimum Cost Tree From Leaf Values
the array order cannot be changed.
- equivalent: remove the smaller at the cost A[i]*A[j]
- greedy: to min A[i]*A[j] need combine A[i] with its next larger.
- using stack to store a sorted sequence (sorted is a simple greedy)

1081. Smallest Subsequence of Distinct Characters
same as eliminate duplicates
to keep it smaller, when a small char comes, need to replace char in stack.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

1028. Recover a Tree From Preorder Traversal
using iterative stack

### expression evaluation using stack
591. tag validator

640. solve the equation
include x, +- and coefficient, numbers
and we want to reduce lhs and rhs into ax+b format.

726. number of atoms
using map in the stack. similar approach for expression evaluation (nested)

856. score of parentheses
support A+B and 2*A, two operations

772. Basic Calculator III
including +-*/() and space.
ignore spaces

770. basic calculator IV
expressions... symbolic programming calculator




## bfs
573. squirrel simulation
squirrel in one position, tree in one position, and several nuts in other places
squirrel get the nut one by one and put under the tree.
squirrel position-closest nut->tree->closet nut->tree.....
lesson: bfs is overkill, using manhatton distance
Proof: Let the minimum distance from each nut to the tree be a_1, ..., a_n and 
let the minimum distance from each nut to the initial squirrel position be b_1, ..., b_n. 
Note that the minimum distance between two positions in the matrix is determined by their Manhattan distance.

Then, if the squirrel were to start at the tree, then the minimum total distance required to collect all the nuts is 2a_1 + ... + 2a_n. 
However, since the squirrel starts elsewhere, we just need to substitute one of the 2a_i terms with a_i + b_i. 
Or equivalently, we replace one of the a_i terms in the sum with b_i. 
To minimize the total sum value at the end, we choose i that maximizes a_i - b_i.


similar problem: 1138. alpha board path.


752. Open the Lock
with deadends
0000 to target
same thing from target to 0000
layer: each digit +1 or -1


773. sliding puzzle
convert the 2x3 board to string, 0 represents the empty slot.
target is 123450
bfs to push all possible swaps


815. bus routes
each bus route is a circle
from one station to another. 
one a route: we have some stations connect other routes.
bfs to reach the destination.
- reconstruct the routes to a map: station vs route.
- visited using hashset
- queue store the route number and station number



841. Keys and Rooms
if we can unlock all the rooms


854. k-similar strings
two anagrams A and B, return the smallest k.
using bfs each time we swap one pair.

909. snakes and ladders
this is a very good bfs question. layer concept.
- convert 2d to 1d array to avoid value-index conversion
- next layer is all the nodes it can go in the next step. including 1 to 6 and ladder.

1024. video stitching
using bfs like to cover the max distance.


1129. Shortest Path with Alternating Colors
- from 0 to all other nodes
- using bfs to get the shortest distance
- the distance can be greater than n since we may need to come back
- form a graph (adjacent matrix) data structure needs 0 for blue and 1 for red
- have two options: first start blue or start red
- we can use simple structure for adj matrix (*2 for blue *2+1 for red)
- self connected edge cannot be ignored since it will be able to connect the path.
- perform two bfs.
* the simple data structure for adj makes the problem a lot simpler.
* using dfs are not good for this. always try bfs first for shortest distance problems.

1102. Path With Maximum Minimum Value
this is similar to the swimming in rising water.
it asks for the min value along the path where all those smaller elements are not passable and there is only one path.
so it is a binary search with a bfs problem

1091. Shortest Path in Binary Matrix
8 directions with 0 and 1 (1 blocked). return the shortest path from top left to bottom right
regular bfs


## dfs
576. out of boundary paths
number of paths
out of boundary +1
inside: +0


582. kill process
using map to assemble all the children, forming a tree relation
then dfs

695. max area of island

694. number of distinct island
only translational


711. number of distinct island
it supports translation, roation and reflection
dfs to get the coordinate for an island, and then perform all possible rotations/reflections
and find the canonical representation by sorting

749. Contain Virus
cell 0 is unaffected, cell 1 is affected.
wall installed on boundary.
each day you can only block one region.
so basically, we need to find the region with the most neighbors and install walls
and the other region will grow and we get the next and install walls.


785. is graph bipartite
giving a list of edges
- we don't need to build the graph
- use only color for both visited and color assigned
- dfs on the edges.

802. find eventual safe states
- dfs
- if meet 0, all nodes on the path will be set zero

851. loud and rich
dfs

886. possible partition
this is very similar to check bipartition
- we do not need to build adjacency matrix, using edge is fine
- we can use color as the visited array
785. Is Graph Bipartite?

934. shortest bridge
- first find the two islands using dfs
- find the smallest distance between the two islands

935. Knight Dialer
using dp or dfs/recursive

959. regions cut by slashes
need upsample and do the dfs

967. Numbers With Same Consecutive Differences
dfs: try +k and -k. not above 9.

980. Unique Paths III
-1 obstacles, 0: empty, 1 source, 2 target
it requires to walk on every empty cell exactly once. 
return number of path
it needs two requirements: walk on every cell, and reach the end.
just regular dfs.
63. Unique Paths II
number of paths, using dp is faster (with obstacles)
62. Unique Paths
dp or pure math.


996. number of squareful arrays
neighboring elements sum is a square.
return the number of permutations.
build the graph (for each element its neighboring)
and then dfs.


1020. number of enclaves
common dfs

1125. Smallest Sufficient Team
- most important: convert the required skills into bits and simple the problem using dfs.
- non-required skills are ignored.
- do a O(N^2) loop and eliminate those people with same skills, or a subset of skills

1059. All Paths from Source Lead to Destination
- lead to other nodes
- lead to infinite cycle

dfs with cycle detection
using 3 states: visited, not visited, visiting.

1036. Escape a Large Maze
two dfs: block the source, block the target
dfs distance > the block size, then we are outside.

1034. coloring a border
dfs using negative color, restore inner side


## backtracking
526. Beautiful Arrangement
index from 1 to N: either A[i]%i==0 or i%A[i]==0
return the number of beautiful arrangement.
- first construct the array from 1 to N. (which is one beautiful arrangement.)
- loop over each element and swap with the end

667. Beautiful Arrangement II
n: 1 to n.
k: need |a1-a2|, ....|a(n-1)-a(n)| has excatly k distinct numbers
correctly understand: it does not ask for there are k numbers between, but asks for the difference is k numbers
greedy: 1,k+1,2,k.....and then all difference is 1.
so difference is k,k-1,k-2.....1,1,1,..1

756. Pyramid Transition Matrix
get all the combinations and backtracking to next layer.

784. letter case permutation
typical backtracking,

797. All Paths From Source to Target
classical backtracking

842. Split Array into Fibonacci Sequence

## counting in array.
891. Sum of Subsequence Widths
subsequence width= max-min in the subsequence
- only care about max and min, so order does not matter so we can sort to see if it is simpler.
- with A[i] as the min and A[j] as the max, all the elements in the range [i+1,j-1] can be used or not used.

898 bitwise ors of subarray
the idea: save previous results in hash set. and use A[i] to or all previous results
for A[i]
A[i]
A[i],A[i-1]
A[i],A[i-1],A[i-2]...
basically this is a brutal force approach.
but the complexity is O(N), why? since we only have 32 bits

902. Numbers At Most N Given Digit Set
giving n digits (not including 0), find number of integers <=N.
equivalent: assume N has k digits, it can be divided into:
1 digit to k-1 digits, this can be computed using permutation.
1000..0 to N with k digits. this can also be computed using permutation


1012. numbers with repeated digits
equivalent: numbers without repeated digits.

1128. Number of Equivalent Domino Pairs
this is common seen counting in array using hashmap
keep adding the previous occurences
equivalent to 1+2+3+...+k 

1124. Longest Well-Performing Interval
- >8 convert to 1, <=8 convert to -1.
- prefix sum. 
	if prefix[i]>0 then all previous are good.
	if prefix[i]<0 then we need to find previous smaller one
	
1099. Two Sum Less Than K
common practice: sort the visited elements in a map/set and then use binary search to find the elements

560. Subarray Sum Equals K
similar to 1099. 1d

1074. Number of Submatrices That Sum to Target
using tech in 560 and reduce to 1d problem

1067. Digit Count in Range
given a digit d in [0,9], return the number of occurences in [low,high].
- we can get [1, high]-[1,low], high low can be converted to number of digits
same length of digits shall be counted carefully.

1063. Number of Valid Subarrays
group and the first element is <= the other elements in the group
it is equivalent to find the next smaller in its right directions for each element.

	
## interval problems
715. range module
addrange: merge to previous intervals
queryrange: check if the range is tracked
removerange: remove the range.
approach 1: using event add/removal
approach 2: merge interval.



732. My Calendar III
interval [start,end) half close half open
k-booking
similarly using ++/-- and prefix sum

731. My Calendar II
triple booking. similar approach as 732
729. My Calendar I
double booking, similar as 732.

757. Set Intersection Size At Least Two
the intersection shall contain at least two elements from each interval.
- sort the intervals according to the end.
- get two elements from the first ..

759. Employee Free Time
similar adding/removing an event.
and then prefix to find if we have common

850. rectangle area II
this is a very good question on 2d interval
- add a rectangle and remove a rectangle, (x,y,value)
- sort using x.
- calculate the area along all x. (using prefix sum in the 1d interval problem).


855. exam room
direct approach: recording the seats and find the largest interval
849. Maximize Distance to Closest Person
very similar to 855.

986. interval list intersection
two sorted list of intervals, find the intersection.
apply two pointer and check if two intervals intersect.


1109. Corporate Flight Bookings
- add an event and remove an event using map for positive and negatives
- prefix sum to get the results.

1094. car pooling
add passenger and unload passenger


	
## Tree
572. Subtree of Another Tree
helper is_sametree
but it is O(N^2)
using serialization and check if the shorter one is a substring using preorder traversal.

590. n-ary tree postorder traversal
589. n-ary tree preorder traversal

606. Construct String from Binary Tree
a kind of serialization
if does not have right no ()
if does not have left but have right need add ()


617. merge two binary trees
simple: if both null, null
either is null, return it
both is not null, return sum

623. add one row to tree
need use bfs to add nodes
get to the previous layer and create new nodes and connect


637. average of levels in binary tree
simple

652. Find Duplicate Subtrees
using hashmap, serialize the tree for each node.
we have to use root+left+right and store in map.


653. Two sum, input is BST
just follow two sum in array

654. Maximum Binary Tree
this is actually the heap.
recursively choose the max and divide into left and right

655. Print Binary Tree
arrange each node's position

662. Maximum Width of Binary Tree
full binary.
dfs. child is always 2*n,2*n+1


663. Equal Tree Partition
remove one edge and make the two subtree the same sum.
just similar to array, we do in order traversal and put the sum of all subtrees into hashmap
then we check if the sum is even and half sum exist.
if sum==0, then we check number of 0.


666. Path Sum IV
the tree is represented as an array.
each number: first digit is the depth, second digit is the level position, 3rd digit is the value.
using full tree storing in an array, (non-existent node all 0)
while building the array we can accumulate the sum till the leaf.

700 search in BST-linked
701 insert into a BST.
insert to the leaf

742. Closest Leaf in a Binary Tree
given a target key, find the nearest leaf. (means min number of edges).
it is equivalent to find the node, and then get the smallest depth leaf node.
- preorder search to get the node
- bfs to search, return the first seen leaf node.
- what if it is already the leaf? we need go back to parent and then go down.
it is also similar to the lowest common ancestor.

another approach: convert the tree into graph and then use bfs
- dfs to build the relation
- bfs to find the node.

776. split BST
given a target value, split it into two subtree:
one tree has nodes <= target
one tree has nodes > target
keep most the structure of the original tree
- if root<=target, its right may contain some nodes <=target. and it is a subproblem
 [less,greater]=subproblem
 less attached to root->right, and the smaller shall be the root.
 greater 
 it is very tricky: the greater is then attached to root's parent's left.
 
 
779. K-th Symbol in Grammar
first row 0, then 0->01 and 1->10
this is a full binary tree.

783. Minimum Distance Between BST Nodes
apparently in order traversal, min diff only occurs between neighboring numbers

814. binary tree pruning
removing subtree with all zero.
post-traversal: get its left and right, and check if it is leaf and 0 node, return null.


834. sum of distances in tree.
return the sum of each node to all other node's distance.
this is a hard graph problem. 
- converting tree into graph
- 

862. all nodes distance K in binary tree.
build a graph from the tree and then bfs from the given node.
adj matrix: map<int,vector<int>>

865. smallest subtree with all the deepest nodes
or the lowest common ancestor for all the deepest nodes
O(N^2) using depth
O(N): get the left and right depth, and:
Hleft==Hright, root
left<right, go to right with d-1

236. Lowest Common Ancestor of a Binary Tree
O(N^2): find p and q repeatedly and return 0,1,2,3
O(N): do the find and return the same time
if node==p || node==q, return node
get left lowest common ancestor
get right lowest common ancestor

1123. Lowest Common Ancestor of Deepest Leaves
similar to 865. 
O(N^2) get depth for each node and return the ancestor
O(N): get the depth and the ancestor at the same time.


872. leaf similar trees
traverse and get the leaf array

889. construct binary tree from preorder and postorder
pre: root, left, right
post: left, right, root
so basically find the root and left subtree and right subtree

894. all possible full binary trees
this is a simple recursive problem with left: 1,3,5,7,.... 


897. increasing order search tree
BST-linked list (in place)
using right,root,left might be easier with a helper pointer prev.

919. Complete Binary Tree Inserter
this is very interesting using array to implement a tree.


938. Range Sum of BST
easy

951. flip equivalent binary tree
left-left & right-right
left-right & right-left

958. check completeness of a binary tree.
- bfs approach: when we see a null node, there shall have no nodes after
- dfs approach: left depth is always>=right depth. (preorder).

965. univalued binary tree.
passing the root value to subtree

968 binary tree cameras
greedy: put the camera on the parent, so it can cover children and parents.
using status to reflect if the root is monitored or not.
do it from bottom to root.

971. Flip Binary Tree To Match Preorder Traversal
array is a binary tree (some subtrees flipped) preorder traversal
first match the node, and then match left/right or right/left.

979. distribute coins in binary tree

also similar to the washing machine. the abs(diff) is the coins up/down the root.

987. Vertical Order Traversal of a Binary Tree
record depth, and x, and value
there are overlaps (same position)
preorder:
then sort according to requirements.

988. Smallest String Starting From Leaf
simple dfs, when reaching leaf, reverse the results.

993. cousins in binary tree
only need to keep the parent information and depth information


654. max binary tree
build from array: max as the root, left is left subtree, right is right subtree
heap. (used for map, set data structure, pq uses complete full binary tree).

998. max binary tree II
append a number to the array, and return the max binary tree
- empty and it shall be the root
- > root, it shall be the root, original root shall be its left
- <root, it shall go to the right

1008. construct binary search tree from preorder traversal
BST, preorder, the root is always the first and divide by left and right
using upper_bound

1022. sum of root to leaf binary number
preorder/dfs/recursive

1026. max difference between node and ancestor
preorder and find the min and max of all prefix.

1028. Recover a Tree From Preorder Traversal
iterative stack

1038. Binary Search Tree to Greater Sum Tree
reverse inorder traversal
similar to array's suffix sum


1123. Lowest Common Ancestor of Deepest Leaves
O(N^2) is easy
O(N): first find the left depth and right depth of the root one pass. second pass find the node with depth-1.
O(N) single pass: get the depth and the node at the same time.

1120. Maximum Average Subtree
average: need to get the sum and number of nodes.
using postorder traversal, we get the sum and number of nodes for its left/right subtree and then get the results for the root.

1110. Delete Nodes And Return Forest
when a node is to br removed, we need update its parent and child becomes another tree
do not forget the root when it is not removed.
google phone screen

1104. Path In Zigzag Labelled Binary Tree
full tree, the node from leaf to parent is n/2 and apply the zigzag relation.

1080. Insufficient Nodes in Root to Leaf Paths
all path passing the node sum<limit.
O(N): the limit - val. if leaf<limit, return null, the left and right both returns null, then the root is also removed.
it is not so easy:
when a leaf node < limit, return null, else return itself
otherwise, check its left and right
if left and right are removed, 


## greedy
575. Distribute Candies
distribute candies between brother and sister, what the max kinds of candies sister can get.
half of the candies, num types of the candies. whichever is min, 
621 task schedule
greedy: find the most common task and arrange in a period of (n+1) task
if there are multiple most common task we need add one extra for each.
finally ans shall be >= number of tasks



649 dota2 senate
greedy to ban the immediate person and move the senate to the end.
using queue.

665. Non-decreasing Array
modify at most 1 element.
This problem is like a greedy problem. 
When you find nums[i-1] > nums[i] for some i, you will prefer to change nums[i-1]'s value, 
since a larger nums[i] will give you more risks that you get inversion errors after position i. 
But, if you also find nums[i-2] > nums[i], then you have to change nums[i]'s value instead, 
or else you need to change both of nums[i-2]'s and nums[i-1]'s values.


738. Monotone Increasing Digits
given N, find the largest number with increasing digit <=N.
approach:
from right to left, find the first position where A[i]<A[i-1].
and then change all digits in its right to '9'

754. reach a number
can go left or right. min number to reach the number
- go above the number
- if difference is even, make half the negative
- if difference is odd, then go another step, and negative

765. couples holding hands
greedy: we divide all numbers by 2, so the couples share the same number
we swap once we see difference. every time we at least fix one pair. without causing less.

775. global and local inversions
needs all global inversions==local inversions

789. escape the ghost
whoever reach the target who will win.

810. chalkboard xor game
remove one number, if the remaining bit xor ==0, then he loses.
we can get the xor of all numbers first.
if xor is 0, then alice win
if xor not 0, then it means we have at least two different numbers, then we can erase any number different from xor, and won't lost
even number length will win.

861. score after flipping matrix
greedy: keep the leftmost bits as 1 then keep the num of 1s in each column >= num of 0s.

870. advantage shuffle
greedy: use weakest to match the one we cannot beat. using the weakest one who can beat.

910. smallest range II
add +k -k
greedy: equivalent to add 0 or 2k.
from left to right, add 2k to see if we can reduce the difference.
908. smallest range I
add a number between [-K,K]. so we can reduce the range by 2K to 0


932. beautiful array
A[k]*2!=A[i]+A[j]
starting from [1].
left odd and right even. expand.
[1]
[1,2]
[1,3,2,4]
[1,5,3,7,2,6,4,8]
.....

936. Stamping The Sequence
reverse from target to source
using greedy match.

942. DI string match
use two end meet. D choose the max, I choose the min


945. min increment to make array unique.
sort first and add 1.

948. Bag of Tokens
greedy: use the point for max power and use least power to gain points

949. largest time for given digits.
from the right, if we have larger digits, choose it.
otherwise, choose the smallest.

969. Pancake Sorting
greedy: flip the min to the top, repeat.

991. broken calculator
only support *2 and -1. 
min number of operations from x to y.
we can also do from y to x, and is more clear. /2 +1

995 min number of k consecutive bit flips
min number of flips needed to make it all 1.
greedy: turn the left most bit 0.

1005. max sum of array after k negations
greedy: try to negate those negatives. after that, we need compare the last negated negative with the smallest original positive

1007. min domino rotations for equal row.
either all rotate to a[0]
either all rotate to b[0]
do it one by one, do not involve two things. do it simple way.


1025 divisor game
greedy: odd/even

1029. two city scheduling
greedy 1: send all to A and then send those most saving to B.

1053. Previous Permutation With One Swap
to make it smaller with one swap.
greedy: find the first peak from right to left, and swap with leftmost element in its right < peak.

1042. Flower Planting With No Adjacent
garden has no more than 3 neighbors
greedy: make a graph and chose available color

1041 robot bounded in circle
greedy: try a whole cycle or more cycles. repeat 4 times and we would be able to do it.
common practice: rotation


## heap
630 course schedule III
the idea: greedy choice: sort the courses according to the closing time, always choose the closing time earlier to ensure more courses taken
using the heap to remove the longest courses in the pq.


632 smallest range
k lists, find the smallest range includes at least one number from each of the list
inuition: similar to merge sort, we store each head element in pq, and pop the smallest and take the followed one from the same list.
we are looking for the max and min.


857. min cost to hire k workers
quality, wage expectation, ....
this is quite tricky: 
the pay ratio shall be the highest ratio, and the total is proportional to the total quality.
so use a heap to remove those largest quality to see if we can reduce the cost.



973. k closest points to original
heap

1121. Divide Array Into Increasing Sequences
greedy: choose K increasing subsequences from the most frequent one
just like to get rid of a layer from the mountain and until it is flat

1090. Largest Values From Labels
values, labels
limited K from each labels
return the max sum
it is natually using heap.
first store the values vs label in a sorted map from larger to smaller.

1086. High Five
top five scores, using minheap to keep only 5 scores.

1066. Campus Bikes II
N workers and M bikes.
min manhattan distance and lowest index bike.
need work on it.

1057. Campus Bikes
sorting all combinations.

1054. Distant Barcodes
rearrange so that no neighboring are the same
using heap to arrange the two most common words
767. reorganize string
same to 1054

## trie
642. Design Search Autocomplete System
add a count in the node.

648. replace words
replace the word with prefix in the dictionary
build the trie using the dictionary 
and then find if it starts with.

745. prefix and suffix search
words[i] has weight i.
search(prefix, suffix) return the word with max weight.
smart solution using one trie.
by adding suffix together with the orginal
for example apple:
apple$apple, pple$apple, ple$apple,le$apple,e$apple
when query we just need to query suffix$prefix and check which one starts with this.
weight i: each node contains the max weight (if we iterate from smaller to larger, it is automatically updated.
be sure to add the empty suffix.

1032 stream of characters
matching with the prefix, startwith




## union find
721. Accounts Merge

737. Sentence Similarity II
a-b is similar then b-a is also similar
a-b similar, b-c similar, then a,b,c are similar
sentense similar: number of words are the same, 

data structure: map<string,int> as parent
self cooked union-find has defects: can only merge the current group to previous, but cannot merge the previous 
group into even previous group
using int for parent are not good.
- for each pair, set its parent to itself
- merge inside pair words

734. Sentence Similarity
similarity is not transferrable. only is symmetric.
data structure is important: 
each string can belong to multiple index group, two words are similar or not, they shall have same index/


["a","very","delicious","meal"]
["one","really","delicious","dinner"]
[["great","good"],["extraordinary","good"],["well","good"],["wonderful","good"],["excellent","good"],["fine","good"],["nice","good"],
["any","one"],["some","one"],["unique","one"],["the","one"],["an","one"],["single","one"],["a","one"],
["truck","car"],["wagon","car"],["automobile","car"],["auto","car"],["vehicle","car"],
["entertain","have"],["drink","have"],["eat","have"],["take","have"],
["fruits","meal"],["brunch","meal"],["breakfast","meal"],["food","meal"],["dinner","meal"],["super","meal"],["lunch","meal"],["possess","own"],["keep","own"],["have","own"],["extremely","very"],["actually","very"],["really","very"],["super","very"]]


803. Bricks Falling When Hit
- only those connected to top will not falling
- we set all the hit bricks to 0
- add these bricks one by one and do union
- the difference of bricks connected to top is the bricks to falling


827. making a large island.
- union find and merge to several islands
- try all 0 cell and to see if we can connect to its neighboring islands
- get the size (it may connect multiple islands)

839. Similar String Groups
typical union-find

924. Minimize Malware Spread
return the first node which can minimize the infected nodes by removing it from initial list.
ie, assuming the node is not affected.
- parent node - the initial nodes, find the one with largest size

928. Minimize Malware Spread II
initial list: remove one infected nodes and disconnect its neighbors.
union find in a reverse way: 
build the disjoint set without the infected
add one by one by disable the node only and add all other nodes, and check which one forms the largest number of elements.
we are not doing merge but only count the number of sets to be union and count the number


947. most stones removed with same row or column
use dfs or union-find, similar to number of islands

952. Largest Component Size by Common Factor
connect the numbers when they share a factor.
use prime factorization for each element.


990. Satisfiability of Equality Equations
use == relation and merge them and use != to check them

1101. The Earliest Moment When Everyone Become Friends
union and find the earliest time that unites as one group

1061. Lexicographically Smallest Equivalent String
union and use each group's parent.


## sliding window
713. Subarray Product Less Than K
similarly, if the window is k then we have k*(k+1)/2 
and we just add the count ending at current number and keeps growing the window

727. Minimum Window Subsequence
find the min substring which T is a subsequence of it.
if there are multiple answer, return the first one. (leftmost)
using two pointer match we can get the sliding window.
it is not efficient when there are a lot of first char.
need some optimizations: we check from right to left and see next jumping position

    string minWindow(string S, string T) {
        int m=S.size(),n=T.size();
        int si=0,ti=0,len=m,start=-1;
        while(si<m){
            if(S[si]==T[ti]){
                if(++ti == n) {
                    //check feasibility from left to right
                    int end=si+1;
                    //check optimization from right to left
                    while(--ti>=0){
                        while(S[si--]!=T[ti]);
                    }
                    si++,ti++;
                    //record the current smallest candidate
                    if(end-si<len){
                        len=end-si;
                        start=si;
                    }
                }
            }
            si++;
        }
        return start==-1?"":S.substr(start,len);
    }
another approach: dp
dp[i,j] stores the starting index of the substring T[0..i] and S[0...j]
similar to edit distance, with just jump
after get all combinations and then we check the smallest


904. fruit into baskets
equivalent: longest window which contains <= 2 kind of trees

927. three equal parts
binary array: leading zeros and trailing zeros, need to have the same pattern

930. Binary Subarrays With Sum
find the window contains S number of 1s, and then the left and right 0s.
we can store all the 1s position and do sliding window on it.

978. longest turbulent subarray
we can use simple counting of +- sign
similar to sliding window.

992. subarrays with k different integers
subarray contains exactly k different integers.

sliding window using hashmap

1004. Max Consecutive Ones III
change up to k 0 to 1. longest subarrays
equivalent to find the longest window with at most k 0s
487. Max Consecutive Ones II
flip at most one 0 to 1. 
equivalent to longest window with <=1 zeros inside
485. Max Consecutive Ones
max window of consecutive ones

1100. Find K-Length Substrings With No Repeated Characters
sliding window with win=K and using hashmap to add a new char and remove old char.

1055. Shortest Way to Form String
copy source (by deleting some chars) to get target.
using sliding window matches.

1052. grumpy bookstore owner
convert to equivalent sliding window with most grumpy which <= k.

1040. Moving Stones Until Consecutive II
equivalent: find the window with min vacancies.


## binary search
702. Search in a Sorted Array of Unknown Size
assuming r=INT_MAX

644. maximum average subarray II
window size >=k.
equivalent: max average is the max element, min average is the min element
so we can use binary search (double) and find the k.
for double: right-left>eps, l=mid,r=mid

643. maximum average subarray I.
fixed window size k.
719. Find K-th Smallest Pair Distance
the absolute difference between pairs is between 0 and A[n]-A[0]
using a difference we count how many is less than it

774. Minimize Max Distance to Gas Station
given a list of station position in a row, add k more station so that the max distance is minimized.
observation: for a distance, if we add one, it reduces to d/2
if we add 2, it shall reduce to d/2 (but if we add based on previous result, we will get d/2)
so we need think it globally.

we can convert it to equivalent binary search problem:
the max distance is max, min distance can be 0
equivalent: using max distance D, how many stations we shall add.


778. swim in rising water
check the first time when connected.
using binary search

786. kth smallest prime fraction
the is an upper triangle prime fraction
row: descending order
cols: ascending order.
so we start from the first row, last col. and push its neighborings into heap.


793. Preimage Size of Factorial Zeroes Function
factorial number of zeros is a staircase increasing function.
what we want to find is the k-zeros how many x.
this is equivalent to find the equal-range of x.


852. peak index in a mountain array
simple binary search: using A[m]<A[m+1]

875. koko eating bananas
equivalent: search and count binary search typical

878. Nth magical number
equivalent: binary search and count, and then get the solution.
min(A,B), max:N*lcm(A,B)

981. Time Based Key-Value Store
time value
get: give a timestamp, return the t<=timestamp. (closest)
binary search using upper_bound

1011. capacity to ship packages within D days
binary search to find the capacity

1095. find in mountain array
fidn the peak
find in left and then find in right

1060. Missing Element in Sorted Array
kth missing elements in sorted array.
using the first element (subtract all the element with it) and then we know:
nums[i]-nums[0]-i is the number of missing number.
must be familiar with tech to convert to equivalent simple problems.

## hashmap
594. Longest Harmonious Subsequence
max and min difference is exactly one.
sort the array using map
and then from the smallest try to get the longest

599. Minimum Index Sum of Two Lists
record the string vs index
find the intersection

609. Find Duplicate File in System
using file content as the key and name as value

659. Split Array into Consecutive Subsequences
get the frequency of each number
and then count required and used.
pretty tricky.

769. Max Chunks To Make Sorted
compare with sorted
then check if hash is the same
768. Max Chunks To Make Sorted II
same to 769, but with duplicate in the hash so use multiset


791. custom sort string
S is sorted using some criteria, sort T using the same criteria.
in S, each char only appears once.
so we just use count sorting, and that is.

846. hand of straights
it needs some tricks, use a map to get its neigbors

874. Walking Robot Simulation
left/right rotation and find the max distance.
with obstacles.

893. Groups of Special-Equivalent Strings
the description is odd, but it is equivalent:
the odd index and even index string shall be equal so we build a common key

929. Unique email address
some simple string operations and hash

937. reorder log files
make sure using multimap to avoid key the same and log get lost.

953. verifying an alien dictionary
both mapped to a known order

957. prison cells after n days
hash to record the status and find the period

963. Minimum Area Rectangle II
rectangle is on the circle. using the circle center and diameter as the hash.
939. Minimum Area Rectangle
rect is along x and y axis. more similar to 2d intervals
using hash for x and y and divide and conquer.

966. Vowel Spellchecker
first exact match
second, case ignore match
third: vowel misspell.

997 find the town judge
the guy knows nobody but all knows him.

1001 grid illumination
row, col, diag, anti-diag
lights


1010. Pairs of songs with total duration divisible by 60.

1122. Relative Sort Array
sort using arr2. (using hashmap and count sort)

1072. Flip Columns For Maximum Number of Equal Rows
need convert to equivalent problem:
flip the column. we are actually looking for the same pattern for all the rows

## parsing a string or expression evaluation
this is where recursive approach most powerful.

1106. Parsing A Boolean Expression
- single t or f.
- ! use true & the result, and use true & the result, or use false | the results
- the , can be ignored and do recursively

1096. Brace Expansion II
using stack and recursion
default operation: union using ,
to avoid duplicate using hashset
stack of hashset
1087. Brace Expansion
return all combinations
there are no nested braces. so just connect them using dfs


## Misc
722. remove comments
aproach 1: regex
appraoch 2: remove // and /* */ for multiline


723. candy crush
find all those candy to crush, and marking them as negative and move forward

751. ip to cidr

788. rotated digits
rotate each digit individually.
brutal force is fine to loop each number.

796. Rotate String
we double the string and see if we can find the other string inside.

800. Similar RGB Color
find the r,g,b and the shortest rr,gg,bb


1111. Maximum Nesting Depth of Two Valid Parentheses Strings
min the max(depth(A),depth(B))
we try to make depth a and depth b similar to minimize
Basically, ( is 1 point, ) is -1 point.
We try to keep total points of two groups even,
by distributing parentheses alternatively.

The good part of this solution is that,
we actually need no extra variable to record anything.

1023. camelcase matching
1016. binary string with substring representing 1 to N.
brutal force searching

954. Array of Doubled Pairs
negative and positive two parts
sort and from smallest.

906 super palindrome
direct approach: 
odd and even, determine the range of the solution
and try its square and see if it is also a palindrome.

899. Orderly Queue
move the first k letters to end.
k==1
k>1 swap, when having two more positions it is equivalent to swap.

### count sort

1093. Statistics from a Large Sample
this is already count sorted results, each element has a count and without restoring the sequence, we need to find the element
prefix sum of the counters and find the element.

900 RLE iterator
this is similar idea: count and the array value and then search.


### combination and permutations
1079. Letter Tile Possibilities
- dfs and eliminate duplicates and using permutation.

### gray code
753. Cracking the Safe
reflection code.
2^k: base k reflection code, 
- loop 2^k
- reflect and change the last digit


### math problem
587. Erect the Fence
convex hull algorithm, gift wrapping 


592. fraction addition and subtraction


593. valid square
6 lengths 4 are the same and 2 are the same

625. min factorization
factorization of the number, and the digit product=num
factorization always get a pair.
and the factor can be decomposed again into smaller numbers until we get one digit number
so it becomes a recursive.
- shortest number of digits---
- choose the smallest factor between [2,9] for example 15=3*5
We only need to pick the largest factor in [2, 9] each time and put it to the front of current result. (So that the first pick is put at the least significant digit).
Why it works?
Lets forget about how we put the digits for a moment. If we just pick the largest factor in [2, 9] every time, we can guarantee the result has the shortest length (least digits).
Now if we have the shortest length, the way to make this number smallest is to put the largest one to the least significant.


710. random pick with blacklist

645. set mismatch
array 1 to n , and one number is converted to other number.
that is: one number missing and one number duplicates
find the two numbers.
using xor: suppose duplicate is a, and missing is b, then we get a^b
if we find the duplicate, and problem solved.
using the hashmap to count.
or check all seen element to negative.

660. Remove 9
removing all numbers containing 9
equivalent: 9-base problem and we get the nth number.

780. reaching a point
from (sx,sy) to (tx,ty) by transforming (x,x+y) or (x+y,y)
- from target to source is the same
- transform (x,y-x) or (x-y,y)
- the transform must be tx-sx % x==0 or ty-sy % x==0

781. Rabbits in forest
- different answers cannot be the same group
- same answer could be one group but could also be another group (when there are more rabits answering)


829. consecutive numbers sum
just check brute force: if it can be decomposed to : x,x+1,x+2....x+i.

836. rectangle overlap
835. image overlap
max of two left
min of two right

848. shifting letters
- %26 circular
- prefix sum

858. Mirror Reflection
mirror reflection is equivalent as modular operation
hence we unwrap the reflection.

866. Prime Palindrome
just try all possible palindrome: all even palindrome are divisible by 11, so can be ignored.

869. reordered power of 2
just try the 32 numbers.

883. projection area of 3d shapes

892. surface area of 3d shapes
common practice: only check with previous shapes and remove the covered surface areas.

1073. adding two negabinary numbers
using & and >>

1018. binary prefix divisible by 5
%5 and accumulate

1017. convert to base -2
using & and >>

1015. smallest integer divisible by K.
digits are all 1. using pigeon hole principle.
and %K and accumulate

1009. complement of base 10 integer
change binary bits from 0 to 1

974. Subarray Sums Divisible by K
prefix sum %K (also note for negatives)
and then count sort.

972. equal rational number
expand the number till double precision

## linked-list
708. insert into a cyclic sorted list
- empty list, insert and linked to itself
- value is between prev and next.
- all values are the same and insert any where


725. split linked list in parts
k in each parts.
just use similar ideas in array

817. linked list components
return number of groups given an array
store array in hashset, and check one by one to see if they are in the hashset

876. middle of the linked list.
slow and fast.


## design
588. design in-memory file system
ls: list files and directories
mkdir: 
addContentToFile: create/append contents to file
readContentFromFile: 

this is a file tree structure.
using trie. or n-ary tree structure.

604 design compressed string iterator
similar to the count and array using binary search and prefix sum

622. design circular queue
using vector and head, tail

631. design excel sum formula
row from 1 to 26
col from A to Z
set: set the value at row and col
get: get the value at row col
sum: sum(r,c,numbers) sum the numbers and set the value at row col
the trick is when one element is changed, the formula shall be applied to the cells again.



635. design log storage system
store the log with timestamp.
retrieve using granuity
using multimap to store to accept duplicate key.
using binary search

642. design search auto-complete system
see trie.
641 design circular deque
using vector, head tail pointer


895. max frequency stack
the idea: for each frequency build a stack: hash: frequency vs stack
value - frequency
freq - stack.

716. max stack
using two stacks. 
the only trick is: popmax, we need find the element and pop and save all those elements and put back.

707. design linked list
706 design hashmap
705. design hashset

## trivial
1119. Remove Vowels from a String
1118. Number of Days in a Month
leap year is: %4==0 %100==0 && %400==0
1108. Defanging an IP Address
replace . with [.]
1085. Sum of Digits in the Minimum Number
1078. Occurrences After Bigram
just understand the problem correctly.
1065. Index Pairs of a String
1064. Fixed Point
A[i]==i binary search
1056. confusing number
1051. Height checker
1047. Remove All Adjacent Duplicates In String
simple stack problem
1037. valid boomerang
1030. matrix cells in distance order
1002. find common characters
999. available captures for rook
994. rotting oranges
one step bfs
989. add to array form of integer
985. sum of even numbers after queries
961. n-repeated element in size 2n array
majority or hashmap
933. number of recent calls
922. sort array by parity II
917. reverse only letters
914. x of a kind in a deck of cards
gcd
905. sort array by parity
896. monotonic array
888. Fair Candy Swap
simple math and set.
884. uncommon words from two sentences
868. binary gap
867. transpose matrix
860. lemonade change
859. Buddy Strings
swap only two letters in A so that A==B
840. magic squares in grid
832. flipping an image
831. masking personal information
830. positions of large group: simple two pointer
824. goat latin
819. most common word
821. shortest distance to a character.
two passes: first get the shortest distance to its left and then get the distance to its right.
812. largest triangle area
sorted
811. subdomain visit count
simple hash
804. unique morse code words
simple hash
766. toeplitz matrix
762. prime number of set bits in binary representation
747. largest number at least twice of others
get the largest and second largest using one pass.
746. min cost climbing stairs
simple dp
744. Find Smallest Letter Greater Than Target
sorted char list, using upper_bound
733. flood fill
simple dfs
724. Find Pivot Index
left sum=right sum, and it is a simple both end problem
720. longest word in dictionary
661. image smoother
need use a new image
657. robot returning to origin.
UDRL without rotation
717. 1 bit and 2 bit characters
two pointer: see 1 jump 2, see 0 jump 1
709. to lower case
704. binary search
703. kth largest elment in a stream
simple heap
633. sum of seuare numbers
brutal force
628. max product of three numbers
598. range addition
all operations is from [0,0] to [i,j] so there are fixed overlaps



knowledge
- random_shuffle
loop from back and swap with previous random
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits<RandomIt>::difference_type i, n;
    n = last - first;
    for (i = n-1; i > 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
        // rand() % (i+1) isn't actually correct, because the generated number
        // is not uniformly distributed for most values of i. A correct implementation
        // will need to essentially reimplement C++11 std::uniform_int_distribution,
        // which is beyond the scope of this example.
    }
}

- pascal triangle each number is C(n,m)












