Array

## contents:

905	Sort Array By Parity		Easy	
832	Flipping an Image		Easy	
977	Squares of a Sorted Array		Easy	
561	Array Partition I		Easy	
922	Sort Array By Parity II		Easy	
999	Available Captures for Rook		Easy	
509	Fibonacci Number		Easy	
1002 Find Common Characters		Easy	
985	Sum of Even Numbers After Queries		Easy	
867	Transpose Matrix		Easy	
766	Toeplitz Matrix		Easy	
566	Reshape the Matrix		Easy	
243	Shortest Word Distance 	Easy	
888	Fair Candy Swap		Easy	
1013 Partition Array Into Three Parts With Equal Sum		Easy	
896	Monotonic Array		Easy	
485	Max Consecutive Ones		Easy	
283	Move Zeroes		Easy	
448	Find All Numbers Disappeared in an Array		Easy	
169	Majority Element		Easy	
122	Best Time to Buy and Sell Stock II		Easy	
217	Contains Duplicate		Easy	
167	Two Sum II - Input array is sorted		Easy	
697	Degree of an Array		Easy	
717	1-bit and 2-bit Characters		Easy	
661	Image Smoother		Easy	
268	Missing Number		Easy	
830	Positions of Large Groups		Easy	
121	Best Time to Buy and Sell Stock		Easy	
746	Min Cost Climbing Stairs		Easy	
628	Maximum Product of Three Numbers		Easy	
1018 Binary Prefix Divisible By 5		Easy	
118	Pascal's Triangle		Easy	
1010 Pairs of Songs With Total Durations Divisible by 60		Easy	
989	Add to Array-Form of Integer		Easy	
27	Remove Element		Easy	
674	Longest Continuous Increasing Subsequence		Easy	
1	Two Sum		Easy	
53	Maximum Subarray		Easy	
119	Pascal's Triangle II		Easy	
66	Plus One		Easy	
724	Find Pivot Index		Easy	
35	Search Insert Position		Easy	
849	Maximize Distance to Closest Person		Easy	
26	Remove Duplicates from Sorted Array		Easy	
747	Largest Number At Least Twice of Others		Easy	
643	Maximum Average Subarray I		Easy	
624	Maximum Distance in 	Easy	
88	Merge Sorted Array		Easy	
840	Magic Squares In Grid		Easy	
219	Contains Duplicate II		Easy	
941	Valid Mountain Array		Easy	
914	X of a Kind in a Deck of Cards		Easy	
605	Can Place Flowers		Easy	
581	Shortest Unsorted Continuous Subarray		Easy	
189	Rotate Array		Easy	
532	K-diff Pairs in an Array		Easy	
414	Third Maximum Number		Easy	
665	Non-decreasing Array		Easy	

950	Reveal Cards In Increasing Order		Medium	
723	Candy Crush 	Medium	
969	Pancake Sorting		Medium	
280	Wiggle Sort 	Medium	
442	Find All Duplicates in an Array		Medium	
370	Range Addition 	Medium	
531	Lonely Pixel I 	Medium	
695	Max Area of Island		Medium	
1031 Maximum Sum of Two Non-Overlapping Subarrays		Medium	
238	Product of Array Except Self		Medium	
245	Shortest Word Distance III 	Medium	
78	Subsets		Medium	
565	Array Nesting		Medium	
1011 Capacity To Ship Packages Within D Days		Medium	
495	Teemo Attacking		Medium	
835	Image Overlap		Medium	
667	Beautiful Arrangement II		Medium	
769	Max Chunks To Make Sorted		Medium	
216	Combination Sum III		Medium	
1035 Uncrossed Lines		Medium	
714	Best Time to Buy and Sell Stock with Transaction Fee		Medium	
900	RLE Iterator		Medium	
287	Find the Duplicate Number		Medium	
926	Flip String to Monotone Increasing		Medium	
39	Combination Sum		Medium	
48	Rotate Image		Medium	
1014 Best Sightseeing Pair		Medium	
62	Unique Paths		Medium	
729	My Calendar I		Medium	
1007 Minimum Domino Rotations For Equal Row		Medium	
64	Minimum Path Sum		Medium	
59	Spiral Matrix II		Medium	
533	Lonely Pixel II 	Medium	
873	Length of Longest Fibonacci Subsequence		Medium	
718	Maximum Length of Repeated Subarray		Medium	
978	Longest Turbulent Subarray		Medium	
16	3Sum Closest		Medium	
621	Task Scheduler		Medium	
289	Game of Life		Medium	
611	Valid Triangle Number		Medium	
1040 Moving Stones Until Consecutive II		Medium	
259	3Sum Smaller 	Medium	
11	Container With Most Water		Medium	
974	Subarray Sums Divisible by K		Medium	
562	Longest Line of Consecutive One in Matrix 	Medium	
548	Split Array with Equal Sum 	Medium	
795	Number of Subarrays with Bounded Maximum		Medium	
915	Partition Array into Disjoint Intervals		Medium	
153	Find Minimum in Rotated Sorted Array		Medium	
380	Insert Delete GetRandom O(1)		Medium	
945	Minimum Increment to Make Array Unique		Medium	
792	Number of Matching Subsequences		Medium	
870	Advantage Shuffle		Medium	
90	Subsets II		Medium	
560	Subarray Sum Equals K		Medium	
75	Sort Colors		Medium	
40	Combination Sum II		Medium	
162	Find Peak Element		Medium	
962	Maximum Width Ramp		Medium	
105	Construct Binary Tree from Preorder and Inorder Traversal		Medium	
80	Remove Duplicates from Sorted Array II		Medium	
755	Pour Water 	Medium	
73	Set Matrix Zeroes		Medium	
670	Maximum Swap		Medium	
120	Triangle		Medium	
106	Construct Binary Tree from Inorder and Postorder Traversal		Medium	
775	Global and Local Inversions		Medium	
277	Find the Celebrity 	Medium	
713	Subarray Product Less Than K		Medium	
825	Friends Of Appropriate Ages		Medium	
228	Summary Ranges		Medium	
56	Merge Intervals		Medium	
74	Search a 2D Matrix		Medium	
209	Minimum Size Subarray Sum		Medium	
954	Array of Doubled Pairs		Medium	
34	Find First and Last Position of Element in Sorted Array		Medium	
63	Unique Paths II		Medium	
33	Search in Rotated Sorted Array		Medium	
81	Search in Rotated Sorted Array II		Medium	
229	Majority Element II		Medium	
55	Jump Game		Medium	
918	Maximum Sum Circular Subarray		Medium	
79	Word Search		Medium	
18	4Sum		Medium	
31	Next Permutation		Medium	
54	Spiral Matrix		Medium	
152	Maximum Product Subarray		Medium	
457	Circular Array Loop		Medium	
907	Sum of Subarray Minimums		Medium	
15	3Sum		Medium	
163	Missing Ranges 	Medium	


768	Max Chunks To Make Sorted II		Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays		Hard	
42	Trapping Rain Water		Hard	
128	Longest Consecutive Sequence		Hard	
782	Transform to Chessboard		Hard	
154	Find Minimum in Rotated Sorted Array II		Hard	
123	Best Time to Buy and Sell Stock III		Hard	
85	Maximal Rectangle		Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed		Hard	
57	Insert Interval		Hard	
84	Largest Rectangle in Histogram		Hard	
719	Find K-th Smallest Pair Distance		Hard	
41	First Missing Positive		Hard	
891	Sum of Subsequence Widths		Hard	
644	Maximum Average Subarray II 	Hard	
45	Jump Game II		Hard	
4	Median of Two Sorted Arrays		Hard	
126	Word Ladder II		Hard

## Easy

### 905. sort array by parity
first even number followed by odd numbers, any order is fine.
two pointer or other methods

### 832. flipping image
Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.
straightforward using reverse.

### 977. Squares of sorted array
has negatives, using two pointer. O(n)

### 561. Array Partition I: 
pair of 2n numbers and add min and make the sum largest
**greedy**. sort and pair. the sum is the even indexed sum
maximize the sum(min(A[i],B[i])) where A[i]<B[i]
Sa=A[0]+A[1]+....+A[n-1]
Sb=B[0]+B[1]+....+B[n-1]
Sd=Sb-Sa=sum(B[i]-A[i])
total=Sa+Sb=Sa+Sd+Sa=2Sa+Sd=constant
we shall minimize Sd.
sorted array adjacent has the smallest difference.
greedy often needs math derives using differences (that is sorting based)

### 922. Sort Array By Parity II
input is half odd, half even. we need to put even element on even index
two pointer: even and odd.
```cpp
    vector<int> sortArrayByParityII(vector<int>& A) {
        vector<int> ans(A.size());
        int odd=1,even=0;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]%2) {ans[odd]=A[i];odd+=2;}
            else {ans[even]=A[i],even+=2;}
        }
        return ans;
    }
```	

### 999. Available capture for rook
find the 4 directions to capture

### 509. Fibonacci Number
using array instead of recursive. a lot of overlaps

### 1002. Find common characters
find all chars (including duplicates) shown in all strings
using hashmap or 26 char vector to record the counts

### 985. Sum of even numbers after queries
a query with val and index, then we add this val to the element at index
```cpp
    vector<int> sumEvenAfterQueries(vector<int>& A, vector<vector<int>>& queries) {
        int sum=0;
        vector<int> ans(queries.size());
        for(int i=0;i<A.size();i++) if(A[i]%2==0) sum+=A[i];
        for(int i=0;i<queries.size();i++)
        {
            int t=A[queries[i][1]]+queries[i][0];
            int ind=queries[i][1];
            if(t%2==0) //even
            {
                if(A[ind]%2) sum+=t;
                else sum+=queries[i][0];
            }
            else //odd
            {
                if(A[ind]%2==0) sum-=A[ind];
            }
            A[ind]=t;
            ans[i]=sum;
        }
        return ans;
    }
```
	
### 867. Transpose Matrix 
swap A[i,j] with A[j,i]
we can do in-place swap.

### 766	Toeplitz Matrix		Easy	
A[i][j]=A[i-1][j-1]

### 566	Reshape the Matrix		Easy	
matlab reshape, index calculation

### 243	Shortest Word Distance 	Easy	
locked

### 888	Fair Candy Swap		Easy	
exchange one candy so each total is the same
simple math, (asum-bsum)/2
```cpp
    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {
        int ta=accumulate(A.begin(),A.end(),0);
        int tb=accumulate(B.begin(),B.end(),0);
        int diff=(tb-ta)/2;
        set<int> sa(A.begin(),A.end());
        set<int> sb(B.begin(),B.end());
        //need satisify b-a=(tb-ta)/2 or b=(tb-ta)/2+a
        for(auto it=sa.begin();it!=sa.end();it++)
            if(sb.count(*it+diff)) return vector<int>({*it,*it+diff});
    }
```	

### 1013 Partition Array Into Three Parts With Equal Sum		Easy	
target sum is known
no order change.

### 896	Monotonic Array		Easy	
simple

### 485	Max Consecutive Ones		Easy	
array of 0 and 1. get the max length of ones

### 283	Move Zeroes		Easy	
move 0 to the end keeping original order in place
simple two pointers

### 448	Find All Numbers Disappeared in an Array		Easy	***
### 1 to n, n is also the array length. some appear twice, some appear once, find all missing numbers
O(n) time and O(1) space

The idea is very similar to problem 442. Find All Duplicates in an Array: https://leetcode.com/problems/find-all-duplicates-in-an-array/.

First iteration to negate values at position whose equal to values appear in array. Second iteration to collect all position whose value is positive, which are the missing values. Complexity is O(n) Time and O(1) space.
```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int len = nums.size();
        for(int i=0; i<len; i++) {
            int m = abs(nums[i])-1; // index start from 0
            nums[m] = nums[m]>0 ? -nums[m] : nums[m];
        }
        vector<int> res;
        for(int i = 0; i<len; i++) {
            if(nums[i] > 0) res.push_back(i+1);
        }
        return res;
    }
};
```

### 169	Majority Element		Easy	***
>=n/2 times
using hashmap O(n) space O(n) time
voting algorithm:
```cpp
    public int majorityElement(int[] num) {

        int major=num[0], count = 1;
        for(int i=1; i<num.length;i++){
            if(count==0){
                count++;
                major=num[i];
            }else if(major==num[i]){
                count++;
            }else count--;
            
        }
        return major;
    }
```


### 122	Best Time to Buy and Sell Stock II		Easy	
see dp

### 217	Contains Duplicate		Easy	
check if an array has duplicates
hashmap on the fly
or set to remove duplicates

### 167	Two Sum II - Input array is sorted		Easy	
two pointer

### 697	Degree of an Array		Easy	
degree of the array: most frequent element
find the shortest range which has the same degree of the array
store the start and ending index of element in hash table
```cpp
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int,vector<int>> mp;
        for(int i=0;i<nums.size();i++) mp[nums[i]].push_back(i);
        int degree=0;
        for(auto it=mp.begin();it!=mp.end();it++) degree=max(degree,int(it->second.size()));
        int shortest=nums.size();
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            if(it->second.size()==degree)
            {
                shortest=min(shortest,it->second.back()-it->second[0]+1);
            }
        }
        return shortest;
    }
```	

### 717	1-bit and 2-bit Characters		Easy	
one bit char 0
two bit char 10 or 11
iven a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.
last two is 00, then the last char is one bit
last two is 10, then we have 010 and 110. 010: it is two bit char, 110 it depends on 0110 (yes) 01110 (odd number of 1s must be two bit char
so we just count number of continuous 1
```cpp
    public boolean isOneBitCharacter(int[] bits) {
        int ones = 0;
        //Starting from one but last, as last one is always 0.
        for (int i = bits.length - 2; i >= 0 && bits[i] != 0 ; i--) { 
            ones++;
        }
        if (ones % 2 > 0) return false; 
        return true;
    }
```	

### 661	Image Smoother		Easy	
trivial

### 268	Missing Number		Easy	
n is the length of array containing 0 to n, one is missing. find the missing one
use xor

### 830	Positions of Large Groups		Easy	
large group has >=3 consecuative same characters
the question asks for lexico order but is incorrect


### 121	Best Time to Buy and Sell Stock		Easy	
see dp

### 746	Min Cost Climbing Stairs		Easy	
see dp

### 628	Maximum Product of Three Numbers		Easy	
sort and use the 3 min and 3 max

### 1018 Binary Prefix Divisible By 5		Easy	
binary string, prefix if divisible by 5 (MSB to LSB)
ans*2+digit

### 118	Pascal's Triangle		Easy	
generate the first N rows
simple

### 1010 Pairs of Songs With Total Durations Divisible by 60		Easy	
mod
```cpp
    int numPairsDivisibleBy60(vector<int>& time) {
        unordered_map<int,int> mp;
        for(int i=0;i<time.size();i++) {time[i]%=60;mp[time[i]]++;}
        
        int ans=0;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            auto t=*it;
            if(t.first==0) ans+=t.second*(t.second-1)/2;
            else if(t.first==30) ans+=t.second*(t.second-1)/2;
            else if(mp.count(60-t.first)) {ans+=t.second*mp[60-t.first]; mp[60-t.first]=0;}
            //cout<<t.first<<","<<t.second<<": "<<ans<<endl;
        }
        return ans;
    }
```	

### 989	Add to Array-Form of Integer		Easy	
one integer and one array-form integer
convert the integer to string

### 27	Remove Element		Easy	
remove all target value
two pointer

### 674	Longest Continuous Increasing Subsequence		Easy	
this needs subarray instead of sub sequence
two pointer or use counter to record

### 1	Two Sum		Easy	
hashmap

### 53	Maximum Subarray		Easy	***
find the max sum of a subarray. THe array has negatives
```cpp
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int maxsum=INT_MIN;
        int maxelem=*max_element(nums.begin(),nums.end());
        if(maxelem<0) return maxelem;
        int tsum=0;
        for(int i=0;i<nums.size();i++)
        {
            if(tsum<0) tsum=0;
            tsum+=nums[i];
            maxsum=max(maxsum,tsum);
        }
        return maxsum;
    }
```
all negatives
contain positives: if we meet a negative we restart.

### 119	Pascal's Triangle II		Easy	
kth row only and only use k space
i.e we need to reuse the memory (similar to dp)
```cpp
    vector<int> getRow(int rowIndex) {
        vector<int> A(rowIndex+1, 0);
        A[0] = 1;
        for(int i=1; i<rowIndex+1; i++)
            for(int j=i; j>=1; j--)
                A[j] += A[j-1];
        return A;
    }
```	

### 66	Plus One		Easy	
simple

### 724	Find Pivot Index		Easy	
its leftsum ==its right sum
prefix sum+nums[i]=totalsum-prefixsum
simple math

### 35	Search Insert Position		Easy	
binary search

### 849	Maximize Distance to Closest Person		Easy	
two ends are different
```cpp
    int maxDistToClosest(vector<int>& seats) {
        //get the longest zero region
        //both end shall be treat differently
        int n=seats.size(),i=0,j=n-1;
        int lwid=0,rwid=0;
        int ans=0;
        while(seats[i]==0) i++; ans=max(ans,i);
        while(seats[j]==0) j--; ans=max(ans,n-j-1);
        int cnt=0;
        while(i<=j)
        {
            if(seats[i]==0) cnt++;
            else {ans=max(ans,(cnt+1)/2);cnt=0;}
            i++;
        }
        return ans;
    }
```	

### 26	Remove Duplicates from Sorted Array		Easy	
two pointers

### 747	Largest Number At Least Twice of Others		Easy	
find the 2 max
```cpp
    int dominantIndex(vector<int>& nums) {
        int max1=INT_MIN,max2=INT_MIN;
        int ans=-1;
        for(int i=0;i<nums.size();i++)
        {
            int t=nums[i];
            if(t>max1) {max2=max1,max1=t;ans=i;}
            else if(t>max2) max2=t;
        }
        if(max1==INT_MIN) return -1;
        if(max2==INT_MIN) return ans;
        if(max1>=2*max2) return ans;
        return -1;
    }
```

### 643	Maximum Average Subarray I		Easy	
sliding window with K

### 624	Maximum Distance in 	Easy	
locked

### 88	Merge Sorted Array		Easy	
two pointer merge

### 840	Magic Squares In Grid		Easy	
### 3x3 all adds up to 15
check how many such squares 
simple

### 219	Contains Duplicate II		Easy	
nums[i]==nums[j] and j-i<=K
hashtable to store index


### 941	Valid Mountain Array		Easy	
two pointers (climbing mountain and meet at the peak)

### 914	X of a Kind in a Deck of Cards		Easy	
gcd and hashmap

### 605	Can Place Flowers		Easy	***
Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.
```cpp
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        //assuming both ends are empty
        int m=flowerbed.size();
        flowerbed.push_back(0);
        flowerbed.insert(flowerbed.begin(),0);
        //a zero region of lenght l can support (l-1)/2 flowers
        int cnt=0;
        for(int i=0;i<flowerbed.size();i++)
        {
            if(flowerbed[i]==0) cnt++;
            else {n-=(cnt-1)/2;cnt=0;}
            if(n<=0) break;
        }
        if(cnt) n-=(cnt-1)/2;
        return n<=0;
        
    }
```
add an empty spot at the two ends.	

### 581	Shortest Unsorted Continuous Subarray		Easy	
compare with sorted O(nlogn)
two pointer: for example [2, 6, 4, 8, 10, 9, 15]
from left we found 6 is not sorted
from right we found 9 is not sorted


### 189	Rotate Array		Easy	***
in place.
```cpp
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        k%=n;
        reverse(nums.begin(),nums.begin()+n-k);
        reverse(nums.begin()+n-k,nums.end());
        reverse(nums.begin(),nums.end());
    }
```	

### 532	K-diff Pairs in an Array		Easy	
Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
```cpp
  int findPairs(vector<int>& nums, int k) {
    if (k < 0) return 0;
    unordered_map<int, int> m;
    for (int n : nums) m[n]++;
    int cnt = 0;
    for (auto p : m) {
      if ((!k && p.second > 1)
        || (k && m.count(p.first + k))) ++cnt;
    }
    return cnt;
  }
```  

### 414	Third Maximum Number		Easy	
```cpp
    int thirdMax(vector<int>& nums) {
       long long m1=LLONG_MIN,m2=LLONG_MIN,m3=LLONG_MIN;
        for(int t: nums)
        {
            if(m1<t) {m3=m2;m2=m1;m1=t;}
            else if(t<m1 && m2<t) {m3=m2;m2=t;}
            else if(t<m2 && m3<t) m3=t;
        }
        return m3==LLONG_MIN?m1:m3;
    }
```
	
### 665	Non-decreasing Array		Easy	***
Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.
greedy:  if we find an inversion, we need make the current one as small as possible. either change current or previous.
```cpp
    bool checkPossibility(vector<int>& nums) {
        int cnt=0;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]<nums[i-1])
            {
                cnt++;
                if(i>=2 && nums[i]<nums[i-2]) nums[i]=nums[i-1];
                else nums[i-1]=nums[i];
            }
        }
        return cnt<=1;
    }
```	

## Medium
### 950. Reveal Cards In Increasing Order
reverse build the cards
the final target is the sorted array. so we first sort the input. and then we reverse the steps to get the initial array
```cpp
    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        //smallest always on top
        sort(deck.begin(),deck.end(),greater<int>());
        deque<int> dq;
        //reverse build the array, put back the cards sequentially
        //before add the card, we need bring the back to the front
        for(int i=0;i<deck.size();i++)
        {
            if(dq.size()>=2) 
            {
                dq.push_front(dq.back());
                dq.pop_back();
            }
            dq.push_front(deck[i]);
        }
        return vector<int>(dq.begin(),dq.end());
    }
```	
### 969. Pancake Sorting
Given an array A, we can perform a pancake flip: We choose some positive integer k <= A.length, then reverse the order of the first k elements of A.  We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.

Return the k-values corresponding to a sequence of pancake flips that sort A.  Any valid answer that sorts the array within 10 * A.length flips will be judged as correct.

input array is permuation of 1 to n
greedy: always move the biggest to the first and move to its sorted position do not need to consider the special case when it is already in the first position reverse to find the largest: the input is 1 to n, using this fact to make it more easier.

```cpp
    vector<int> pancakeSort(vector<int> A) {
        vector<int> res;
        int x,i;
        for (x = A.size(); x > 0; --x) { //the current max
            for (i = 0; A[i] != x; ++i);
            reverse(A.begin(), A.begin() + i + 1);
            res.push_back(i + 1);//number of operations
            reverse(A.begin(), A.begin() + x); //move max to its sorted position
            res.push_back(x);
        }
        return res;
    }
```

### 442. Find All Duplicates in an Array
mark the number seen as negative, then those not marked is duplicates (will marked twice)
```cpp
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        
        for (int n: nums) 
        {
            int pos = abs(n);
            if(nums[pos - 1] > 0) nums[pos - 1] *= -1;
            else res.push_back(pos);
        }
        
        return res;
    }
```
see 	448	Find All Numbers Disappeared in an Array


### 695. Max Area of Island
dfs or bfs from any nodes
dfs: remember to mark it visited.

### 1031. Maximum Sum of Two Non-Overlapping Subarrays
this is a simple version of three non-overlapping subarrays
sliding window.

```cpp
    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {
        return max(helper(A,L,M),helper(A,M,L));
    }
    int helper(vector<int>& A,int L,int M) //left and right fixed
    {
        int n=A.size();
        vector<int> lmax(n-M);
        int tsum=0;
        int leftmax=0;
        for(int i=0;i<L;i++) tsum+=A[i];
        lmax[L-1]=leftmax=tsum;
        for(int i=L;i<n-M;i++) 
        {
            tsum+=A[i]-A[i-L];
            lmax[i]=leftmax=max(leftmax,tsum);
        }

        int rmax=0;
        for(int i=n-1;i>=n-M;i--) rmax+=A[i];
        tsum=rmax;
        int gsum=rmax+lmax[n-M-1];
        for(int i=n-M-1;i>=L;i--)
        {
            tsum+=A[i]-A[i+M];
            rmax=max(rmax,tsum);
            gsum=max(gsum,rmax+lmax[i-1]);
        }

        return gsum;
    }
```	
to avoid complicated index, we can waste a bit memory

### 238. Product of Array Except Self
left product and right product, two direction methodology
```cpp
    vector<int> productExceptSelf(vector<int>& nums) {
        //left and right product and then times left and right
        int len=nums.size();
        long long left=1,right=1;
        vector<int> res(len,1);
        for(int i=1;i<len;i++)
        {
            left*=nums[i-1];
            res[i]*=left;
        }
        for(int i=len-2;i>=0;i--)
        {
            right*=nums[i+1];
            res[i]*=right;
        }
        return res;
    }
```
### 78. Subsets
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

```cpp
    vector<vector<int>> subsets(vector<int>& nums) {
        //approach: each element has an option to be in or not in
        //brute force, loop over, very hard to make it work
        //it is similar to a nbit number and its value are from 0-2^n-1
        //there shall be a restrict on the length of the nums, otherwise it cannot fit in an integer
        int n=nums.size();
        int num=1<<n; //total 2
        vector<vector<int>> res;
        res.push_back(vector<int>());
        vector<int> vt; //length is known!
        for(int i=1;i<num;i++) //0 to 2^n-1
        {
            bitset<32> mybit(i);
            vt.clear();
            for(int j=0;j<n;j++) //exactly n bits
            {
                if(mybit[j]) vt.push_back(nums[j]);
            }
            res.push_back(vt);
        }
        
        return res;
    }
```
	
### 565. Array Nesting	
A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.

Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.

use visited array, since every nested array will form a cycle. if a node is visited, it is not needed

```cpp
    int arrayNesting(vector<int>& nums) {
        //strategy: visited, it will form multiple circles and we keep the circle length
        int maxlen=0;
        int cycle_len=0;
        vector<bool> visited(nums.size());
        for(int i=0;i<nums.size();i++)
        {
            if(!visited[i]) //start a new cycle
            {
                cycle_len=1;
                int ind=nums[i];
                visited[i]=1;
                
                while(!visited[ind]) {visited[ind]=1;ind=nums[ind];cycle_len++;}
            }
            if(cycle_len>maxlen) maxlen=cycle_len;
        }
        return maxlen;
    }
```
cyclic linking 

### 1011. Capacity to ship packages within D days
see binary search
	
### 495. Teemo Attacking
In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.

You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.

need subtract those overlaps

```cpp
    int findPoisonedDuration(vector<int>& timeSeries, int duration) {
        //timeseries point is the left side point, duration is the length of the line segment
        //the problem needs to accumulate the line. timeseries is sorted
        //brutal force solution
        int tp=0;
        int tend=0;
        for(int i=0;i<timeSeries.size();i++)
        {
            tp+=duration-(timeSeries[i]<tend)*(tend-timeSeries[i]);
            tend=timeSeries[i]+duration;
        }
        return tp;
    }
```	

### 835. Image overlap
```cpp
    int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {
        int n=A.size();
        int max_overlap=0;
        for(int i=-n+1;i<n;i++) //sliding is 2n
        {
            for(int j=-n+1;j<n;j++)
            {
                max_overlap=max(max_overlap,overlap(A,B,i,j));
            }
        }
        return max_overlap;
    }
    int overlap(vector<vector<int>>& A, vector<vector<int>>& B,int x,int y)
    {
        //the other top left coordinate is (x,y)
        //need find the overlap of the two image, 
        int xl,xr,yt,yb;
        int n=A.size();
        xl=max(x,0);
        xr=min(x+n-1,n-1);
        yt=max(y,0);
        yb=min(y+n-1,n-1);

        int res=0;
        for(int i=xl;i<=xr;i++)
        {
            for(int j=yt;j<=yb;j++) res+=A[i][j]*B[i-x][j-y];
        }
        return res;
    }
```
	
### 667. Beautiful Arrangement II
Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: 
Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.

1,k+1,2,k,3,k-1,4,k-2....
```cpp
    vector<int> constructArray(int n, int k) {
        vector<int> vs(n);
        //for(int i=0;i<n;i++) vs[i]=i+1;
        //1,k+1,2,k,3,k-1,4,k-2.....but do not use duplicates
        //the distance is k,k-1......1
        //until they meet 
        int l=1,r=k+1;
        int cnt=0;
        while(l<=r) //when l+1==r r cannot be added
        {
            vs[cnt++]=l++;
            if(r>=l) vs[cnt++]=r--;//when r==l+1, the difference is 1
        }
        //we already used 1...k+1, the remaining difference is 1!
        for(int i=cnt;i<n;i++) vs[i]=i+1;
        return vs;
    }
```
	

### 769. Max Chunks To Make Sorted
split and sort, then connect and the whole array is sorted, return the max chunks
compare with the sorted array. If the two has same hash, then it is a segment
O(nlogn)
```cpp
    int maxChunksToSorted(vector<int>& arr) {
        //a segment shall be smaller than all its elements behind.
        vector<int> va=arr;
        sort(va.begin(),va.end());
        //compare the two array. if the element is the same then it is a segment
        int nseg=0;
        unordered_set<int> ms0,ms1;
        for(int i=0;i<arr.size();i++)
        {
            ms0.insert(arr[i]);ms1.insert(va[i]);
            if(ms0==ms1) {nseg++;ms0.clear();ms1.clear();}
        }
        return nseg;
    }
```	
O(n) similar to 763 Partitional labels
```cpp
int maxChunksToSorted(vector<int>& arr) {
    for (auto i = 0, max_i = 0, ch = 0; i <= arr.size(); ++i) {
      if (i == arr.size()) return ch;
      max_i = max(max_i, arr[i]);
      if (max_i == i) ++ch;
    }
}
```

### 216. Combination Sum III
1-9, k numbers combination sum to n
dfs with backtrace. don't forget to pop out the solved node
```cpp
vector<vector<int>> combinationSum3(int k, int n)
{
    vector<vector<int>> result;
    vector<int> path;
    backtrack(result, path, 1, k, n);//start from root 1, k is number of nodes, n is the target
    return result;
}

void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target)
{
    if(target==0 && k==0) //we reach a good solution
    {
        result.push_back(path);
        return;
    }
    for(int i=start; i<=10-k && i<=target; i++)
    {
        path.push_back(i);
        backtrack(result,path,i+1,k-1,target-i);//reduce a smaller problem k-1
        path.pop_back(); //after trial, go back to another
    }
}
```

### 1035. Uncrossed Lines
see dp for longest common subsequence or edit distance

### 714. Best Time to Buy and Sell Stock with Transaction Fee
see dp

### 900. RLE Iterator
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.

The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead.

For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".

count of numbers, number...
use a pointer to record the current head

```cpp
    vector<long long> v1;
    vector<int> vnum;
    long long cur;
    RLEIterator(vector<int> A) {
        cur=0;
        for(int i=0;i<A.size();i++)
        {
            if(i%2) vnum.push_back(A[i]); //the number
            else v1.push_back(A[i]+(i==0?0:v1.back())); //repeat times
        }
    }
    
    int next(int n) {
        cur+=n;
        //binary search to find the position
        auto it=lower_bound(v1.begin(),v1.end(),cur); //<=
        if(it==v1.end()) return -1;
        int ind=it-v1.begin();
        return vnum[ind];
    }
```
A is the input with even indexed element as count, followed by the number
we store the numbers in vnum and its counters in v. so v1 and vnum corresponds one to one.
to use binary search, we accumulate the index.

### 287. Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
again this is a cyclic problem
treat it as a linked list
```cpp
    int findDuplicate(vector<int>& nums) {
/*if it is a linked-list, this is easier to understand. Actually the following method treats the array a hidden linked list. The element itself serves as the next pointer.
first, the slow one step, the fast two step. The two will meet somewhere in the circle. Then one starts from the first point, the other starts from the meet point. 
Assume the slow runs x, and fast runs 2x, the difference is n cycle. 2x-x=nc. slow must be in the circle so x>k. its distance to A point is (nc-k)%c, which needs k steps.
*/
		int slow=0,fast=0,finder=0;
		while(1)
		{
			slow=nums[slow];
			fast=nums[nums[fast]];
			if(slow==fast) break;
		}
		while(1)
		{
			slow=nums[slow];
			finder=nums[finder];
			if(slow==finder) return slow;
		}
   }
```	


### 926. Flip String to Monotone Increasing
A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)

We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.

Return the minimum number of flips to make S monotone increasing.

min number of flips
if choose i as the mid point, we need flip all 1 in front, and all zeros behind
so left to right scan to get number of 1s
right to left scan to get number of 0s
```cpp
    int minFlipsMonoIncr(string S) {
        //need to flip to get two substring, left is all 0 right all 1
        int n=S.size();
        vector<int> left1(n+1);
        for(int i=0;i<S.size();i++) 
        {
            left1[i+1]=left1[i]+(S[i]=='1');
        }
            
        int minflip=n;
        int right0=0;
        for(int i=S.size()-1;i>=0;i--)
        {
            right0+=(S[i]=='0');
            minflip=min(minflip,right0+left1[i+1]-1);
            //cout<<i<<" "<<right0[i]<<" "<<left1[i+1]<<endl;
        }
        return minflip;
    }
```
	
### 48. Rotate Image
rotate clockwise 90 degrees
AB    DA
DC    CB
one way:
swap A with C and we get:
CB
DA
then reverse vertically.

another way:
swap B with D and we get:
AD
BC
then reverse horizontally

2nd approach is easier.
```cpp
    void rotate(vector<vector<int>>& matrix) { //matrix transpose, row->column, col->row
        for(int i=0;i<matrix.size();i++)
        {
            for(int j=i+1;j<matrix[i].size();j++)
            {
                swap(matrix[i][j],matrix[j][i]);
            }
            reverse(matrix[i].begin(),matrix[i].end());
        }
    }
```

### 1014. Best Sightseeing Pair
Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.

The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

maximize A[i]+i and A[j]-j with i<j. left and right two directions.

```cpp
    int maxScoreSightseeingPair(vector<int>& A) {
        vector<int> lmax(A.size(),INT_MIN);
        lmax[0]=A[0];
        int n=A.size();
       for(int i=1;i<A.size();i++) 
           lmax[i]=max(A[i]+i,lmax[i-1]);
        int ans=lmax[n-2]+A[n-1]-n+1;
        A[n-1]-=n-1;
        for(int i=A.size()-2;i>0;i--)
        {
            A[i]=max(A[i]-i,A[i+1]);
            ans=max(lmax[i-1]+A[i],ans);
        }
        return ans;
    }
```	

### 1007 min domino rotations for equal row
either choose A or B
```cpp
int minDominoRotations(vector<int>& A, vector<int>& B) {
  auto top = A[0], bot = B[0], top1 = 0, bot1 = 0, top2 = 0, bot2 = 0;
  for (auto i = 0; i < A.size(); ++i) {
    if (A[i] != top && B[i] != top) top = 0;
    if (A[i] != bot && B[i] != bot) bot = 0;
    top1 += A[i] == top;
    bot1 += B[i] == top;
    top2 += A[i] == bot;
    bot2 += B[i] == bot;
  }
  return top || bot ? min(A.size() - max(top1, bot1), A.size() - max(top2, bot2)) : -1;
}
```

### 729. My Calendar I
double booking
we need a sorted array of intervals and using binary search to find the one to add

### 731. My Calendar II
tripe booking
The key is to use double booking to create overlaps and to see the new added one overlaps with current overlap

### 732. My Calendar III: k booking
if we mark the start a new event, and end minus an event, then accumulate all until the ending is the k event. If we choose the max, we can iterate until the end.
segment tree: build a tree with cnt, start +1, end -1, the same idea
```cpp
class MyCalendarThree {
    map<int, int> timeline;
public:
    int book(int s, int e) {
        timeline[s]++; // 1 new event will be starting at [s]
        timeline[e]--; // 1 new event will be ending at [e];
        int ongoing = 0, k = 0;
        for (pair<int, int> t : timeline)
            k = max(k, ongoing += t.second);
        return k;
    }
};
```
### 62. Unique Paths
dp problem

### 39. Combination Sum
no duplicates, all combinations sum to target, number can be reused
dfs with backtracking
```cpp
    void helper(vector<int>& nums,int target,vector<vector<int>>& res,vector<int> tmp,int pos)
    {
        if(target==0) {res.push_back(tmp);return;}
        if(target<0) {return;}
        //solved solution?
        for(int i=pos;i<nums.size();i++)
        {
            //tmp.clear();
            tmp.push_back(nums[i]);
            helper(nums,target-nums[i],res,tmp,i);//since it allows duplicates, use i here
            tmp.pop_back();
        }
    }
```
### 40. Combination Sum II
each number can only be used once
```cpp
    void helper(vector<int>& nums,int target,vector<vector<int>>& res,vector<int> tmp,int pos)
    {
        if(target==0) {res.push_back(tmp);return;}
        if(target<0) {return;}
        //solved solution?
        for(int i=pos;i<nums.size();i++)
        {
            //tmp.clear();
            if(i && nums[i]==nums[i-1]&&i>pos) continue;
            tmp.push_back(nums[i]);
            helper(nums,target-nums[i],res,tmp,i+1);//since it does not allows duplicates, use i here
            tmp.pop_back();
        }
    }
```
### 216. Combination Sum III
use 1 to 9, and k numbers to sum to n
```cpp
void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target)
{
    if(target==0 && k==0) //we reach a good solution
    {
        result.push_back(path);
        return;
    }
    for(int i=start; i<=10-k && i<=target; i++)
    {
        path.push_back(i);
        backtrack(result,path,i+1,k-1,target-i);//reduce a smaller problem k-1
        path.pop_back(); //after trial, go back to another
    }
}
```
### 377. Combination Sum IV
get the number of combinations. number can be repeated
knapsack with repetition

### 64. Minimum Path Sum
in matrix, dp problem,

### 59. Spiral Matrix II
fill the matrix from 1 to n^2
need to get: how many loops, and each loop how to iterate

### 621. Task Scheduler
given a list of tasks and requirement, return the min number of intervals needed
somewhat similar to the playlist
choose the most frequent char and divide it into k interval with n period
and put other inside, the min time is (k-1)*n
however when n is smaller than the period, we need suppress non-necessary idle

### 718. Maximum Length of Repeated Subarray
straightforward: sliding window to find max overlap
however, dp is the right way to find the largest common substr
```cpp
    int findLength(vector<int>& A, vector<int>& B) {
        //longest common substring
        int m=A.size(),n=B.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1)); 
        //dp[i, j] represents the longest common subarray between A[0..i-1] and B[0...j-1] 
        //boundary: dp[0][0]=0, 0th row and 0th column all zero
        int max0=0;
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(A[i-1]==B[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                //else dp[i][j]=0;
                max0=max(max0,dp[i][j]);
            }
        }
        return max0;
    }
```

### 611. Valid Triangle Number
a+b>c
sort first and then fix two a and b, find c

### 873. Length of Longest Fibonacci Subsequence
dp mixed with array tech, fixed i, i+1, and derive i+2

### 153. Find Minimum in Rotated Sorted Array
binary search

### 795. Number of Subarrays with Bounded Maximum
subarrays: for example 1,2,3 is a subarray, then it has [1],[1,2],[2],[2,3],[3],[1,2,3] total 6=1+2+3
using two pointers: 

### 289. Game of Life
state change at the same time: generally needs another copy for changes, but we can use bit in original to do in-place

### 11. Container With Most Water
this is a stack problem.
principle: 
each element must be pushed and poped once
increasing or decreasing order: depending on the question. 
For this question, when a lower bar comes, it shall be considered as the highest bar to contain water if using it as the right bar. So we need keep the stack increasing.

### 560. Subarray Sum Equals K
accumulate sum and find cumsum-k if exist
using hashmap

### 915. Partition Array into Disjoint Intervals
two parts, so that all elements in left < all elements in right
left and right problem: two directions to get the max

### 945. Minimum Increment to Make Array Unique
sort and add, greedy

### 870. Advantage Shuffle
Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i].
Return any permutation of A that maximizes its advantage with respect to B.
greedy: if there is higher, use the smallest, if no, use the smallest.
sort it in multiset, if chosen then we remove it

### 162. Find Peak Element
num[i]>nums[i-1] && nums[i]>nums[i+1] naively by adding two padding INT_MIN
linear scan: only need compare nums[i]>nums[i+1] and that is the peak. (since nums[i-1]<nums[i] is the reverse of nums[i]>nums[i+1].)
binary search: we reduce the problem size by finding a mid, and mid+1
linear scan can find all local peaks, binary search can just find one.

### 792. Number of Matching Subsequences
find number of words in dict is subsequence of S
making a hashmap of s (the char vs the list of its index, can also use 26 char vector). Then greedy choose the first matching one

### 670. Maximum Swap
Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.
greedy: ith digit compare with its behind max. if less, swap

### 80. Remove Duplicates from Sorted Array II
inplace remove duplicates, allowing at most 2 duplicates. sorted.
two pointers: a[i]>a[j-2] then add it in

### 73. Set Matrix Zeroes
Inplace set its row and col to be zero.
just collect all zero's row and columns and set them to be zeros

### 105. Construct Binary Tree from Preorder and Inorder Traversal
in order: left node right
preorder: node left right
so we can get the root from the preorder first, and split the left and right from in-order
and then recursively solve the subproblems.

### 120. Triangle
min path sum, dp as min path sum.

### 106. Construct Binary Tree from Inorder and Postorder Traversal
similar to 105

### 775. Global and Local Inversions
i<j, A[i]>A[j] calls global inversion, j=i+1 is called local inversion
check if local inversion == global inversion. The array is 0-N-1
Apparently we only have local inversion, that means if we compare with 0,1,...N-1 and we only see local inversions.

### 713. Subarray Product Less Than K
similar to sum, if product >k then remove the oldest one.

### 74. Search a 2D Matrix
row sorted. next row > previous row
### 2d search using the property. start from the bottom left

### 228. Summary Ranges
sorted array, summary of ranges, merge into ranges

### 56. Merge Intervals
classical: sort the interval, and iterate and merge always to the back, and update the back

### 825. Friends Of Appropriate Ages

### 209. Minimum Size Subarray Sum
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.
common practice: when sum>=s we keep shrinking the range from the left side

### 63. Unique Paths II-dp
### 34. Find First and Last Position of Element in Sorted Array-equal range
### 33. Search in Rotated Sorted Array-binary search
### 954. Array of Doubled Pairs
if we can arrange it 2*A[i]=A[i+1]
using multiset to store negative and positive separately
### 229. Majority Element II
find all elements appearing >n/3 times
hashmap

### 55. Jump Game
array number is the max steps you can jump, find if we can reach the last.
max steps we can reach at i, and also we must be able to reach i (reach>=i)

### 79. Word Search
dfs at any starting position. we need mark visited position first and then restore

### 31. Next Permutation
the next bigger permutation. from right to left, choose the first smaller one with larger one behind it, swap
### 918. Maximum Sum Circular Subarray
two cases: if the max is inside, and if the min is inside
### 907. Sum of Subarray Minimums
for each element we find a window which A[i] is the min.
















