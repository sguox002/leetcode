Array

## contents:

905	Sort Array By Parity		Easy	
832	Flipping an Image		Easy	
977	Squares of a Sorted Array		Easy	
561	Array Partition I		Easy	
922	Sort Array By Parity II		Easy	
999	Available Captures for Rook		Easy	
509	Fibonacci Number		Easy	
1002 Find Common Characters		Easy	
985	Sum of Even Numbers After Queries		Easy	
867	Transpose Matrix		Easy	
766	Toeplitz Matrix		Easy	
566	Reshape the Matrix		Easy	
243	Shortest Word Distance 	Easy	
888	Fair Candy Swap		Easy	
1013 Partition Array Into Three Parts With Equal Sum		Easy	
896	Monotonic Array		Easy	
485	Max Consecutive Ones		Easy	
283	Move Zeroes		Easy	
448	Find All Numbers Disappeared in an Array		Easy	
169	Majority Element		Easy	
122	Best Time to Buy and Sell Stock II		Easy	
217	Contains Duplicate		Easy	
167	Two Sum II - Input array is sorted		Easy	
697	Degree of an Array		Easy	
717	1-bit and 2-bit Characters		Easy	
661	Image Smoother		Easy	
268	Missing Number		Easy	
830	Positions of Large Groups		Easy	
121	Best Time to Buy and Sell Stock		Easy	
746	Min Cost Climbing Stairs		Easy	
628	Maximum Product of Three Numbers		Easy	
1018 Binary Prefix Divisible By 5		Easy	
118	Pascal's Triangle		Easy	
1010 Pairs of Songs With Total Durations Divisible by 60		Easy	
989	Add to Array-Form of Integer		Easy	
27	Remove Element		Easy	
674	Longest Continuous Increasing Subsequence		Easy	
1	Two Sum		Easy	
53	Maximum Subarray		Easy	
119	Pascal's Triangle II		Easy	
66	Plus One		Easy	
724	Find Pivot Index		Easy	
35	Search Insert Position		Easy	
849	Maximize Distance to Closest Person		Easy	
26	Remove Duplicates from Sorted Array		Easy	
747	Largest Number At Least Twice of Others		Easy	
643	Maximum Average Subarray I		Easy	
624	Maximum Distance in 	Easy	
88	Merge Sorted Array		Easy	
840	Magic Squares In Grid		Easy	
219	Contains Duplicate II		Easy	
941	Valid Mountain Array		Easy	
914	X of a Kind in a Deck of Cards		Easy	
605	Can Place Flowers		Easy	
581	Shortest Unsorted Continuous Subarray		Easy	
189	Rotate Array		Easy	
532	K-diff Pairs in an Array		Easy	
414	Third Maximum Number		Easy	
665	Non-decreasing Array		Easy	

950	Reveal Cards In Increasing Order		Medium	
723	Candy Crush 	Medium	
969	Pancake Sorting		Medium	
280	Wiggle Sort 	Medium	
442	Find All Duplicates in an Array		Medium	
370	Range Addition 	Medium	
531	Lonely Pixel I 	Medium	
695	Max Area of Island		Medium	
1031 Maximum Sum of Two Non-Overlapping Subarrays		Medium	
238	Product of Array Except Self		Medium	
245	Shortest Word Distance III 	Medium	
78	Subsets		Medium	
565	Array Nesting		Medium	
1011 Capacity To Ship Packages Within D Days		Medium	
495	Teemo Attacking		Medium	
835	Image Overlap		Medium	
667	Beautiful Arrangement II		Medium	
769	Max Chunks To Make Sorted		Medium	
216	Combination Sum III		Medium	
1035 Uncrossed Lines		Medium	
714	Best Time to Buy and Sell Stock with Transaction Fee		Medium	
900	RLE Iterator		Medium	
287	Find the Duplicate Number		Medium	
926	Flip String to Monotone Increasing		Medium	
39	Combination Sum		Medium	
48	Rotate Image		Medium	
1014 Best Sightseeing Pair		Medium	
62	Unique Paths		Medium	
729	My Calendar I		Medium	
1007 Minimum Domino Rotations For Equal Row		Medium	
64	Minimum Path Sum		Medium	
59	Spiral Matrix II		Medium	
533	Lonely Pixel II 	Medium	
873	Length of Longest Fibonacci Subsequence		Medium	
718	Maximum Length of Repeated Subarray		Medium	
978	Longest Turbulent Subarray		Medium	
16	3Sum Closest		Medium	
621	Task Scheduler		Medium	
289	Game of Life		Medium	
611	Valid Triangle Number		Medium	
1040 Moving Stones Until Consecutive II		Medium	
259	3Sum Smaller 	Medium	
11	Container With Most Water		Medium	
974	Subarray Sums Divisible by K		Medium	
562	Longest Line of Consecutive One in Matrix 	Medium	
548	Split Array with Equal Sum 	Medium	
795	Number of Subarrays with Bounded Maximum		Medium	
915	Partition Array into Disjoint Intervals		Medium	
153	Find Minimum in Rotated Sorted Array		Medium	
380	Insert Delete GetRandom O(1)		Medium	
945	Minimum Increment to Make Array Unique		Medium	
792	Number of Matching Subsequences		Medium	
870	Advantage Shuffle		Medium	
90	Subsets II		Medium	
560	Subarray Sum Equals K		Medium	
75	Sort Colors		Medium	
40	Combination Sum II		Medium	
162	Find Peak Element		Medium	
962	Maximum Width Ramp		Medium	
105	Construct Binary Tree from Preorder and Inorder Traversal		Medium	
80	Remove Duplicates from Sorted Array II		Medium	
755	Pour Water 	Medium	
73	Set Matrix Zeroes		Medium	
670	Maximum Swap		Medium	
120	Triangle		Medium	
106	Construct Binary Tree from Inorder and Postorder Traversal		Medium	
775	Global and Local Inversions		Medium	
277	Find the Celebrity 	Medium	
713	Subarray Product Less Than K		Medium	
825	Friends Of Appropriate Ages		Medium	
228	Summary Ranges		Medium	
56	Merge Intervals		Medium	
74	Search a 2D Matrix		Medium	
209	Minimum Size Subarray Sum		Medium	
954	Array of Doubled Pairs		Medium	
34	Find First and Last Position of Element in Sorted Array		Medium	
63	Unique Paths II		Medium	
33	Search in Rotated Sorted Array		Medium	
81	Search in Rotated Sorted Array II		Medium	
229	Majority Element II		Medium	
55	Jump Game		Medium	
918	Maximum Sum Circular Subarray		Medium	
79	Word Search		Medium	
18	4Sum		Medium	
31	Next Permutation		Medium	
54	Spiral Matrix		Medium	
152	Maximum Product Subarray		Medium	
457	Circular Array Loop		Medium	
907	Sum of Subarray Minimums		Medium	
15	3Sum		Medium	
163	Missing Ranges 	Medium	


768	Max Chunks To Make Sorted II		Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays		Hard	
42	Trapping Rain Water		Hard	
128	Longest Consecutive Sequence		Hard	
782	Transform to Chessboard		Hard	
154	Find Minimum in Rotated Sorted Array II		Hard	
123	Best Time to Buy and Sell Stock III		Hard	
85	Maximal Rectangle		Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed		Hard	
57	Insert Interval		Hard	
84	Largest Rectangle in Histogram		Hard	
719	Find K-th Smallest Pair Distance		Hard	
41	First Missing Positive		Hard	
891	Sum of Subsequence Widths		Hard	
644	Maximum Average Subarray II 	Hard	
45	Jump Game II		Hard	
4	Median of Two Sorted Arrays		Hard	
126	Word Ladder II		Hard

## Easy

### 905. sort array by parity
first even number followed by odd numbers, any order is fine.
two pointer or other methods

### 832. flipping image
Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.
straightforward using reverse.

### 977. Squares of sorted array
has negatives, using two pointer. O(n)

### 561. Array Partition I: 
pair of 2n numbers and add min and make the sum largest
**greedy**. sort and pair. the sum is the even indexed sum
maximize the sum(min(A[i],B[i])) where A[i]<B[i]
Sa=A[0]+A[1]+....+A[n-1]
Sb=B[0]+B[1]+....+B[n-1]
Sd=Sb-Sa=sum(B[i]-A[i])
total=Sa+Sb=Sa+Sd+Sa=2Sa+Sd=constant
we shall minimize Sd.
sorted array adjacent has the smallest difference.
greedy often needs math derives using differences (that is sorting based)

### 922. Sort Array By Parity II
input is half odd, half even. we need to put even element on even index
two pointer: even and odd.
```cpp
    vector<int> sortArrayByParityII(vector<int>& A) {
        vector<int> ans(A.size());
        int odd=1,even=0;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]%2) {ans[odd]=A[i];odd+=2;}
            else {ans[even]=A[i],even+=2;}
        }
        return ans;
    }
```	

### 999. Available capture for rook
find the 4 directions to capture

### 509. Fibonacci Number
using array instead of recursive. a lot of overlaps

### 1002. Find common characters
find all chars (including duplicates) shown in all strings
using hashmap or 26 char vector to record the counts

### 985. Sum of even numbers after queries
a query with val and index, then we add this val to the element at index
```cpp
    vector<int> sumEvenAfterQueries(vector<int>& A, vector<vector<int>>& queries) {
        int sum=0;
        vector<int> ans(queries.size());
        for(int i=0;i<A.size();i++) if(A[i]%2==0) sum+=A[i];
        for(int i=0;i<queries.size();i++)
        {
            int t=A[queries[i][1]]+queries[i][0];
            int ind=queries[i][1];
            if(t%2==0) //even
            {
                if(A[ind]%2) sum+=t;
                else sum+=queries[i][0];
            }
            else //odd
            {
                if(A[ind]%2==0) sum-=A[ind];
            }
            A[ind]=t;
            ans[i]=sum;
        }
        return ans;
    }
```
	
### 867. Transpose Matrix 
swap A[i,j] with A[j,i]
we can do in-place swap.

### 766	Toeplitz Matrix		Easy	
A[i][j]=A[i-1][j-1]

### 566	Reshape the Matrix		Easy	
matlab reshape, index calculation

### 243	Shortest Word Distance 	Easy	
locked

### 888	Fair Candy Swap		Easy	
exchange one candy so each total is the same
simple math, (asum-bsum)/2
```cpp
    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {
        int ta=accumulate(A.begin(),A.end(),0);
        int tb=accumulate(B.begin(),B.end(),0);
        int diff=(tb-ta)/2;
        set<int> sa(A.begin(),A.end());
        set<int> sb(B.begin(),B.end());
        //need satisify b-a=(tb-ta)/2 or b=(tb-ta)/2+a
        for(auto it=sa.begin();it!=sa.end();it++)
            if(sb.count(*it+diff)) return vector<int>({*it,*it+diff});
    }
```	

### 1013 Partition Array Into Three Parts With Equal Sum		Easy	
target sum is known
no order change.

### 896	Monotonic Array		Easy	
simple

### 485	Max Consecutive Ones		Easy	
array of 0 and 1. get the max length of ones

### 283	Move Zeroes		Easy	
move 0 to the end keeping original order in place
simple two pointers

### 448	Find All Numbers Disappeared in an Array		Easy	***
### 1 to n, n is also the array length. some appear twice, some appear once, find all missing numbers
O(n) time and O(1) space

The idea is very similar to problem 442. Find All Duplicates in an Array: https://leetcode.com/problems/find-all-duplicates-in-an-array/.

First iteration to negate values at position whose equal to values appear in array. Second iteration to collect all position whose value is positive, which are the missing values. Complexity is O(n) Time and O(1) space.
```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int len = nums.size();
        for(int i=0; i<len; i++) {
            int m = abs(nums[i])-1; // index start from 0
            nums[m] = nums[m]>0 ? -nums[m] : nums[m];
        }
        vector<int> res;
        for(int i = 0; i<len; i++) {
            if(nums[i] > 0) res.push_back(i+1);
        }
        return res;
    }
};
```

### 169	Majority Element		Easy	***
>=n/2 times
using hashmap O(n) space O(n) time
voting algorithm:
```cpp
    public int majorityElement(int[] num) {

        int major=num[0], count = 1;
        for(int i=1; i<num.length;i++){
            if(count==0){
                count++;
                major=num[i];
            }else if(major==num[i]){
                count++;
            }else count--;
            
        }
        return major;
    }
```


### 122	Best Time to Buy and Sell Stock II		Easy	
see dp

### 217	Contains Duplicate		Easy	
check if an array has duplicates
hashmap on the fly
or set to remove duplicates

### 167	Two Sum II - Input array is sorted		Easy	
two pointer

### 697	Degree of an Array		Easy	
degree of the array: most frequent element
find the shortest range which has the same degree of the array
store the start and ending index of element in hash table
```cpp
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int,vector<int>> mp;
        for(int i=0;i<nums.size();i++) mp[nums[i]].push_back(i);
        int degree=0;
        for(auto it=mp.begin();it!=mp.end();it++) degree=max(degree,int(it->second.size()));
        int shortest=nums.size();
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            if(it->second.size()==degree)
            {
                shortest=min(shortest,it->second.back()-it->second[0]+1);
            }
        }
        return shortest;
    }
```	

### 717	1-bit and 2-bit Characters		Easy	
one bit char 0
two bit char 10 or 11
iven a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.
last two is 00, then the last char is one bit
last two is 10, then we have 010 and 110. 010: it is two bit char, 110 it depends on 0110 (yes) 01110 (odd number of 1s must be two bit char
so we just count number of continuous 1
```cpp
    public boolean isOneBitCharacter(int[] bits) {
        int ones = 0;
        //Starting from one but last, as last one is always 0.
        for (int i = bits.length - 2; i >= 0 && bits[i] != 0 ; i--) { 
            ones++;
        }
        if (ones % 2 > 0) return false; 
        return true;
    }
```	

### 661	Image Smoother		Easy	
trivial

### 268	Missing Number		Easy	
n is the length of array containing 0 to n, one is missing. find the missing one
use xor

### 830	Positions of Large Groups		Easy	
large group has >=3 consecuative same characters
the question asks for lexico order but is incorrect


### 121	Best Time to Buy and Sell Stock		Easy	
see dp

### 746	Min Cost Climbing Stairs		Easy	
see dp

### 628	Maximum Product of Three Numbers		Easy	
sort and use the 3 min and 3 max

### 1018 Binary Prefix Divisible By 5		Easy	
binary string, prefix if divisible by 5 (MSB to LSB)
ans*2+digit

### 118	Pascal's Triangle		Easy	
generate the first N rows
simple

### 1010 Pairs of Songs With Total Durations Divisible by 60		Easy	
mod
```cpp
    int numPairsDivisibleBy60(vector<int>& time) {
        unordered_map<int,int> mp;
        for(int i=0;i<time.size();i++) {time[i]%=60;mp[time[i]]++;}
        
        int ans=0;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            auto t=*it;
            if(t.first==0) ans+=t.second*(t.second-1)/2;
            else if(t.first==30) ans+=t.second*(t.second-1)/2;
            else if(mp.count(60-t.first)) {ans+=t.second*mp[60-t.first]; mp[60-t.first]=0;}
            //cout<<t.first<<","<<t.second<<": "<<ans<<endl;
        }
        return ans;
    }
```	

### 989	Add to Array-Form of Integer		Easy	
one integer and one array-form integer
convert the integer to string

### 27	Remove Element		Easy	
remove all target value
two pointer

### 674	Longest Continuous Increasing Subsequence		Easy	
this needs subarray instead of sub sequence
two pointer or use counter to record

### 1	Two Sum		Easy	
hashmap

### 53	Maximum Subarray		Easy	***
find the max sum of a subarray. THe array has negatives
```cpp
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int maxsum=INT_MIN;
        int maxelem=*max_element(nums.begin(),nums.end());
        if(maxelem<0) return maxelem;
        int tsum=0;
        for(int i=0;i<nums.size();i++)
        {
            if(tsum<0) tsum=0;
            tsum+=nums[i];
            maxsum=max(maxsum,tsum);
        }
        return maxsum;
    }
```
all negatives
contain positives: if we meet a negative we restart.

### 119	Pascal's Triangle II		Easy	
kth row only and only use k space
i.e we need to reuse the memory (similar to dp)
```cpp
    vector<int> getRow(int rowIndex) {
        vector<int> A(rowIndex+1, 0);
        A[0] = 1;
        for(int i=1; i<rowIndex+1; i++)
            for(int j=i; j>=1; j--)
                A[j] += A[j-1];
        return A;
    }
```	

### 66	Plus One		Easy	
simple

### 724	Find Pivot Index		Easy	
its leftsum ==its right sum
prefix sum+nums[i]=totalsum-prefixsum
simple math

### 35	Search Insert Position		Easy	
binary search

### 849	Maximize Distance to Closest Person		Easy	
two ends are different
```cpp
    int maxDistToClosest(vector<int>& seats) {
        //get the longest zero region
        //both end shall be treat differently
        int n=seats.size(),i=0,j=n-1;
        int lwid=0,rwid=0;
        int ans=0;
        while(seats[i]==0) i++; ans=max(ans,i);
        while(seats[j]==0) j--; ans=max(ans,n-j-1);
        int cnt=0;
        while(i<=j)
        {
            if(seats[i]==0) cnt++;
            else {ans=max(ans,(cnt+1)/2);cnt=0;}
            i++;
        }
        return ans;
    }
```	

### 26	Remove Duplicates from Sorted Array		Easy	
two pointers

### 747	Largest Number At Least Twice of Others		Easy	
find the 2 max
```cpp
    int dominantIndex(vector<int>& nums) {
        int max1=INT_MIN,max2=INT_MIN;
        int ans=-1;
        for(int i=0;i<nums.size();i++)
        {
            int t=nums[i];
            if(t>max1) {max2=max1,max1=t;ans=i;}
            else if(t>max2) max2=t;
        }
        if(max1==INT_MIN) return -1;
        if(max2==INT_MIN) return ans;
        if(max1>=2*max2) return ans;
        return -1;
    }
```

### 643	Maximum Average Subarray I		Easy	
sliding window with K

### 624	Maximum Distance in 	Easy	
locked

### 88	Merge Sorted Array		Easy	
two pointer merge

### 840	Magic Squares In Grid		Easy	
### 3x3 all adds up to 15
check how many such squares 
simple

### 219	Contains Duplicate II		Easy	
nums[i]==nums[j] and j-i<=K
hashtable to store index


### 941	Valid Mountain Array		Easy	
two pointers (climbing mountain and meet at the peak)

### 914	X of a Kind in a Deck of Cards		Easy	
gcd and hashmap

### 605	Can Place Flowers		Easy	***
Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.
```cpp
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        //assuming both ends are empty
        int m=flowerbed.size();
        flowerbed.push_back(0);
        flowerbed.insert(flowerbed.begin(),0);
        //a zero region of lenght l can support (l-1)/2 flowers
        int cnt=0;
        for(int i=0;i<flowerbed.size();i++)
        {
            if(flowerbed[i]==0) cnt++;
            else {n-=(cnt-1)/2;cnt=0;}
            if(n<=0) break;
        }
        if(cnt) n-=(cnt-1)/2;
        return n<=0;
        
    }
```
add an empty spot at the two ends.	

### 581	Shortest Unsorted Continuous Subarray		Easy	
compare with sorted O(nlogn)
two pointer: for example [2, 6, 4, 8, 10, 9, 15]
from left we found 6 is not sorted
from right we found 9 is not sorted


### 189	Rotate Array		Easy	***
in place.
```cpp
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        k%=n;
        reverse(nums.begin(),nums.begin()+n-k);
        reverse(nums.begin()+n-k,nums.end());
        reverse(nums.begin(),nums.end());
    }
```	

### 532	K-diff Pairs in an Array		Easy	
Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
```cpp
  int findPairs(vector<int>& nums, int k) {
    if (k < 0) return 0;
    unordered_map<int, int> m;
    for (int n : nums) m[n]++;
    int cnt = 0;
    for (auto p : m) {
      if ((!k && p.second > 1)
        || (k && m.count(p.first + k))) ++cnt;
    }
    return cnt;
  }
```  

### 414	Third Maximum Number		Easy	
```cpp
    int thirdMax(vector<int>& nums) {
       long long m1=LLONG_MIN,m2=LLONG_MIN,m3=LLONG_MIN;
        for(int t: nums)
        {
            if(m1<t) {m3=m2;m2=m1;m1=t;}
            else if(t<m1 && m2<t) {m3=m2;m2=t;}
            else if(t<m2 && m3<t) m3=t;
        }
        return m3==LLONG_MIN?m1:m3;
    }
```
	
### 665	Non-decreasing Array		Easy	***
Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.
greedy:  if we find an inversion, we need make the current one as small as possible. either change current or previous.
```cpp
    bool checkPossibility(vector<int>& nums) {
        int cnt=0;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]<nums[i-1])
            {
                cnt++;
                if(i>=2 && nums[i]<nums[i-2]) nums[i]=nums[i-1];
                else nums[i-1]=nums[i];
            }
        }
        return cnt<=1;
    }
```	

## Medium
### 950. Reveal Cards In Increasing Order
reverse build the cards
the final target is the sorted array. so we first sort the input. and then we reverse the steps to get the initial array
```cpp
    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        //smallest always on top
        sort(deck.begin(),deck.end(),greater<int>());
        deque<int> dq;
        //reverse build the array, put back the cards sequentially
        //before add the card, we need bring the back to the front
        for(int i=0;i<deck.size();i++)
        {
            if(dq.size()>=2) 
            {
                dq.push_front(dq.back());
                dq.pop_back();
            }
            dq.push_front(deck[i]);
        }
        return vector<int>(dq.begin(),dq.end());
    }
```	
### 969. Pancake Sorting
Given an array A, we can perform a pancake flip: We choose some positive integer k <= A.length, then reverse the order of the first k elements of A.  We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.

Return the k-values corresponding to a sequence of pancake flips that sort A.  Any valid answer that sorts the array within 10 * A.length flips will be judged as correct.

input array is permuation of 1 to n
greedy: always move the biggest to the first and move to its sorted position do not need to consider the special case when it is already in the first position reverse to find the largest: the input is 1 to n, using this fact to make it more easier.

```cpp
    vector<int> pancakeSort(vector<int> A) {
        vector<int> res;
        int x,i;
        for (x = A.size(); x > 0; --x) { //the current max
            for (i = 0; A[i] != x; ++i);
            reverse(A.begin(), A.begin() + i + 1);
            res.push_back(i + 1);//number of operations
            reverse(A.begin(), A.begin() + x); //move max to its sorted position
            res.push_back(x);
        }
        return res;
    }
```

### 442. Find All Duplicates in an Array
mark the number seen as negative, then those not marked is duplicates (will marked twice)
```cpp
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        
        for (int n: nums) 
        {
            int pos = abs(n);
            if(nums[pos - 1] > 0) nums[pos - 1] *= -1;
            else res.push_back(pos);
        }
        
        return res;
    }
```
see 	448	Find All Numbers Disappeared in an Array


### 695. Max Area of Island
dfs or bfs from any nodes
dfs: remember to mark it visited.

### 1031. Maximum Sum of Two Non-Overlapping Subarrays
this is a simple version of three non-overlapping subarrays
sliding window.

```cpp
    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {
        return max(helper(A,L,M),helper(A,M,L));
    }
    int helper(vector<int>& A,int L,int M) //left and right fixed
    {
        int n=A.size();
        vector<int> lmax(n-M);
        int tsum=0;
        int leftmax=0;
        for(int i=0;i<L;i++) tsum+=A[i];
        lmax[L-1]=leftmax=tsum;
        for(int i=L;i<n-M;i++) 
        {
            tsum+=A[i]-A[i-L];
            lmax[i]=leftmax=max(leftmax,tsum);
        }

        int rmax=0;
        for(int i=n-1;i>=n-M;i--) rmax+=A[i];
        tsum=rmax;
        int gsum=rmax+lmax[n-M-1];
        for(int i=n-M-1;i>=L;i--)
        {
            tsum+=A[i]-A[i+M];
            rmax=max(rmax,tsum);
            gsum=max(gsum,rmax+lmax[i-1]);
        }

        return gsum;
    }
```	
to avoid complicated index, we can waste a bit memory

### 238. Product of Array Except Self
left product and right product, two direction methodology
```cpp
    vector<int> productExceptSelf(vector<int>& nums) {
        //left and right product and then times left and right
        int len=nums.size();
        long long left=1,right=1;
        vector<int> res(len,1);
        for(int i=1;i<len;i++)
        {
            left*=nums[i-1];
            res[i]*=left;
        }
        for(int i=len-2;i>=0;i--)
        {
            right*=nums[i+1];
            res[i]*=right;
        }
        return res;
    }
```
### 78. Subsets
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

```cpp
    vector<vector<int>> subsets(vector<int>& nums) {
        //approach: each element has an option to be in or not in
        //brute force, loop over, very hard to make it work
        //it is similar to a nbit number and its value are from 0-2^n-1
        //there shall be a restrict on the length of the nums, otherwise it cannot fit in an integer
        int n=nums.size();
        int num=1<<n; //total 2
        vector<vector<int>> res;
        res.push_back(vector<int>());
        vector<int> vt; //length is known!
        for(int i=1;i<num;i++) //0 to 2^n-1
        {
            bitset<32> mybit(i);
            vt.clear();
            for(int j=0;j<n;j++) //exactly n bits
            {
                if(mybit[j]) vt.push_back(nums[j]);
            }
            res.push_back(vt);
        }
        
        return res;
    }
```
	
### 565. Array Nesting	
A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.

Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]â€¦ By that analogy, we stop adding right before a duplicate element occurs in S.

use visited array, since every nested array will form a cycle. if a node is visited, it is not needed

```cpp
    int arrayNesting(vector<int>& nums) {
        //strategy: visited, it will form multiple circles and we keep the circle length
        int maxlen=0;
        int cycle_len=0;
        vector<bool> visited(nums.size());
        for(int i=0;i<nums.size();i++)
        {
            if(!visited[i]) //start a new cycle
            {
                cycle_len=1;
                int ind=nums[i];
                visited[i]=1;
                
                while(!visited[ind]) {visited[ind]=1;ind=nums[ind];cycle_len++;}
            }
            if(cycle_len>maxlen) maxlen=cycle_len;
        }
        return maxlen;
    }
```
cyclic linking 

### 1011. Capacity to ship packages within D days
see binary search
	
### 495. Teemo Attacking
In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.

You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.

need subtract those overlaps

```cpp
    int findPoisonedDuration(vector<int>& timeSeries, int duration) {
        //timeseries point is the left side point, duration is the length of the line segment
        //the problem needs to accumulate the line. timeseries is sorted
        //brutal force solution
        int tp=0;
        int tend=0;
        for(int i=0;i<timeSeries.size();i++)
        {
            tp+=duration-(timeSeries[i]<tend)*(tend-timeSeries[i]);
            tend=timeSeries[i]+duration;
        }
        return tp;
    }
```	

### 835. Image overlap
```cpp
    int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {
        int n=A.size();
        int max_overlap=0;
        for(int i=-n+1;i<n;i++) //sliding is 2n
        {
            for(int j=-n+1;j<n;j++)
            {
                max_overlap=max(max_overlap,overlap(A,B,i,j));
            }
        }
        return max_overlap;
    }
    int overlap(vector<vector<int>>& A, vector<vector<int>>& B,int x,int y)
    {
        //the other top left coordinate is (x,y)
        //need find the overlap of the two image, 
        int xl,xr,yt,yb;
        int n=A.size();
        xl=max(x,0);
        xr=min(x+n-1,n-1);
        yt=max(y,0);
        yb=min(y+n-1,n-1);

        int res=0;
        for(int i=xl;i<=xr;i++)
        {
            for(int j=yt;j<=yb;j++) res+=A[i][j]*B[i-x][j-y];
        }
        return res;
    }
```
	
### 667. Beautiful Arrangement II
Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: 
Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.

1,k+1,2,k,3,k-1,4,k-2....
```cpp
    vector<int> constructArray(int n, int k) {
        vector<int> vs(n);
        //for(int i=0;i<n;i++) vs[i]=i+1;
        //1,k+1,2,k,3,k-1,4,k-2.....but do not use duplicates
        //the distance is k,k-1......1
        //until they meet 
        int l=1,r=k+1;
        int cnt=0;
        while(l<=r) //when l+1==r r cannot be added
        {
            vs[cnt++]=l++;
            if(r>=l) vs[cnt++]=r--;//when r==l+1, the difference is 1
        }
        //we already used 1...k+1, the remaining difference is 1!
        for(int i=cnt;i<n;i++) vs[i]=i+1;
        return vs;
    }
```
	

### 769. Max Chunks To Make Sorted
split and sort, then connect and the whole array is sorted, return the max chunks
compare with the sorted array. If the two has same hash, then it is a segment
O(nlogn)
```cpp
    int maxChunksToSorted(vector<int>& arr) {
        //a segment shall be smaller than all its elements behind.
        vector<int> va=arr;
        sort(va.begin(),va.end());
        //compare the two array. if the element is the same then it is a segment
        int nseg=0;
        unordered_set<int> ms0,ms1;
        for(int i=0;i<arr.size();i++)
        {
            ms0.insert(arr[i]);ms1.insert(va[i]);
            if(ms0==ms1) {nseg++;ms0.clear();ms1.clear();}
        }
        return nseg;
    }
```	
O(n) similar to 763 Partitional labels
```cpp
int maxChunksToSorted(vector<int>& arr) {
    for (auto i = 0, max_i = 0, ch = 0; i <= arr.size(); ++i) {
      if (i == arr.size()) return ch;
      max_i = max(max_i, arr[i]);
      if (max_i == i) ++ch;
    }
}
```

### 216. Combination Sum III
1-9, k numbers combination sum to n
dfs with backtrace. don't forget to pop out the solved node
```cpp
vector<vector<int>> combinationSum3(int k, int n)
{
    vector<vector<int>> result;
    vector<int> path;
    backtrack(result, path, 1, k, n);//start from root 1, k is number of nodes, n is the target
    return result;
}

void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target)
{
    if(target==0 && k==0) //we reach a good solution
    {
        result.push_back(path);
        return;
    }
    for(int i=start; i<=10-k && i<=target; i++)
    {
        path.push_back(i);
        backtrack(result,path,i+1,k-1,target-i);//reduce a smaller problem k-1
        path.pop_back(); //after trial, go back to another
    }
}
```

### 1035. Uncrossed Lines
see dp for longest common subsequence or edit distance

### 714. Best Time to Buy and Sell Stock with Transaction Fee
see dp

### 900. RLE Iterator
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.

The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead.

For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".

count of numbers, number...
use a pointer to record the current head

```cpp
    vector<long long> v1;
    vector<int> vnum;
    long long cur;
    RLEIterator(vector<int> A) {
        cur=0;
        for(int i=0;i<A.size();i++)
        {
            if(i%2) vnum.push_back(A[i]); //the number
            else v1.push_back(A[i]+(i==0?0:v1.back())); //repeat times
        }
    }
    
    int next(int n) {
        cur+=n;
        //binary search to find the position
        auto it=lower_bound(v1.begin(),v1.end(),cur); //<=
        if(it==v1.end()) return -1;
        int ind=it-v1.begin();
        return vnum[ind];
    }
```
A is the input with even indexed element as count, followed by the number
we store the numbers in vnum and its counters in v. so v1 and vnum corresponds one to one.
to use binary search, we accumulate the index.

### 287. Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
again this is a cyclic problem
treat it as a linked list
```cpp
    int findDuplicate(vector<int>& nums) {
/*if it is a linked-list, this is easier to understand. Actually the following method treats the array a hidden linked list. The element itself serves as the next pointer.
first, the slow one step, the fast two step. The two will meet somewhere in the circle. Then one starts from the first point, the other starts from the meet point. 
Assume the slow runs x, and fast runs 2x, the difference is n cycle. 2x-x=nc. slow must be in the circle so x>k. its distance to A point is (nc-k)%c, which needs k steps.
*/
		int slow=0,fast=0,finder=0;
		while(1)
		{
			slow=nums[slow];
			fast=nums[nums[fast]];
			if(slow==fast) break;
		}
		while(1)
		{
			slow=nums[slow];
			finder=nums[finder];
			if(slow==finder) return slow;
		}
   }
```	


### 926. Flip String to Monotone Increasing
A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)

We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.

Return the minimum number of flips to make S monotone increasing.

min number of flips
if choose i as the mid point, we need flip all 1 in front, and all zeros behind
so left to right scan to get number of 1s
right to left scan to get number of 0s
```cpp
    int minFlipsMonoIncr(string S) {
        //need to flip to get two substring, left is all 0 right all 1
        int n=S.size();
        vector<int> left1(n+1);
        for(int i=0;i<S.size();i++) 
        {
            left1[i+1]=left1[i]+(S[i]=='1');
        }
            
        int minflip=n;
        int right0=0;
        for(int i=S.size()-1;i>=0;i--)
        {
            right0+=(S[i]=='0');
            minflip=min(minflip,right0+left1[i+1]-1);
            //cout<<i<<" "<<right0[i]<<" "<<left1[i+1]<<endl;
        }
        return minflip;
    }
```
	
### 48. Rotate Image
rotate clockwise 90 degrees
AB    DA
DC    CB
one way:
swap A with C and we get:
CB
DA
then reverse vertically.

another way:
swap B with D and we get:
AD
BC
then reverse horizontally

2nd approach is easier.
```cpp
    void rotate(vector<vector<int>>& matrix) { //matrix transpose, row->column, col->row
        for(int i=0;i<matrix.size();i++)
        {
            for(int j=i+1;j<matrix[i].size();j++)
            {
                swap(matrix[i][j],matrix[j][i]);
            }
            reverse(matrix[i].begin(),matrix[i].end());
        }
    }
```

### 1014. Best Sightseeing Pair
Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.

The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

maximize A[i]+i and A[j]-j with i<j. left and right two directions.

```cpp
    int maxScoreSightseeingPair(vector<int>& A) {
        vector<int> lmax(A.size(),INT_MIN);
        lmax[0]=A[0];
        int n=A.size();
       for(int i=1;i<A.size();i++) 
           lmax[i]=max(A[i]+i,lmax[i-1]);
        int ans=lmax[n-2]+A[n-1]-n+1;
        A[n-1]-=n-1;
        for(int i=A.size()-2;i>0;i--)
        {
            A[i]=max(A[i]-i,A[i+1]);
            ans=max(lmax[i-1]+A[i],ans);
        }
        return ans;
    }
```	

### 1007 min domino rotations for equal row
either choose A or B
```cpp
int minDominoRotations(vector<int>& A, vector<int>& B) {
  auto top = A[0], bot = B[0], top1 = 0, bot1 = 0, top2 = 0, bot2 = 0;
  for (auto i = 0; i < A.size(); ++i) {
    if (A[i] != top && B[i] != top) top = 0;
    if (A[i] != bot && B[i] != bot) bot = 0;
    top1 += A[i] == top;
    bot1 += B[i] == top;
    top2 += A[i] == bot;
    bot2 += B[i] == bot;
  }
  return top || bot ? min(A.size() - max(top1, bot1), A.size() - max(top2, bot2)) : -1;
}
```

### 729. My Calendar I
double booking
we need a sorted array of intervals and using binary search to find the one to add

### 731. My Calendar II
tripe booking
The key is to use double booking to create overlaps and to see the new added one overlaps with current overlap

### 732. My Calendar III: k booking
if we mark the start a new event, and end minus an event, then accumulate all until the ending is the k event. If we choose the max, we can iterate until the end.
segment tree: build a tree with cnt, start +1, end -1, the same idea
```cpp
class MyCalendarThree {
    map<int, int> timeline;
public:
    int book(int s, int e) {
        timeline[s]++; // 1 new event will be starting at [s]
        timeline[e]--; // 1 new event will be ending at [e];
        int ongoing = 0, k = 0;
        for (pair<int, int> t : timeline)
            k = max(k, ongoing += t.second);
        return k;
    }
};
```
### 62. Unique Paths
dp problem

### 39. Combination Sum
no duplicates, all combinations sum to target, number can be reused
dfs with backtracking
```cpp
    void helper(vector<int>& nums,int target,vector<vector<int>>& res,vector<int> tmp,int pos)
    {
        if(target==0) {res.push_back(tmp);return;}
        if(target<0) {return;}
        //solved solution?
        for(int i=pos;i<nums.size();i++)
        {
            //tmp.clear();
            tmp.push_back(nums[i]);
            helper(nums,target-nums[i],res,tmp,i);//since it allows duplicates, use i here
            tmp.pop_back();
        }
    }
```
### 40. Combination Sum II
each number can only be used once
```cpp
    void helper(vector<int>& nums,int target,vector<vector<int>>& res,vector<int> tmp,int pos)
    {
        if(target==0) {res.push_back(tmp);return;}
        if(target<0) {return;}
        //solved solution?
        for(int i=pos;i<nums.size();i++)
        {
            //tmp.clear();
            if(i && nums[i]==nums[i-1]&&i>pos) continue;
            tmp.push_back(nums[i]);
            helper(nums,target-nums[i],res,tmp,i+1);//since it does not allows duplicates, use i here
            tmp.pop_back();
        }
    }
```
### 216. Combination Sum III
use 1 to 9, and k numbers to sum to n
```cpp
void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target)
{
    if(target==0 && k==0) //we reach a good solution
    {
        result.push_back(path);
        return;
    }
    for(int i=start; i<=10-k && i<=target; i++)
    {
        path.push_back(i);
        backtrack(result,path,i+1,k-1,target-i);//reduce a smaller problem k-1
        path.pop_back(); //after trial, go back to another
    }
}
```
### 377. Combination Sum IV
get the number of combinations. number can be repeated
knapsack with repetition

### 64. Minimum Path Sum
in matrix, dp problem,

### 59. Spiral Matrix II
fill the matrix from 1 to n^2
need to get: how many loops, and each loop how to iterate

### 621. Task Scheduler
given a list of tasks and requirement, return the min number of intervals needed
somewhat similar to the playlist
choose the most frequent char and divide it into k interval with n period
and put other inside, the min time is (k-1)*n
however when n is smaller than the period, we need suppress non-necessary idle

### 718. Maximum Length of Repeated Subarray
straightforward: sliding window to find max overlap
however, dp is the right way to find the largest common substr
```cpp
    int findLength(vector<int>& A, vector<int>& B) {
        //longest common substring
        int m=A.size(),n=B.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1)); 
        //dp[i, j] represents the longest common subarray between A[0..i-1] and B[0...j-1] 
        //boundary: dp[0][0]=0, 0th row and 0th column all zero
        int max0=0;
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(A[i-1]==B[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                //else dp[i][j]=0;
                max0=max(max0,dp[i][j]);
            }
        }
        return max0;
    }
```

### 978. Longest Turbulent Subarray
A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:

For i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even;
OR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.
That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

Return the length of a maximum size turbulent subarray of A.

```cpp
    int maxTurbulenceSize(vector<int>& A) {
        int ans=1;
        int prev=0,curr=0,cnt=0;
        for(int i=1;i<A.size();i++)
        {
            if(A[i]>A[i-1]) curr=1;
            else if(A[i]<A[i-1]) curr=-1;
            else {curr=0;}
            if(prev && prev==-curr) cnt++;
            else {ans=max(ans,cnt+2);cnt=0;}
            prev=curr;
            //cout<<prev<<" "<<cnt<<endl;
        }
        if(cnt) ans=max(ans,cnt+2);
        return ans;
    }
```
just record the flip of signs
	
### 611. Valid Triangle Number
a+b>c
sort first and then fix two a and b, find c

### 873. Length of Longest Fibonacci Subsequence
dp mixed with array tech, fixed i, i+1, and derive i+2

### 153. Find Minimum in Rotated Sorted Array
binary search

### 795. Number of Subarrays with Bounded Maximum
subarrays: for example 1,2,3 is a subarray, then it has [1],[1,2],[2],[2,3],[3],[1,2,3] total 6=1+2+3
using two pointers: 
```cpp
    int numSubarrayBoundedMax(vector<int>& A, int L, int R) {
        int cnt=0,i=0,j=0;
        for (auto n: A){
            i=(n<L) ? i+1 : 0;
            j=(n<=R) ? j+1 : 0;
            cnt+=j-i;
        }
        return cnt;
    }
```	
### 289. Game of Life
state change at the same time: generally needs another copy for changes, but we can use bit in original to do in-place
Any live cell with fewer than two live neighbors dies, as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population..
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

in place: store the status in high byte
```cpp
    void gameOfLife(vector<vector<int>>& board) {
        //use in-place storage, since each int uses 0 or 1 we can add one more bit
        int m=board.size();
        if(!m) return;
        int n=board[0].size();
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                //the boundary cells: assumming outside are all zeros
                int count=0;
                for(int k=max(i-1,0);k<min(i+2,m);k++)
                {
                    for(int l=max(j-1,0);l<min(j+2,n);l++) count+=board[k][l]&1;
                }
                count-=(board[i][j]&1); //excluding itself
                if(count<2) board[i][j]&=1;
                else if(count<=3)
                {
                    if(board[i][j]&1) board[i][j]|=2; //lives on to the next generation
                    if(count==3) board[i][j]|=2;
                }
                else //live becomes dead
                    board[i][j]&=1;
            }
        }
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++) board[i][j]>>=1;
    }
```	

### 1040. Moving Stones Until Consecutive II
sliding window to find min number of vacancies
```cpp
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(),stones.end());
        //the max: keep moving left to right or right to left
        int n=stones.size();
        //leftmost A[0] to A1[1]+1 until to A[n-1]-n+1
        int max0=max(stones[n-1]-n+2-stones[1], stones[n-2]-stones[0]-n+2);
        //sliding window to find the min number of empty positions
        int min0=n,i=0;
        for(int j=0;j<n;j++)
        {
            while(stones[j]-stones[i]>=n) i++;
           if (j - i == n - 2 && stones[j] - stones[i] == n - 2) //continuous
                min0 = min(min0, 2);
            else
                min0 = min(min0, n - (j - i + 1));            
        }
        return {min0,max0};
    }
```
	
### 11. Container With Most Water
this is a two pointer problem.
```cpp
    int maxArea(vector<int>& height) {
        int n=height.size();
        int head=0,tail=n-1;
        int max0=0;
        while(head<tail)
        {
            int area=min(height[head],height[tail])*(tail-head);
            max0=max(area,max0);
            int t0=height[head],t1=height[tail];
            if(t0<t1)
            {
                while(height[head+1]<t0) head++;
                head++;
            }
            else
            {
                while(height[tail-1]<t1) tail--;
                tail--;
            }
        }
        return max0;
    }
```	

### 560. Subarray Sum Equals K
accumulate sum and find cumsum-k if exist
using hashmap

### 974. Subarray Sums Divisible by K
Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.
modal theory: same remainder for the prefix sum.
get the prefix sum and leave the remainder
group same remainder together.

```cpp
    int subarraysDivByK(vector<int>& A, int K) {
        A[0]=(A[0]%K+K)%K;
        for(int i=1;i<A.size();i++) 
        {
            A[i]+=A[i-1];
            A[i]=(A[i]%K+K)%K;
        }
        //copy(A.begin(),A.end(),ostream_iterator<int>(cout," "));
        sort(A.begin(),A.end());
        
        int ans=0,cnt=0;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]==0) ans++;
            if(i && A[i]==A[i-1]) cnt++,ans+=cnt;
            else cnt=0;
        }
        return ans;
    }
```	

### 915. Partition Array into Disjoint Intervals
two parts, so that all elements in left < all elements in right
left and right problem: two directions to get the max

### 153. Find Minimum in Rotated Sorted Array
binary search or brutal force

### 380. Insert Delete GetRandom O(1)
see design
generally for O(1) we need use a O(n) data structure and an O(1) for indexing the data to reach O(1)
```cpp
class RandomizedSet {
    unordered_map<int,int> m; //val with its index so find takes o(1)
    vector<int> nums;
    
public:
    /** Initialize your data structure here. */
    RandomizedSet() {
        
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        if(m.find(val)!=m.end()) return 0;
        nums.push_back(val);
        m[val]=nums.size()-1;
        return 1;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    bool remove(int val) {
        if(m.find(val)==m.end()) return 0;
        int ind=m[val];
        int tmp=nums.back();
        
        //swap the two elements
        if(tmp!=val)
        {
            nums[ind]=tmp;
            m[tmp]=ind;
        }
        nums.pop_back();
        m.erase(val);
        return 1;
    }
    
    /** Get a random element from the set. */
    int getRandom() {
        return nums[rand()%nums.size()];
    }
```	

### 945. Minimum Increment to Make Array Unique
sort and add, greedy
```cpp
    int minIncrementForUnique(vector<int>& A) {
        //sort the array
        sort(A.begin(),A.end());
        int ans=0;
        for(int i=1;i<A.size();i++)
        {
            int t=A[i];
            A[i]=max(A[i],A[i-1]+1);
            ans+=A[i]-t;
        }
        return ans;
    }
```
	
### 870. Advantage Shuffle
Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i].
Return any permutation of A that maximizes its advantage with respect to B.
greedy: if there is higher, use the smallest, if no, use the smallest.
sort it in multiset, if chosen then we remove it
see greedy

### 162. Find Peak Element
num[i]>nums[i-1] && nums[i]>nums[i+1] naively by adding two padding INT_MIN
linear scan: only need compare nums[i]>nums[i+1] and that is the peak. (since nums[i-1]<nums[i] is the reverse of nums[i]>nums[i+1].)
binary search: we reduce the problem size by finding a mid, and mid+1
linear scan can find all local peaks, binary search can just find one.

### 792. Number of Matching Subsequences
find number of words in dict is subsequence of S
making a hashmap of s (the char vs the list of its index, can also use 26 char vector). Then greedy choose the first matching one
```cpp
    int numMatchingSubseq(string S, vector<string>& words) {
        unordered_map<char,vector<int>> mp,tmp;
        for(int i=0;i<S.size();i++) mp[S[i]].push_back(i);
        int num=0;
        for(int i=0;i<words.size();i++)
        {
            bool match=1;
            int prev_ind=-1;
            for(int j=0;j<words[i].size();j++)
            {
                char c=words[i][j];
                if(mp.count(c))
                {
                    auto it=upper_bound(mp[c].begin(),mp[c].end(),prev_ind);
                    if(it==mp[c].end()) {match=0;break;}
                    else prev_ind=*it;//int(it-mp[c].begin());
                    //cout<<words[i]<<":"<<prev_ind<<endl;
                }
                else {match=0;break;}
            }
            if(match) num++;
        }
        return num;
    }
```
many string against one string, then one string shall be preprocessed to expedite.	

### 962. Maximum width ramp

Given an array A of integers, a ramp is a tuple (i, j) for which i < j and A[i] <= A[j].  The width of such a ramp is j - i.

Find the maximum width of a ramp in A.  If one doesn't exist, return 
approach: find the left min, the left min will only become smaller when more elements are added.
we need to find the first min A[i]<=A[j] (there could be a lot of duplicates) reverse and find the upper boundary

```cpp
    int maxWidthRamp(vector<int>& A) {
        //two pointers?
        int n=A.size();
        if(n<2) return 0;
        if(n==2) return A[1]>=A[0];
        vector<int> lmin(A.size());
        lmin[0]=A[0];
        for(int i=1;i<A.size();i++) lmin[i]=min(lmin[i-1],A[i]);
        reverse(lmin.begin(),lmin.end());
        int rmax=A.back();
        int maxdiff=INT_MIN;
        
        for(int i=A.size()-1;i>=0;i--) //when size==2 does not work
        {
            rmax=max(rmax,A[i]);
            int ind=upper_bound(lmin.begin(),lmin.end(),rmax)-lmin.begin();
            ind--;
            if(rmax>=lmin[ind]) maxdiff=max(maxdiff,i-(n-1-ind));
        }
        return maxdiff==INT_MIN?0:maxdiff;
    }
```	

### 105. construct binary tree from preorder and inorder traversal
see tree

### 670. Maximum Swap
Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.
greedy: ith digit compare with its behind max. if less, swap
```cpp
    int maximumSwap(int num) {
        //this is a selection sort
        string s=to_string(num);
        int len=s.size();
        //char maxc=*max_element(s.begin(),s.end());
        int pos;
        int firstpos=INT_MAX;
        for(int i=0;i<s.size();i++)
        {
            int ind=(int)(max_element(s.rbegin(),s.rbegin()+len-1-i)-s.rbegin());//this gives the first max
            ind=len-1-ind;
            if(s[i]<s[ind])
            {
                swap(s[i],s[ind]);
                break;
            }
        }
        //swap the last max with the first non-max
        return stoll(s);
    }
```
	
### 80. Remove Duplicates from Sorted Array II
inplace remove duplicates, allowing at most 2 duplicates. sorted.
two pointers: a[i]>a[j-2] then add it in
```cpp
    int removeDuplicates(vector<int>& nums) {
    //idea just linear scan the whole array
        //note it needs update the array itself!!!
    int i = 0;
    for (int n : nums)
        if (i < 2 || n > nums[i-2])
            nums[i++] = n;
    return i;
}
```
### 73. Set Matrix Zeroes
Inplace set its row and col to be zero.
just collect all zero's row and columns and set them to be zeros

### 105. Construct Binary Tree from Preorder and Inorder Traversal
in order: left node right
preorder: node left right
so we can get the root from the preorder first, and split the left and right from in-order
and then recursively solve the subproblems.

### 120. Triangle
min path sum, dp as min path sum.

### 106. Construct Binary Tree from Inorder and Postorder Traversal
similar to 105

### 775. Global and Local Inversions
i<j, A[i]>A[j] calls global inversion, j=i+1 is called local inversion
check if local inversion == global inversion. The array is 0-N-1
Apparently we only have local inversion, that means if we compare with 0,1,...N-1 and we only see local inversions.
```cpp
    bool isIdealPermutation(vector<int>& A) {
		for (int i = 0; i < A.size(); ++i) {
				if (abs(A[i] - i) > 1) return false;
			}
		return true;
    }
```	
### 713. Subarray Product Less Than K
similar to sum, if product >k then remove the oldest one.
```cpp
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int n=nums.size();
        //cout<<n;
        if(k<=*min_element(nums.begin(),nums.end())) return 0;
        //if(*max_element(nums.begin(),nums.end())<2)
            //return n*(n+1)/2;
        //use two pointers to find the region
        int pi=0,pj=0;
        int ans=0;
        int prod=1;
        while(pi<n)
        {
            for(;pj<n;pj++)
            {
                
                if(prod*nums[pj]>=k) break;
                prod*=nums[pj];
            }
            int m=pj-pi;
            ans+=m;
            //cout<<nums[pi]<<" "<<m<<":"<<ans<<endl;
            prod/=nums[pi];
            if(pi==pj) {pj++;prod=1;}
            pi++;
        }
        return ans;
    }
```
### 825. Friends Of Appropriate Ages
Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. 

Person A will NOT friend request person B (B != A) if any of the following conditions are true:

age[B] <= 0.5 * age[A] + 7
age[B] > age[A]
age[B] > 100 && age[A] < 100
Otherwise, A will friend request B.

Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.

How many total friend requests are made?
	
```cpp
    int numFriendRequests(vector<int>& ages) {
        int va[121]={0};
        for(int i=0;i<ages.size();i++) va[ages[i]]++;
        //larger age friend request smaller age
        //age difference
        //can use binary search
        int total=0;
        for(int i=1;i<=120;i++)
        {
            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition
            if(i>1 && va[i]) //2nd condition, only friend request with smaller age
            {
                int smallest_age=i/2+7+1;//>age C1 condition
                //cout<<smallest_age<<endl;
                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];
            }
        }
        return total;
    }
```	

### 74. Search a 2D Matrix
row sorted. next row > previous row
2d search using the property. start from the bottom left

### 228. Summary Ranges
sorted array, summary of ranges, merge into ranges
arrays -> intervals

```cpp
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> vs;
        string s;
        if(nums.size()==0) return vs;
        long long diff;
        
        s=to_string(nums[0]);
        int cnt=1;
        for(int i=1;i<nums.size();i++)
        {
            diff=(long long)nums[i]-nums[i-1];
            if(diff>1) //the difference may overflow!
            {
                if(cnt>1) {s+="->";s+=to_string(nums[i-1]);}
                vs.push_back(s);
                s=to_string(nums[i]);
                cnt=1; //reset count
            }
            else cnt++;
        }
        //the last one, either is alone, or grouped
        if(cnt>1) {s+="->";s+=to_string(nums[nums.size()-1]);}
        vs.push_back(s);
        return vs;
    }
```	
### 56. Merge Intervals
classical: sort the interval, and iterate and merge always to the back, and update the back

### 209. Minimum Size Subarray Sum
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum â‰¥ s. If there isn't one, return 0 instead.
common practice: when sum>=s we keep shrinking the range from the left side
cumsum and then we use binary search for sum+s. nlogn

```cpp
    int minSubArrayLen(int s, vector<int>& nums) {
        //all positive numbers cumsum will make it sorted
        if(!nums.size()) return 0;
        vector<int> cumsum(nums.size()+1);
        cumsum[0]=0;
        for(int i=1;i<cumsum.size();i++) cumsum[i]=cumsum[i-1]+nums[i-1];
        int minlen=INT_MAX;
        for(int i=1;i<cumsum.size();i++)
        {
            int t=cumsum[i-1]+s;
            auto it=lower_bound(cumsum.begin()+i,cumsum.end(),t);
            if(it!=cumsum.end()) //it founds a valid position
			{
				int len=distance(cumsum.begin()+i,it)+1;
		        if(len<minlen) minlen=len;
			}
        }
        return minlen==INT_MAX?0:minlen;
    }
```	
### 63. Unique Paths II
see dp

### 34. Find First and Last Position of Element in Sorted Array
equal range or binary search

### 33. Search in Rotated Sorted Array
see binary search

### 954. Array of Doubled Pairs
if we can arrange it 2*A[i]=A[i+1]
using multiset to store negative and positive separately
```cpp
    bool canReorderDoubled(vector<int>& A) {
        multiset<int> pos,neg;
        for(int i=0;i<A.size();i++)
        {
            if(A[i]>=0) pos.insert(A[i]);
            else neg.insert(-A[i]);
        }
        if(pos.size()%2 || neg.size()%2) return 0;
        return checkpairs(pos) && checkpairs(neg);
     }
    bool checkpairs(multiset<int> ms)
    {
        auto it=ms.begin();
        while(ms.size())
        {
            it=ms.begin();
            auto it1=ms.upper_bound((*it)*2);
            --it1;
            if(it1!=ms.begin() && *it1==*it*2)
            {
                ms.erase(it1);
                ms.erase(ms.begin());
            }
            else return 0;
            
        }
        return 1;        
    }
```
	

### 229. Majority Element II
find all elements appearing >n/3 times
hashmap
voting method O(n) two pass, second pass to verify the candidate.
```cpp
  vector<int> majorityElement(vector<int> &a) {
    int y = 0, z = 1, cy = 0, cz = 0;
    for (auto x: a) {
      if (x == y) cy++;
      else if (x == z) cz++;
      else if (! cy) y = x, cy = 1;
      else if (! cz) z = x, cz = 1;
      else cy--, cz--;
    }
    cy = cz = 0;
    for (auto x: a)
      if (x == y) cy++;
      else if (x == z) cz++;
    vector<int> r;
    if (cy > a.size()/3) r.push_back(y);
    if (cz > a.size()/3) r.push_back(z);
    return r;
  }
```  

### 55. Jump Game
array number is the max steps you can jump, find if we can reach the last.
max steps we can reach at i, and also we must be able to reach i (reach>=i)
use bfs like approach to check the farthest.
see bfs/dfs

### 79. Word Search
dfs at any starting position. we need mark visited position first and then restore
see dfs

### 31. Next Permutation
the next bigger permutation. from right to left, choose the first smaller one with larger one behind it, swap
this is more like a greedy or math problem but can extend to string.
```cpp
    void nextPermutation(vector<int>& nums) {
        if(nums.size()<2) return;
        int i=nums.size()-1;
        while(i)
        {
            if(nums[i]>nums[i-1]) break;
            i--;
        }
        if(!i) {reverse(nums.begin(),nums.end());return;}
        //swap i-1 with the smallest >num[i-1]
        int j=nums.size()-1;
        while(nums[j]<=nums[i-1]) j--;
        swap(nums[i-1],nums[j]);
        reverse(nums.begin()+i,nums.end());
    }
```

### 918. Maximum Sum Circular Subarray
two cases: if the max is inside, and if the min is inside
so we do not need to wrap around or extend the buffer (flatten)
```cpp
    int maxSubarraySumCircular(vector<int>& A) {
        if (A.empty()) return 0;

        int n = A.size();
        int tot = 0, ma = A[0], last_ma = 0, mi = A[0], last_mi = 0;
        for (int i = 0; i < n; i++) {
            tot += A[i];
            ma = max(ma, last_ma = A[i] + max(0, last_ma));
            mi = min(mi, last_mi = A[i] + min(0, last_mi));
        }
        return ma < 0 ? ma : max(ma, tot - mi);
    }
```

### 15. 3 sum
sort and fix one index and apply two pointers

```cpp
    vector<vector<int> > threeSum(vector<int> &num) {
        vector<vector<int> > ans;
        int i, j, k, n = num.size();
        sort(num.begin(), num.begin() + n);
        for (i = 0; i < n; i++){
            if (i > 0 && num[i] == num[i - 1]) continue;
            k = n - 1;
            j = i + 1;
            while (j < k){
                if (num[i] + num[j] + num[k] > 0) k--;
                else if (num[i] + num[j] + num[k] < 0) j++;
                else{
                    vector<int> tmp;
                    tmp.push_back(num[i]);
                    tmp.push_back(num[j]);
                    tmp.push_back(num[k]);
                    ans.push_back(tmp);
                    while (j < k && num[k] == num[k - 1]) k--;
                    while (j < k && num[j] == num[j + 1]) j++;
                    k--; j++;
                }
            }
        }
        return ans;
    }
```	
### 18. 4 sum
fix two and the most inner side using two pointers

### 54. Spiral Matrix
visit the matrix in spiral order
use left, right, top down 4 variables to record the boundaries

152. Maximum Product Subarray
when a negative is multiplied, max becomes min, min becomes max
```cpp
    int maxProduct(vector<int>& nums) {
        int minp=nums[0],maxp=nums[0];
        int gmax=maxp;
        for(int i=1;i<nums.size();i++)
        {
            int n=nums[i];
            if(n<0) swap(minp,maxp);
            minp=min(n,n*minp);
            maxp=max(n,n*maxp);
            gmax=max(gmax,maxp);
        }
        return gmax;
    }
```

### 457. Circular Array Loop	
You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element.

Determine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle's length > 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.

use slow and fast pointer treating it as a linked list.
if loop not found we set the elements on the path as 0.
```cpp
    bool circularArrayLoop(vector<int>& nums) {
        bool loop = false;
        for (int i = 0; i < nums.size() && !loop; i++)
            if (nums[i]) {
                int j1 = i, j2 = i, dir = nums[i];
                do {
                    j1 = advanceBy(1, j1, nums, dir);
                    j2 = advanceBy(2, j2, nums, dir);
                } while (j1 >= 0 && j2 >= 0 && j1 != j2);
                
                if (j1 >= 0 && j2 >= 0 && j1 == j2) {
                    if (j1 == advanceBy(1, j1, nums, dir)) //single element cycle
                        nums[j1] = 0;
                    else
                        loop = true;
                }
                
                nums[i] = 0; //mark the element not in a cycle.
            }
        return loop;
    }
    
    int advanceBy(int step, int j, vector<int>& nums, int dir) {
        int n = nums.size();
        for (; step > 0; step--) {
            j = (j + nums[j] + n) % n;
            if (nums[j] * dir <= 0)
                return -1;
        }
        return j;
    }
```	
### 907. Sum of Subarray Minimums
Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.

Since the answer may be large, return the answer modulo 10^9 + 7.

for each element we find a window which A[i] is the min.

```cpp
    int sumSubarrayMins(vector<int>& A) {
        int mod=1e9+7;
        //each element can appear many times
        //for element i, we have a window size which A[i] is the minimum
        vector<int> win(A.size());
        int ans=0;
        for(int i=0;i<A.size();i++)
        {
            int l=i,r=i;
            while(A[r+1]>A[i] && r<A.size()-1) r++;
            while(l>0 && A[l-1]>=A[i]) l--;
            ans+=((((r-i+1)*(i-l+1))%mod)*A[i])%mod;
            ans%=mod;
        }
        return ans;
    }
```	


## hard

### 768	Max Chunks To Make Sorted II		Hard
sort and compare. return the max chunks.
```cpp
    int maxChunksToSorted(vector<int>& arr) {
        //a segment shall be smaller than all its elements behind.
        vector<int> va=arr;
        sort(va.begin(),va.end());
        //compare the two array. if the element is the same then it is a segment
        int nseg=0;
        multiset<int> ms0,ms1;
        for(int i=0;i<arr.size();i++)
        {
            ms0.insert(arr[i]);ms1.insert(va[i]);
            if(ms0==ms1) {nseg++;ms0.clear();ms1.clear();}
        }
        return nseg;
    }
```	

### 689	Maximum Sum of 3 Non-Overlapping Subarrays		Hard	
left max and right max, subarray size is K.
sliding window to get the window sum.
get the smallest window start index.

```cpp
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        //get the partial sum first
        int n=nums.size();
        vector<int> psum(n-k+1);
        psum[0]=accumulate(nums.begin(),nums.begin()+k,0);
        for(int i=1;i<n-k+1;i++) psum[i]=psum[i-1]+nums[i+k-1]-nums[i-1];
        
        vector<int> leftmax(n-k+1),rightmax(n-k+1);
        int tmax=INT_MIN;
        for(int i=0;i<n-k+1;i++) tmax=leftmax[i]=max(tmax,psum[i]);
        tmax=INT_MIN;
        for(int i=n-k;i>=0;i--) tmax=rightmax[i]=max(tmax,psum[i]);
       
        int globalmax=INT_MIN;
        int mid=0,left=0,right=0;
        for(int i=k;i<psum.size()-k;i++) //mid can from k to n-k
        {
            int l=i-k,r=i+k; 
            int localmax=leftmax[i-k]+psum[i]+rightmax[i+k];
            if(globalmax<localmax) //use < so equal max will not be counted in
            {
                globalmax=localmax;
                mid=i;left=i-k;right=i+k;
            }
        }

        for(int i=left-1;i>=0;i--) if(leftmax[i]==leftmax[left]) left--;else break;
        for(int i=right+1;i<n-k+1;i++) if(rightmax[i]==rightmax[right]) right++;else break;
        return vector<int>({left,mid,right});
    }
```	

### 42	Trapping Rain Water		Hard	
typical stack problem
stack decreasing order. when there is one larger, we can always form a container using current, stack top and the one before the top.
```cpp
    int trap(vector<int>& height) {
        //using stack similar to largest rectangle in histogram
        //we maintain a stack with index, in decreasing order of height
        int n=height.size();
        stack<int> s;
        int i=0,total=0;

        while(i<n)
        {
            if(s.empty() || height[i]<=height[s.top()]) s.push(i++);
            else
            {
                int tp=s.top();s.pop();
                //min(h(l),h(r))-h(i). If there is no element in stack, the area is 0
                if(!s.empty())
                {
                    int area=(min(height[i],height[s.top()])-height[tp])*(i-s.top()-1);//current one as the minimum
                    total+=area;
                }
            }
        }
        return total;
    }
```	
### 128	Longest Consecutive Sequence		Hard	
input unsorted. O(n) complexity
O(nlogn) approach:
```cpp
    int longestConsecutive(vector<int>& nums) {
        if(!nums.size()) return 0;
        sort(nums.begin(),nums.end());//if it has duplicates this would be messed up!
        nums.erase(unique(nums.begin(),nums.end()),nums.end());
        int maxlen=1;
        //check the jump non-1 to 1 start, from 1 to non-1 is end
        //scan the whole sequence
        int ind0=0,ind1=0;
        
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]==nums[i-1]+1)
                ind1=i;
            else
            {
                if(ind1) maxlen=max(maxlen,ind1-ind0+1);
                ind0=i;
            }
        }
        if(ind1) maxlen=max(maxlen,ind1-ind0+1);
        return maxlen;
    }
```	
O(n) using hashmap to expand two ends.
```cpp
    int longestConsecutive(vector<int> &num) {
        unordered_set<int> record(num.begin(),num.end());
        int res = 1;
        for(int n : num){
            if(record.find(n)==record.end()) continue;
            record.erase(n);
            int prev = n-1,next = n+1;
            while(record.find(prev)!=record.end()) record.erase(prev--);
            while(record.find(next)!=record.end()) record.erase(next++);
            res = max(res,next-prev-1);
        }
        return res;
    }
```	
### 782	Transform to Chessboard		Hard	
01 matrix convert to chessboard
Two conditions to help solve this problem:

In a valid chess board, there are 2 and only 2 kinds of rows and one is inverse to the other.
For example if there is a row 01010011 in the board, any other row must be either 01010011 or 10101100.
The same for columns
A corollary is that, any rectangle inside the board with corners top left, top right, bottom left, bottom right must be 4 zeros or 2 ones 2 zeros or 4 zeros.

Another important property is that every row and column has half ones. Assume the board is N * N:
If N = 2*K, every row and every column has K ones and K zeros.
If N = 2*K + 1, every row and every column has K ones and K + 1 zeros or K + 1 ones and K zeros.

```cpp
    int movesToChessboard(vector<vector<int>>& board) {
        //check all rows against row 0, check all columns against col 0
        //save them in a vector in 1 0 format, 1: the same, 0: reverse, other invalid
        int n=board.size();
        vector<int> row(n,1),col(n,1);
        for(int i=1;i<n;i++)
        {
            int t=0;
            for(int j=0;j<n;j++) t+=board[i][j]^board[0][j];
            if(t!=n && t!=0) return -1;
            row[i]=(t==0);//==0 means they are the same as row 0
        }

        for(int j=1;j<n;j++)
        {
            int t=0;
            for(int i=0;i<n;i++) t+=board[i][j]^board[i][0];
            if(t!=n && t!=0) return -1;
            col[j]=t==0;
        }

        //check minimum swap for row and col to make it in chess order
        int m1=num_swap(row),m2=num_swap(col);
        return m1>=0 && m2>=0?m1+m2:-1;
    }
    int num_swap(vector<int>& row)
    {
        int n=row.size();
        int num1s=accumulate(row.begin(),row.end(),0); //1 and 0 shall same amount or differ by 1
        //n: even, must be the same, odd: differ by 1
        bool keep_1st=1;
        int ns=0;
        if(n%2==0) //for even, 1 or 0 can be both first
        {
            if(num1s*2!=n) return -1;
            int ns1=0;
            for(int i=0;i<n;i+=2) 
            {
                ns+=row[i]; //if the element is not 1, then need switch, they coul
                ns1+=!row[i];
            }
            ns=min(ns,ns1);
        }
        else
        {
            if(abs(num1s*2-n)!=1) return -1;
            if(num1s*2<n) keep_1st=0;//first row must be switched

            for(int i=0;i<n;i+=2) 
            {
                ns+=row[i]!=keep_1st; //if the element is not 1, then need switch, they coul
            }
        }
        return ns;
    }
```	

### 154	Find Minimum in Rotated Sorted Array II		Hard	
contain duplicates, see binary search

### 123	Best Time to Buy and Sell Stock III		Hard	
see dp

### 84	Largest Rectangle in Histogram		Hard	
approach 1: use two pointer. the width keeps shrinking and the min height shall be increasing to offset the width
approach 2: stack.
keep the stack in increasing order, when we have a height lower than stack top, then we can use this bar as the lowest bar and
process the area.
stack empty we assume left is -1 is necessary when the last one is not processed.
this we guarantee that the between bars are all taller and so is safe.

```cpp
	int largestRectangleArea(vector<int>& height) {
		int n = height.size(), area = 0, h, l;
		stack<int> indexes;
		for (int i = 0; i <= n; i++) {
			while (i == n || (!indexes.empty() && height[indexes.top()] > height[i])) {
				if (i == n && indexes.empty()) h = 0, i++;
				else h = height[indexes.top()], indexes.pop();			
				l = indexes.empty() ? -1 : indexes.top();
				area = max(area, h * (i - l - 1));
			}
			indexes.push(i);
		}
		return area;
	}
```	

### 85	Maximal Rectangle		Hard	
can use the largest area in histogram

### 381	Insert Delete GetRandom O(1) - Duplicates allowed		Hard	
without duplicates we use hashmap for index and array to achieve O(1)
Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.

```cpp
class RandomizedCollection {
    unordered_map<int,set<int>> m; //record the value with its index
    vector<int> nums; //the array
    
public:
    /** Initialize your data structure here. */
    RandomizedCollection() {
        
    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    bool insert(int val) {
        nums.push_back(val);
        m[val].insert(nums.size()-1);
        return m[val].size()==1;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    bool remove(int val) {
        if(m.find(val)==m.end()) return 0;
        int ind=*(--m[val].end());//m[val].back();
        //swap the value with the end, note also needs to update the index
        int tmp=nums.back();
        if(tmp!=val)
        {
            //nums[nums.size()-1]=nums[ind];//not needed
            //m[tmp].back()=ind;//update the index, it might not be true it is the last element,need sort the index array
            m[tmp].erase(--m[tmp].end());
            m[tmp].insert(ind);//first need remove the old position to modify the value
            nums[ind]=tmp;
        }
        nums.pop_back();
        m[val].erase(--m[val].end());//m[val].pop_back();
        if(m[val].size()==0) m.erase(val);//delete from hashmap when no index
        return 1;
    }
    
    /** Get a random element from the collection. */
    int getRandom() {
        return nums[rand()%nums.size()];
    }
};
```
set of index

### 57	Insert Interval		Hard	
non overlapped intervals.

### 719	Find K-th Smallest Pair Distance		Hard	
Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.
straightforward O(N^2)
```cpp
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int max0=nums.back();//*max_element(nums.begin(),nums.end());
        vector<int> vt(max0+1); //0 to max bins
        for(int i=0;i<nums.size();i++)
        {
            for(int j=i+1;j<nums.size();j++)
                vt[nums[j]-nums[i]]++;
        }
        int cnt=0;
        for(int i=0;i<vt.size();i++)
        {
            cnt+=vt[i];
            if(cnt>=k) return i;
        }
    }
```	
binary search O(nlogn)
```cpp
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), low = 0, high = 1000000;
        while (low < high) {
            int mid = (low + high)/2, cnt = 0;
            for (int i = 0, j = 0; i < n; i++) {
                while (j < n && nums[j]-nums[i] <= mid) j++;
                cnt += j-i-1;
            }
            if (cnt < k) 
                low = mid+1;
            else
                high = mid;
        }
        return low;
    }
```	
### 41	First Missing Positive		Hard	
Given an unsorted integer array, find the smallest missing positive integer.

```cpp
    int firstMissingPositive(vector<int>& nums) {
       //two pass, first time put all the elements in its position
        //1 at 0, 2 at 1. it may over boundary
        if(nums.size()==0) return 1;
        for(int i=0;i<nums.size();i++)
        {
            while(nums[i]>0 && nums[i]!=i+1 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1]) 
                swap(nums[i],nums[nums[i]-1]);
            //what about nums[i]-1>=nums.size()
            //copy(nums.begin(),nums.end(),ostream_iterator<int>(cout," "));cout<<endl;
        }
        
        for(int i=0;i<nums.size();i++)
            if(nums[i]!=i+1) return i+1;
        return nums[nums.size()-1]+1;
    }
```	
### 891	Sum of Subsequence Widths		Hard	
Given an array of integers A, consider all non-empty subsequences of A.

For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A. 

As the answer may be very large, return the answer modulo 10^9 + 7.
he order in initial arrays doesn't matter,
my first intuition is to sort the array.

For A[i]:
There are i smaller numbers,
so there are 2 ^ i sequences in which A[i] is maximum.
we should do res += A[i] * (2 ^ i)

There are n - i - 1 bigger numbers,
so there are 2 ^ (n - i - 1) sequences in which A[i] is minimum.
we should do res -= A[i] * 2 ^ (n - i - 1)

Done.

Time Complexity:
O(NlogN)

C++:
```cpp
    int sumSubseqWidths(vector<int> A) {
        sort(A.begin(), A.end());
        long c = 1, res = 0, mod = 1e9 + 7;
        for (int i = 0; i < A.size(); ++i, c = (c << 1) % mod)
            res = (res + A[i] * c - A[A.size() - i - 1] * c) % mod;
        return (res + mod) % mod;
    }
```	
### 644	Maximum Average Subarray II 	Hard
locked
	
### 45	Jump Game II		Hard	
this time we need to calculate the min number of steps
still use bfs like approach.
```cpp
    int jump(vector<int>& nums) {
    int n=nums.size();
	 if(n<2)return 0;
	 int level=0,currentMax=0,i=0,nextMax=0;

	 while(currentMax-i+1>0)
     {		//nodes count of current level>0
		 level++;
		 for(;i<=currentMax;i++)
         {	//traverse current level , and update the max reach of next level
			nextMax=max(nextMax,nums[i]+i);
			if(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level 
		 }
		 currentMax=nextMax;
	 }
	 return 0;
 }     
``` 
### 4	Median of Two Sorted Arrays		Hard	
binary search
```cpp
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //binary search shall be the best strategy for this problem
        //to find kth number recursively. 
        int m=nums1.size(),n=nums2.size();
        double v=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2);
        double v1;
        if((m+n)%2==0) {v1=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2+1);v=(v+v1)*0.5;}
        return v; 
          
    }
    int findkth(vector<int>& va,vector<int>& vb,int la,int ra,int lb,int rb,int k)
    {
        if(la>ra) return vb[lb+k-1];
        if(lb>rb) return va[la+k-1];
        
        int ma=(la+ra)/2,mb=(lb+rb)/2;
        if(va[ma]<=vb[mb])
        {
            if(k<=(ma-la)+(mb-lb)+1) return findkth(va,vb,la,ra,lb,mb-1,k);
            else return findkth(va,vb,ma+1,ra,lb,rb,k-(ma-la)-1);
        }
        else //va[ma]>vb[mb]
        {
            if(k<=ma-la+mb-lb+1) return findkth(va,vb,la,ma-1,lb,rb,k);
            else return findkth(va,vb,la,ra,mb+1,rb,k-(mb-lb)-1);
        }
    }
```
	
### 126	Word Ladder II		Hard
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.

bfs approach
```cpp
    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
        //very interesting problem
        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!
        //Then the queue becomes a queue of paths.
        vector<vector<string>> ans;
        queue<vector<string>> paths;
        wordList.insert(endWord);
        paths.push({beginWord});
        int level = 1;
        int minLevel = INT_MAX;
        
        //"visited" records all the visited nodes on this level
        //these words will never be visited again after this level 
        //and should be removed from wordList. This is guaranteed
        // by the shortest path.
        unordered_set<string> visited; 
        
        while (!paths.empty()) {
            vector<string> path = paths.front();
            paths.pop();
            if (path.size() > level) {
                //reach a new level
                for (string w : visited) wordList.erase(w);
                visited.clear();
                if (path.size() > minLevel)
                    break;
                else
                    level = path.size();
            }
            string last = path.back();
            //find next words in wordList by changing
            //each element from 'a' to 'z'
            for (int i = 0; i < last.size(); ++i) {
                string news = last;
                for (char c = 'a'; c <= 'z'; ++c) {
                    news[i] = c;
                    if (wordList.find(news) != wordList.end()) {
                    //next word is in wordList
                    //append this word to path
                    //path will be reused in the loop
                    //so copy a new path
                        vector<string> newpath = path;
                        newpath.push_back(news);
                        visited.insert(news);
                        if (news == endWord) {
                            minLevel = level;
                            ans.push_back(newpath);
                        }
                        else
                            paths.push(newpath);
                    }
                }
            }
        }
        return ans;
    }
```
	











