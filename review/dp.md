# Chapter 3. dynamic programming

## contents

1025	Divisor Game		Easy	<br/>
256	Paint House 	Easy	<br/>
121	Best Time to Buy and Sell Stock		Easy	<br/>
746	Min Cost Climbing Stairs		Easy	<br/>
70	Climbing Stairs		Easy	<br/>
53	Maximum Subarray		Easy	<br/>
198	House Robber		Easy	<br/>
303	Range Sum Query - Immutable		Easy	<br/>
276	Paint Fence 	Easy	<br/>
<br/>
338	Counting Bits		Medium	<br/>
750	Number Of Corner Rectangles 	Medium	<br/>
877	Stone Game		Medium	<br/>
931	Minimum Falling Path Sum		Medium	<br/>
983	Minimum Cost For Tickets		Medium	<br/>
647	Palindromic Substrings		Medium	<br/>
413	Arithmetic Slices		Medium	<br/>
712	Minimum ASCII Delete Sum for Two Strings		Medium	<br/>
651	4 Keys Keyboard 	Medium	<br/>
714	Best Time to Buy and Sell Stock with Transaction Fee		Medium	<br/>
646	Maximum Length of Pair Chain		Medium	<br/>
638	Shopping Offers		Medium	<br/>
343	Integer Break		Medium	<br/>
62	Unique Paths		Medium	<br/>
1024 Video Stitching		Medium	<br/>
357	Count Numbers with Unique Digits		Medium	<br/>
64	Minimum Path Sum		Medium	<br/>
486	Predict the Winner		Medium	<br/>
392	Is Subsequence		Medium	<br/>
516	Longest Palindromic Subsequence		Medium	<br/>
650	2 Keys Keyboard		Medium	<br/>
1027 Longest Arithmetic Sequence		Medium	<br/>
96	Unique Binary Search Trees		Medium	<br/>
873	Length of Longest Fibonacci Subsequence		Medium	<br/>
1048 Longest String Chain		Medium	<br/>
718	Maximum Length of Repeated Subarray		Medium	<br/>
740	Delete and Earn		Medium	<br/>
351	Android Unlock Patterns 	Medium	<br/>
978	Longest Turbulent Subarray		Medium	<br/>
494	Target Sum		Medium	<br/>
813	Largest Sum of Averages		Medium	<br/>
688	Knight Probability in Chessboard		Medium	<br/>
309	Best Time to Buy and Sell Stock with Cooldown		Medium	<br/>
377	Combination Sum IV		Medium	<br/>
838	Push Dominoes		Medium	<br/>
361	Bomb Enemy 	Medium	<br/>
764	Largest Plus Sign		Medium	<br/>
698	Partition to K Equal Sum Subsets		Medium	<br/>
279	Perfect Squares		Medium	<br/>
300	Longest Increasing Subsequence		Medium	<br/>
416	Partition Equal Subset Sum		Medium	<br/>
935	Knight Dialer		Medium	<br/>
1039 Minimum Score Triangulation of Polygon		Medium	<br/>
474	Ones and Zeroes		Medium	<br/>
120	Triangle		Medium	<br/>
375	Guess Number Higher or Lower II		Medium	<br/>
376	Wiggle Subsequence		Medium	<br/>
808	Soup Servings		Medium	<br/>
967	Numbers With Same Consecutive Differences		Medium	<br/>
1049 Last Stone Weight II		Medium	<br/>
264	Ugly Number II		Medium	<br/>
95	Unique Binary Search Trees II		Medium	<br/>
790	Domino and Tromino Tiling		Medium	<br/>
139	Word Break		Medium	<br/>
213	House Robber II		Medium	<br/>
368	Largest Divisible Subset		Medium	<br/>
787	Cheapest Flights Within K Stops		Medium	<br/>
801	Minimum Swaps To Make Sequences Increasing		Medium	<br/>
467	Unique Substrings in Wraparound String		Medium	<br/>
898	Bitwise ORs of Subarrays		Medium	<br/>
63	Unique Paths II		Medium	<br/>
673	Number of Longest Increasing Subsequence		Medium	<br/>
221	Maximal Square		Medium	<br/>
304	Range Sum Query 2D - Immutable		Medium	<br/>
576	Out of Boundary Paths		Medium	<br/>
837	New 21 Game		Medium	<br/>
418	Sentence Screen Fitting 	Medium	<br/>
322	Coin Change		Medium	<br/>
152	Maximum Product Subarray		Medium	<br/>
5	Longest Palindromic Substring		Medium	<br/>
464	Can I Win		Medium	<br/>
523	Continuous Subarray Sum		Medium	<br/>
91	Decode Ways		Medium	<br/>
<br/>
982	Triples with Bitwise AND Equal To Zero		Hard	<br/>
960	Delete Columns to Make Sorted III		Hard	<br/>
975	Odd Even Jump		Hard	<br/>
312	Burst Balloons		Hard	<br/>
847	Shortest Path Visiting All Nodes		Hard	<br/>
471	Encode String with Shortest Length 	Hard	<br/>
689	Maximum Sum of 3 Non-Overlapping Subarrays		Hard	<br/>
920	Number of Music Playlists		Hard	<br/>
903	Valid Permutations for DI Sequence		Hard	<br/>
410	Split Array Largest Sum		Hard	<br/>
265	Paint House II 	Hard	<br/>
514	Freedom Trail		Hard	<br/>
964	Least Operators to Express Number		Hard	<br/>
940	Distinct Subsequences II		Hard	<br/>
730	Count Different Palindromic Subsequences		Hard	<br/>
546	Remove Boxes		Hard	<br/>
568	Maximum Vacation Days 	Hard	<br/>
691	Stickers to Spell Word		Hard	<br/>
72	Edit Distance		Hard	<br/>
943	Find the Shortest Superstring		Hard	<br/>
956	Tallest Billboard		Hard	<br/>
727	Minimum Window Subsequence 	Hard	<br/>
517	Super Washing Machines		Hard	<br/>
664	Strange Printer		Hard	<br/>
879	Profitable Schemes		Hard	<br/>
403	Frog Jump		Hard	<br/>
968	Binary Tree Cameras		Hard	<br/>
115	Distinct Subsequences		Hard	<br/>
363	Max Sum of Rectangle No Larger Than K		Hard	<br/>
818	Race Car		Hard	<br/>
472	Concatenated Words		Hard	<br/>
1012 Numbers With Repeated Digits		Hard	<br/>
354	Russian Doll Envelopes		Hard	<br/>
123	Best Time to Buy and Sell Stock III		Hard	<br/>
85	Maximal Rectangle		Hard	<br/>
552	Student Attendance Record II		Hard	<br/>
600	Non-negative Integers without Consecutive Ones		Hard	<br/>
87	Scramble String		Hard	<br/>
1000 Minimum Cost to Merge Stones		Hard	<br/>
446	Arithmetic Slices II - Subsequence		Hard	<br/>
741	Cherry Pickup		Hard	<br/>
629	K Inverse Pairs Array		Hard	<br/>
871	Minimum Number of Refueling Stops		Hard	<br/>
902	Numbers At Most N Given Digit Set		Hard	<br/>
97	Interleaving String		Hard	<br/>
132	Palindrome Partitioning II		Hard	<br/>
466	Count The Repetitions		Hard	<br/>
140	Word Break II		Hard	<br/>
174	Dungeon Game		Hard	<br/>
656	Coin Path 	Hard	<br/>
188	Best Time to Buy and Sell Stock IV		Hard	<br/>
32	Longest Valid Parentheses		Hard	<br/>
321	Create Maximum Number		Hard	<br/>
10	Regular Expression Matching		Hard	<br/>
639	Decode Ways II		Hard	<br/>
887	Super Egg Drop		Hard	<br/>
44	Wildcard Matching		Hard<br/>

## easy

### 1025	Divisor Game		Easy
each take a move N-x, 0<x<N and N%x==0
when N=2, A take 1 and B will not be able to move, A win
when N=3, A take 1 and A lose.

when N is odd, it only has odd factors, we give B an even number, it will eventually reaches 2, A lose
when N is even, A take 1 and B always get odd number, and will eventually get to 3, A win.
	
### 256	Paint House 	Easy	
locked

## stock problem
get the solution based on previous solution and get the recurrence relation
reduce complexity by on-the -fly to update the tempMax
each day we have two options: no transaction and sell it.

### 121	Best Time to Buy and Sell Stock		Easy	
perform at most 1 transaction. <br/>
intuition is straightforward, today sell and buy at previous min<br/>
dp[i] is the max profit selling at ith day: sell at ith day or not doing anything on ith day<br/>
dp[i]=max(dp[i-1],prices[i]-min(price[j]))<br/>
O(n^2) reduced to O(N)
```cpp
    int maxProfit(vector<int>& prices) {
        //dp[i]: is the max profit at ith day
        int n=prices.size();
        if(n<2) return 0;
        
        vector<int> dp(n);
        int tmin=INT_MAX;
        for(int i=1;i<n;i++)
        {
            tmin=min(tmin,prices[i-1]);
            dp[i]=max(dp[i-1],prices[i]-tmin);
        }
        return dp[n-1];
    }
```	
tmin can also set as price[0] and then the two statements in the loop shall be reversed.

### 122	Best Time to Buy and Sell Stock		Easy	
perform as many transactions as possible
the profit shall be accumulated from previous transactions<br/>

profitable transaction is dp[i-1]+max(price[i]-price[i-1],0] <br/>


### 714. Best Time to Buy and Sell Stock with Transaction Fee<br/>
dp[i]=max(dp[i-1],dp[j]+price[i]-price[j]-fee) for j=0 to i-1<br/>
sell or not sell on ith day<br/>
```cpp
    int maxProfit(vector<int>& prices, int fee) {
        //1d DP: dp[i]=max(dp[i-1],dp[j]+price[i]-price[j]-fee) for j=0 to i-1
        //this reduce to max(dp[j]-price[j]-fee)
        int tmax=INT_MIN;
        int n=prices.size();
        vector<int> dp(n);
        for(int i=1;i<prices.size();i++)
        {
            tmax=max(tmax,dp[i-1]-(prices[i-1]+fee));
            dp[i]=max(dp[i-1],prices[i]+tmax);
        }
        return dp[n-1];
    }
```

### 309. Best Time to Buy and Sell Stock with Cooldown<br/>
after sell, you have to rest one day before buy stock<br/>
on ith day:<br/>
if we sell, the profit is dp[j-2]+price[i-2]-price[j-2] (buy at jth day, at least two days before ith day)<br/>
if we not sell, the profit is dp[i-1]<br/>
note: price[i-2] and price[j-2] is the price at ith and jth day (since we add two guarding elements)<br/>
dp[j-2] is the profit before we buy at jth day (sell at two days ago)<br/>

```cpp
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        if(n<2) return 0;
        vector<int> dp(n+2); //dp[i] is the max profit on ith day, adding two guarding
        if(prices[1]>prices[0]) dp[3]=prices[1]-prices[0];
        for(int i=4;i<n+2;i++)
        {
            for(int j=i;j>=2;j--)
            {
                dp[i]=max(dp[i],max(dp[i-1],dp[j-2]+prices[i-2]-prices[j-2]));
            }
        }
        return dp[n+1];
    }
```
no operation dp[i-1]
sell on ith day: dp[j-2]+price[i-2]-price[j-2]. why on jth day buy in, the profit is dp[j-2] (two days ago)
Note the j iteration shall from i. 

### 123. Best Time to Buy and Sell Stock III	
at most two transactions<br/>
a special case for 188.<br/>

```cpp
    int maxProfit(vector<int> &prices) {
        // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. 
        // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) { jj in range of [0, ii-1] }
        //          = max(f[k, ii-1], prices[ii] + max(f[k-1, jj] - prices[jj]))
        // f[0, ii] = 0; 0 times transation makes 0 profit
        // f[k, 0] = 0; if there is only one price data point you can't make any money no matter how many times you can trade
        if (prices.size() <= 1) return 0;
        else {
            int K = 2; // number of max transation allowed
            int maxProf = 0;
            vector<vector<int>> f(K+1, vector<int>(prices.size(), 0));
            for (int kk = 1; kk <= K; kk++) {
                int tmpMax = f[kk-1][0] - prices[0];
                for (int ii = 1; ii < prices.size(); ii++) {
                    f[kk][ii] = max(f[kk][ii-1], prices[ii] + tmpMax);
                    tmpMax = max(tmpMax, f[kk-1][ii] - prices[ii]);
                    maxProf = max(f[kk][ii], maxProf);
                }
            }
            return maxProf;
        }
    }
```

### 188. Best Time to Buy and Sell Stock IV	
k transactions<br/>
how to get the solution from k-1 transactions?<br/>
when multiple transactions are allowed, the profit shall be accumulated, i.e. the current transaction profit + previous transactions profit.<br/>

assuming dp[k, i] is the kth transaction at ith day, then:<br/>

dp[k,i]=max(dp[k, i-1],dp[k-1, j]+price[i]-price[j]) j=0...i-1<br/>
sell on ith day (buy on jth day, j<i): it shall be the sum of previous profit dp[k-1, j] and price[i]-price[j].<br/>

no transaction on ith day, then the profit is dp[k, i-1].<br/>

dp[k][i]=max(dp[k][i-1],dp[k-1][j]+prices[i]-prices[j]) j=0...i-1<br/>
O(KN^2) reduce to O(KN)<br/>

```cpp
    int maxProfit(int k, vector<int>& prices) {
       int n=prices.size();
        if(k>=n/2)
        {
            int sum=0;
            for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) sum+=prices[i]-prices[i-1];
            return sum;
        }
        vector<vector<int>> dp(k+1,vector<int>(n));
        int maxprof=0;
        
        for(int t=1;t<=k;t++)
        {
            int tmin=INT_MAX;
            for(int i=1;i<n;i++)
            {
                tmin=min(tmin,prices[i-1]-dp[t-1][i-1]);
                dp[t][i]=max(dp[t][i-1],prices[i]-tmin);
                maxprof=max(maxprof,dp[t][i]);
            }
        }
        return maxprof;
    }
```
## climbing stairs & house robbers
each step have two options<br/>
each step may have costs<br/>
boundary condition<br/>

### 746	Min Cost Climbing Stairs		Easy	
you start from step 0 or step 1 and make a 1-step or 2-step move. you need pay the cost[i] to be able to move
what is the min cost to reach the top
dp[i]=min(dp[i-1],dp[i-2])+cost[i], dp[i] is the min cost to be able to move at i.
so the final answer is min(dp[n-1],dp[n-2])
```cpp
    int minCostClimbingStairs(vector<int>& cost) {
		int n=cost.size();
        vector<int> dp(n);
        dp[0]=cost[0],dp[1]=cost[1];
        for(int i=2;i<n;i++)
            dp[i]=min(dp[i-1],dp[i-2])+cost[i];
        return min(n-1],dp[n-2]);
    }
```	
The problem is not well stated. It asks to be able to move over the top, so the top level is actually nth (instead of n-1)

### 70	Climbing Stairs		Easy	
n steps. each move 1 or 2 steps. how many distinct ways:<br/>
dp[i]=dp[i-1]+dp[i-2]<br/>
dp[0]=1,dp[1]=2;<br/>
fib-sequences, and we do not need to store all elements. (also, fib-sequence shall do like this)<br/>
```cpp
    int climbStairs(int n) {
        
        int a0=1,a1=2;
        int res;
        if(n==1) return a0;
        if(n==2) return a1;
        for(int i=2;i<n;i++)
        {
            res=a0+a1;
            a0=a1;
            a1=res;
        }
        return res;
    }
```	
though it is simple, but not easy to get to the best.

### 198	House Robber		Easy	
dp[i]=max(dp[i-1],dp[i-2]+prices[i])

### 213. House Robber II<br/>
circular, this is two house robber 1 problem<br/>
```cpp
   int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return 0;
        if(n==1) return nums[0];
        return max(helper(nums,0,n-1),helper(nums,1,n));
    }
    int helper(vector<int>& nums, int l, int r)
    {
        vector<int> dp(r+1);
        //dp[i]=max(dp[i-1],dp[i-2]+a[i])
        //(l==r) return nums[l];
        dp[l]=nums[l],dp[l+1]=max(nums[l+1],nums[l]);
        for(int i=l+2;i<r;i++)
        {
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[r-1];
    }
```

### 740. Delete and Earn
Given an array nums of integers, you can perform operations on the array.

In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.

You start with 0 points. Return the maximum number of points you can earn by applying such operations.

put the numbers in contiguous bins
this is house robber with duplicates (if there are a lot of value=nums[i]). So we use bucket sort (bucket distance is 1)<br/>

```cpp
    int deleteAndEarn(vector<int>& nums) {
        vector<int> a(10001,0);//include 0
        for(int i=0;i<nums.size();i++) a[nums[i]]+=nums[i];
        vector<int> dp(10003);//add two more elements
        for(int i=0;i<=10000;i++)
            dp[i+2]=max(dp[i]+a[i],dp[i+1]);
        return dp[10002];
    }
```


### 62. Unique Paths
dp[i,j]=dp[i-1][j]+dp[i,j-1]
boundary dp[0][1]=1 so we can enter the top left cell
```cpp
    int uniquePaths(int m, int n) {
    //need use dynamic programming p(i,j)=p(i-1,j)+p(i,j-1) if current node is reachable
    //
		vector<vector<int>> dp(m+1,vector<int>(n+1,0)); //all initialized as 0
		dp[0][1]=1; //assuming to the first element is 1
		for(int i=1;i<=m;i++)
		{
			for(int j=1;j<=n;j++)
			{
				dp[i][j]=dp[i-1][j]+dp[i][j-1];
			}
		}
		return dp[m][n];
    }
```	

### 64. Minimum Path Sum	
```cpp
    int minPathSum(vector<vector<int>>& grid) {
        //state equation S(i,j)=min(S(i-1,j),S(i,j-1))+grid(i,j)
        //boundary condition: i=0 case, and j=0 case, toprow and left column
        //either pad the grid or define the  boundary for S
        //top row: to each node is the accumulate previous elememts
        //left col: to each node is the accumulation of previous elements
        int m=grid.size(),n=grid[0].size();
        vector<vector<int>> vs(m,vector<int>(n,0));
        vs[0][0]=grid[0][0];
        for(int i=1;i<m;i++) vs[i][0]=vs[i-1][0]+grid[i][0];
        for(int j=1;j<n;j++) vs[0][j]=vs[0][j-1]+grid[0][j];
        
        for(int i=1;i<m;i++)
        {
            for(int j=1;j<n;j++) 
                vs[i][j]=min(vs[i-1][j],vs[i][j-1])+grid[i][j];
        }
        return vs[m-1][n-1];
    }
```	

### 120. Triangle<br/>
min path sum
```cpp
    int minimumTotal(vector<vector<int>>& triangle) {
        if(!triangle.size()) return 0;
        if(triangle.size()==1) return triangle[0][0];
        int level=triangle.size();
        for(int l=level-2;l>=0;l--)
        {
            for(int j=0;j<=l;j++)
                triangle[l][j]+=min(triangle[l+1][j],triangle[l+1][j+1]);
        }
        return triangle[0][0];
    }
```
	
### 357. Count Numbers with Unique Digits<br/>
dp[i] is the number from 10^(i-1) 10^i<br/>
first digit: 1-9<br/>
second digit: 0-9 but cannot use previous digit, 9<br/>
9*9*8*7.....
```cpp
    int countNumbersWithUniqueDigits(int n) {
      int num=0;
      if(!n) return 1;
      for(int i=1;i<=n;i++) num+=uniqueNumbers(i);
      return num;
    }
    int uniqueNumbers(int n)
    {
        if(n==1) return 10;
        int num=9;
        for(int i=1;i<n;i++) num*=(9-i+1);
        return num;
    }
```
this is more a math problem than a dp problem
	

## subarray partition problem
use some criteria to partition the array into subarrays

### 53	Maximum Subarray		Easy	
get the max sum of the subarray.<br/>
subarray with the max sum.<br/>
when previous sum is negative we shall not attach to previous, and that is the key.<br/>
```cpp
	int maxSubArray(vector<int>& nums)
	{
		int n=nums.size();
		if(n<2) return nums[0];
		int ans=INT_MIN;
		int tsum=0;
		for(int i: nums)
		{
			tsum=(tsum>=0?tsum:0)+i;
			ans=max(ans,max(tsum,i));
		}
		return ans;
	}
```
divide and conquer approach O(nlogn):
Step1. Select the middle element of the array.
So the maximum subarray may contain that middle element or not.

Step 2.1 If the maximum subarray does not contain the middle element, then we can apply the same algorithm to the the subarray to the left of the middle element and the subarray to the right of the middle element.

Step 2.2 If the maximum subarray does contain the middle element, then the result will be simply the maximum suffix subarray of the left subarray plus the maximum prefix subarray of the right subarray

Step 3 return the maximum of those three answer.
```cpp
    int maxSubArray(int A[], int n) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
        if(n==0) return 0;
        return maxSubArrayHelperFunction(A,0,n-1);
    }
    
    int maxSubArrayHelperFunction(int A[], int left, int right) {
        if(right == left) return A[left];
        int middle = (left+right)/2;
        int leftans = maxSubArrayHelperFunction(A, left, middle);
        int rightans = maxSubArrayHelperFunction(A, middle+1, right);
        int leftmax = A[middle];
        int rightmax = A[middle+1];
        int temp = 0;
        for(int i=middle;i>=left;i--) {
            temp += A[i];
            if(temp > leftmax) leftmax = temp;
        }
        temp = 0;
        for(int i=middle+1;i<=right;i++) {
            temp += A[i];
            if(temp > rightmax) rightmax = temp;
        }
        return max(max(leftans, rightans),leftmax+rightmax);
    }
```	

### 413. Arithmetic Slices<br/>
return the number of arithmetic slices in the array A.
dp[i] means the number of arithmetic slices ending with A[i]<br/>
dp[i]=dp[i-1]+1 if it satisfy arithmetic<br/>
answer is the accumulation<br/>
```cpp
    int numberOfArithmeticSlices(vector<int>& A) {
        int n = A.size();
        if (n < 3) return 0;
        vector<int> dp(n, 0); // dp[i] means the number of arithmetic slices ending with A[i]
        if (A[2]-A[1] == A[1]-A[0]) dp[2] = 1; // if the first three numbers are arithmetic or not
        int result = dp[2];
        for (int i = 3; i < n; ++i) {
            if (A[i]-A[i-1] == A[i-1]-A[i-2]) 
                dp[i] = dp[i-1] + 1;
            result += dp[i]; // accumulate all valid slices
        }
        return result;
    }
```	

### 813. Largest Sum of Averages<br/>
partition the list into at most k parts and make the sum of average the max.<br/>
assuming dp[i,k] is the max sum of average for list len=i, and k groups, then we check every j to add one more group<br/>
dp[i][k]=max(dp[i][k],dp[j][k-1]+double(A[i]-A[j])/(i-j));

```cpp
    double largestSumOfAverages(vector<int>& A, int K) {
        if(A.empty() || K == 0)  return 0;
        vector<vector<double>> dp(K+1,vector<double>(A.size(),0));
        for(int i=1;i<A.size();i++) A[i]+=A[i-1];
        for(int i=0;i<A.size();i++) dp[1][i]=double(A[i])/(i+1);
        for(int k = 2; k <= K; k++)
        {
            for(int i = k-1; i < A.size(); i++) //0 to i needs k groups
            { 
                for(int j = k-2 ; j < i; j++) //0 to j needs k-1 groups
                {
                    dp[k][i] = max(dp[k-1][j]+double(A[i]-A[j])/(i - j),dp[k][i]);
                }
            }
        }
        return dp[K][A.size()-1];
    }
```
	
### 376. Wiggle Subsequence<br/>
return the max length of the wiggling subsequence<br/>
- by tracking the number of down and ups
- when num[i]>num[i-1], we increase up, up[i]=dn[i-1]+1 (since the two are dependent)
- when num[i]<num[i-1], we increase down
- equal case: no change
- final answer shall be the max of up and down ending at the last element
```cpp
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int up=1,dn=1;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>nums[i-1]) up=dn+1;
            if(nums[i]<nums[i-1]) dn=up+1;
            //cout<<nums[i]<<"\t"<<up<<" "<<dn<<endl;
        }
        return max(up,dn);
    }
```

	

### 303	Range Sum Query - Immutable		Easy	
get the sum from i to j (inclusive). note the prefix sum can only give i to j (not including i)
```cpp
    NumArray(vector<int> &nums) { //do the summation once! note the summation includes i,j
        int sum0=0;
        sum.push_back(0); //add one zero
        for(int i=0;i<nums.size();i++)
        {
            sum0+=nums[i];
            sum.push_back(sum0);
        }
    }

    int sumRange(int i, int j) {
        return sum[j+1]-sum[i];//this will not include nums[i]
    }
```
by adding a 0, prefix[i] does not include nums[i]
prefix[j+1] include nums[j]
	
### 276	Paint Fence 	Easy	
locked

## solve problem using small solutions-build intution
sometimes when we do not have explicit recurrence relation. It is still be able to approach using smaller solutions<br/>

### 338. Counting Bits<br/>
given a number get all number of 1s in binary for each one.<br/> dp[i]=dp[i/2]+i&1
need to be O(n) time and space
n: dp[n/2]+n%2

### 931. Minimum Falling Path Sum<br/>
given a matrix, element + min(previous row closest three sum)
```cpp
    int minFallingPathSum(vector<vector<int>>& A) {
        //use the matrix A for dp
        int n=A.size();
        for(int i=1;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(j>0 && j<n-1)
                    A[i][j]+=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]);
                else if(j==0) A[i][j]+=min(A[i-1][j],A[i-1][j+1]);
                else A[i][j]+=min(A[i-1][j],A[i-1][j-1]);
            }
        }
        //print(A);
        int ans=A[n-1][0];
        for(int i=0;i<n;i++) ans=min(ans,A[n-1][i]);
        return ans;
    }
```	

### 343. Integer Break<br/>
make the product the largest.<br/>
j*(i-j) vs j*dp[i-j], break into j and i-j two numbers<br/>
this is also a math problem. see math

```cpp
    int integerBreak(int n) {
        
        if (n <= 2)
            return 1;

        vector<int> maxArr(n+1, 0);
                    
        maxArr[1] = 0;
        maxArr[2] = 1; // 2=1+1 so maxArr[2] = 1*1
        
        for (int i=3; i<=n; i++) {
            for (int j=1; j<i; j++) {
                maxArr[i] = max(maxArr[i], max(j*(i-j), j*maxArr[i-j]));
            }
        }
        return maxArr[n];
    }
```	

### 650. 2 Keys Keyboard<br/>
copy all and paste two operations<br/>
dp[i]=dp[j]+i/j if i%j==0. paste j for i/j times, find the max j.<br/>
```cpp
    int minSteps(int n) {
        vector<int> dp(n+1);
        dp[1]=0;dp[2]=2;dp[3]=3;
        for(int i=4;i<=n;i++)
        {
            if(i%2) //odd number always need one copy,even number of paste 2,4,6,8...can only from its max divisor
            {
                int m=max_divisor(i);
                dp[i]=dp[m]+i/m;
            }
            else //even number always need one copy, odd number of paste
            {
                if(i%2==0) dp[i]=dp[i/2]+2;
                if(i%4==0) dp[i]=min(dp[i],dp[i/4]+4);
            }
        }
        return dp[n];
    }
    
    int max_divisor(int n) //find the max divisor except itself
    {
        int res=1;
        for(int i=2;i<n/2;i++) if(n%i==0) res=i;
        return res;
    }
```

### 96. Unique Binary Search Trees	
Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?
sum(dp[i]) dp[i] is the number of BSTs using i as the root.
dp[i]=sum(dp[j-1]*dp[i-j])
```cpp
    int numTrees(int n) {
        int count=0;
        vector<int> g(n+1,0);
        g[0]=1;g[1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int j=1;j<=i;j++) g[i]+=g[j-1]*g[i-j];
        }
        return g[n];
    }
```	

### 375. Guess Number Higher or Lower II<br/>
when guess wrong, you need pay that amount<br/>
min cost to ensure win<br/>
- minmax problem, get the max to ensure win and then get the min of all the max
- when we pick a number k, it splits into [left, k-1] and [k+1,right] the cost is num[k]+max(dp[left,k-1],dp[k+1,right])
- 1st dimension depends on k+1 and second dimension depends on k-1 so first using reverse iteration and 2nd use normal iteration

```cpp
    int getMoneyAmount(int n) {
        //pick a number k it always split it into two regions (1,k-1) (k+1,n)
        vector<vector<int>> dp(n+1,vector<int>(n+1));
        
        for(int r=2;r<=n;r++) //right
        {
            for(int l=r-1;l>0;l--) //left
            {
                int gmin=INT_MAX;        
                for(int k=l+1;k<r;k++) //choose k from {l+1,r-1} need at least 3 numbers
                {
                    int tmax=k+max(dp[l][k-1],dp[k+1][r]);
                    gmin=min(gmin,tmax);
                }
                dp[l][r]=gmin==INT_MAX?l:gmin;//in case of one element
            }
        }
        return dp[1][n];
    }
```

### 264. Ugly Number II<br/>
only has factor of 2,3,5, find the nth ugly number<br/>
iteratively find the next ugly number, it shall be the min of previous *2 *3 *5<br/>
use 3 pointers i: *2, j *3, k: *5 represents the current 3 min ugly number.<br/>
```cpp
    int nthUglyNumber(int n) {
        vector<int> dp(n);
        dp[0]=1;
        int i=0,j=0,k=0;
        for(int m=1;m<n;m++)
        {
            dp[m]=min(dp[i]*2,min(dp[j]*3,dp[k]*5));
            if(dp[m]==dp[i]*2) i++;
            if(dp[m]==dp[j]*3) j++;
            if(dp[m]==dp[k]*5) k++;
        }
        return dp[n-1];
    }
```

## top down vs bottom up

### 877. Stone Game<br/>
a list of numbers, picking from either end. who wins<br/>
we pick positive, the other pick negative, maximize the score. (for the other player it is the same)<br/>

```cpp
    bool stoneGame(vector<int>& piles) {
       int n=piles.size();
       int l=0,r=n-1;
        //three variables: l, r and id, use -1 as flag is not good
       vector<vector<int>> dp(n,vector<int>(n,INT_MAX));
        return helper(piles,dp,0,n-1)>0;
    }
    
    int helper(vector<int>& piles,vector<vector<int>>& dp,int l,int r)
    {
        if(l>r) return 0;
        if(dp[l][r]!=INT_MAX) return dp[l][r];
        dp[l][r]=max(piles[l]-helper(piles,dp,l+1,r),piles[r]-helper(piles,dp,l,r-1));
        return dp[l][r];
    }
```

### 486. Predict the Winner<br/>
same as 877, but we can use direct dp max(num[l]-dp[l+1,r],num[r]-dp[l,r-1])<br/>
l: reverse iteration, r normal iteration<br/>
bottom up approach:

```cpp
    bool PredictTheWinner(vector<int>& nums) {
        int n=nums.size();
        vector<vector<int>> dp(n,vector<int>(n,INT_MIN)); 
        //dp[i][j]: the score difference using the subarray from i to j i<=j
        for(int i=0;i<n;i++) dp[i][i]=nums[i];
        for(int l=n-2;l>=0;l--)
        {
            for(int r=l+1;r<n;r++) //r>=l
                dp[l][r]=max(dp[l][r],max(nums[l]-dp[l+1][r],nums[r]-dp[l][r-1]));
        }
        //print(dp);
        return dp[0][n-1]>=0;
    }
```
	
### 638. Shopping Offers<br/>
better using recursive for this
```cpp
void operator+=(vector<int> &a, const vector<int> &b) {
    for (int i = 0; i < a.size(); i++)
        a[i] += b[i];
}

void operator-=(vector<int> &a, const vector<int> &b) {
    for (int i = 0; i < a.size(); i++)
        a[i] -= b[i];
}

bool operator<(const vector<int> &a, const int &n) {
    for (int i : a)
        if (i < n)
            return true;
    return false;
}

int operator*(const vector<int> &a, const vector<int> &b) {
    int res = 0;
    for (int i = 0; i < a.size(); i++)
        res += a[i] * b[i];
    return res;
}    
class Solution {
public:
    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int cost = 0) {
        if (needs < 0) return INT_MAX;

        int m = cost + needs * price;//buy everything separately

        for (auto &offer : special) 
        {
            if (cost + offer.back() >= m) // pruning
                continue;
            needs -= offer; //add this offer
            m = min(m, shoppingOffers(price, special, needs, cost + offer.back()));
            needs += offer; //put it back (pop)
        }

        return m;
    }

};
```

## palindrome
	
### 647. Palindromic Substrings<br/>
Given a string, your task is to count how many palindromic substrings in this string.

dp[i,j] is the number of p-string for S(i...j)<br/>
self+dp[i,j-1]+dp[i+1,j]-dp[i+1,j-1]<br/>
iterate i reverse, j normal<br/>
```cpp
    int countSubstrings(string s) {
        //dp solution: using 2d approach
        //dp[i,j]=self+dp[i,j-1]+dp[i+1,j]-dp[i+1,j-1]
        //dp[i,j] is the number of p-string for S(i...j)
        //i: reverse, j: normal
        int n=s.size();
        vector<vector<int>> dp(n,vector<int>(n));
        for(int i=0;i<n;i++) dp[i][i]=1; //itself is a p-string
        
        for(int i=n-2;i>=0;i--) //reverse
        {
            for(int j=i+1;j<n;j++) //j>i must be met
            {
                int self=isPalindrome(s,i,j);
                dp[i][j]=self+dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1];
            }
        }
        return dp[0][n-1];
    }
    int isPalindrome(string& s,int i,int j)
    {
        //two pointer early exit
        while(i<j) 
        {
            if(s[i]==s[j]) {i++,j--;} else return 0;
        }
        return 1;
    }
```

## edit distance
using insert, delete, replace to make two strings (arrays) to be the same or transform from one to another<br/>
this can solve a lot of subsequence problems.<br/>
	
### 72. Edit Distance	
insert delete and replace
min number of operations
```cpp
    int minDistance(string s1, string s2) {
        //note it has three operations!
		int n=s1.size();
		int m=s2.size();
		vector<vector<char>> d(n+1,vector<char>(m+1));
		for(int i=0;i<=n;i++) d[i][0]=i;
		for(int j=0;j<=m;j++) d[0][j]=j;
		short ins,del,match,mismatch;
		for(int j=1;j<=m;j++)
		{
			for(int i=1;i<=n;i++)
			{
				ins=d[i][j-1]+1;
				del=d[i-1][j]+1;
				match=d[i-1][j-1];
				mismatch=d[i-1][j-1]+1;//replace
				if(s1[i-1]==s2[j-1]) //note string start from 0
					//d[i][j]=min(ins,min(del,match));
					d[i][j]=match;
				else
					d[i][j]=min(ins,min(del,mismatch));
			}
		}
		return d[n][m];   
    }
```		
### 712. Minimum ASCII Delete Sum for Two Strings<br/>
edit distance dp[i,j]
```cpp
    int minimumDeleteSum(string s1, string s2) {
		int n=s1.size();
		int m=s2.size();
		vector<vector<int>> d(n+1,vector<int>(m+1)); //minimum delete sum, (i-1)(j-1)
		for(int i=1;i<=n;i++) d[i][0]+=d[i-1][0]+s1[i-1];//s2 is empty
		for(int j=1;j<=m;j++) d[0][j]+=d[0][j-1]+s2[j-1];//s1 is empty
		int del,match,mismatch;
		for(int j=1;j<=m;j++)
		{
			for(int i=1;i<=n;i++)
			{
				match=d[i-1][j-1];
				mismatch=d[i-1][j-1]+s1[i-1]+s2[j-1];//delete both
				int del1=d[i-1][j]+s1[i-1]; //delete s1[i-1], when mismatch
				int del2=d[i][j-1]+s2[j-1]; //delete s2[j-1], when mismatch
				
				if(s1[i-1]==s2[j-1]) //note string start from 0
					d[i][j]=min(match,min(del1,del2));//even it matches we may need delete it
				else
					d[i][j]=min(mismatch,min(del1,del2));
			}   
		}
		return d[n][m];           
    }
```	

### 392. Is Subsequence
Given a string s and a string t, check if s is subsequence of t.
edit distance problem, greedy or two pointer
dp: by deleting char to see if we can reach to the other string<br/>
greedy: always match the first char using two pointers

```cpp
    bool isSubsequence(string s, string t) {
        int m=s.size(),n=t.size();
        if(m>n) return 0;
        int j=0;
        for(int i=0;i<s.size();i++)
        {
            char c=s[i];
            bool found=0;
            while(j<t.size()) {if(t[j]==c) {j++;found=1;break;}j++;}
            if(!found) return 0;
        }
        return 1;
    }
```

### 516. Longest Palindromic Subsequence	
Given a string s, find the longest palindromic subsequence's length in s
```cpp
    int longestPalindromeSubseq(string s) {
        // dp[i][j] longest palindrome subsequence within s[i...j]
        //
        // dp[i][j] = dp[i+1][j-1] + 2 if s[i] == s[j]
        // dp[i][j] = max(dp[i+1][j], dp[i][j-1]) if s[i] != s[j]
        // 
        // dp[i][i] = 1. dp[i][i-1] = 0.
        //
        // To save space, use 1d array.
        // i: n-1 -> 0. j : i->n-1
        
        int n = s.size();
        vector<int> dp(n, 0);
        
        for(int i = n-1; i >= 0 ; --i) 
        {
            int p1, p2 = dp[i];
            dp[i] = 1;
            for(int j = i+1; j < n; ++j) 
            {
                p1 = dp[j];
                dp[j] = (s[i] == s[j]) ?  p2+2 : max(p1, dp[j-1]);
                p2 = p1;
            }
        }
        return dp[n-1];
    }
```
again can convert to edit distance. by reversing the string we are looking for the largest common subsequence.<br/>

```cpp
    int longestPalindromeSubseq(string s) {
        string rs=s;
        reverse(rs.begin(),rs.end());
        int n=s.size();
        //align the two strings with min deletion
        vector<vector<int>> dp(n+1,vector<int>(n+1));
        for(int i=0;i<=n;i++) dp[0][i]=dp[i][0]=i;
        //dp(i,j) represents the s0(0...i-1) and s1(0...j-1)
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                int t=min(dp[i-1][j],dp[i][j-1])+1; //delete a char from s0 or s1
                //mismatch or match
                if(s[i-1]==rs[j-1]) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=min(dp[i-1][j-1]+2,t);//delete a char from s0 and s1
            }
        }
        return (2*n-dp[n][n])/2;
    }
```

### 97. Interleaving String.md
#### problem summary: 
check if s1 and s2 interleaves to s3

#### Approach
This is similar to a mxn matrix which we can find a path of s3

dp[i, j] represents s1[0...i-1] with s2[0...j-1] can interleave to s3[0...i+j-1]

when s1[i-1]==s3[i+j-1] we may choose s1[i-1], previous solution is dp[i-1, j]

when s2[j-1]==s3[i+j-1], we may choose s2[j-1], previous solution is dp[i, j-1]

when both s1[i-1] and s2[j-1] equals s3[i+j-1] we may choose either of them.

So, the recurrence relation is:

dp[i, j]=(dp[i-1, j] && s1[i-1]==s3[i+j-1]) || (dp[i, j-1] && s2[j-1]==s3[i+j-1])

Boundary condition:
0th row: when s1 is empty, dp[0,i] depends previous dp[0, i-1] and current char if the same

0th col: when s2 is empty, dp[i,0] depends previous dp[i-1,0] and current char if the same

#### code
```cpp

    bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.size(),n2=s2.size();
        if(s3.length() != n1+n2) return 0;
        if(n1==0) return s3==s2;
        if(n2==0) return s3==s1;
        vector<vector<bool>> dp(n1+1,vector<bool>(n2+1));
        dp[0][0]=1; //empty vs empty
        //boundary condition
        for(int i=1;i<=n1;i++) dp[i][0]=dp[i-1][0] && (s1[i-1]==s3[i-1]); //j=0, s1 compare with s3
        for(int j=1;j<=n2;j++) dp[0][j]=dp[0][j-1] && (s2[j-1]==s3[j-1]); //i=0: s2 compare with s3
        for(int i=1; i<=n1; i++)
        {
            for(int j=1; j<=n2; j++)
            {
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1] ) || (dp[i][j-1] && s2[j-1] == s3[i+j-1] );
            }
        }   
        return dp[n1][n2];
    }
    
```

#### Attention:
- this is a direct dp problem, which uses dp(i, j) directly for the string s1 with len i and s2 with string j and s3 with len i+j
- deal with special case: which is easy
- boundary condition: easy but if incorrectly specified, will get wrong results
- complexity O(N^2)



## ending with ith element

solve ith based on previous solutions.

### 983. Minimum Cost For Tickets
In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.

Train tickets are sold in 3 different ways:

a 1-day pass is sold for costs[0] dollars;
a 7-day pass is sold for costs[1] dollars;
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

Return the minimum number of dollars you need to travel every day in the given list of days.

typical dp: compare with 1 day, 7 day or 30 day

```cpp
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        sort(days.begin(),days.end());
        vector<int> dp(n+1);//dp[i] is the min cost ending at ith day
        //dp[1]=costs[0];
        for(int i=1;i<=n;i++)
        {
            dp[i]=dp[i-1]+costs[0];
            for(int j=i-1;j>0;j--)
            {
                if(days[i-1]-days[j-1]>=30) break;
                dp[i]=min(dp[i],dp[j-1]+costs[2]);
                if(days[i-1]-days[j-1]<7) dp[i]=min(dp[i],dp[j-1]+costs[1]);
            }
            //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout," "));cout<<endl;
        }
        return dp[n];
    }
```

	
### 646. Maximum Length of Pair Chain<br/>
sort the chain according to its start.<br/>
dp[i] is the number of longest chain for ith pair, it shall be the previous chain+1
```cpp
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(),pairs.end()); //sort with start
        vector<int> dp(pairs.size(),1);
        for(int i=1;i<pairs.size();i++)
        {
            //dp[i] is the number of longest chain for ith pair, it shall be the previous chain+1
            for(int j=i-1;j>=0;j--)
            {
                if(pairs[j][1]<pairs[i][0]) {dp[i]=dp[j]+1;break;}
            }
        }
        return dp[pairs.size()-1];
    }
```

### 1024. Video Stitching
You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.

Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].

Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.
this is equivalent to 646 max chained pairs or merge intervals using bfs like approach

```cpp
bool cmp(vector<int> a,vector<int> b) {return a[0]<b[0] || (a[0]==b[0] && a[1]<b[1]);}
class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int T) {
        //looking for the min number of intervals covering the whole duration
        sort(clips.begin(),clips.end(),cmp);
        if(clips[0][0]<0 || clips.back()[1]<T) return -1;
        //for(int i=0;i<clips.size();i++) cout<<clips[i][0]<<","<<clips[i][1]<<endl;
        int n=clips.size();
        int ans=0;
        //get the leftmost interval with the longest coverage
        int t=0,i=0;
        while(t<T)
        {
            int tend=t;
            for(int i=0;i<n;i++)
                if(clips[i][0]<=t) tend=max(tend,clips[i][1]);else break;
            if(tend<=t) return -1;
            t=tend;
            ans++;
        }
        return ans;
    }
};
```

### 639. Decode Ways II
* represents any numbers
```cpp
    int numDecodings(string s) {
        //dp[i]=ways[i]*dp[i-1]+ways[i-1,i]*dp[i-2]
        if(s.size()==0) return 0;
        vector<long long> dp(s.size());
        const int mod=1e9+7;
        dp[0]=ways(s[0]);
        if(s.size()<2) return dp[0];
        dp[1]=ways(s[1])*dp[0]+ways(s[0],s[1]);
        for(int i=2;i<s.size();i++)
            dp[i]=(ways(s[i])*dp[i-1]+ways(s[i-1],s[i])*dp[i-2])%mod;
        return dp[s.size()-1];
    }
    int ways(char digit)
    {
        if(digit=='0') return 0;
        if(digit!='*') return 1;//note * can only be 1 to 9
        return 9;
    }
    int ways(char d1,char d2)
    {
        if(isdigit(d1)&&isdigit(d2))
        {
            if(d1>'2' || d1=='0') return 0; //does not matter d2
            if(d1=='2')
            {
                if(d2<'7') return 1;
                else return 0;
            }
            if(d1=='1') return 1;
        }
        if(d1=='*' && d2!='*')
        {
            //* can only be 1 or 2
            if(d2>'6') return 1;
            else return 2;
        }
        if(d1!='*' && d2=='*')
        {
            if(d1=='1') return 9;
            if(d1=='2') return 6;
            return 0;
        }
        if(d1=='*' && d2=='*')
        {
            return 15; //11-19 21..26
        }
    }
```

## longest/shortest subsequence

### 1027. Longest Arithmetic Sequence	
get sequence with previous with same difference
dp[diff][index] equals to the length of arithmetic sequence at index with difference diff.
```cpp
    int longestArithSeqLength(vector<int>& A) {
        unordered_map<int, unordered_map<int, int>> dp;
        int res = 2;
        for (int i = 0; i < A.size(); ++i)
            for (int j = i + 1; j < A.size(); ++j)  {
                int d = A[j] - A[i];
                dp[d][j] = dp[d].count(i) ? dp[d][i] + 1 : 2;
                res = max(res, dp[d][j]);
            }
        return res;
    }
```


### 873. Length of Longest Fibonacci Subsequence
two pointers with dp

```cpp
    int lenLongestFibSubseq(vector<int>& A) {
        unordered_map<int, int> m;
        int n = A.size(), res = 0;
        int dp[n][n];//1d: up to ith element, 2d: n-1 element 
        for (int i = 0; i < n; ++i) 
        {
            m[A[i]] = i;
            for (int j = 0; j < i; ++j) 
            {
                int k=-1;
                int d=A[i]-A[j];
                if(m.count(d)) k=m[d];//search for n-2 element
                dp[i][j] = (k>=0 && A[k]<A[j]) ? dp[j][k] + 1 : 2;
                res = max(res, dp[i][j]);
            }
        }
        return res > 2 ? res : 0;
    }
```	
### 1048. Longest String Chain
sort the strings according to length so we can only consider previous words
using two pointer to judge if the two string has only one char difference.
```cpp
bool cmp(string& a,string &b) {return a.size()<b.size();}
class Solution {
public:
    int longestStrChain(vector<string>& words) {
        sort(words.begin(),words.end(),cmp);
        //copy(words.begin(),words.end(),ostream_iterator<string>(cout," "));cout<<endl;
        int n=words.size();
        vector<int> dp(n,1); //dp[i] is the longest chain ending with word[i]
        for(int i=1;i<n;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(words[j].size()+1==words[i].size())
                {
                    if(ispred(words[j],words[i])) 
                        dp[i]=max(dp[i],dp[j]+1);
                }
            }
        }
        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout," "));
        return *max_element(dp.begin(),dp.end());
    }
    bool ispred(string a,string b) //a is shorter
    {
        
        int i=0,j=0;
        while(i<a.size() && j<b.size())
        {
            if(a[i]!=b[j]) j++;
            else i++,j++;
        }
        bool res=(i==a.size() && j<=b.size());
        //cout<<a<<" "<<b<<" "<<res<<endl;
        return res;
    }
};
```

### 718. Maximum Length of Repeated Subarray
again it is the max length of common subarray (also can be considered a edit distance problem)
```cpp
    int findLength(vector<int>& A, vector<int>& B) {
        //longest common substring
        int m=A.size(),n=B.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1)); 
        //dp[i, j] represents the longest common subarray between A[0..i-1] and B[0...j-1] 
        //boundary: dp[0][0]=0, 0th row and 0th column all zero
        int max0=0;
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(A[i-1]==B[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                //else dp[i][j]=0;
                max0=max(max0,dp[i][j]);
            }
        }
        return max0;
    }
```

	
### 978. Longest Turbulent Subarray	
A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:

For i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even;
OR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.
That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

Return the length of a maximum size turbulent subarray of A.
For each A[i]
```cpp
    public int maxTurbulenceSize(int[] A) {
        int inc = 1, dec = 1, result = 1;
        for (int i = 1; i < A.length; i++) {
            if (A[i] < A[i - 1]) {
                dec = inc + 1;
                inc = 1;
            } else if (A[i] > A[i - 1]) {
                inc = dec + 1;
                dec = 1;
            } else {
                inc = 1;
                dec = 1;
            }
            result = Math.max(result, Math.max(dec, inc));
        }
        return result;
    }
```
	
inc: The length of current valid sequence which ends with two increasing numbers
dec: The length of current valid sequence which ends with two decreasing numbers

### 300. Longest Increasing Subsequence<br/>
dp[i] is the max length subsequence ending at i.<br/>
if(nums[j]<nums[i]) dp[i]=max(dp[i],dp[j]+1);<br/>
```cpp
    int lengthOfLIS(vector<int>& nums) {
        int n=nums.size();
        if(!n) return 0;
        vector<int> dp(n,1);//dp[i] is the max length at i
        for(int i=1;i<n;i++) //how to get dp[i] from dp[i-1] or previous solution
        {
            //if >previous dp[i]=dp[i-1]+1
            //if <previous find the first one which is smaller than it
            for(int j=i-1;j>=0;j--)
            {
                if(nums[j]<nums[i]) {dp[i]=max(dp[j]+1,dp[i]);}
            }
            
        }
        return *max_element(dp.begin(),dp.end());
    }
```

### 673. Number of Longest Increasing Subsequence<br/>
solving two dp problem at the same time: find the longest subsequence, remembering the number of path to each of the longest subsequence<br/>
```cpp
    int findNumberOfLIS(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return 0;
        vector<int> dp(n,1),cnt(n,1);//each number itself is a increasing subsequence
        //cnt is the count of largest subsequence, dp is the length
        for(int i=1;i<n;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(nums[i]>nums[j]) 
                {
                    //dp[i]=max(dp[i],dp[j]+1);
                    if(dp[i]==dp[j]+1) cnt[i]+=cnt[j]; //j is the max, this is important!!!
                    if(dp[i]<dp[j]+1) //the new max
                    {
                        dp[i]=dp[j]+1;
                        cnt[i]=cnt[j];//update the max
                    }
                }
            }
        }
        int maxlen=*max_element(dp.begin(),dp.end());
        int ans=0;
        for(int i=0;i<n;i++) if(dp[i]==maxlen) ans+=cnt[i];
        return ans;
    }
```    

### 32. Longest Valid Parentheses
using stack
```cpp
    int longestValidParentheses(string s) {
		stack<int> st;
		s=')'+s+'(';
		int maxlen=0;
		for(int i=0;i<s.size();i++)
		{
			char c=s[i];
			if(c=='(') st.push(i);
			else 
			{
				if(st.size() && s[st.top()]=='(')
					st.pop();
				else st.push(i);
			}
		}
		//pop out the invalid index and get the max
		int ind=st.top();st.pop();
		while(st.size()) {maxlen=max(maxlen,ind-st.top()-1);ind=st.top();st.pop();}
		return maxlen;
	}
```

## knapsack problem
with repetition, without repetition

### 322. Coin Change-min number<br/>
classical knapsack with repetition: the amount shall be in outer loop<br/>
```cpp
    int coinChange(vector<int>& coins, int amount) {
        //knapsack with repetitive
        int n=coins.size();
        vector<int> dp(amount+1,amount+1);//min number for amount with number of different coins
        //since coins can be repeated, the coins shall be inside loop
        dp[0]=0;
        for(int w=1;w<=amount;w++)
        {
            for(int i=1;i<=coins.size();i++)
            {
                //choose or not choose
                int m=coins[i-1];
                if(w>=m) dp[w]=min(dp[w],dp[w-m]+1);
            }
        }
        return dp[amount]==amount+1?-1:dp[amount];
    }
 ```

### 494. Target Sum<br/>
using + and - to reach the target sum. how many ways?<br/>
negative sum N and positive sum P
- P+N=target
- P-N=total so P=(S+T)/2
it reduces to get the number of ways to reach a new target sum.<br/>
and it is a knapsack problem without repetition<br/>

```cpp
    int findTargetSumWays(vector<int>& nums, int S) {
        //P-N=T, P+N=S P=(S+T)/2 T is the total
        int T=accumulate(nums.begin(),nums.end(),0);
        if((T+S)%2) return 0;
        int target=(T+S)/2;//T+S must be even
        if(target>T) return 0;
        int n=nums.size();
        vector<vector<int>> dp(n+1,vector<int>(target+1));
        //boundary: 0th row, using 0 element to reach target, no way
        //0th col: using elements to reach target 0, can only choose empty
        //for(int i=0;i<=n;i++) dp[i][0]=1;
        dp[0][0]=1; //other are all 0
        for(int i=1;i<=n;i++) //iterate over elements
        {
            for(int j=0;j<=target;j++) //j>=nums[i]
            {
                dp[i][j]=dp[i-1][j];//not using it
                if(j>=nums[i-1]) dp[i][j]+=dp[i-1][j-nums[i-1]]; //using it
            }
        }
        return dp[n][target];
    }
```

### 377. Combination Sum IV<br/>
give a target, get the number of combinations that sums to the target<br/>
knapsack with repetition: for smaller target, we shall iterate over all the numbers.<br/>
Note: it also includes climbing stairs, if we have multiple methods to reach i, we need sum them up.<br/>

```cpp
    int combinationSum4(vector<int>& nums, int target) {
        //typical dp knapsack problem
        vector<int> dp(target+1);
        dp[0]=1; //when target is 0, empty choice
        for(int i=1;i<=target;i++)
        {
            for(int j=0;j<nums.size();j++)
            {
                if(i>=nums[j]) dp[i]+=dp[i-nums[j]];
            }
        }
        return dp[target];
    }
```    

### 698. Partition to K Equal Sum Subsets<br/>
knapsack without repetition, need take k-1 times and mark those already used
- sort in descending order will make it faster
- dfs to choose the elements

```cpp
   bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if(sum%k) return 0;
        int target=sum/k;
        multiset<int,greater<int>> myset(nums.begin(),nums.end(),greater<int>());
        multiset<int,greater<int>>::iterator it=myset.begin();
        if(*it>target) return 0;
        for(int i=0;i<k-1;i++) //the last loop is not needed
        {
            it=myset.begin();
            if(*it==target) {myset.erase(it);continue;}
            int t=target-*it;
            myset.erase(it);
            bool res=helper(myset,t);
            if(!res) return 0;
        }
        return 1;
    }
    bool helper(multiset<int,greater<int>>& mset,int target)
    {
        auto it=mset.find(target);
        if(it!=mset.end()) {mset.erase(it);return 1;}
        //fix one element and search for other
        for(it=mset.begin();it!=mset.end();it++)
        {
            if(*it>target) continue;
            int t=target-*it;
            int val=*it;
            mset.erase(it);
            if(helper(mset,t)) return 1;
            mset.insert(val); //cannot find it restore this value
        }
        return 0;
    }
```
recursion approach is more concise and understandable
```cpp
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0;
        for(int num:nums)sum+=num;
        if(k <= 0 || sum%k != 0)return false;
        vector<int> visited(nums.size(), 0);
        return canPartition(nums, visited, 0, k, 0, 0, sum/k);
    }
    
    bool canPartition(vector<int>& nums, vector<int>& visited, int start_index, int k, int cur_sum, int cur_num, int target){
        if(k==1)return true;
        if(cur_sum == target && cur_num >0 )return canPartition(nums, visited, 0, k-1, 0, 0, target);
        for(int i = start_index; i<nums.size(); i++){
            if(!visited[i]){
                visited[i] = 1;
                if(canPartition(nums, visited, i+1, k, cur_sum + nums[i], cur_num++, target))return true;
                visited[i] = 0;
            }
        }
        return false;
    }
```

### 279. Perfect Square<br/>
again knapsack problem with repetition, the selection is 1^2, 2^2, 3^2....n^2
can also be approached using math


```cpp
    int numSquares(int n) {
        int target=sqrt(n);
        vector<int> dp(n+1);
        for(int w=1;w<=n;w++)
        {
            dp[w]=INT_MAX;
            for(int i=1;i<=sqrt(w);i++)
            {
                dp[w]=min(dp[w],dp[w-i*i]+1);
            }
        }
        return dp[n];
    }
```

### 416. Partition Equal Subset Sum<br/>
knapsack without repetition. so iteration on elements shall be outside<br/>
then solve all the smaller problems<br/>
```cpp
    bool canPartition(vector<int>& nums) {
        int sum0=accumulate(nums.begin(),nums.end(),0);
        if(sum0%2) return 0;
        //discrete knapsack without repetition
        //value(w,i) 
        //cout<<sum0<<endl;
        int n=nums.size();
        //vector<vector<int>> value(sum0/2+1,vector<int>(n+1));
        int target=sum0/2;
        vector<int> dp(target+1); //dp[0]
        for(int i=1;i<=n;i++)
        {
            int wi=nums[i-1];
            //cout<<wi<<endl;
            for(int w=1;w<=target;w++) //all smaller problems
            {
                //dp[w][i]=dp[w][i-1];//if w>wi then it use previous value
                if(w>=wi)
                {
                    dp[w]=max(dp[w-wi]+wi,dp[w]);                    
                }
                //cout<<value[w][i]<<" ";
            }
            //cout<<endl;
        }
        return dp[sum0/2]==sum0/2;
    }
```

### 474. Ones and Zeroes<br/>
with m 0s and n 1s, get the max number of string in dictionary<br/>
knapsack with more complexity<br/>
- calculate each string's 0 and 1
- solve subproblem of i 0s and j 1s
- cannot repeat the string, so string iteration shall in the outer loop

```cpp
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len=strs.size();
        vector<vector<int>>num10(len,vector<int>(2));
        for(int i=0;i<len;i++)
        {
            for(int j=0;j<strs[i].size();j++) num10[i][0]+=strs[i][j]-'0';
            num10[i][1]=strs[i].size()-num10[i][0];
        }
        vector<vector<vector<int>>> dp(len+1,vector<vector<int>>(m+1,vector<int>(n+1)));
        for(int i=1;i<=len;i++)
        {
            int ones=num10[i-1][0],zeros=num10[i-1][1];
            for(int j=0;j<=m;j++) //zeros
            {
                for(int k=0;k<=n;k++) //ones
                {
                    dp[i][j][k]=dp[i-1][j][k];
                    if(j>=zeros && k>=ones) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-zeros][k-ones]+1);
                }
            }
        }
        return dp[len][m][n];
    }
```

### 1049. Last Stone Weight II	
convert to a knapsack problem making sum<=n/2 the max
+/- to each number problem
```cpp
    int lastStoneWeightII(vector<int>& stones) {
        int n=stones.size();
        int tsum=accumulate(stones.begin(),stones.end(),0);
        vector<vector<bool>> dp(tsum/2+1,vector<bool>(n+1));
        //boundary
        for(int i=0;i<=n;i++) dp[0][i]=1;//any sized choose 0.
        int maxsum=0;
        for(int i=1;i<=tsum/2;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(dp[i][j-1] ||(i>=stones[j-1] && dp[i-stones[j-1]][j-1]))
                {
                    dp[i][j]=1;
                    maxsum=max(maxsum,i);
                }
            }
        }
        return tsum-2*maxsum;
    }
```

### 956. Tallest Billboard	
You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height.

You have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.

Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.

```cpp
    int tallestBillboard(vector<int>& rods) {
        int n=rods.size();
        int tsum=accumulate(rods.begin(),rods.end(),0)/2;
        vector<vector<int>> dp(n,vector<int>(10001));//dp[i,j]: -tsum to tsum
        return helper(rods,0,5000,dp);
    }
    
    int helper(vector<int>& rods,int start,int tsum,vector<vector<int>>& dp)
    {
        if(start==rods.size()) return tsum==5000?0:INT_MIN/2;
        if(dp[start][tsum]) return dp[start][tsum];
        int ans=helper(rods,start+1,tsum,dp); //do not use current
        ans=max(ans,helper(rods,start+1,tsum-rods[start],dp)); //choose rods[i] as negative
        ans=max(ans,helper(rods,start+1,tsum+rods[start],dp)+rods[start]); //choose rods[i] as positive
        //note the answer is the sum of positives
        return dp[start][tsum]=ans;
    }
```

 ### 879. Profitable Schemes.md
 #### problem summary
Given G people, a list of profit with person required, and a target profit P. If person is used for one project, then it cannot be used for another one.

Ask: the number of profitable scheme

#### idea
First impression: this is a knapsack problem without repetition. All profitable scheme with total profit>=P. Or all profit >=P can be counted as P.

knapsack dp[i,p]: with number of items and weight p. Since each item can be chosen or not chosen, we iterate the item for all w.
There is another factor: the number of people, making it a 3D dp problem: 
dp[i, p, g]: i: number of items, p: target profit, g: number of people 

Assuming dp[i,p,g] is the number of combinations for using i projects, target profit p, and number of people g.
when we add ith element into it: dp[i,p+pi,g+gi]+=dp[i-1,p,g] (there is no min/max compare since it asks for the number of combinations)

i only involves with i-1, we can safely remove the first dimension but need to use reverse iteration to avoid using updated values

The final answer:
sum of all dp[P,g] 

Boundary condition:
dp[0,0]=1, there is one way to reach 0 and 0 people

#### code
```cpp
   int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {
        int n=group.size();
        vector<vector<int>> dp(P+1,vector<int>(G+1)); //dp is the number of combinations with p, g
        //reduced 3d to 2D
       dp[0][0]=1;
        int mod=1e9+7;
        for(int i=0;i<n;i++)
        {
            int p=profit[i],g=group[i];
            for(int pp=P;pp>=0;pp--)
            {
                for(int gg=G-g;gg>=0;gg--)
                {
                    int p1=pp+p;
                    if(p1>P) p1=P;
                    dp[p1][g+gg]=(dp[p1][g+gg]+dp[pp][gg])%mod;
                }
            }
        }
        return accumulate(dp[P].begin(),dp[P].end(),0LL)%mod;
    }
```

#### comments
- there is multiple way to reach p, g, the total method shall be sum of them, similar to climbing stairs


## dfs/recursion with memoization

### 688. Knight Probability in Chessboard<br/>
at most k moves, the probability that the knight in the board<br/>
8 directions, out of board is 0, stay in board is 1<br/>
dp[k, i, j]=sum(dp[k-1,m,n)/8 m,n is the next 8 possible directions<br/>
we can effectively remove the k dimension<br/>

```cpp
    double knightProbability(int N, int K, int r, int c) {
        int moves[][2]={{-2,-1},{-2,1},{-1,2},{-1,-2},{1,-2},{1,2},{2,-1},{2,1}};
        vector<vector<double>> dp(N,vector<double>(N,1)); //inside the board is all 1
        for(int k=0;k<K;k++) //k steps, shall have a k dimension
        {
            vector<vector<double>> curr(N,vector<double>(N));//=dp;
            for(int i=0;i<N;i++)
            {
                for(int j=0;j<N;j++)
                {
                    for(int d=0;d<8;d++)
                    {
                        int ii=i+moves[d][0];
                        int jj=j+moves[d][1];
                        if(ii>=0 && ii<N && jj>=0 && jj<N) curr[i][j]+=dp[ii][jj]; //previous times dp
                    }
                }
            }
            dp=curr; //update dp, dp is actually previous state
        }
        return double(dp[r][c])/pow(8.0,K);
    }
```
	

### 935. Knight Dialer<br/>
Get the number of different numbers given n presses.<br/>
just list next numbers for all given number.<br/>
this is similar to 688. knight probability<br/>
dp[k,i] is the number of different path using k presses, i the number ending at k times (or starting is also fine)<br/>

```cpp
    int knightDialer(int N) {
       vector<vector<int>> adj={{4,6},{8,6},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{4,2}} ;
        int mod=1e9+7;
        vector<vector<int>> dp(N,vector<int>(10));
        for(int i=0;i<10;i++) dp[0][i]=1; //each digit can be one
        for(int k=1;k<N;k++)
        {
            for(int i=0;i<10;i++)
            {
                for(int j=0;j<adj[i].size();j++) 
                {
                    dp[k][i]+=dp[k-1][adj[i][j]];
                    dp[k][i]%=mod;
                }
            }
        }
        int ans=0;
        for(int i=0;i<10;i++) ans+=dp[N-1][i],ans%=mod;
        return ans;
    }
```

### 808. Soup Servings<br/>
- make things easy, divide by 25
- then options are, A4B0, A3B1, A2B2, A1B3
- A tends to be used up first, so when A is large, the probability is 1
- recursive is fine

```cpp
    double soupServings(int N) {
        int n=(N+24)/25;
        if(n>200) return 1.0;
        vector<vector<double>> dp(n+1,vector<double>(n+1));
        return helper(n,n,dp);
    }
    double helper(int m,int n,vector<vector<double>>& dp)
    {
        if(m<=0 && n>0) return 1.0;
        if(m<=0 && n<=0) return 0.5;
        if(m>0 && n<=0) return 0.0;
        if(dp[m][n]>0) return dp[m][n];
        return dp[m][n]=0.25*(helper(m-4,n,dp)+helper(m-3,n-1,dp)+helper(m-2,n-2,dp)+helper(m-1,n-3,dp));
    }
```

### 967. Numbers With Same Consecutive Differences
Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K.

Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid.

You may return the answer in any order.

recursive approach
```cpp
    vector<int> numsSameConsecDiff(int N, int K) {
        //choose the pair of digit which difference is K
        //if it contains 0, then it cannot be on the first.
        //for a digit chosen, next can be +1 or -1
        //so this is a dfs problem
        vector<int> ans;
        if(N==1) return vector<int>({0,1,2,3,4,5,6,7,8,9});
        for(int i=1;i<10;i++)
            dfs(i,N-1,K,ans,0);
        return vector<int>(ans.begin(),ans.end());
    }
    void dfs(int start,int n,int K,vector<int>& ans,int res)
    {
        res=res*10+start;                
        if(n==0 ) {ans.push_back(res);return;}
     
        if(start+K<10) dfs(start+K,n-1,K,ans,res);
        if(K && start-K>=0) dfs(start-K,n-1,K,ans,res);
    }
```

### 838. Push Dominoes
There are N dominoes in a line, and we place each domino vertically upright.

In the beginning, we simultaneously push some of the dominoes either to the left or to the right.

Whether be pushed or not, depend on the shortest distance to 'L' and 'R'.
Also the direction matters.
Base on this idea, you can do the same thing inspired by this problem.
https://leetcode.com/problems/shortest-distance-to-a-character/discuss/125788/

Here is another idea that focus on 'L' and 'R'.
'R......R' => 'RRRRRRRR'
'R......L' => 'RRRRLLLL' or 'RRRR.LLLL'
'L......R' => 'L......R'
'L......L' => 'LLLLLLLL

```cpp
    string pushDominoes(string d) {
        d = 'L' + d + 'R';
        string res = "";
        for (int i = 0, j = 1; j < d.length(); ++j) {
            if (d[j] == '.') continue;
            int middle = j - i - 1;
            if (i > 0) res += d[i];
            if (d[i] == d[j]) res += string(middle, d[i]);
            else if (d[i] == 'L' && d[j] == 'R') res += string(middle, '.');
            else res += string(middle / 2, 'R') + string(middle % 2,'.') + string(middle / 2, 'L');
            i = j;
        }
        return res;
    }
```
	
### 764. Largest Plus Sign<br/>
in four directions, using dp to get the largest radius (including itself)<br/>
then the larget radius is the min of the 4 directions<br/>
```cpp
int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {
    vector<vector<int>> grid(N, vector<int>(N, N));
        
    for (auto& m : mines) {
        grid[m[0]][m[1]] = 0;
    }
        
    for (int i = 0; i < N; i++) {
        for (int j = 0, k = N - 1, l = 0, r = 0, u = 0, d = 0; j < N; j++, k--) {
            grid[i][j] = min(grid[i][j], l = (grid[i][j] == 0 ? 0 : l + 1));
            grid[i][k] = min(grid[i][k], r = (grid[i][k] == 0 ? 0 : r + 1));
            grid[j][i] = min(grid[j][i], u = (grid[j][i] == 0 ? 0 : u + 1));
            grid[k][i] = min(grid[k][i], d = (grid[k][i] == 0 ? 0 : d + 1));
        }
    }
        
    int res = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            res = max(res, grid[i][j]);
        }
    }
        
    return res;
}
```

### 1039. Minimum Score Triangulation of Polygon
Given N, consider a convex N-sided polygon with vertices labelled A[0], A[i], ..., A[N-1] in clockwise order.

Suppose you triangulate the polygon into N-2 triangles.  For each triangle, the value of that triangle is the product of the labels of the vertices, and the total score of the triangulation is the sum of these values over all N-2 triangles in the triangulation.

Return the smallest possible total score that you can achieve with some triangulation of the polygon.
```cpp
    int minScoreTriangulation(vector<int>& A) {
    /*
    dp[i][j] means the minimum score to triangulate A[i] ~ A[j],
while there is edge connect A[i] and A[j].

We enumerate all points A[k] with i < k < j to form a triangle.

The score of this triangulation is dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]
*/
        int n = A.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int j = 2; j < n; ++j) {
            for (int i = j - 2; i >= 0; --i) { //i<k<j that is why we need reverse iteration
                dp[i][j] = INT_MAX;
                for (int k = i + 1; k < j; ++k)
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]);
            }
        }
        return dp[0][n - 1];
    }
```
	









	
	

	
### 95. Unique Binary Search Trees II<br/>
dp. combine with left and right
```cpp
    vector<TreeNode*> genTree(int start,int end)
    {
        vector<TreeNode*> ans;
        if(start>end) {ans.push_back(NULL);return ans;}
        //if(start==end) return vector<TreeNode*>(1,new TreeNode(start));
        for(int i=start;i<=end;i++)
        {
            vector<TreeNode*> left=genTree(start,i-1);
            vector<TreeNode*> right=genTree(i+1,end);
            //combine the left right, note left or right could be empty

            for(int l=0;l<left.size();l++)
            {
                for(int r=0;r<right.size();r++)
                {
                    TreeNode *root=new TreeNode(i);    
                    root->left=left[l];
                    root->right=right[r];
                    ans.push_back(root);
                }
            }
        }
        return ans;
    }
```    
	
### 790. Domino and Tromino Tiling<br/>
we have I shape and L shape, to build 2*N tile, what is the number of combinations<br/>
this is actually hard.<br/>
we have two shapes ending: one is flat at the end and one is L shaped at the end
- g(i) represents the number of combinations ending with flat
- u(i) represents the number of combinations ending with L shape

```cpp
    int numTilings(int N) 
    {
        vector<long long> g(N+1),u(N+1);
        int mod=1000000007;
        g[0]=0; g[1]=1; g[2]=2;
        u[0]=0; u[1]=1; u[2]=2;
        
        for(int i=3;i<=N;i++)
        {
            u[i] = (u[i-1] + g[i-1]           )   %mod;
            g[i] = (g[i-1] + g[i-2] + 2*u[i-2])   %mod;
        }
        return g[N]%mod;
    }
```   
 	
### 139. Word Break<br/>
break the word into dictionary words<br/>
iterate and break the problem into a word + a smaller subproblem.<br/>
direct dp:<br/>
we mark the possible cut positions and when we iterate more, we check [j, i] if is also a word in the dict.<br/>
```cpp
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> ms(wordDict.begin(),wordDict.end());
        vector<bool> dp(s.size()+1);
        dp[0]=1; //empty s
        for(int i=1;i<=s.size();i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(dp[j])
                {
                    if(ms.count(s.substr(j,i-j))) {dp[i]=1;break;}
                }
            }
        }
        return dp[s.size()];
    }
```
	


### 368. Largest Divisible Subset<br/>
find the largest subset which Si%Sj=0 (they are a part of geometric series)<br/>
dp with backtrace ability, we need keep the previous information.<br/>
dp with a bit complexity<br/>
```cpp
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return vector<int>();
        sort(nums.begin(),nums.end());
        
        vector<int> dp(n,1); //l
        vector<int> prev(n,-1);
        for(int i=1;i<n;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(nums[i]%nums[j]==0) 
                {
                    dp[i]=max(dp[i],dp[j]+1);
                    if(dp[i]==dp[j]+1) prev[i]=j;
                }
            }
        }
        int ind=max_element(dp.begin(),dp.end())-dp.begin();
        vector<int> ans;
        while(ind>=0)
        {
            ans.push_back(nums[ind]);
            ind=prev[ind];
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
```

## shortest distance
dijkstra, bellman-ford, bfs, dp

### 787. Cheapest Flights Within K Stops<br/>
define dp[i,k] is the min cost from start to j with at most k stops<br/>
the key is we add one stop j: dp[j,k-1]+price[i,j] to minimize the cost<br/>

```cpp
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
        vector<vector<int>> prices(n,vector<int>(n,INT_MAX)),dp(n,vector<int>(K+1,INT_MAX));
        for(int i=0;i<flights.size();i++) 
        {
            if(flights[i][0]==src) dp[flights[i][1]][0]=flights[i][2];
            prices[flights[i][0]][flights[i][1]]=flights[i][2];
        }
        for(int k=0;k<=K;k++) dp[src][k]=0;
        for(int k=1;k<=K;k++)
        {
            //add one stop based on previous k-1 stop
            for(int j=0;j<n;j++)
            {
                if(src==j) continue;
                for(int m=0;m<n;m++)
                {
                    if(dp[m][k-1]!=INT_MAX && prices[m][j]!=INT_MAX)
                    dp[j][k]=min(dp[j][k],dp[m][k-1]+prices[m][j]);
                }
            }
        }
        return dp[dst][K]==INT_MAX?-1:dp[dst][K];
    }
```    

### 801. Minimum Swaps To Make Sequences Increasing<br/>
two arrays, swap at the same position to make both array sorted<br/>
two cases:<br/>
- A[i]>A[i-1] && B[i]>B[i-1]: no swap, then i-1 no swap, swap then swap i-1
- A[i]>B[i-1] && B[i]>A[i-1]: no swap, then swap i-1. swap i, then no swap i-1
- Note: the two cases may overlap, so second case we need take the min

```cpp
    int minSwap(vector<int>& A, vector<int>& B) {
        int n=A.size();
        vector<int> swap(n,INT_MAX),no_swap(n,INT_MAX); 
        //swap(n) represent min swap when we swap n
        //no_swap(n) represent min swaps when we do not swap n
        swap[0]=1; //if we swap 0
        no_swap[0]=0;
        for(int i=1;i<n;i++)
        {
            if(A[i-1]<A[i] && B[i-1]<B[i]) //adding a[i] still sorted
            {
                //if we swap i, we also need swap i-1
                swap[i]=swap[i-1]+1;
                //if we do not swap i, we also not swap i-1
                no_swap[i]=no_swap[i-1];
            }
            if(A[i-1]<B[i] && B[i-1]<A[i]) //not sorted, or sorted (there is overlapping with previous condition)
            {
                //if we swap i, we shall not swap i-1
                swap[i]=min(swap[i],no_swap[i-1]+1);
                //if we not swap i, we need swap i-1
                no_swap[i]=min(no_swap[i],swap[i-1]);
            }
        }
        return min(swap[n-1],no_swap[n-1]);
    }
```

### 467. Unique Substrings in Wraparound String<br/>
- ending with different char guarantee the uniqueness.
- ending with a char, with a length, the substring is fixed (since it is always abcde...zabcd...z

```cpp
    int findSubstringInWraproundString(string p) {
        int n=p.size();
        vector<int> dp(26);
        int maxlen=1;
        for(int i=0;i<n;i++)
        {
            int ind=p[i]-'a';
            if(i&& (p[i]==p[i-1]+1 || p[i]+25==p[i-1])) maxlen++;
            else maxlen=1;
            dp[ind]=max(dp[ind],maxlen);
        }
        return accumulate(dp.begin(),dp.end(),0);
    }
```

### 898. Bitwise ORs of Subarrays<br/>
for all subarray, bit or of all elements, return number of possible results<br/>
for input ABC<br/>
A<br/>
A|B, B<br/>
A|B|C, B|C,C<br/>
so we take two set, one for final one for intermediate<br/>

```cpp
    int subarrayBitwiseORs(vector<int>& A) {
        unordered_set<int> ms,tmp;
        for(int i=0;i<A.size();i++)
        {
            if(i && A[i]==A[i-1]) continue;
            unordered_set<int> tt;
            for(auto it=tmp.begin();it!=tmp.end();it++)
                tt.insert(*it|A[i]);
            tt.insert(A[i]);
            tmp=tt;
            ms.insert(tmp.begin(),tmp.end());
        }
        return ms.size();
    }
```

### 221. Maximal Square<br/>
finding the max square with all 1s<br/>
similar to histogram but we uses dp<br/>
keep updating the height on each row.<br/>
keep updating its max range at j (left and right) using the height as the min height (this could be obtained using left max and right min dp process)<br/>

```cpp
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.size()==0) return 0;
        int m=matrix.size(),n=matrix[0].size();
        vector<int> left(n),right(n,n),height(n);
        int max_area=0;
        for(int i=0;i<m;i++)
        {
            int curr_left=0,curr_right=n;
            for(int j=0;j<n;j++) height[j]=(matrix[i][j]=='1')?(height[j]+1):0;
            for(int j=0;j<n;j++)
            {
                if(matrix[i][j]=='0') {curr_left=j+1;left[j]=0;}
                else left[j]=max(curr_left,left[j]);
            }
            for(int j=n-1;j>=0;j--)
            {
                if(matrix[i][j]=='0') {curr_right=j;right[j]=n;} //not inclusive
                else right[j]=min(right[j],curr_right);
            }
            for(int j=0;j<n;j++)
            {
                max_area=max(max_area,min(height[j],(right[j]-left[j])));
            }
        }
        return max_area*max_area;
    }
```

### 576. Out of Boundary Path<br/>
quite a few similar problems. using recursion<br/>
```cpp    
    int dp[50][50][51];
    Solution() {memset(dp,-1,sizeof(dp));}
    int findPaths(int m, int n, int N, int i, int j) {
        if(i<0 || i>=m || j<0 ||j>=n)  return 1;
        if(N<=0) return 0;
        if(dp[i][j][N]!=-1) return dp[i][j][N];
        int mod=1e9+7;
        dp[i][j][N]=findPaths(m,n,N-1,i-1,j)%mod;
        dp[i][j][N]+=findPaths(m,n,N-1,i+1,j)%mod;dp[i][j][N]%=mod;
        dp[i][j][N]+=findPaths(m,n,N-1,i,j-1)%mod;dp[i][j][N]%=mod;
        dp[i][j][N]+=findPaths(m,n,N-1,i,j+1)%mod;dp[i][j][N]%=mod;
        return dp[i][j][N];
    }
```

### 152. Maximum Product Subarray<br/>
largest product subarray<br/>
when a negative is involved, max becomes min, min becomes max<br/>
```cpp
    int maxProduct(vector<int>& nums) {
        //max times negative becomes min, min*negative becomes max
        int imax=nums[0],imin=nums[0];
        int ans=imax;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]<0) swap(imax,imin);
            imax=max(imax*nums[i],nums[i]);
            imin=min(imin*nums[i],nums[i]);
            ans=max(ans,imax);
        }
        return ans;
    }
```

### 5. Longest Palindromic Substring
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000
```cpp
    string longestPalindrome(string s) {
       //dp solution using i j
        int n=s.length();
        vector<vector<int>> dp(n,vector<int>(n)); //initialize to 0
        //dp(i,j)=length of p-string
        int ans=0;
        int start=0;
        for(int i=0;i<n;i++) {dp[i][i]=1;ans=1;}
        for(int i=0;i<n-1;i++) 
        {
            if(s[i]==s[i+1]) {dp[i][i+1]=2,ans=2,start=i;}
        }
        for(int i=n-3;i>=0;i--) //since it needs i+1
        {
            for(int j=i+2;j<n;j++) //since it needs j-1
            {
                if(s[i]==s[j] && dp[i+1][j-1]) dp[i][j]=dp[i+1][j-1]+2;
                if(ans<dp[i][j]) ans=dp[i][j],start=i;
            }
        }
        //print(dp);
        return s.substr(start,ans);
    }
```
lc516 is for sub sequence

 
### 837. New 21 Game<br/>
this is like climbing stairs, there are more than two methods to reach a stair<br/>
 
 ```cpp
     double new21Game(int N, int K, int W) {
        //this is like climbing stairs. ith position can be obtained
        //dp[i]=sum(dp[j])/W j=i-1 to i-W
        if(N>=K+W || K==0) return 1.0;
        vector<double> dp(K+1); //dp[i] is the probability to reach i points
        dp[0]=1.0;
        //dp[i]=sum(dp[j])/W for j=i-1 to i-w
        double wsum=0;

        for(int i=1;i<=K;i++)
        {
            if(i<=W) dp[i]=wsum+=dp[i-1]/W;
            else {dp[i]=wsum+=(dp[i-1]-dp[i-W-1])/W;}
        }
        //copy(dp.begin(),dp.end(),ostream_iterator<double>(cout," "));
        double ans=0;
        for(int i=K-1;i>=max(K-W,0);i--)
        {
            int d=K-1-i;
            int len=min(W-d,N-K+1);
            ans+=len*dp[i]/W;
        }
        return ans;
    }
```

### 464. Can I Win<br/>
It is important to get the problem right: the two player adds to the same sum, and who reach the target first wins
number chosen cannot be reused.<br/>
- use bitset to indicate number used or not
- subtract target
- who reaches 0 wins
- if other wins, then we lose
- store solved solutions

```cpp
    bool canIWin(int m,int sum,int status)
    {
        if(sum<=0) return 0; //already to the dead end, but still did not win
        if(win.count(status)) return 1;
        if(lose.count(status)) return 0;
        for(int i=1;i<=m;i++)
        {
            int bit=1<<i;
            if(status & bit) continue; //already solved, need the solved results recorded
            bool res=canIWin(m,sum-i,status|bit);
            if(!res) //surely win, why use ! since it is the even times.
            {
                win.insert(status);
                return 1;
            }
        }
        lose.insert(status);//after all trials, cannot win
        return 0;
    }
```

### 523. Continuous Subarray Sum<br/>
target: multiples of K<br/>
accumulate sum (prefix sum). the prefix sum shall %k has the same value<br/>
```cpp
    bool checkSubarraySum(vector<int>& nums, int k) {
        //accumulate first and then check (a-b)%k==0
        vector<int> accum(nums.size()+1,0);
        unordered_map<int,vector<int>> cntmap;
        for(int i=0;i<nums.size();i++) accum[i+1]=accum[i]+nums[i];
        if(k)
        for(int i=1;i<accum.size();i++)
        {
            int t=accum[i]%k;
            cntmap[t].push_back(i); //same remainder, 3 the same must be true, 2 possibly be true
            if(cntmap[t].size()>2) return 1;
            if(cntmap[t].size()==2)
            {
                if(abs(cntmap[t][0]-cntmap[t][1])>1) return 1;
            }
        }
        else
        for(int i=0;i<accum.size();i++)
        {
            for(int j=i+2;j<accum.size();j++)
                if(accum[j]==accum[i]) return 1;
        }
            
        return 0;
        
    }
```
	
### 91. Decode Ways<br/>
A-Z decode as 1-26<br/>
given a digit string, return number of decoding ways<br/>
only have two options:
- the number itself 
- the number combine with previous digit
```cpp
    int numDecodings(string s) {
        //read it into 1 to 26, seems dfs or dp problem
        //dp[i] is number of decodings for s[0...i-1]
        if(s.size()==0 || s[0]=='0') return 0;
        vector<int> dp(s.size()+1,0);
        dp[0]=1; //empty string only has 0 way to decode
        dp[1]=(s[0]!='0');
        for(int i=2;i<=s.size();i++)
        {
            if(s[i-1]=='0') //can only combine with previous!, one case: previous is also zero then no choice
                dp[i]=dp[i-2];
            else //non zero digit
            {
                int a=(s[i-2]-'0')*10+s[i-1]-'0';
                if(a>10 && a<=26) dp[i]=dp[i-2]+dp[i-1]; //can add or not add, two choices
                else dp[i]=dp[i-1];//this char cannot combine with previous
            }
        }
        return dp[s.size()];
    }
```
	
## hard

### 982. Triples with Bitwise AND Equal To Zero
find the number of triples

O(N^2) straightforward

```cpp
    int countTriplets(vector<int>& A) {
        unordered_map<int,int> mp;
        int n=A.size();
        int ans=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++) mp[A[i]&A[j]]++;
        }
        for(int i=0;i<n;i++)
        {
            for(auto it=mp.begin();it!=mp.end();it++)
                if((it->first&A[i])==0) ans+=it->second;
        }
        return ans;
    }
```
dp approach
```java
    public int countTriplets(int[] A) {
        int N = 1 << 16, M = 3;
        int[][] dp = new int[M + 1][N];
        dp[0][N - 1] = 1;
        for (int i = 0; i < M; i++) {
            for (int k = 0; k < N; k++) {
                for (int a : A) {
                    dp[i + 1][k & a] += dp[i][k];
                }
            }
        }
        return dp[M][0];
    }
```
dp[i][j] represents the number of combinations if we pick i numbers where the AND of these numbers is j:

the and result is always a int.

### 960. Delete Columns to Make Sorted III	
delete columns of chars to make row sorted.

longest increasing subsequence for all strings

```cpp
    int minDeletionSize(vector<string>& A) {
        //longest increasing subsequence for all strings
        int m=A.size(),n=A[0].size();
        vector<int> dp(n);
        //check each column to see if it satisfy > previous
        int maxlen=0;
        for(int i=0;i<n;i++)
        {
            for(int k=0;k<i;k++) //compare to all previous
            {
                bool sorted=1;
                for(int j=0;j<m;j++) //all string
                {
                    if(A[j][i]<A[j][k]) {sorted=0;break;} //current i,k cannot be combined   
                }
                if(sorted) dp[i]=max(dp[i],dp[k]+1);
            }
            maxlen=max(maxlen,dp[i]+1);
        }
        return n-maxlen;
    }
```	

### 975. Odd Even Jump
1st,3rd,...odd jumps
2nd,4th....even jumps
during odd jumps: jump to the first element >=A[i], the value shall be as small as possible
during even jumps: jump to the first element <=A[i], the value shall be as large as possible
check all the good starting index so we can reach the end.

Take [5,1,3,4,2] as example.

If we start at 2,
we can jump either higher first or lower first to the end,
because we are already at the end.
higher(2) = true
lower(2) = true

If we start at 4,
we can't jump higher, higher(4) = false
we can jump lower to 2, lower(4) = higher(2) = true

If we start at 3,
we can jump higher to 4, higher(3) = lower(4) = true
we can jump lower to 2, lower(3) = higher(2) = true

If we start at 1,
we can jump higher to 2, higher(1) = lower(2) = true
we can't jump lower, lower(1) = false

If we start at 5,
we can't jump higher, higher(5) = false
we can jump lower to 4, lower(5) = higher(4) = false

```cpp
    int oddEvenJumps(vector<int>& A) {
        int n  = A.size(), res = 1;
        vector<int> higher(n), lower(n);
        higher[n - 1] = lower[n - 1] = 1;
        map<int, int> map;
        map[A[n - 1]] = n - 1;
        for (int i = n - 2; i >= 0; --i) {
            auto hi = map.lower_bound(A[i]), lo = map.upper_bound(A[i]);
            if (hi != map.end()) higher[i] = lower[hi->second];
            if (lo != map.begin()) lower[i] = higher[(--lo)->second];
            if (higher[i]) res++;
            map[A[i]] = i;
        }
        return res;
    }
```
	

### 10. Regular Expression Matching
##### problem summary
'.' matches any single char and 
'*' matches 0 or more of preceding char

##### idea
1. two string direct dp problem, dp[i, j] represents if s[0...i-1] matches p[0...j-1]
2. p[j-1] is letter or ., dp[i, j]=dp[i-1, j-1]&&(s[i-1]==p[j-1]||p[j-1]=='.')
3. p[j-1]=='*', assuming previous char is a, then a*
  - matches 0 char, previous char is skipped, a* matches empty, dp[i,j]=dp[i,j-2] (s(0...i-1) matches p(0...j-3). Note: we are using previous solution for current solution!)
  - matches 1 char, then dp[i,j]=(s[i-1]==p[j-2] || p[j-2]=='.') && dp[i,j-1] (a* counts as one a, s(0..i-1) matches p[0..j-2])
  - matches more than 1 char, a* represents multiple a, dp[i,j]=(s[i-1]==p[j-2] || p[j-2]=='.') && dp[i-1,j] (depends s(0...i-2) matches p(0...j-1)). Actually this case is included in match 1 char.
4. boundary condition
  - dp[0,0]=1, empty vs empty
  - p empty, s non-empty, all false, col 0 shall not be included in loop.
  - s empty, p non-empty, must have .* letter* to match 0 char dp[0,i]=dp[0, i-2] && p[j-1]=='*'
5. extra complexity: it involves p[j-2] and dp[j-2], which indicates that row 1 needs to be included in boundary. A common approach is: we do not involve the boundary except col 0, but using the recurrence relation to process the boundary. This is much simpler in some cases when the boundary is not so straightforward.

##### code
```cpp
    bool isMatch(string s, string p) {
        int m=s.size(),n=p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        //p is empty, s non-empty all false is straightforward dp[i][0]=0
        //put other boundary in loops
        for(int i=0;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(p[j-1]!='*') dp[i][j]=i && dp[i-1][j-1] && (s[i-1]==p[j-1] || p[j-1]=='.');
                else dp[i][j]=(j>1 &&dp[i][j-2]) 
                    || (i && j>1 && dp[i][j-1] && (s[i-1]==p[j-2] || p[j-2]=='.'))
                    || (i && j>1 && dp[i-1][j] && (s[i-1]==p[j-2] || p[j-2]=='.'));
            }
        }
        return dp[m][n];
    }
  ```
  
  ##### comments
  1. when boundary is hard to write, include it in the loop
  2. a* matches empty, then it means previous solution shall be s(0..i-1) matches p(0..j-3), which is dp[i, j-2]
  3. a* matches 1, then it means previous solution is s(0..i-2) matches p(0..j-1) which is dp[i-1,j]
  4. the last condition can be skipped.

 ### 115. Distinct Subsequences.md
 ##### problem Summary
return the number of distinct subsequence of S which is equal to t.

##### idea
this is two string compare with only deletion in S is allowed,
The number of distinct subsequence is similar to climbing stairs.

if s[i-1]!=t[j-1], dp[i,j]=d[i-1,j] where we need skip this char
else we have two choices use this char or not: if we use dp[i,j]=dp[i-1,j-1]
if we do not use dp[i,j]=dp[i-1,j]

This is also similar to walking in a 2d matrix.

##### code
```cpp
    int numDistinct(string s, string t) {
        //dp edit distance
        int m=s.size(),n=t.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        //dp[i,j] represent number of subsequence for s(0...i) vs t[0..j]
        //allowing only deletion from s
        //boundary: dp[0,0]=1
        for(int i=0;i<=m;i++) dp[i][0]=1; //when t is empty, need delete all s
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(s[i-1]!=t[j-1]) dp[i][j]=dp[i-1][j]; //need delete this char, i proceed one
                else dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; //delete: i proceed one, keep: dp[i-1][j-1]
            }
        }
        return dp[m][n];
    }
```

##### comments
- the key is when we delete char i-1, why it is dp[i-1,j] instead of dp[i-1,j-1]?

### 132. Palindrome Partitioning II.md
##### problem summary
find the min number of cut to make s a list of palindrome strings

##### idea
assuming dp[i] is the number of min cut at position i, previous cut position is at j
s[i..j] has to be a palindrome string then
dp[i]=min(dp[i],dp[j]+1) for all dp[j]>0 && s[i..j] is palindrome

fixing the end is kind of clumsy for palindrome problem, if we consider i as the center and grows both end:
1. odd length with center at i and with radius j, s[i-j, i+j]
2. even length with center at i+0.5 and with radius j, s[i-j+1,i+j]

dp[i+j+1]=min(dp[i+j+1],dp[i-j]+1) odd
dp[i+j+1]=min(dp[i+j+1],dp[i-j+1]+1) even

Boundary condition:
max number of cuts for s with i length s[i]=i-1 (by cutting into a single characters)

##### code
```cpp
    int minCut(string s) {
        int n=s.size();
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++) dp[i]=i-1;
        int j=0;
        for(int i=0;i<n;i++)
        {
            //odd expanding
            j=0;while(i-j>=0 && i+j<n && s[i+j]==s[i-j]) dp[i+j+1]=min(dp[i+j+1],dp[i-j]+1),j++;
            //even expanding
            j=0;while(i-j+1>=0 && i+j<n  && s[i+j]==s[i-j+1]) dp[i+j+1]=min(dp[i+j+1],dp[i-j+1]+1),j++;
        }
        return dp[n];
    }
```

##### comments
- dp[0]=-1 is necessary since dp[1] has to be 0 for one char. 



### 140. Word Break II.md
##### problem Summary
Given a string, and a list of words in dictionary, return all possible combinations using words in dictionary

##### idea
since we need combine words by words, using recursive + memoization is simpler. 
We use the front as the sub problem and the ending as the solved, which makes combination easier.
It uses the last word (may have different) recursively added.
for example "catsanddog" dict=["cat","cats","and","sand","dog"]
dog + sub problem catsand
and + sub problem cats -> cats and dog
sand + sub problem cat -> cat sand dog


```cpp
    unordered_map<string, vector<string>> m;

    vector<string> combine(string word, vector<string> prev)
    {
        for(int i=0;i<prev.size();++i)
            prev[i]+=" "+word;
        return prev;
    }

    vector<string> wordBreak(string s, vector<string>& wordDict) 
    {
        unordered_set<string> dict(wordDict.begin(),wordDict.end());
        return wordBreak(s,dict);
    }    

    vector<string> wordBreak(string s, unordered_set<string>& dict) 
    {
        if(m.count(s)) return m[s]; //take from memory
        vector<string> result;
        if(dict.count(s)){result.push_back(s);} //a whole string is a word
        for(int i=s.size()-1;i>=0;i--)
        {
            string word=s.substr(i);
            if(dict.count(word))
            {
                string rem=s.substr(0,i);
                vector<string> prev=combine(word,wordBreak(rem,dict));
                result.insert(result.end(),prev.begin(), prev.end());
            }
        }
        m[s]=result; //memorize
        return result;
    }
```    

##### comments
1. the code is hard to understand. The prev is the solution for the front subproblem which returns a list of words (already combined), so we just append the later word into each of it. It uses the sub-problem: the string return a list of combined words (doing the cut and combination the same time)
2. for the above example:
dog + subproblem(catsand)
subproblem catsand returns a list:
"cats and"
"cat sand"
and then we append the dog which get the final answer.
3. when the subproblem cannot produce a combination, the result is empty and combine will also produce empty (which is a trick here)

### 174. Dungeon Game.md
##### problem Summary
positive: add power
negative: reduce power
power need >=1 to be alive

#### Approach
reverse traverse

##### code
```cpp
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        //this shall be done in reverse order from bottom-right to top-left
        int m=dungeon.size(),n=dungeon[0].size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,INT_MAX));
        //add a right, bottom cell as 1 so that we can apply +1 to the min
        dp[m][n-1]=dp[m-1][n]=1;
        for(int i=m-1;i>=0;i--)
        {
            for(int j=n-1;j>=0;j--)
            {
                int t=min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];
                dp[i][j]=t<=0?1:t; //we need at least add 1 to it
            }
        }
        return dp[0][0];
        
    }
```

##### comment
- need initialize to be int-max
- initial to be 1 so that they can enter the two cells

### 312. Burst Balloons.md
##### problem Summary
Given a list of balloons with number on it. If a balloon is burst, point num[l] * num * num[r] will be added. (l,r is the adjacent left and right balloon)
Ask: to return max point we can get

##### idea
1. add a guardian to avoid boundary. add 1 to left and 1 to right
2. every time we burst a balloon, it depends on the left and right index (we do not want to alter the array and it will be a big mess). It is naturally to use left and right in the dp solutions
3. Once we want to burst balloon i, its points will be nums[i]*nums[l]*nums[r]. And it leaves two parts l to i-1 and i+1 to r. (Between l and r there are multiple elements, we are just assuming after some bursting, l and r becomes adjacent). This is similar to a reverse process. When we solve l, i, r, the previous problem (l, i-1) and (i+1, r) have all be solved. In another word, those balloons are all bursted already.
4. so the recurrence dp[l, r]=max(num[i] * num[l] * num[r]+dp[l,i-1]+dp[i+1,l]), i from l to r

##### code
```cpp
    int maxCoins(vector<int>& nums) {
        nums.insert(nums.begin(),1);
        nums.push_back(1);
        int n=nums.size();
        vector<vector<int>> dp(n,vector<int>(n));
        return helper(nums,1,n-2,dp);
    }
    int helper(vector<int>& nums,int s,int e,vector<vector<int>>& dp)
    {
        if(s>e) return 0;
        if(dp[s][e]>0) return dp[s][e];
        for(int i=s;i<=e;i++)
        {
            dp[s][e]=max(dp[s][e],nums[i]*nums[s-1]*nums[e+1]+helper(nums,s,i-1,dp)+helper(nums,i+1,e,dp));
        }
        return dp[s][e];
    }
```

#### comments
1. start,end are all possible balloon to burst, its left and right are its adjacent. So it is num[i]*num[s-1]*num[e+1]
2. terminate condition then is s>e (s==e is allowed for a single element left)
3. dp[s,e] is exactly a subproblem from start to end (a continuous partial array)
4. These details reflect the correct understanding of the method and shall pay special attention.



### 321. Create Maximum Number.md
#### problem summary
from two arrays with numbers 0-9, create k digits which is the max number.

#### idea:

try all combinations: i+j=k when get i digits from num1, and j digits from num2 and then merge the two.

Get k digits from one array: leave the k-1 digits alone, and find the max digit from 0 to n-k. And then search for the 2nd max after the previous max position.

When merge two arrays, one point need attention: when two elements are the same, we need compare lexicographically the arrays behind them.

For example, 2,1.. and 2,3... If we choose 2 from the 2nd array, then next would 2,1... merge with 3.... and 3 will be chosen and we get 2,3. On the contrary, if we choose 2 from the first array, we then need merge 1... and 2,3..., then we get 2,2 which is not correct.

#### code
```cpp
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        int m=nums1.size(),n=nums2.size();
        //cout<<m<<" "<<n<<" "<<k<<endl;
        if(k>=m+n)  //just merge the two arrays
            return merge(nums1,nums2);
        //try all possible combinations, i from array 1, k-i from array 2
        //i range is [max(m-k,0),min(k,m)], other array range is [max(n-k,0),min(k,n)]
        vector<int> ans(k);
        for(int i=0;i<=min(m,k);i++)
        {
            if(k-i>nums2.size()) continue;
            vector<int> a=maxNumber(nums1,i);
            vector<int> b=maxNumber(nums2,k-i);
            vector<int> c=merge(a,b);
            if(lexicographical_compare(ans.begin(),ans.end(),c.begin(),c.end())) ans=c;
        }
        return ans;
    }
    
    vector<int> maxNumber(vector<int>& v,int k) //get k digits from 1 array
    {
        int n=v.size();
        if(k>=n) return v;
        if(k==0) return vector<int>();
        vector<int> ans(k);
        //greedy choice, the leftmost digit is the max from i+[0,n-(k-1))
        int i=0;
        for(int j=1;j<=k;j++) //repeat k times
        {
            auto it=max_element(v.begin()+i,v.begin()+n-(k-j));
            i=int(it-v.begin())+1; //now the new pointer
            ans[j-1]=*it;
        }
        return ans;
    }
    vector<int> merge(vector<int>& v1,vector<int>& v2)
    {
        int i=0,j=0,k=0;
        vector<int> ans(v1.size()+v2.size());
        while(i<v1.size() && j<v2.size())
        {
            if(v1[i]>v2[j]) {ans[k++]=v1[i++];}
            else if(v1[i]<v2[j]) {ans[k++]=v2[j++];}
            else //two number is equal, choose the one behind is larger
            {
                if(lexicographical_compare(v1.begin()+i,v1.end(),v2.begin()+j,v2.end())) //v1<v2
                {ans[k++]=v2[j++];}
                else {ans[k++]=v1[i++];}
            }
        }
        if(i<v1.size()) copy(v1.begin()+i,v1.end(),ans.begin()+k);
        if(j<v2.size()) copy(v2.begin()+j,v2.end(),ans.begin()+k);
        return ans;
    }
```

#### comments
- this is a typical greedy choice problem. The key is if we want k digits from array, we leave space for the unsolved k-1 digits and greedy choose the max.
- lexicographical_compare is useful for string and array (do not need same length)
- merge two array

### 321. Create Maximum Number.md
#### problem summary
from two arrays with numbers 0-9, create k digits which is the max number.

#### idea:

try all combinations: i+j=k when get i digits from num1, and j digits from num2 and then merge the two.

Get k digits from one array: leave the k-1 digits alone, and find the max digit from 0 to n-k. And then search for the 2nd max after the previous max position.

When merge two arrays, one point need attention: when two elements are the same, we need compare lexicographically the arrays behind them.

For example, 2,1.. and 2,3... If we choose 2 from the 2nd array, then next would 2,1... merge with 3.... and 3 will be chosen and we get 2,3. On the contrary, if we choose 2 from the first array, we then need merge 1... and 2,3..., then we get 2,2 which is not correct.

#### code
```cpp
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        int m=nums1.size(),n=nums2.size();
        //cout<<m<<" "<<n<<" "<<k<<endl;
        if(k>=m+n)  //just merge the two arrays
            return merge(nums1,nums2);
        //try all possible combinations, i from array 1, k-i from array 2
        //i range is [max(m-k,0),min(k,m)], other array range is [max(n-k,0),min(k,n)]
        vector<int> ans(k);
        for(int i=0;i<=min(m,k);i++)
        {
            if(k-i>nums2.size()) continue;
            vector<int> a=maxNumber(nums1,i);
            vector<int> b=maxNumber(nums2,k-i);
            vector<int> c=merge(a,b);
            if(lexicographical_compare(ans.begin(),ans.end(),c.begin(),c.end())) ans=c;
        }
        return ans;
    }
    
    vector<int> maxNumber(vector<int>& v,int k) //get k digits from 1 array
    {
        int n=v.size();
        if(k>=n) return v;
        if(k==0) return vector<int>();
        vector<int> ans(k);
        //greedy choice, the leftmost digit is the max from i+[0,n-(k-1))
        int i=0;
        for(int j=1;j<=k;j++) //repeat k times
        {
            auto it=max_element(v.begin()+i,v.begin()+n-(k-j));
            i=int(it-v.begin())+1; //now the new pointer
            ans[j-1]=*it;
        }
        return ans;
    }
    vector<int> merge(vector<int>& v1,vector<int>& v2)
    {
        int i=0,j=0,k=0;
        vector<int> ans(v1.size()+v2.size());
        while(i<v1.size() && j<v2.size())
        {
            if(v1[i]>v2[j]) {ans[k++]=v1[i++];}
            else if(v1[i]<v2[j]) {ans[k++]=v2[j++];}
            else //two number is equal, choose the one behind is larger
            {
                if(lexicographical_compare(v1.begin()+i,v1.end(),v2.begin()+j,v2.end())) //v1<v2
                {ans[k++]=v2[j++];}
                else {ans[k++]=v1[i++];}
            }
        }
        if(i<v1.size()) copy(v1.begin()+i,v1.end(),ans.begin()+k);
        if(j<v2.size()) copy(v2.begin()+j,v2.end(),ans.begin()+k);
        return ans;
    }
```

#### comments
- this is a typical greedy choice problem. The key is if we want k digits from array, we leave space for the unsolved k-1 digits and greedy choose the max.
- lexicographical_compare is useful for string and array (do not need same length)
- merge two array

### 354. Russian Doll Envelopes.md
#### problem Summary
Given a list of envelopes with width and height. What is the max number of envelops we can russian doll (one put inside another if width and height are both smaller. Rotation is not allowed.

Input: [[5,4],[6,4],[6,7],[2,3]]
Output: 3 

Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).

#### analysis
It is natural to compare each evelope with all others. We can sort the envelpes so that larger one only need to compare with previous smaller ones. (save by half)

2d sort: first sort by width, if width is the same, sort by height.

dp[i] represents the largest russian doll ending at i, dp[i]=max(dp[i],dp[j]+1) if j can fit into i

The answer is max(dp[i]).

boundary condition:
each envelope itself counts 1: dp[i]=1;

This problem seems not that hard.

#### Implementation
```cpp
bool cmp(pair<int,int> a,pair<int,int> b) {return a.first<b.first || (a.first==b.first && a.second<b.second);}
class Solution {
public:
    bool canfit(pair<int,int> a,pair<int,int> b) {return a.first<b.first && a.second<b.second;}
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        int n=envelopes.size();
        if(n==0) return 0;
        sort(envelopes.begin(),envelopes.end(),cmp);
        vector<int> dp(n,1); //dp[i] largest number ending at i (i is the outer envelope)
        for(int i=1;i<n;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(canfit(envelopes[j],envelopes[i])) dp[i]=max(dp[i],dp[j]+1);
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

#### comments:
- boundary is critical for the correctness.




### 403. Frog Jump.md
#### problem summary
A list of stone at different positions in ascending order and first stone is always 0, and first jump is always 1.
frog can only jump on the stones
if previous jump is k, next jump can only be k+1, k, or k-1 steps.
Ask: check if the frog can reach the end.

#### idea
seems like a dfs problem. At every stone, we have 3 options, k, k+1, k-1. If none can reach next stone, we are done here and return 0.
suppose we take k step to reach stone pos[i]:
next is subproblem 

canCross(stones, i, k+1), 
canCross(stones, i, k), 
canCross(stones,i, k-1)

#### code
```cpp
    unordered_map<int,bool> mp;
    bool canCross(vector<int>& stones) {
        //dfs
        return helper(stones,0,1);// || helper(stones,1,2);
    }
    bool helper(vector<int>& stones,int ind,int nextstep) //step is previous step used
    {
        if(nextstep<=0) return 0;
        int key=ind | (nextstep<<11);
        if(mp.count(key)) return mp[key];
        if(stones[ind]+nextstep==stones.back()) return 1;
        int next=stones[ind]+nextstep;
        int it=lower_bound(stones.begin()+ind,stones.end(),next)-stones.begin();
        
        if(it<stones.size() && stones[it]==next) 
            return mp[key]=helper(stones,it,nextstep+1) || helper(stones,it,nextstep) || helper(stones,it,nextstep-1);
        return 0;
    }
```

#### comment
- dfs has to be with memoization since dfs is O(2^n)
- use nextstep is easier.

### 410. Split Array Largest Sum.md
#### problem summary
Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.

Note:
If n is the length of array, assume the following constraints are satisfied:

1 ≤ n ≤ 1000
1 ≤ m ≤ min(50, n)

#### analysis
1. the min sum is the max element in the array, the largest sum is the total sum of the array
2. accumulate ths sum, and array is sorted, segment sum is easily calculated using a[i]-a[j]
3. use binary search until we reach m segments, the idea is:
- use the mid=(lbound+ubound)/2
- if more than m part is needed, mid value is too small, lbound=mid+1
- if less than m part is obtained, mid value is too large, ubound=mid-1
- find how many part is easier given the max sum target. Just iterate and cut. We can consider this is greedy.

#### Implementation
```cpp
    int splitArray(vector<int>& nums, int m) {
        //the sum is between the max and the sum of all elements
        //use the mid value to split and use the greedy algorithm to form split arrays
        //if more than m can be obtained, the mid value is smaller, 
        //if less than m can be obtained, the mid value is larger
        
        int lbound=*max_element(nums.begin(),nums.end());
        int ubound=accumulate(nums.begin(),nums.end(),0);
        if(m<=1) return ubound;
        if(m>=nums.size()) return lbound;
        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];//accumulate sum, and they are sorted
        int mid,maxsum;
        int numseg=0;
        while(lbound<=ubound)
        {
            mid=(lbound+ubound)/2;
            numseg=calcNumSeg(nums,mid,maxsum);
            if(numseg>m) {lbound=mid+1;}
            else {ubound=mid-1;}
        }
        return lbound;//maxsum;
    }
    int calcNumSeg(vector<int>& nums,int midval,int& maxsum)
    {
        int cnt=0,i=0,prevsum=0;
        maxsum=0;
        while(i<nums.size())
        {
            int ind=int(upper_bound(nums.begin()+i,nums.end(),midval+prevsum)-nums.begin());
            if(ind!=nums.size()) 
            {
                maxsum=max(maxsum,nums[ind-1]-prevsum);
                i=ind;
                prevsum=nums[ind-1];
            }
            else 
            {
                maxsum=max(maxsum,nums[ind-1]-prevsum);
                i=ind;
            }
            cnt++;
        }
        return cnt;
    }
```

###  Wildcard Matching.md
#### problem summary
given input string s and match pattern p, ? matches any single char, * matches 0 or more chars.
Check if p matches s.

#### idea
1. two string problem is a 2d dp problem. assuming dp[i, j] represents if s(0..i-1) matches p(0...j-1)
2. when add p[j], it could be a letter, a ? or a *
  - a letter: dp[i, j]=dp[i-1, j-1]&& s[i]==p[j]
  - a ?, always match dp[i, j]=dp[i-1, j-1]
  - a *, 
    - matches 0 char, dp[i, j]=dp[i-1, j]
    - matches 1 or more chars, dp[i, j]=dp[i,j-1] (s can advance one, but p cannot)
    - so when p[j-1]=='*' dp[i,j]=dp[i-1,j]||dp[i, j-1]
3. boundary condition
  -. dp[0, 0]: empty vs empty always true
  -. p empty, s non-empty, no match
  -. s empty, p non-empty, then p can only contains *
    
#### code
```cpp
    bool isMatch(string s, string p) {
        int m=s.size(),n=p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        for(int i=1;i<=n;i++) dp[0][i]=dp[0][i-1] && p[i-1]=='*';
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(p[j-1]!='*') dp[i][j]=dp[i-1][j-1] && (s[i-1]==p[j-1] || p[j-1]=='?');
                else dp[i][j]=dp[i-1][j]||dp[i][j-1];
            }
        }
        return dp[m][n];
    }
```

#### comments
  - complexity O(m*n)
  - one subtle point: when * matches 0, we need advance p, when * matches 1 or more char, s need advance, p cannot (leaving it for latter match).
  - direct dp for two string problem. 
  - similar problem regular expression matching
  
### 446. Arithmetic Slices II - Subsequence.md
#### problem summary
arithmetic subsequence: len>=3 and differene is the same
ask: number of arithmetic subsequence

#### idea
Suppose we are adding A[i] to A[0]...A[i-1]. It could form arithmetic subsequence ending with A[i]
1,3,5: 1 sub
1,3,5,7: 2 subs
1,3,5,7,9:
1,3,5: ending with 5, difference is 2
3,5,7
1,3,5,7: ending with 7, difference is 2
5,7,9
3,5,7,9
1,3,5,7,9: ending with 9, difference is 2
1,5,9: ending with 9, difference is 4

so adding A[i]:
1. it form a new arithmetic subsequence with difference d, dp[i][d]=1, 
2. it extends an existent array with difference d, dp[i][d]=sum(dp[j][d]+1), for all j<i when j has d
  - Why? since we may have duplicate numbers and they count.
  - what about starting from two elements? 
  for example 1,2,3, for 2, d=1. dp[2][1]=1, 
  for 3, we get dp[3][1]=1+1, dp[3][2]=1+0. But we only have 1 subsequence. (so when adding to results, we can just add the dp[j][d].
3. the final answer is the sum of all endings
4. since d can be negative range from INT_MIN to INT_MAX, using a hashmap is more suitable

boundary condition
all zero

#### code
```cpp
    int numberOfArithmeticSlices(vector<int>& A) {
        if(A.empty()) return 0;
        vector<unordered_map<int,int>> dp(A.size());
        int res=0;
        for(int i=1;i<A.size();i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                long long d=(long long)A[i]-A[j];
                if(d<=INT_MIN || d>=INT_MAX) continue;
                dp[i][d]++;
                if(dp[j].count(d)) 
                {
                    dp[i][d]+=dp[j][d];
                    res+=dp[j][d];//reason we add dp[j][d]: we need to get rid of those two-element slices
                }
            }
            
        }
        return res;
    }
```

#### comment
1. using long long for difference is necessary to avoid overflow
2. we add dp[j][d] to make sure we are only counting len>=3 subsequences. (1 element dp is 0, 2 element dp is 1, 3 element dp is 2)

### 466. Count The Repetitions.md
#### problem summary
define S=[s,n] repeat s n times and get S
given s1 and s2, S1=[s1,n1], S2=[s2,n2]
find the max M so that [S2,M] is a subsequence of S1
n1 is [0 1e6] and n2 is [1 1e6]
s1 and s2 max length is 100

#### analysis
the repeated string is up to 10^8. Even O(N) algorithm may get TLE.
if character in s2 is not in s1, then answer is 0

Not a typical dp problem but more likely a greedy problem.

Brutal force: two pointers 
find the repeating pattern of s2 in S1.
What is a repeating cycle? 
The first or last character position of s2 matching position in S1 (repeating segment and its inside index)
When an identical inside index is found, we know the cycle length is the segment!

When we reach the ending char of s2, we reached one segment, record the position in S1 and number of segment of s2 in a hashmap with the key i%s1.length().
When a repeat pattern is found, i%s1.length appeared in the hashmap, then we can safely skip all the repeating pattern until to the remaining part.

```cpp
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        //greedy choice to find the repeat pattern
        int i=0,j=0; //i is for s1 and j is for s2
        int nseg2=0,nseg1=0;
        int m=s1.size(),n=s2.size();
        if(m*n1<n*n2) return 0;
        if(!contains(s1,s2)) return 0;
        unordered_map<int,vector<int>> start_indx; //key is starting inside a seg
        //value0: the repeat number of s2, value 1: the index in S1
        while(i<n1*m)
        {
            while(s1[i%m]!=s2[j%n]) i++;
            if(j%n==n-1) //first char
            {
                nseg2++;
                if(start_indx.count(i%m)) //have found repeat pattern
                {
                    int T=i-start_indx[i%m][0];//the repeat period
                    int R=nseg2-start_indx[i%m][1]; //the repeat s2 segment
                    int nremain=(n1*m-i-1)/T;
                    
                    i+=nremain*T;
                    j+=nremain*R*n;
                    //cout<<T<<" "<<R<<" "<<nremain<<": "<<i<<" "<<j;
                    nseg2+=nremain*R;                    
                }
                else start_indx[i%m]=vector<int>({i,nseg2});
            }
            i++,j++;
        }
        return nseg2/n2;
    }
    bool contains(string s1,string s2)
    {
        unordered_set<char> cs1(s1.begin(),s1.end());
        unordered_set<char> cs2(s2.begin(),s2.end());
        for(auto it=cs2.begin();it!=cs2.end();it++)
            if(cs1.count(*it)==0) return 0;
        return 1;
    }
```

#### comments
- the beginning and ending part shall be treated iteratively
- the mid part is the repeating part and can be skipped
- some apparent non-match shall be pruned first, including length problem and s2 is not a subset of s1.
- I tried to find an equation but failed many times, and has to switch to above solution

### 472. Concatenated Words.md
#### problem Summary
Given a list of words, return all the words in the list which can be combined by other words in the list

#### analysis
1. Apparently we shall first sort the words according to its length, so we only need to check its front words.

2. if a word is found in it, then it is split into left and right sub-problem.

3. so recursion + memoization could be a solution. Memoization shall record what string is already processed.

4. using a hashset is good for searching.

#### Implementation
without memoization
```cpp
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        sort(words.begin(),words.end(),cmp);
        unordered_set<string> dict;
        vector<string> ans;
        unordered_map<string,bool> dp;
        for(int i=0;i<words.size();i++)
        {
            if(canCombine(words[i],dict,dp)) ans.push_back(words[i]);
            dict.insert(words[i]);
        }
        return ans;
    }
    //check if a word can be combined using words from a dictionary
    bool canCombine(string w,unordered_set<string>& dict,unordered_map<string,bool>& dp)
    {
        if(dict.empty()) return 0;
        //if(dp.count(w)) return dp[w];
        if(dict.count(w)) return dp[w]=1;
        
        for(int i=1;i<w.size();i++)
        {
            if(dict.count(w.substr(0,i)))
            {
                if(canCombine(w.substr(i),dict,dp))
                {
                    return dp[w]=1;
                }
            }
        }
        return dp[w]=0;
    }
```
Note using the recorded result is disabled. Some bugs are with the memoization.

Partial DP solution: dp approach is just used for a single word.
The idea is similar to the word break, dp[i] represents if i is good cut position
```cpp
    bool canCombine(string& word,unordered_set<string>& dict)
    {
        if(dict.empty()) return 0;
        vector<bool> dp(word.length()+1);//dp[i]: [0...i-1] substr can be combined
        dp[0]=1;//always can form by an empty string
        for(int i=1;i<=word.length();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(!dp[j]) continue;//previous one is not a word
                string t=word.substr(j,i-j);//note substr 2nd is the length
                if(dict.count(t)) {dp[i]=1;break;} //cannot search the whole set!
            }
        }
        return dp[word.length()];
    }
```

The two solutions runs almost the same time.

#### comments


### 514. Freedom Trail.md
#### problem Summary
On a ring, there is a string. Initially the 0th character is on 12:00 direction. Given a keyword, we need in turn to rotate the letter to 12:00 direction and select it.
Ask: the minimum steps (rotation + selection)

#### idea
1. selection can be ignored since each letter requires exactly one selection.
2. support clockwise and anti-clockwise rotation. Greedy choice will not work to choose the min distance of clockwise and counter-clockwise since it may affect the following rotations
3. correct way is to choose all possible positions and solving the remaining subproblem using its position as the reference point. This is a dfs approach.
4. For convenience we maintain a hashmap with the key as the char and list of positions as its value.

#### code
```cpp
    int findRotateSteps(string ring, string key) {
        //dfs
        int n=ring.size(),m=key.size();
        vector<vector<int>> mp(26);
        for(int i=0;i<ring.size();i++) mp[ring[i]-'a'].push_back(i);
        vector<vector<int>> dp(n,vector<int>(m));
        int minSteps=minsteps(mp,key,0,vector<int>(1,0),n,dp);
        return minSteps+key.length();
    }
    
    int minsteps(vector<vector<int>>& mp,string& key,int start,vector<int> prev,int n,vector<vector<int>>& dp)
    {
        if(start==key.length()) {return 0;}
        if(dp[prev.back()][start]) return dp[prev.back()][start];
        vector<int>& v=mp[key[start]-'a'];
        int sum=INT_MAX;
        for(int i=0;i<v.size();i++)
        {
            int d=abs(v[i]-prev.back());
            d=min(d,n-d);
            prev.push_back(v[i]);
            sum=min(sum,d+minsteps(mp,key,start+1,prev,n,dp));
            prev.pop_back();
        }
        dp[prev.back()][start]=sum;
        return sum;
    }
```

### DP approach:
  dp approach shall use reverse thinking, using the key from right to left since the first status (0th char at 0th position) is known.
  dp[i, j]: represents the min number of moves for subproblem: ring position at i and spell the key 0...j-1. The final answer is dp[0,0].
  When we solved the subproblem i to n-1, and leaving the ring position at i.
  dp[i, j]=min(dp[v[k]][j+1]+d) d is the distance from v[k] to i, and v[k] is the position for key[j].
  
  
#### comments
- previous position is the list of previous position, initialized as 0, since 0th char is at 0 move position
- start is the key position





### 517. Super Washing Machines.md
#### problem Summary
a list of washing machine with some clothes inside, each move choose any number of machine and passing one clothes to machines on its left or right side.

Ask: the min number of move to make each machine the same load

#### idea
target is the average load. We can elmininate those illegal cases. and then subtract the average. The new target will be 0.
A machine with positive value can only pass out clothes.
1. from left to right, we shall give all its load to right to make it 0 (does not matter it is negative or positive). number of move is abs(value). That is like accumulate.

2. the least steps we need to eventually finish this process is determined by the peak of abs(cnt) and the max of "gain/lose" array
refer to:
https://leetcode.com/problems/super-washing-machines/discuss/99185/Super-Short-and-Easy-Java-O(n)-Solution


#### code
```cpp
    int findMinMoves(vector<int>& machines) {
        int n=machines.size();
        int avg=accumulate(machines.begin(),machines.end(),0);
        if(avg%n) return -1;
        avg/=n;
        for(int i=0;i<n;i++) machines[i]-=avg;
        int max0=0,cnt=0;
        for(int i=0;i<n;i++)
        {
            cnt+=machines[i];
            max0=max(max0,max(abs(cnt),machines[i]));
        }
        return max0;
    }
```

#### comments
1. the machine with largest load shall give away all of it. That is one bound
2. at ith position, the prefix sum is another bound: which shall pass out or pass in to it. That is another bound.
3. be sure to include max0 self in the max function, otherwise it will only use current (local) max. 

### 546. Remove Boxes.md
#### problem Summary
Given a list of numbers (different colors), every time you can choose to remove continuous same number (box with same color). If you remove k boxes, you get point k^2.
Return the max point you can get.

#### idea
for example [1, 3, 2, 2, 2, 3, 4, 3, 1]
You can remove 2 first, and let the 3 connected together, 9 points
1,3,3,4,3,1, remove the 4, get 1
1,3,3,3,1 remove the 3, get 9
1,1 remove 1, get 4 total: 23

assuming dp[i,j] is the max points you can get from i to j (inclusive). And the final answer would be dp[0, n-1].

we get the group a[i] to a[i+k], assuming the k+1 elements are the same color, then we have two choices:

    group them and get the score and delete them
    leave them for a while and process other first and hope to have a longer sequence and higher scores.

For the first case, the score is (k+1)^2+subproblem(i+k+1,j)
for the second case, assuming we find mth element==nums[i] and want to combine with a[i, i+k], then we need solve two subproblem first [i+k, m-1] with no previous same char and [m, j] with previous k+1 same char.

Thus the dp needs to add another dimension k, dp[i][j][k] defines the max score we get from the sequence i to j (inclusive) with number of same color box ahead.

dp[i][j][k]=max((k+1)^2+sub(i+k+1,j,0), sub(i+k+1,m-1,0), sub(m, j, k+1))

#### code
```cpp
    int removeBoxes(vector<int> boxes) {
        int n = boxes.size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(n,vector<int>(n)));
        return removeBoxesSub(boxes, 0, n - 1, 0, dp);
    }

    int removeBoxesSub(vector<int>& boxes, int i, int j, int k, vector<vector<vector<int>>>& dp) 
    {
        if (i > j) return 0;
        if (dp[i][j][k] > 0) return dp[i][j][k];
        for (; i + 1 <= j && boxes[i + 1] == boxes[i]; i++, k++); 
        // optimization: all boxes of the same color counted continuously from the first box should be grouped together
        int res = (k + 1) * (k + 1) + removeBoxesSub(boxes, i + 1, j, 0, dp);
        for (int m = i + 1; m <= j; m++) {
            if (boxes[i] == boxes[m]) {
                res = max(res, removeBoxesSub(boxes, i + 1, m - 1, 0, dp) + removeBoxesSub(boxes, m, j, k + 1, dp));
            }
        }
        dp[i][j][k] = res;
        return res;
    }
```

#### comment
- recursive + memoization is more straightforward.
- similar problem: 664 strange printer

### 552. Student Attendance Record II.md
#### problem summary
Given string length n, A: Absent, P: Present, L: Late. A rewardable record is: no more than one A, or more than two continuous L
Return the number of records

#### idea
This is a typical DP problem.
Best approach here: https://leetcode.com/problems/student-attendance-record-ii/discuss/101634/Python-DP-with-explanation

1. there is no A
ending with:
P: dp[i]=dp[i-1]
PL: dp[i]=dp[i-2]
PLL: dp[i]=dp[i-3]

2. With A.
A can be in any position from 0 to j. When A is at j, it divides the string into two strings with no A case:

left from 0 to i-1: dp(i)

right from i+1 to n-1: dp(n-1-i)

sum(dp(left)*dp(right)) j=0 to i

dp[i]: represents the number of strings without A

boundary: dp[0]=1, 
dp[1]=2, P, L
dp[2]=4: PP, PL,LP,LL

#### code
```cpp
    int checkRecord(int n) {
        if(n==0) return 1;
        if(n==1) return 3;
        vector<int> dp(n+1);//dp: number of strings without A
        dp[0]=1;
        dp[1]=2;
        dp[2]=4;
        int mod=1e9+7;
        for(int i=3;i<=n;i++) dp[i]=((long long)dp[i-1]+dp[i-2]+dp[i-3])%mod;
        int result=dp[n];
        
        for(int i=0;i<=n;i++)
        {    
            result+=((long long)dp[i]*dp[n-1-i])%mod;
            result%=mod;
        }
        return result;
    }
```

#### comments
-. dp[i] is the number of strings with length i, without A

-. need use long long for intermediate results to avoid overflow

### 600. Non-negative Integers without Consecutive Ones.md
#### problem Summary
Given n, from 0 to n, return the number of integers whose binary contains no consecuative 1s

#### idea
1. convert n to binary, it will have m bits
2. can we solve problem when n=11111..1 with m bits case? 
Assuming dp[i] is the number of valid string with length i.
  - if previous bit is 1, then we can only add 0 dp[i][0]=dp[i-1][1]
  - if previous bit is 0, then we can add 1 or 0 dp[i][0]=dp[i-1][0], dp[i][1]=dp[i-1][1]
  - above is awkward, if we think in another way, 
  if we define a[i] as the number of valid strings ending with 0, b[i] is the string ending with 1
  we can add 0 no matter previous: 
  a[i]=a[i-1]+b[i-1], 
  we can add 1 only when previous is 0:
  b[i]=a[i-1]
3. subtract all over counted integers when number>n
-. when binary of N appears 11, we just break, since all next smaller
-. when binary of N appears 00, over count those ending with 1

#### code
```cpp
    int findIntegers(int num) {
        string s;
        while(num) {s+=num%2+'0';num/=2;}
        reverse(s.begin(),s.end());//MSB is at 0
        int m=s.length();
        vector<int> dp0(m),dp1(m);
        dp0[0]=1,dp1[0]=1;
        for(int i=1;i<m;i++)
        {
            dp0[i]=dp0[i-1]+dp1[i-1];
            dp1[i]=dp0[i-1];
        }
        int result=dp0[m-1]+dp1[m-1];
        for(int i=1;i<m;i++)
        {
            if(s[i]=='1' && s[i-1]=='1') break;
            if(s[i]=='0' && s[i-1]=='0') result-=dp1[m-i-1];
        }
        return result;
    }
```

#### comments
1. the string of n is in human preference with MSB at the first element in string
2. when previous of n is 00, we need minus dp1[m-i-1] (those > this number is ith bit is 1)
3. if we use LSB at 0, it is easier to understand

  
### 629. K Inverse Pairs Array.md
#### problem summary
given 1 to n, get the number of combinations that having exactly k inverse pairs

#### ideas
assuming we solved problems for [1, i-1], adding i to exisiting condition:
i can be anywhere, for example adding 5 to [1,4]
5xxxx: adding 4 inversion pairs (i-1)
x5xxx: adding 3 (i-2)
xx5xx: adding 2 (i-3)
xxx5x: adding 1 (i-4)
xxxx5: adding 0 (i-5)
we have 5 ways to reach to a specific number of inverse.

dp[i,k] represents the number of permutation with k inverse pairs
according to above observations
if we put n as the last number then all the k inverse pair should come from the first n-1 numbers
if we put n as the second last number then there's 1 inverse pair involves n so the rest k-1 comes from the first n-1 numbers
...
if we put n as the first number then there's n-1 inverse pairs involve n so the rest k-(n-1) comes from the first n-1 numbers

dp[i,k]=dp[i-1,k]+dp[i-1,k-1]+dp[i-1,k-2]+dp[i-1,k-3].....+dp[i-1,k-(i-1)]
using above equation:
dp[i,k-1]=dp[i-1,k-1]+dp[i-1,k-2]+....dp[i-1,k-i]
subtract the two:
dp[i,k]=dp[i-1,k]+dp[i,k-1]-dp[i-1,k-i]

boundary condition:
i=0, there is no inverse pair dp[0][k]=0;
k=0, only sorted array supports dp[i][0]=1
dp[i,0]=1

#### code
```cpp
    int kInversePairs(int n, int k) {
        if (k > n*(n-1)/2 || k < 0) return 0;
        if (k == 0 || k == n*(n-1)/2) return 1;        
        vector<vector<int>> dp(n+1,vector<int>(k+1));
        for(int i=0;i<=n;i++) dp[i][0]=1;
        int mod=1e9+7;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=k;j++) ###
            {
                dp[i][j]=(dp[i-1][j]+dp[i][j-1])%mod;
                if(j-i>=0) dp[i][j]-=dp[i-1][j-i];
                dp[i][j]=(dp[i][j]+mod)%mod;
            }
        }
        return dp[n][k];
    }
```

#### comment
- why dp[0,0]=1?


### 664. Strange Printer.md
#### problem summary
Printer each move prints a list of same characters. Next print will be on the previous print, covering those under.
Given a string, get the min number of moves

#### idea
1. the number of same char does not matter (different from previous problem on remove boxes which is depending on k)
2. when same char is separated, either we connect them or print differently. That is why it is the same as removing boxes.

We don't need the k dimension in this case, since number of char does not matter.
3. this is similar to a series of overlapped segments, greedy choice will not work.

#### code
```cpp
    int strangePrinter(string s) {
        if(s.length()<1) return 0;
        string ss;
        //reduce the string first to avoid time or space TLE
        char c=s[0];
        ss+=s[0];
        for(int i=1;i<s.length();i++) if(s[i]!=c) {c=s[i];ss+=s[i];}
        s=ss;
        int n=s.length();
        vector<vector<int>> dp(n,vector<int>(n));
        return helper(s,dp,0,n-1);
    }
    int helper(string& s,vector<vector<int>>& dp,int i,int j)
    {
        if(i>j) return 0;
        if(i==j) return 1;
        if(dp[i][j]) return dp[i][j];
        //k is the number of same char
        int res=1+helper(s,dp,i+1,j);//no char attached
        for(int m=i+1;m<=j;m++)
        {
            if(s[m]==s[i])
                res=min(res,helper(s,dp,i+1,m-1)+helper(s,dp,m,j));
        }
        dp[i][j]=res;
        return res;
    }
```

#### comments
- please refer to remove boxes, which is almost the same.

### 689. Maximum Sum of 3 Non-Overlapping Subarrays.md
#### problem Summary
Given a array of length n, and a number k, find 3 non-overlap region with k elements each, make the sum largest.
Ask: get the starting index of the 3 segment. If there is tie, choose the smaller index (lexigraphically smaller one)

#### idea
1. There are 3 segments, left, right and mid. left range limits <n-2*k, right range limits >2*k
2. using dp to update the k window sum for left from left to right (dp[i] is the k-window sum max for 0 to i-1)
3. using dp to update the k window sum for right from right to left (dp[i] is the k window sum max for i to n)
4. iterate on all mid position to get the max
5. find the leftmost index satisfying the max

#### Implementation
```cpp
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        //get the partial sum first
        int n=nums.size();
        vector<int> psum(n-k+1);
        psum[0]=accumulate(nums.begin(),nums.begin()+k,0);
        for(int i=1;i<n-k+1;i++) psum[i]=psum[i-1]+nums[i+k-1]-nums[i-1];
        
        vector<int> leftmax(n-k+1),rightmax(n-k+1);
        int tmax=INT_MIN;for(int i=0;i<n-k+1;i++) tmax=leftmax[i]=max(tmax,psum[i]);
        tmax=INT_MIN;for(int i=n-k;i>=0;i--) tmax=rightmax[i]=max(tmax,psum[i]);

        int globalmax=INT_MIN;
        int mid=0,left=0,right=0;
        for(int i=k;i<psum.size()-k;i++) //mid can from k to n-k
        {
            int l=i-k,r=i+k; 
            int localmax=leftmax[i-k]+psum[i]+rightmax[i+k];
            if(globalmax<localmax) //use < so equal max will not be counted in
            {
                globalmax=localmax;
                mid=i;left=i-k;right=i+k;
            }
        }
        
        for(int i=left-1;i>=0;i--) if(leftmax[i]==leftmax[left]) left--;else break;
        for(int i=right+1;i<n-k+1;i++) if(rightmax[i]==rightmax[right]) right++;else break;
        return vector<int>({left,mid,right});
    }
```

### 730. Count Different Palindromic Subsequences.md
#### problem Summary
Given a string of length n, find the number of different Palindrome subsequences, string has only a,b,c,d
Attention: it asks for **subsequences**, not substring

#### ideas
1. it is easy to extend to 26 chars

2. a palindrome string can be from i to j. It is naturally use a start, end pair, or a start, length pair to indicate a palindrome string.

3. dp natural thinking: we start from the (i,len) subproblem and extend to see if we can solve bigger problem
assuming we add a char to s[i, i+len-1] (we use xxxx to indicat the string which is palindrome):

4. if we define dp[i,len,x] as the number of different pal-subsequence starting at i, with length=len, with start/end char =x

if s[i]!='x', we can ignore (remove) first char, dp[i,len,x]=dp[i+1,len-1,x]
else if s[j]!='x', we can ignore (remove) last char, dp[i,len,x]=dp[i,len-1,x] (the head is x but tail is not)

if both are x: 
dp[i,len,x]=dp[i+1,len-2,'a']+dp[i+1,len-2,'b']+dp[i+1,len-2,'c']+dp[i+1,len-2,'d']+2

why?
  - we are adding one x to the head and one x to the tail, which makes xa..ax, xb..bx, xc..cx, xd..dx all different pal-subsequence. Since we are making the length increased by 2, and they are all different.
  
  - +2: we can add x and xx into it since we add two x into previous solution, and we at least have length>=3
  
for example: we have aabaa, the subsequence start and end with a:

a,aa,aaa,aaaa,aba,aabaa

when add a to head and tail, they become:

aaa,aaaa,aaaaaa,aabaa,aaabaaa

and we add a and aa into it.

5. since it only involves len-2, len-1 and len, we only need 3 matrices.

6. The final answer is the sum of start=0, len=n, and char=a, b, c, d

#### Implementation
```cpp
    int countPalindromicSubsequences(string S) {
       int n=S.length();
        int mod=1e9+7;
        //dp[i][len][c]: represents starting at i, with length=len start and ending with c
        vector<vector<int>> dp0(n,vector<int>(4)),dp1(n,vector<int>(4)),dp2(n,vector<int>(4));
        //dp0:len, dp1: len-1, dp2: len-2
        for(int len=1;len<=n;len++)
        {
            for(int i=0;i+len<=n;i++)
            {
                for(int j=0;j<4;j++)
                {
                    dp0[i][j]=0;
                    if(len==1) {dp0[i][j]=(S[i]=='a'+j);continue;}
                    if(S[i]!='a'+j) dp0[i][j]=dp1[i+1][j];//dp[i][len][c]=dp[i+1][len-1][c]
                    else if(S[i+len-1]!='a'+j) dp0[i][j]=dp1[i][j];//dp[i,len,c]=dp[i,len-1,c]
                    else //both ==x
                    {
                        dp0[i][j]=2;
                        if(len>2) for(int k=0;k<4;k++) {dp0[i][j]+=dp2[i+1][k];dp0[i][j]%=mod;} //dp[i+1,len-2,k]
                    }
                    dp0[i][j]%=mod;
                }
            }
            //len increase
            dp2=dp1;
            dp1=dp0;
        }
        //final answer is sum(dp[0,n,c])
        return accumulate(dp0[0].begin(),dp0[0].end(),0LL)%mod;
    }
```

#### comments
- it needs subsequence, not substring, this is very important to the understanding of the algorithm
- need special treat len=1 case
- need special treat len==2 case when add two char (empty)
- when an iteration on len is done, we need update len-1->len-2, len->len-1
- every time len shall be initialized since we reuse the matrix. that is why dp2[i][x]=0 is needed. Attention shall be paid to this.



### 741. cherry pickup.md
#### problem Summary
This is a pretty hard DP problem.

matrix: 0 empty, 1 cherry -1: thorn

You need go roundtrip from top left to bottom right and back to top left and get the max cherry.

### Approach:

- intuitively way that maximizes the first pass and changes the optimal path and then finds the second pass optimal path will not work. Since this will only maximize the first pass and the global optimal is not guaranteed.

- From top left to bottom right is equivalent to from bottom right to top left

- The correct approach is to try the two passes simultaneously and make the two passes optimal. The only constraint is: the two passes cannot pick up the same cherry twice.

- for a matrix n x n, one trip takes 2N-1 steps. We can try all possible locations for two passes for each step and this is the key point. i.e., the first pass goes to (i,j) and second pass goes to (p,q) and i+j=p+q=steps. The only constraint is (i, j)=(p, q). The cherry picked up at these two locations are grid[i, j]+grid[p, q].

- From previous position to current (i,j) and (p,q), the previous combination could be the following: (i-1, j, p-1, q, k-1) (i-1, j, p, q-1, k-1) (i, j-1, p-1, q, k-1) (i, j-1, p, q-1, k-1). k is the number of steps.

- So the recurrence relation is dp(i, j, p, q, k)=max(dp(i-1, j, p-1, q, k-1), dp(i-1, j, p, q-1, k-1), dp(i, j-1, p-1, q, k-1), dp(i, j-1, p, q-1, k-1))+grid(i, j)+grid(p,q).

- Since i and j are associated, also p and q are associated, dp shall not use i and j, but we need use i and p, or j and q. (the x coordinate for two positions or y coordinates for the two passes).

    - dp(i-1, j, p-1, q, k-1) reduced to dp(i-1, p-1, k-1)

    - dp(i-1, j, p, q-1, k-1) reduced to dp(i-1, p, k-1)

    - dp(i, j-1, p-1, q, k-1) reduced to dp(i, p-1, k-1)

    - dp(i, j-1, p, q-1, k-1) reduced to dp(i, p, k-1)
    
Since only k-1 iteration is involved, we may not need the 3rd dimension, but extra care is needed, generally reverse iteration is required to avoid using updated values.

And finally we reached the solution:

Attention:

Since we reduce the 3d problem into 2d problem we need do reverse iteration to use n-1 values

when grid[x][y]<0, we need set dp[x1][x2]=-1 it is necessary since it is dp[x1][x2][n]! and dp[x1][x2][n-1] may be >0 but dp[x1][x2][n] may be <0. Need to keep updating.

two legs can cross the same position, but can only pick the cherry once.

#### code
```cpp
    int cherryPickup(vector<vector<int>>& grid) {
        int n=grid.size();
        vector<vector<int>> dp(n,vector<int>(n,-1));
        dp[0][0]=grid[0][0];
        for(int nstep=1;nstep<2*n-1;nstep++)
        {
            for(int x1=n-1;x1>=0;x1--)
            {
                for(int x2=n-1;x2>=0;x2--) //can share the same position but cannot pick twice
                {
                    int y1=nstep-x1,y2=nstep-x2;
                    if(y1<0 || y2<0 ||y1>=n || y2>=n) continue;
                    if(grid[x1][y1]<0 || grid[x2][y2]<0) {dp[x1][x2]=-1;continue;}
                    int delta=grid[x1][y1];
                    if(x1!=x2) delta+=grid[x2][y2];
                    int best=-1;
                    if(x1 && x2 && dp[x1-1][x2-1]>=0) best=max(best,dp[x1-1][x2-1]+delta);
                    if(y1 && x2 && dp[x1][x2-1]>=0) best=max(best,dp[x1][x2-1]+delta);
                    if(x1 && y2 && dp[x1-1][x2]>=0) best=max(best,dp[x1-1][x2]+delta);
                    if(y1 && y2 && dp[x1][x2]>=0) best=max(best,dp[x1][x2]+delta); 
                    dp[x1][x2]=best; 
                }
            }
        }
        return dp[n-1][n-1]==-1?0:dp[n-1][n-1];
    }

```

### Attention:
- this is a 3d problem with space reduced to 2d, especial care needs attention. one is the reverse iteration, one is setting dp to be -1 when there is a thorn at either position
- cannot pick the same cherry
- initialize to -1 to mark. do not have to be int_min which makes things more complicated.
- complexity O(N^3)

### 787. Cheapest Flights Within K Stops.md
#### problem Summary

from src to dst, find the cheapest cost using at most k stops

#### idea

- since src is fixed, we only need calculate src to all other airport min cost and the answer is src to dst. Why we care about other dest, that is the nature of dp. We solve our problem from other solved problems.

- No need 3D space. Assuming dp[j, k] is the min cost from src to j using at most k stops.

- The key idea using dp approach is:

when we have k-1 stops, we add one more stop to check if the cost will be relaxed.

assuming the added airport is m, then dp[j, k]=min(dp[j, k], dp[m, k-1]+prices[m, j])

Boundary condition:

    1. src to src is 0
    2. src to other station directly is given in flights
    
#### code
```cpp
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
        vector<vector<int>> prices(n,vector<int>(n,INT_MAX)),dp(n,vector<int>(K+1,INT_MAX));
       
        for(int i=0;i<flights.size();i++) 
        {
            if(flights[i][0]==src) dp[flights[i][1]][0]=flights[i][2];
            prices[flights[i][0]][flights[i][1]]=flights[i][2];
        }
              
        for(int k=0;k<=K;k++) dp[src][k]=0;
        
        for(int k=1;k<=K;k++)
        {
            //add one stop based on previous k-1 stop
            for(int j=0;j<n;j++)
            {
                if(src==j) continue;
                for(int m=0;m<n;m++)
                {
                    if(dp[m][k-1]!=INT_MAX && prices[m][j]!=INT_MAX)
                    dp[j][k]=min(dp[j][k],dp[m][k-1]+prices[m][j]);
                }
            }

        }
        return dp[dst][K]==INT_MAX?-1:dp[dst][K];
    }
 ```
 #### comments on the code
 - we build a matrix on the prices, which may have other way to just use the flights, but it is not important
 - boundary: src to src is 0, src to other is given
 - there are quite a few similar problems with at most k times, they are all approached with similar idea: compare add one time on previous k-1 or not add. dp[k-1], dp[k-1]+one transaction.
 - based on above conclusion, there is another equivalent coding:
 ```cpp
         for(int k=1;k<=K;k++)
        {
            //add one stop based on previous k-1 stop
            for(int j=0;j<n;j++)
            {
                if(src==j) continue;
                dp[j][k]=dp[j][k-1]; //not add one stop
                for(int m=0;m<n;m++)
                {
                    if(dp[m][k-1]!=INT_MAX && prices[m][j]!=INT_MAX)
                    dp[j][k]=min(dp[j][k-1],dp[m][k-1]+prices[m][j]);
                }
            }
        }
```        

### 818. Race Car.md
#### problem summary
Initial position 0 and speed +1, and given a target>0
Instruction A: position+=speed, speed*=2;
Instruction R: position no change, speed=+1 if negative, -1 if positive
Ask: minimum length of instructios

#### idea
Greedy choice 1: accelerate until passing target 1+2+4+8+...+2^n>=target and then reverse back. Remaining is a subproblem with reduced target distance.
Greedy choice 2: acceleate and stop before the target, 1+2+4+...+2^n<=target, and then reverse back and go for some steps and reverse back again. Remaining is a subproblem with reduced target distance

choose the min of the two

1+2+4+..+2^n=2^(n+1)-1, total n instructions
n+dp(2^(n+1)-target)+1 +1: represent the R

Reverse before target is more complicated. We need get away from the target for some steps and then reverse back.
n+dp(target-2^n+2^m)+1, +2 represent two time of reverse. The number of m shall <n (we shall make the distance smaller)
stop when it is 0

#### code
```cpp
    int dp[10001];
    int racecar(int t) {
        if (dp[t] > 0) return dp[t];
        int n = floor(log2(t)) + 1, res;
        if (1 << n == t + 1) dp[t] = n;
        else {
            dp[t] = racecar((1 << n) - 1 - t) + n + 1;
            for (int m = 0; m < n - 1; ++m)
                dp[t] = min(dp[t], racecar(t - (1 << (n - 1)) + (1 << m)) + n + m + 1);
        }
        return dp[t];
    }
```

#### comments
- 1 to 2^n only n accelerations
- recursive with memoization is needed to avoid repeative solving same problems.

### 847. Shortest Path Visiting All Nodes.md
#### problem summary
Given a graph with n nodes, the array gives the connected nodes to ith node. Graph is undirected. number of nodes <=12
Ask: get the min length to visit all nodes

#### analysis
1. We shall try all nodes as the starting node.
2. using bitset as the visited for a limited number of nodes
3. shortest path problem generally uses bfs. Here we shall solve n node bfs
4. The key idea: when we add a node's children through some paths (indicated by the status) makes the length shorter. Then we need relax the length to the child

BFS procedure for one starting node:
-. push the node in the queue, set the bit
-. iterate on its children, relax the distance (initialize to max)
-. push the children node into queue
-. until queue is empty

for n nodes the bfs is similar. Just push all starting nodes in the queue. The later starting nodes keeps on relaxing the distances.
May worth a try to test if run n separate bfs the same.

The final answer is starting nodes is min for all i and status is 0b1111111..1.

dp[i,status] represents starting node i, status: all nodes visited.

#### code
```cpp
    struct State{
        int mask,source;
        State(int m,int s):mask(m),source(s){}
    };
    int shortestPathLength(vector<vector<int>>& graph) {
        int m=graph.size();
        int len=1<<m;
        vector<vector<int>> dp(m,vector<int>(len,m*m));
        queue<State> qs;
        for(int i=0;i<m;i++) 
        {
            dp[i][1<<i]=0; //self to self distance is 0
            qs.push(State(1<<i,i)); //try all nodes as starting
        }
        while(!qs.empty()) //until no node is in the queue, which means no node can make it closer
        {
            State state=qs.front();qs.pop();
            for(int next:graph[state.source]) //connected nodes
            {
                int nextmask=state.mask|(1<<next);
                if(dp[next][nextmask]>dp[state.source][state.mask]+1) //if passing its parent node can be closer
                {
                    dp[next][nextmask]=dp[state.source][state.mask]+1;
                    qs.push(State(nextmask,next));//bfs next layer
                }
            }
        }
        //shortest path 
        int ans=INT_MAX;
        for(int i=0;i<m;i++) ans=min(ans,dp[i][(1<<m)-1]);
        return ans;
    }
```

#### comment



### 85. Maximal Rectangle.md
#### problem Summary
Given a matrix mxn, return the max area of rectangle with all 1 inside

#### idea
This can be approached using the max rectangle in histogram using stack.
However we are now using dp method

Dp method can still process row by row, but repeating the 1d problem, which is pretty similar to the histogram problem.

when we add a row matrix[i]:

individual column height: height[j]=0 if m[i,j]=0, height[j]++ if m[i,j]=1

If we know the width for height[j] and then we can calculate the area. (the height is the min from left to right)

needs update row by row

left: left[j]=max(left[j],curr_left) curr_left is the left for current row

right: right[j]=min(right[j],curr_right), curr_right is the right for current row

init left as 0, and right as n.
Since left and right are updated row by row, and we guarantee the height[j] with width (right[j]-left[j]) is a rectangle with all 1.

#### code
```cpp
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.size()==0) return 0;
        int m=matrix.size(),n=matrix[0].size();
        vector<int> left(n),right(n,n),height(n);
        int max_area=0;
        for(int i=0;i<m;i++)
        {
            int curr_left=0,curr_right=n;
            for(int j=0;j<n;j++) height[j]=(matrix[i][j]=='1')?(height[j]+1):0;
            for(int j=0;j<n;j++)
            {
                if(matrix[i][j]=='0') {curr_left=j+1;left[j]=0;}
                else left[j]=max(curr_left,left[j]);
            }
            for(int j=n-1;j>=0;j--)
            {
                if(matrix[i][j]=='0') {curr_right=j;right[j]=n;} //not inclusive
                else right[j]=min(right[j],curr_right);
            }
            for(int j=0;j<n;j++)
            {
                max_area=max(max_area,height[j]*(right[j]-left[j]));
            }
        }
        return max_area;
    }
```

#### comment
1. when meet 0, set left[j]=0 or right[j]=n is necessary since next row update left[j] or right[j] will be bound by previous row. 
2. similar problem maximal square can also be solved using similar code, except the area shall be the min of height and width





### 87. Scramble String.md
#### problem summary
partition a string into left and right recursively.
choose any node and swap its left right branch
The leaf is a scrambled string of original

Check if a new string is a scramble string of s

#### analysis
partition at i, left s[0,i) and right [i,n)
swap left and right: left [i,n) and right [0,i)
we need recursively check if they are scrambled.
left vs left and right vs right
s1[0,i) vs s2[0,i) && s1[i,n) vs s2[i,n)
left vs right and right vs left
s1[0,i) vs s2[n-i,i) && s1[i,n) vs s2[0,n-i)

#### code
```cpp
    bool isScramble(string s1, string s2) {
        if(s1==s2) return 1;
        if(s1.length()!=s2.length()) return 0;
        int n=s1.length();
        //check if the histogram the same
        vector<int> cnt(26);
        for(int i=0;i<s1.length();i++)
        {
            cnt[s1[i]-'a']++;
            cnt[s2[i]-'a']--;
        }
        for(int i=0;i<26;i++) if(cnt[i]) return 0;
        
        for(int i=1;i<=n-1;i++) //possible partition position
        {
            if(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i),s2.substr(i))) return 1;
            if(isScramble(s1.substr(0,i),s2.substr(n-i)) && isScramble(s1.substr(i),s2.substr(0,n-i))) return 1;
        }
        return 0;
    }
```

#### comment
- the iteration i is actually the length of the left string, make sure it reaches n-1
- prune: s1==s2, length not match, histogram match
- check similar problem 951 Flip Equivalent Binary Trees
It uses a tree
```cpp
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if(!root1 && !root2) return 1; //both null
        else if(!root1 || !root2) return 0;
        if(root1->val!=root2->val) return 0;
        if(flipEquiv(root1->left,root2->left) && flipEquiv(root1->right,root2->right)) return 1;
        if(flipEquiv(root1->left,root2->right) && flipEquiv(root1->right,root2->left)) return 1;
        return 0;
    }
```    
### 871. Minimum Number of Refueling Stops.md
#### problem summary
given initial milage, a list of station at different position with adding milage. Find the min number of refueling station to reach target.

#### idea
This is similar to the super egg drop problem.

By solving an equivalent dp problem: what is the max distance using a number of refuelings

assuming dp[i] is the max distance using i refueling stations

dp[i]=max(dp[i], dp[i-1]+gas[j]) with constrains dp[i-1]>=pos[j] (You have to be able to reach pos[j] to add the gas[j])

#### code
```cpp
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        int n=stations.size();
        vector<int> dp(n+1); //the largest miles at each station
        dp[0]=startFuel;
        for(int i=0;i<n;i++) //iterate on all stations
        {
            int pos=stations[i][0],gas=stations[i][1];
            for(int j=i;j>=0;j--)
            {
                if(dp[j]>=pos) dp[j+1]=max(dp[j+1],dp[j]+gas);  //previous station needs update
            }
        }
        for(int i=0;i<=n;i++) if(dp[i]>=target) return i;
        return -1;
    }
 ```
 
 #### comments
 - need iterate all stations and cannot early exit since each station may contribute to the max distance



### 887. Super Egg Drop.md
#### problem summary
given k eggs, and floor 1 to N, there is a floor F 0<=F<<N, when you drop the egg on >F the egg will break. Get the min number of moves required to determine F

#### idea
Since F could be any number, this is a minmax problem, ie. get the min of all the max eggs to guarantee the finding of F.

If we drop egg at floor j, there are two options:

egg does not breaks, then F>j the problem is a smaller problem with k eggs, and N-j floors

egg breaks, the F<j, we are solving problem with k-1 eggs and j-1 floors

so dp(k, n)=min(dp[k,n],1+max(dp[k-1, j-1], dp[k, n-j]) where k is the number of eggs, n is the number of floor, and j is the floor from 1 to n.

The final answer is dp[k,N] with k eggs and N floors

bounary condition:
0 eggs we cannot determine anything, dp[0, i]=0;
i eggs, 0 floor, min number of eggs is also 0. k=0, N=0 is actually not needed. 
1 eggs, i floor, need i moves
i eggs, 1 floor, need 1 moves

And we get the code

```cpp
    int superEggDrop(int K, int N) {
        //
        vector<vector<int>> dp(K+1,vector<int>(N+1));
        for(int i=1;i<=K;i++) dp[i][1]=1;
        for(int i=1;i<=N;i++) dp[1][i]=i;
        for(int k=2;k<=K;k++)
        {
            for(int n=2;n<=N;n++)
            {
                dp[k][n]=INT_MAX;
                for(int j=1;j<=n;j++)
                    dp[k][n]=min(dp[k][n],1+max(dp[k-1][j-1],dp[k][n-j]));
            }
        }
        return dp[K][N];
    }
```
The complexity is O(KN^2), which needs further optimization.
Possible optimization: dp[k-1][j-1] increase with j, and dp[k][N-j] decreases with j. The min of the max of the two can be found using binary search, which reduce the complexity to O(KNlogN)

Inspired @lee215, we can solve an equivalent dp problem: assuming dp[k,m] as using k eggs, m moves, what is the max number of floors we can reach:

if egg breaks: we can check max floor dp[k-1,m-1] <current floor

if egg does not break: we can check max floor dp[k, m-1] > current floor (using current floor as the base 0)

When N floors are checked, F is found. dp[k, m]=N and we find the min m.

dp[k,m]=dp[k-1,m-1]+dp[k,m-1]+1 (the combined below and above number of floors)

Why the above equation: 
dp[k-1, m-1] using m-1 moves and k-1 eggs, the max number of floors we can check (lower than current)
dp[k, m-1] using m-1 moves and k eggs, the max number of floors we can check (higher than current)
+1: the floor we currently checked.

```cpp
    int superEggDrop(int K, int N) {
        //
        vector<vector<int>> dp(K+1,vector<int>(N+1));
        //dp[k,n] now is the max number of floors checked using k eggs and n moves
        for(int m=1;m<=N;m++)
        {
            for(int k=1;k<=K;k++)
                dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1;
            if(dp[K][m]>=N) return m;
        }
    }
```

Above solution can be reduced to 1D since it only involves with m-1. Please attention if using 1D, need to reverse iterate on k since we don't want to use the updated dp[k-1][m] to replace dp[k-1][m-1].

### 903. Valid Permutations for DI Sequence.md
#### problem Summary
D: decrease A[i]>A[i+1], I: increase, A[i]<A[i+1]
Given numbers from 0 to n and DI string of length=n
Ask: number of valid permutations

#### idea
let dp[i,j] represents number of valid permutation with string length i (given number 0 to i) and ending number j
when D: previous number shall be bigger, i.e, j+1 to n, then dp[i,j]=sum(dp[i-1,k]) k=j..i-1 
when I: previous number shall be smaller, i.e from 0 to j-1 then dp[i,j]=sum(dp[i-1,k]) k=0...j-1

final answer: i=n, ending with 0 to n

boundary condition: It only needs previous row values, so the 0th row shall be provided.
i=0, dp[0,0]=1
Actually this is a lower triangle, we do not need to calculate the whole row, they are not used.

#### code
```cpp
    int numPermsDISequence(string S) {
        int n=S.length();
        vector<vector<int>> dp(n+1,vector<int>(n+1));
        //dp[i,j] represents len=i, ending with j (j=0 to i)
        dp[0][0]=1;
        //for(int i=0;i<=n;i++) dp[0][i]=1;
        int mod=1e9+7;
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=i;j++)
            {
                if(S[i-1]=='D') //previous is larger
                {
                    for(int k=j;k<i;k++) {dp[i][j]+=dp[i-1][k];dp[i][j]%=mod;}
                }
                else for(int k=0;k<j;k++) {dp[i][j]+=dp[i-1][k];dp[i][j]%=mod;}
            }
        }
        //print(dp);
        return accumulate(dp[n].begin(),dp[n].end(),0LL)%mod;
    }
```

#### comment
1. when D, **why sum from j to i-1 instead from j+1 to i**? Because for (0...i-1) cases, k can only change from 0 to i-1. for (0..i) case, j can from 0 to i. The j is used already in the previous solution.

So, why start with j, not j + 1, since the sequence is decreasing to j?
Thought Experiment: 
In the sequence with length of i-1, the largest number in this sequence should be i-1. 
However, when we are dealing with length i and end with j, the previous sequence has already another j and we should also add i to the sequence. What we can do is, add one to all those numbers greater than or equal to j. This operation will make the largest number to be i without breaking the sequence property, also, it will free the j so that we can use it at the end of the sequence. 

### 920. Number of Music Playlists.md
#### problem Summary
Given N different songs, create a playlist with L songs, requiring:

each song play at least one time

same song can be played only if K other songs has played
0 <= K < N <= L <= 100

Ask: number of possible playlist (mod 1e9+7)

#### analysis
seems no clue?

It is natural to define the problem as dp(n,l,k) with n songs, l in list, with k constraints.

We need to find how we can build the solution from sub-problems. That is the essence of DP technique.

if only N-1 songs are used in l-1 songs, then the last song can be anyone (not appeared yet)
dp[n,l,k]=n*dp[n-1,l-1,k]

if N songs are used in l-1 songs, then the previous k songs cannot be placed at the list end, which we have N-K choices
dp[n,l,k]=(n-k)*dp[n,l-1,k]

K dimension can be removed.

The answer is the sum of the two: dp[n,l,k]=n*dp[n-1, l-1, k]+(n-k)*dp[n, l-1, k], which is simplified to:

dp[n,l]=dp[n-1,l-1] * n+dp[n,l-1] * (n-k). 

Update only depends on left and up cell.

And the final answer is dp[N,L]

**Boundary condition:**
n=0, there is only 0 playlist dp[0,l]=0 but dp[0,0]=1 (empty vs empty)

since l>=n, we are only updating the upper triangle, and dp[n,n] is the boundary.

dp[n,n]=n! (when n songs and list is also n, any permutation is fine)

#### Implementation
```cpp
    int numMusicPlaylists(int N, int L, int K) {
        vector<vector<long long>> dp(N+1,vector<long long>(L+1));
        dp[0][0]=1;
        int mod=1e9+7;
        for(int i=1;i<=N;i++) dp[i][i]=(dp[i-1][i-1]*i)%mod;
        for(int n=1;n<=N;n++)
        {
            for(int l=n+1;l<=L;l++)
            {
                dp[n][l]=(n*dp[n-1][l-1])%mod;
                if(n>K) dp[n][l]+=((n-K)*dp[n][l-1])%mod;
                dp[n][l]%=mod;
            }
        }
        return dp[N][L];
    }
```

#### comments
- has to use long long for the type since dp[n,l]+= will overflow and we have no way to avoid that
- make sure n>K is added otherwise it will add a negative value
- The main difficulty of the problem is the thinking process or the dp methodology.

### 940. Distinct Subsequences II.md
#### problem summary
Given a string, count all distinct subsequence

#### idea
for example aba
a: ending with a
ab,b: ending with b
ba,aba: ending with a (a is duplicate and shall be removed)

Since the number of subsequence ending with same char could be very large, it is not suitable to store them in a data structure, hence we need find a way to get rid of those duplicates.

When we add a char to the end, we append a char to all previous string ending with from a to z. This is the key observation.
we can use an array of 26 to record the number.

adding all numbers together and the letter itself dp[c]=sum(dp(a to z))+1

#### code
```cpp
    int distinctSubseqII(string S) {
        vector<int> dp(26); //store the number of strings ending with a char a to z
        int mod=1e9+7;
        for(int i=0;i<S.size();i++)
        {
            int ind=S[i]-'a';
            long long t=0;
            for(int j=0;j<26;j++) {t+=dp[j];t%=mod;}
            dp[ind]=t+1; //the letter itself
        }
        return accumulate(dp.begin(),dp.end(),0LL)%mod;
    }
```

#### comments
- be sure to use long long to avoid overflow.
- use 26 char array and update the table is a common practice for string dp problem



### 964. Least Operators to Express Number
Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /).  For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.

When writing such an expression, we adhere to the following conventions:

The division operator (/) returns rational numbers.
There are no parentheses placed anywhere.
We use the usual order of operations: multiplication and division happens before addition and subtraction.
It's not allowed to use the unary negation operator (-).  For example, "x - x" is a valid expression as it only uses subtraction, but "-x + x" is not because it uses negation.
We would like to write an expression with the least number of operators such that the expression equals the given target.  Return the least number of operators used.

x-base number representation

```cpp
    int leastOpsExpressTarget(int x, int target) {
        //dp: x-ary number to use least operations
        //n=sum(Ai*X^i) to use less operator need to compare x^(i+1) and x^i
        vector<int> digits;
        while(target) {digits.push_back(target%x);target/=x;}
        
        int n=digits.size();
        digits.push_back(0);
        vector<int> pos(n+1),neg(n+1);
        pos[0]=digits[0]*2;
        neg[0]=(x-digits[0])*2; //x^0=x/x use more operations
        for(int i=1;i<=n;i++)
        {
            //if use neg, we have a carrier flag to i
            //Aix^i: add Ai times, each with i multplication
            pos[i]=digits[i]*i+min(pos[i-1],neg[i-1]+i); 
            //AiX^i=x^(i+1)-(x-Ai)x^i
            neg[i]=min((x-digits[i])*i+pos[i-1],(x-digits[i]-1)*i+neg[i-1]);
        }
        return min(pos[n],neg[n])-1;
    }
```	

### 691. Stickers to Spell Word
you can use stickes multiple times
min number of sticker to be used to spell out the target
```cpp
    int minStickers(vector<string>& stickers, string target) {
        //target as a hashmap and stickes also a vector of hashmap
        vector<vector<int>> mp_stick(stickers.size(),vector<int>(26));
        //vector<int> mp_target(26);//use ordered_map to form string will be definite
        for(int i=0;i<stickers.size();i++)
        {
            for(int j=0;j<stickers[i].size();j++)
                mp_stick[i][stickers[i][j]-'a']++;
        }
        //for(int i=0;i<target.size();i++) mp_target[target[i]-'a']++;
        //dp is the minimum stickers used for a string, 
        unordered_map<string,int> dp;
        int res=dfs(mp_stick,target,dp); //dfs with memoization
        return res==INT_MAX?-1:res;
    }
    int dfs(vector<vector<int>>& mps,string target,unordered_map<string,int>& dp)
    {
        //dp[string]=min(1+dp[left_over])
        //string target=form_string(mpt);
        //cout<<target<<endl;
        if(dp.count(target)) return dp[target];
        if(target.size()==0) return 0;
        int min_stick=INT_MAX;
        vector<int> mpt(26);
        for(int i=0;i<target.size();i++) mpt[target[i]-'a']++;
        for(int i=0;i<mps.size();i++)
        {
            vector<int>& tmp=mps[i];//the sticker map
            //find the shared characters and greedy pick it
            //vector<int> shared=find_common(tmp,mpt);
            //int cnt=accumulate(shared.begin(),shared.end(),0);
            //if(cnt==0) continue;
            //if(shared.empty()) continue;
            //minus_map(mpt,shared);
            //string ntarget=form_string(mpt);
            string ntarget;
            for(int j=0;j<26;j++) if(mpt[j]>tmp[j]) ntarget.append(mpt[j]-tmp[j],'a'+j);
            if(ntarget==target) continue;
            //cout<<ntarget<<endl;
            int res=dfs(mps,ntarget,dp);
            if(res<INT_MAX)  min_stick=min(min_stick,1+res);//INT_MAX add 1 will overflow
            //add_map(mpt,shared);
        }
        dp[target]=min_stick;
        return min_stick;
    }
```
### 943. Find the Shortest Superstring
Given an array A of strings, find any smallest string that contains each string in A as a substring.

We may assume that no string in A is substring of another string in A.

```cpp
    string shortestSuperstring(vector<string>& A) {
        int n=A.size(); //number of nodes
        vector<vector<int>> graph(n,vector<int>(n));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                graph[i][j]=calc(A[i],A[j]);
                graph[j][i]=calc(A[j],A[i]);
            }
        }
        //dp: also need keep the path
        //other dimension shall be the bitset
        int m=1<<n;
        vector<vector<int>> dp(m,vector<int>(n,INT_MAX)),path(m,vector<int>(n));
        int last=-1,gmin=INT_MAX;
        //dp[i,j]: min distance starting from node j and visiting other nodes indicated in the bitset
        for(int i=1;i<m;i++) //0x0001 to 0xffff
        {
            for(int j=0;j<n;j++)
            {
                if(i & (1<<j)) //if node j is visited
                {
                    int prev=i-(1<<j); //previous status
                    if(prev==0) dp[i][j]=A[j].length();
                    else //try to use other edge to relax  
                    {
                        for(int k=0;k<n;k++)
                        {
                            if(dp[prev][k]<INT_MAX && dp[i][j]>dp[prev][k]+graph[k][j])
                            {
                                dp[i][j]=dp[prev][k]+graph[k][j];
                                path[i][j]=k; //save the node
                            }
                        }
                    }
                }
                if(i==m-1 && gmin>dp[i][j]) {gmin=dp[i][j];last=j;}
            }
        }

        //backtrace to get the results, path stored in path[i][j]
        int curr=m-1; //0xffff
        vector<int> seq;
        cout<<last<<endl;
        while(curr)
        {
            seq.push_back(last);
            int t=path[curr][last];
            curr-=(1<<last);
            last=t;
        }
        //now connect the strings
        string ans=A[seq.back()];//the first
        for(int i=seq.size()-2;i>=0;i--)
        {
            //cout<<seq[i]<<": ";
            int num_app=graph[seq[i+1]][seq[i]];
            int len=A[seq[i]].length();
            //cout<<len<<" "<<num_app<<endl;
            ans+=A[seq[i]].substr(len-num_app);
        }
        return ans;
    }
    
    int calc(string& a,string& b)
    {
        int m=a.size(),n=b.size();
        for(int i=1;i<a.size();i++) //no duplicates
        {
            if(b.substr(0,m-i)==a.substr(i)) return n-(m-i);
        }
        return n;
    }
```

### 968. Binary Tree Cameras	
Given a binary tree, we install cameras on the nodes of the tree. 

Each camera at a node can monitor its parent, itself, and its immediate children.

Calculate the minimum number of cameras needed to monitor all nodes of the tree.

```cpp
    int res = 0;
    int minCameraCover(TreeNode* root) {
        return (dfs(root) < 1 ? 1 : 0) + res;
    }

    int dfs(TreeNode* root) {
        int left = root->left ? dfs(root->left) : 2,//left null, then it is covered?
            right = root->right ? dfs(root->right) : 2;
        if (left == 0 || right == 0) { //not covered
            res++;
            return 1;
        }
        return left == 1 || right == 1 ? 2 : 0;
    }
```	

### 363. Max Sum of Rectangle No Larger Than K
Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.

kadane algorithm
```cpp
 int maxSumSubmatrix(vector<vector<int>>& matrix, int k) 
 {
    if (matrix.empty()) return 0;
    int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;
    for (int l = 0; l < col; ++l) //iterate all columns
    {
        vector<int> sums(row, 0);
        for (int r = l; r < col; ++r) //moving the right column
        {
            for (int i = 0; i < row; ++i) //kadane algorithm, column add
            {
                sums[i] += matrix[i][r];
            }
            
            // Find the max subarray no more than K 
            set<int> accuSet; //sort the results
            accuSet.insert(0);
            int curSum = 0, curMax = INT_MIN;
            for (int sum : sums) 
            {
                curSum += sum;//cumsum
                set<int>::iterator it = accuSet.lower_bound(curSum - k); //>=curSum-k
                if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);
                accuSet.insert(curSum);
            }
            res = std::max(res, curMax);
        }
    }
    return res;
}
```

### 1012. Numbers With Repeated Digits
Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.
```cpp
    int numDupDigitsAtMostN(int N) {
        //equivalent: N-number of digits without repeative
        if(N<10) return 0;
        string s=to_string(N+1);
        int ndigits=s.length();
        int ans=0;
        for(int i=1;i<ndigits;i++) ans+=num_norepeat(i);
        //cout<<ans<<endl;
        //now we need add from 10xxxx0 to N
        //to solve this, for example 321: we first calculate 100-299, then 10-20, and then 1
        ans+=(s[0]-'1')*helper(9,s.length()-1);
        //cout<<ans<<endl;
        unordered_set<int> appeared;
        appeared.insert(s[0]-'0');
        for(int i=1;i<s.length();i++)
        {
            int t=s[i]-'0';
            int nused=appeared.size();
            for(int j=0;j<t;j++)
            {
                if(appeared.count(j)==0)
                    ans+=helper(9-nused,s.length()-i-1);//
            }
                
            if(appeared.count(t)) break;
            appeared.insert(t);
            //cout<<t<<" "<<nused<<endl;
        }
        return N-ans;
        
    }
    int num_norepeat(int ndigits)
    {
        if(ndigits>10 || ndigits<1) return 0;
        int ans=9;
        for(int i=1;i<ndigits;i++) ans*=(10-i);
        return ans;
    }
    int helper(int n,int len)
    {
        //if(len==0) return n;
        int ans=1;
        for(int i=0;i<len;i++) ans*=(n-i);
        return ans;
    }
```


### 1000. Minimum Cost to Merge Stones	
There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones.

A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.

```cpp
    int mergeStones(vector<int>& stones, int K)
    {
        int N = (int)stones.size();
        if((N - 1) % (K - 1)) return -1;

        vector<int> sum(N + 1, 0);
        for(int i = 0; i < N; i++) sum[i + 1] = sum[i] + stones[i];

        vector<vector<int> > dp(N + 1, vector<int>(N, 0));
        for(int l = K; l <= N; l++)
            for(int i = 0; i + l <= N; i++)
            {
                dp[l][i] = 10000;
                for(int k = 1; k < l; k += K - 1)
                    dp[l][i] = min(dp[l][i], dp[k][i] + dp[l - k][i + k]);
                if((l - 1) % (K - 1) == 0) dp[l][i] += sum[i + l] - sum[i];
            }
        return dp[N][0];
    }
```

### 902. Numbers At Most N Given Digit Set
We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.)

Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'.

Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.

```cpp
    int atMostNGivenDigitSet(vector<string>& D, int N) {
        string NS = to_string(N);
        int digit = NS.size(), dsize = D.size(), rtn = 0;
        
        for (int i = 1 ; i < digit ; ++i)
            rtn += pow(dsize, i);
        
        for (int i = 0 ; i < digit ; ++i) {
            bool hasSameNum = false;
            for (string &d : D) {
                if (d[0] < NS[i]) 
                    rtn += pow(dsize, digit - i - 1);
                else if (d[0] == NS[i]) 
                    hasSameNum = true;
            }
            if (!hasSameNum) return rtn;
        }               
        return rtn+1;
    }
```


	
