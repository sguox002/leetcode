hard review

4	Median of Two Sorted Arrays    		26.5%	Hard	
10	Regular Expression Matching    		25.3%	Hard	
23	Merge k Sorted Lists    		34.7%	Hard	
25	Reverse Nodes in k-Group    		36.6%	Hard	
30	Substring with Concatenation of All Words    		23.7%	Hard	
32	Longest Valid Parentheses    		25.6%	Hard	
37	Sudoku Solver    		37.2%	Hard	
41	First Missing Positive    		29.0%	Hard	
42	Trapping Rain Water    		43.3%	Hard	
44	Wildcard Matching    		22.9%	Hard	
45	Jump Game II    		28.1%	Hard	
51	N-Queens    		39.5%	Hard	
52	N-Queens II    		52.2%	Hard	
57	Insert Interval    		31.3%	Hard	
65	Valid Number    		14.0%	Hard	
68	Text Justification    		23.4%	Hard	
72	Edit Distance    		37.9%	Hard	
76	Minimum Window Substring    		30.9%	Hard	
84	Largest Rectangle in Histogram    		31.3%	Hard	
85	Maximal Rectangle    		33.5%	Hard	
87	Scramble String    		31.7%	Hard	
97	Interleaving String    		28.1%	Hard	
99	Recover Binary Search Tree    		34.8%	Hard	
115	Distinct Subsequences    		35.1%	Hard	
123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
126	Word Ladder II    		17.8%	Hard	
128	Longest Consecutive Sequence    		41.8%	Hard	
132	Palindrome Partitioning II    		27.5%	Hard	
135	Candy    		28.5%	Hard	
140	Word Break II    		27.4%	Hard	
145	Binary Tree Postorder Traversal    		48.7%	Hard	
149	Max Points on a Line    		15.8%	Hard	
154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
174	Dungeon Game    		27.2%	Hard	
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
212	Word Search II    		28.8%	Hard	
214	Shortest Palindrome    		27.6%	Hard	
218	The Skyline Problem    		31.7%	Hard	
224	Basic Calculator    		32.8%	Hard	
233	Number of Digit One    		30.2%	Hard	
239	Sliding Window Maximum    		38.3%	Hard	
248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
282	Expression Add Operators    		32.8%	Hard	
291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard	
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
354	Russian Doll Envelopes    		34.0%	Hard	
358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
391	Perfect Rectangle    		28.2%	Hard	
403	Frog Jump    		36.2%	Hard	
407	Trapping Rain Water II    		39.3%	Hard	
410	Split Array Largest Sum    		42.4%	Hard	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
425	Word Squares    		44.4%	Hard	
428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
458	Poor Pigs    		45.4%	Hard	
460	LFU Cache    		28.9%	Hard	
465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
471	Encode String with Shortest Length    		45.2%	Hard	
472	Concatenated Words    		34.8%	Hard	
479	Largest Palindrome Product    		27.4%	Hard	
480	Sliding Window Median    		32.6%	Hard	
483	Smallest Good Base    		34.2%	Hard	
488	Zuma Game    		39.0%	Hard	
489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
514	Freedom Trail    		40.6%	Hard	
517	Super Washing Machines    		37.0%	Hard	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
552	Student Attendance Record II    		33.2%	Hard	
564	Find the Closest Palindrome    		18.8%	Hard	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard

*******always purse short and concise implementation**********

## divide and conquer/binary search

4	Median of Two Sorted Arrays    		26.5%	Hard	
one array m, one n, for odd, it is (m+n+1)/2
for even it is two mid value average.
Approach 1: merge sort and it is O(m+n)
Approach 2: use binary search (count the number < the mid) O(log(m)+log(n))
two sorted array. two problem find the (m+n+1)/2 and (m+n+1)/2+1 element
or find kth element.
using la, ra for array a, and lb, rb for array b.
then the mid for a and mid for b divide the two array into 4 parts
a: [la,ma], [ma,ra]
b: [lb,mb], [mb,rb]
a[ma]<=b[mb]: 

```cpp
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //binary search shall be the best strategy for this problem
        //to find kth number recursively. 
        int m=nums1.size(),n=nums2.size();
        double v=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2);
        double v1;
        if((m+n)%2==0) {v1=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2+1);v=(v+v1)*0.5;}
        return v; 
          
    }
    int findkth(vector<int>& va,vector<int>& vb,int la,int ra,int lb,int rb,int k)
    {
        if(la>ra) return vb[lb+k-1];
        if(lb>rb) return va[la+k-1];
        
        int ma=(la+ra)/2,mb=(lb+rb)/2;
        if(va[ma]<=vb[mb])
        {
            if(k<=(ma-la)+(mb-lb)+1) return findkth(va,vb,la,ra,lb,mb-1,k);
            else return findkth(va,vb,ma+1,ra,lb,rb,k-(ma-la)-1);
        }
        else //va[ma]>vb[mb]
        {
            if(k<=ma-la+mb-lb+1) return findkth(va,vb,la,ma-1,lb,rb,k);
            else return findkth(va,vb,la,ra,mb+1,rb,k-(mb-lb)-1);
        }
    }
```	
- this is a typical divide and conquer problem using binary search

87	Scramble String    		31.7%	Hard	
similar to flip left right tree
split the string s1 into left and right, and s2 similar
4 subproblem: {LL,RR} {lR,RL}
recursive:
```cpp
    bool isScramble(string s1, string s2) {
        if(s1==s2)
            return true;
            
        int len = s1.length();
        int count[26] = {0};
        for(int i=0; i<len; i++)
        {
            count[s1[i]-'a']++;
            count[s2[i]-'a']--;
        }
        
        for(int i=0; i<26; i++)
        {
            if(count[i]!=0)
                return false;
        }
        
        for(int i=1; i<=len-1; i++)
        {
            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))
                return true;
            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))
                return true;
        }
        return false;
    }
```	

154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
contain duplicates using binary search
the min is the first true in the array.
so when A[mid]==A[r] r--
A[mid]<A[r] r=m (mid could be the answer)
A[mid]>A[r] l=m+1 (m could not be the answer)
```cpp
	int findMin(vector<int>& nums) {
		int l=0,r=nums.size()-1;
		while(l<r)
		{
			int m=l+(r-l)/2;
			if(nums[m]<nums[r]) r=m;
			else if(nums[m]>nums[r]) l=m+1;
			else r--;//nums[m]==nums[r], this same thing cannot be the solution
		}
		return nums[l];
	}
```
301	Remove Invalid Parentheses    		39.4%	Hard	
string contains () and other letters
return all possible results.
()())()
first choice: ()()() remove 5th )  this can count from left to right when cnt<0 remove that )
second choice: (())() remove 2nd ). this can count from right to left
need use backtracking
paired using cnt++ for ( and cnt-- for )

Key Points:

Generate unique answer once and only once, do not rely on Set.
Do not need preprocess.
Runtime 3 ms.
Explanation:
We all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter.
The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.

To make the prefix valid, we need to remove a ‘)’. 
The problem is: which one? The answer is any one in the prefix. 
However, if we remove any one, we will generate duplicate results, 
for example: s = ()), we can remove s[1] or s[2] but the result is the same (). 
Thus, we restrict ourself to remove the first ) in a series of concecutive )s.

After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. 
If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.
For this, we keep tracking the last removal position and only remove ‘)’ after that.

Now one may ask. What about ‘(‘? What if s = ‘(()(()’ in which we need remove ‘(‘?
The answer is: do the same from right to left.
However a cleverer idea is: reverse the string and reuse the code!

```cpp
    vector<string> removeInvalidParentheses(string s) {
        vector<string> ans;
        helper(s,ans,0,0,{'(',')'});
        return ans;
    }
    void helper(string s,vector<string>& ans,int lasti,int lastj,vector<char> par)
    {
        int cnt=0;
        for(int i=lasti;i<s.size();i++)
        {
            if(s[i]==par[0]) cnt++;
            if(s[i]==par[1]) cnt--;
            if(cnt<0)
            {
                for(int j=lastj;j<=i;j++)
                {
                    if(s[j]==par[1] && (j==lastj || s[j-1]!=par[1]))
                        helper(s.substr(0,j)+s.substr(j+1),ans,i,j,par);
                }
                return; 
            }
        }
        string rs=s;
        reverse(rs.begin(),rs.end());
        if(par[0]=='(') helper(rs,ans,0,0,{')','('}); //finished left to right
        else ans.push_back(rs);//finished right to left
    }
```	

410	Split Array Largest Sum    		42.4%	Hard	
Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
typical binary search problem
search in the range, [max_element, total_sum]
could have multiple choices, we need find the first true.

```cpp
    int splitArray(vector<int>& nums, int m) {
        //the sum is between the max and the sum of all elements
        //use the mid value to split and use the greedy algorithm to form split arrays
        //if more than m can be obtained, the mid value is smaller, 
        //if less than m can be obtained, the mid value is larger
        
        int lbound=*max_element(nums.begin(),nums.end());
        int ubound=accumulate(nums.begin(),nums.end(),0);
        if(m<=1) return ubound;
        if(m>=nums.size()) return lbound;
        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];//accumulate sum, and they are sorted
        //copy(nums.begin(),nums.end(),ostream_iterator<int>(cout," "));cout<<endl;
        int mid,maxsum;
        int numseg=0;
        while(lbound<=ubound)
        {
            //cout<<mid<<endl;
            mid=(lbound+ubound)/2;
            numseg=calcNumSeg(nums,mid,maxsum);
            //cout<<mid<<" "<<numseg<<endl;
            if(numseg>m) {lbound=mid+1;}
            else {ubound=mid-1;}
        }
        return lbound;//maxsum;
    }
    int calcNumSeg(vector<int>& nums,int midval,int& maxsum)
    {
        int cnt=0,i=0,prevsum=0;
        maxsum=0;
        while(i<nums.size())
        {
            int ind=int(upper_bound(nums.begin()+i,nums.end(),midval+prevsum)-nums.begin());
            if(ind!=nums.size()) 
            {
                /*if(nums[ind]==midval+prevsum) {maxsum=max(maxsum,nums[ind]-prevsum);i=ind+1;prevsum=nums[ind];}
                else */{maxsum=max(maxsum,nums[ind-1]-prevsum);i=ind;prevsum=nums[ind-1];}
            }
            else {maxsum=max(maxsum,nums[ind-1]-prevsum);i=ind;}
            cnt++;
        }
        return cnt;
    }
```

483	Smallest Good Base    		34.2%	Hard	
in the base all 1s.
binary search: 
or brutal force search: n=sum(k^i) =(k^(m+1)-1)/(k-1), k<n^(1/m)<k+1

```cpp
    string smallestGoodBase(string n) {
       //approach n=sum(k^i) =(k^(m+1)-1)/(k-1), k<n^(1/m)<k+1
       //so only need to consider n^(1/m) m from 2 to log2(n)
        long long nn=stoll(n);
        int max_m=log2(nn);
        //cout<<nn<<":"<<max_m;
        for(int m=max_m;m>1;m--)
        {
            int k=pow(nn,1.0/m);
            //long long t=(mypow(k,m+1)-1)/(k-1); //will overflow!
            if((nn-1)%k) continue;
            else
            {
                long long t=(mypow(k,m)-1)/(k-1); //will overflow!
                //cout<<m<<" "<<k<<" "<<t<<endl;
                if((nn-1)/k==t) return to_string(k);//note power cannot be used since it does not have the precision
            }
        }
        return to_string(nn-1);
    }
    
    long long mypow(int k,int m)
    {
        long long res=1;
        for(int i=0;i<m;i++) res*=k;
        return res;
    }
```	

668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
binary search
this is sorted matrix, row sorted and col sorted.
height mxn
similar to 378. only difference is mxn instead of nxn.
378 has two approaches:
1. priority queue (min heap and adding current min's next larger element into it.
multiplication table has a lot of duplicates.
2. binary search. 

multiplication table at M(i,j)=(i+1)*(j+1)
so the matrix is symmetric. 

similarly we can use binary search. 
given the mid value, we count number of elements <=mid
for a value mid, we may have duplicates. 
so when cnt>=k it may be an answer r=m


```cpp
    int findKthNumber(int m, int n, int k) {
		int l=1,r=m*n;
		while(l<r)
		{
			int mid=l+(r-l)/2;
			int cnt=cntle(mid);
			if(cnt>=k) r=m;
			else l=m+1;
		}
		return l;
    }
	int cntle(int mid,int m,int n) //count numbers <=mid
	{
		int ans=0;
		for(int i=1;i<=m;i++)
			ans+=min(mid/i,n);
		return ans;
	}

```	

786	K-th Smallest Prime Fraction    		39.8%	Hard	
a division table using pq or binary search
```cpp
    struct quad
    {
        int a,b,i,j;
        quad() {}
        quad(int x,int y,int m,int n):a(x),b(y),i(m),j(n){}
    };
    struct compare
    {
        bool operator()(const quad& a,const quad& b) {return a.a*1.0/a.b>b.a*1.0/b.b;}
    };
public:
    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {
        if(A.size()==0) return vector<int>();
        int n=A.size();
        if(K>n*(n-1)/2) K=n*(n-1)/2;
        priority_queue<quad,vector<quad>,compare> p;
        //A[0]/A[n] is always the smallest
        for(int i=1;i<A.size();i++) p.push(quad(A[0],A[i],0,i));
        vector<int> ans(2);
        quad q;
        while(K--)
        {
            q=p.top();p.pop();
            int i=q.i,j=q.j;
            //cout<<i<<" "<<j<<":"<<A[i]<<"/"<<A[j]<<endl;
            if(i<A.size()-1) p.push(quad(A[i+1],A[j],i+1,j));//next bigger one
        }
        ans[0]=q.a;ans[1]=q.b;
        return ans;
    }
```	
binary search
a list of prime numbers
for every p<q in the list forms the fraction. return the kth fraction.

similar to multiplication table, but now forms a upper matrix of division table.

every row is sorted from right to left.
every col is sorted from top to down.

define the search range: min is 1/max, max is 2nd_max/max we can use 1.
do we use double? bad idea, we need calculate all the combinations. and store in a matrix
we can use double m and m*denominator to find the divisor

```cpp
    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {
		double l=0, r=1;
		int n=A.size();
		int p,q;
		while(l<r)
		{
			double m=l+(r-l)/2;
			int cnt=cntle(A,m,p,q);
            //cout<<m<<":"<<cnt<<endl;
			if(cnt>K) r=m;
			else if(cnt<K) l=m;
			else return {p,q};
		}
        return {p,q};
    }
	int cntle(vector<int>& A,double v,int&p,int& q)
	{
		int ans=0;
		int n=A.size();
		p=0,q=1;
		for(int i=0;i<n-1;i++) //upper triangle
		{
			for(int j=i+1;j<n;j++)
				if(A[i]<=A[j]*v) //A[i]/A[j]<=v
				{
					ans+=n-j;//ith line starts from i+1
					if(p*A[j]<q*A[i]) {p=A[i],q=A[j];} //p/q<A[i]/A[j]
					break;
				}
		}
		return ans;
	}
```
O(N^2logn) 

719	Find K-th Smallest Pair Distance    		29.2%	Hard	
approach1: sort it using the abs(diff) and then use heap. it has n^2 elements so it is O(N^2)
approach2: sort the array and using binary search and count number < the mid.
```cpp
    int smallestDistancePair(vector<int>& a, int k) {
        sort(a.begin(), a.end());
        int n = a.size(), lo = 0, hi = a[n-1] - a[0], ans = -1;
        while (lo <= hi) {
            int cnt = 0, j = 0, md = (lo + hi)/2;
            for (int i = 0; i < n; ++i) {
                while (j < n && a[j] - a[i] <= md) ++j;
                cnt += j - i-1;
            }
            if (cnt >= k) {
                ans = md;
                hi = md - 1;
            }
            else lo = md + 1;
        }
        
        return ans;
    }
```

878	Nth Magical Number    		25.5%	Hard	
magic number: it is divisible by A and B.
binary search: the number is in the range [min(A,B),N*min(A,B)] choose a mid and count the numbers <N.

```cpp
    int nthMagicalNumber(int N, int A, int B) {
        int ans=0;
        int lcm=A*B/gcd(A,B);
        int mod=1e9+7;
        long l=min(A,B), r=N*l;
        while(l<r)
        {
            long m=l+(r-l)/2;
            int n=m/A+m/B-m/lcm;
            if(n<N) l=m+1;
            else r=m;
        }
        return l%mod;
    }
    int gcd(int a,int b)
    {
        if(!b) return a;
        return gcd(b,a%b);
    }
```

679	24 Game    		42.9%	Hard	
4 numbers from 1 to 9, apply +-*/() to get the value of 24
actually we do not have to put ()
divide and conquer: compute any combination using +-*/ and reduce to one item

```cpp
    bool judgePoint24(vector<int>& nums) {
        //recursive approach. 
        //for all combination check if we can get 24
        //pick any two numbers and do +-*/ and reduce to 3 numbers, then 2 and then 1
        vector<double> v(nums.size());
        for(int i=0;i<nums.size();i++) v[i]=nums[i];
        return search24(v);
    }
    
    bool search24(vector<double> v)
    {
        if(v.size()==1) return abs(v[0]-24)<1e-7;
        vector<double> list;
        char op[]={'+','*','-','/'};
        for(int i=0;i<v.size();i++)
        {
            for(int j=0;j<v.size();j++)
            {
                if(i==j) continue; //same cards cannot be used
                //pick v[i] op v[j]
                //+ * a+b=b+a a*b=b*a so do not have to compute
                for(int k=0;k<4;k++) //operations
                {
                    if((op[k]=='+' || op[k]=='*') && i>j) continue;
                    if(op[k]=='/' && v[j]==0) continue; //cannot divide 0
                    double res;
                    switch(op[k])
                    {
                        case '+': res=v[i]+v[j];break;
                        case '-': res=v[i]-v[j];break;
                        case '*': res=v[i]*v[j];break;
                        case '/': res=v[i]/v[j];break;
                    }
                    //remove i,j and add res int a new list
                    list.clear();
                    for(int l=0;l<v.size();l++) if(l!=i && l!=j) list.push_back(v[l]);
                    list.push_back(res);
                    //for(int l=0;l<list.size();l++) cout<<list[i]<<",";cout<<endl;
                    if(search24(list)) return 1;
                }
            }
        }
        return 0;
        
    }
```	

805	Split Array With Same Average    		24.4%	Hard	
split the array into two parts, so that the average is the same
assuming group A has k elements, B has n-k elements
Asum/k=Bsum/(n-k)-->B=A*(n-k)/k-->A+B=A*n/k=T-->A/k=T/n. so the target is the original average.
also T*k/n must be a integer so T*k%n==0
and it is changed to a combination sum problem then.

```cpp
    bool splitArraySameAverage(vector<int>& A) {
        int n = A.size(), m = n/2, totalSum = accumulate(A.begin(), A.end(), 0);
        sort(A.rbegin(), A.rend()); // Optimization
        for (int i = 1; i <= m; ++i) 
            if (totalSum*i%n == 0 && combinationSum(A, 0, i, totalSum*i/n)) return true;
        return false;
    }
    bool combinationSum(vector<int>& nums, int idx, int k, int tar) {
        if (tar > k * nums[idx]) return false; // Optimization, A is sorted from large to small
        if (k == 0) return tar == 0;
        for (int i = idx; i <= nums.size()-k; ++i) 
            if (nums[i] <= tar && combinationSum(nums, i+1, k-1, tar-nums[i])) return true;
        return false;
    }
```	

## dp
10	Regular Expression Matching    		25.3%	Hard	
dp, two string matching problem s and t.
'.' matches any single char if t[j]=='.' dp[i][j]=dp[i-1][j-1]
'*' matches zero or more of the **preceding** char
Problem summary
'.' matches any single char and '*' matches 0 or more of preceding char

idea
two string direct dp problem, dp[i, j] represents if s[0...i-1] matches p[0...j-1]
p[j-1] is letter or ., dp[i, j]=dp[i-1, j-1]&&(s[i-1]==p[j-1]||p[j-1]=='.')
p[j-1]=='', assuming previous char is a, then a
matches 0 char, previous char is skipped, a* matches empty, dp[i,j]=dp[i,j-2] (s(0...i-1) matches p(0...j-3). Note: we are using previous solution for current solution!)
matches 1 char, then dp[i,j]=(s[i-1]==p[j-2] || p[j-2]=='.') && dp[i,j-1] (a* counts as one a, s(0..i-1) matches p[0..j-2])
matches more than 1 char, a* represents multiple a, dp[i,j]=(s[i-1]==p[j-2] || p[j-2]=='.') && dp[i-1,j] (depends s(0...i-2) matches p(0...j-1)). 
Actually this case is included in match 1 char.
boundary condition
dp[0,0]=1, empty vs empty
p empty, s non-empty, all false, col 0 shall not be included in loop.
s empty, p non-empty, must have .* letter* to match 0 char dp[0,i]=dp[0, i-2] && p[j-1]=='*'
extra complexity: it involves p[j-2] and dp[j-2], which indicates that row 1 needs to be included in boundary. A common approach is: we do not involve the boundary except col 0, but using the recurrence relation to process the boundary. This is much simpler in some cases when the boundary is not so straightforward.
1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];
2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];
3, If p.charAt(j) == '*': 
   here are two sub conditions:
               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty
               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':
                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a 
                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a
                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty
boundary condition: it must have a* pattern, so it is dp[0][i-2]						   
code
    bool isMatch(string s, string p) {
        int m=s.size(),n=p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        //p is empty, s non-empty all false is straightforward dp[i][0]=0
        //put other boundary in loops
        for(int i=0;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(p[j-1]!='*') dp[i][j]=i && dp[i-1][j-1] && (s[i-1]==p[j-1] || p[j-1]=='.');
                else dp[i][j]=(j>1 &&dp[i][j-2]) 
                    || (i && j>1 && dp[i][j-1] && (s[i-1]==p[j-2] || p[j-2]=='.'))
                    || (i && j>1 && dp[i-1][j] && (s[i-1]==p[j-2] || p[j-2]=='.'));
            }
        }
        return dp[m][n];
    }
comments
when boundary is hard to write, include it in the loop
a* matches empty, then it means previous solution shall be s(0..i-1) matches p(0..j-3), which is dp[i, j-2]
a* matches 1, then it means previous solution is s(0..i-2) matches p(0..j-1) which is dp[i-1,j]
the last condition can be skipped.
or
```cpp
    bool isMatch(string s, string p) {
        int m=s.size(),n=p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1; //empty vs empty
        //pattern empty, string non-empty all 0
        //string empty, pattern non-empty
        for(int i=1;i<=n;i++) if(i>1) dp[0][i]=dp[0][i-2]&&p[i-1]=='*';
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(p[j-1]!='*')
                    dp[i][j]=dp[i-1][j-1]&&(s[i-1]==p[j-1]||p[j-1]=='.');
                else if(j>1)//*
                    dp[i][j]=dp[i][j-2] || //matches 0 previous char a* matches empty
                    (dp[i][j-1] && (s[i-1]==p[j-2] || p[j-2]=='.')) || //a* matches one char
                    (dp[i-1][j] && (s[i-1]==p[j-2] || p[j-2]=='.')); //a* matches multiple chars
            }
        }
        return dp[m][n];
    }
```
	
44	Wildcard Matching    		22.9%	Hard	
typical two string compare dp problem
? matches any single char
* matches any sequence of char (including empty)
Problem summary
given input string s and match pattern p, ? matches any single char, * matches 0 or more chars. Check if p matches s.

idea
two string problem is a 2d dp problem. assuming dp[i, j] represents if s(0..i-1) matches p(0...j-1)
when add p[j], it could be a letter, a ? or a *
a letter: dp[i, j]=dp[i-1, j-1]&& s[i]==p[j]
a ?, always match dp[i, j]=dp[i-1, j-1]
a *,
matches 0 char, dp[i, j]=dp[i-1, j]
matches 1 or more chars, dp[i, j]=dp[i,j-1] (s can advance one, but p cannot)
so when p[j-1]=='*' dp[i,j]=dp[i-1,j]||dp[i, j-1]
boundary condition -. dp[0, 0]: empty vs empty always true -. p empty, s non-empty, no match -. s empty, p non-empty, then p can only contains *
code
```cpp
    bool isMatch(string s, string p) {
        int m=s.size(),n=p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1; //empty vs empty
        //pattern empty, string non-empty all 0
        //string empty, pattern non-empty
        for(int i=1;i<=n;i++) dp[0][i]=dp[0][i-1]&&p[i-1]=='*';//must be *****
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(p[j-1]!='*')
                    dp[i][j]=dp[i-1][j-1]&&(s[i-1]==p[j-1]||p[j-1]=='?');
                else 
                    dp[i][j]=dp[i][j-1] || //matches 1 char s[0..i-1] matches p[0...j-2]
                        dp[i-1][j]; //matches 0 char or more s[0...i-2] matches p[0...j-1]
            }
        }
        return dp[m][n];
    }
```	
comments
complexity O(m*n)
one subtle point: when * matches 0, we need advance p, when * matches 1 or more char, s need advance, p cannot (leaving it for latter match).
direct dp for two string problem.
similar problem regular expression matching

72	Edit Distance    		37.9%	Hard	
insert/delete/replace
typical dp problem
If word1[i - 1] != word2[j - 1], we need to consider three cases.

Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1);
If word1[0..i - 1) = word2[0..j) then delete word1[i - 1] (dp[i][j] = dp[i - 1][j] + 1);
If word1[0..i) + word2[j - 1] = word2[0..j) then insert word2[j - 1] to word1[0..i) (dp[i][j] = dp[i][j - 1] + 1).
```cpp
    int minDistance(string w1, string w2) {
        int m=w1.size(),n=w2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        dp[0][0]=0;
        
        for(int i=1;i<=m;i++) dp[i][0]=i;//s2 is empty, delete all
        for(int i=1;i<=n;i++) dp[0][i]=i;//s1 is empty, delete all
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    int ins=dp[i][j-1]+1; //insert w2[j-1] so that s1[0...i-1] matches s2[0..j-1]
                    int del=dp[i-1][j]+1; //del w1[j-1] so that s1[0...i-2] matches s2[0...j-1]
                    int rep=dp[i-1][j-1]+1;//replace so that w1[0..i-1] matches s2[0..j-1]
                    dp[i][j]=min({ins,del,rep});
                }
            }
        }
        return dp[m][n];
    }
```	
we will see edit distance can have multiple variation.
need to understand the subproblems! otherwise we cannot get it right.

943	Find the Shortest Superstring    		38.1%	Hard	
this is a good question: travelling salesman problem.

similar problem: shortest superstring of two string. it uses subsequences.
but this question needs substring. suffix A and prefix B shall be maxmized, so the overlap can be maxmized
convert the overlaps to distance to each other (directed graph) and then min the distance.
dijkstra: need to trace back to get the path.
approach: 
- first generate the graph data structure using nxn matrix
- need visit all nodes and also need to reverse back the path
- dp[i,j] represents the min distance from node i to node j.
- use a bitset to indicate if a node visited or not
- using any other nodes to relax the distance between i to j.
```cpp
    string shortestSuperstring(vector<string>& A) {
        int n=A.size();
        vector<vector<int>> graph(n,vector<int>(n));
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                graph[i][j]=overlap(A[i],A[j]);
                graph[j][i]=overlap(A[j],A[i]);
            }
        }
        //limit 12 words, we need visit all nodes
        int m=1<<n;
        int gmin=INT_MAX,last=-1;
        vector<vector<int>> dp(m,vector<int>(n,INT_MAX)),path(m,vector<int>(n));
        for(int i=1;i<m;i++) {//0x001 to 0xfff
            for(int j=0;j<n;j++){
                if(i & (1<<j)) {//node j is set, and we want to relax j
                    int prev=i-(1<<j);
                    if(prev==0) dp[i][j]=A[j].size(); //initial length
                    else{
                        for(int k=0;k<n;k++) { //use k node to relax distance
                            if(dp[prev][k]<INT_MAX){
                                if(dp[i][j]>dp[prev][k]+graph[k][j]){
                                    dp[i][j]=dp[prev][k]+graph[k][j];
                                    path[i][j]=k;
                                }
                            }
                        }
                    }
                }//end if
                if(i==m-1 && gmin>dp[i][j]) {gmin=dp[i][j];last=j;}
            }//end j loop
        }//end i loop
        //traceback to get the route
        int curr=m-1;
        vector<int> seq;
        while(curr){
            seq.push_back(last);
            int t=path[curr][last];
            curr-=1<<last;
            last=t;
        }
        //now connect the strings in reverse way.
        string ans=A[seq.back()];
        for(int i=seq.size()-2;i>=0;i--)
        {
            int num_app=graph[seq[i+1]][seq[i]];
            int len=A[seq[i]].length();
            ans+=A[seq[i]].substr(len-num_app);
        }
        return ans;        
        
    }
    //number of chars to append: the sum of all shall be minimized.
	int overlap(string& a,string& b){ //actually it is not overlap, this is number of chars to append to A
        //A+B: A's suffix=B's prefix
        int m=a.size(),n=b.size();
        for(int i=1;i<a.size();i++) //no duplicates
        {
            if(b.substr(0,m-i)==a.substr(i)) return n-(m-i);
        }
        return n;
    }
```
this is really hard. O(N^2*2^n)
graph[i][j] means the length of string to append when A[i] followed by A[j]. eg. A[i] = abcd, A[j] = bcde, then graph[i][j] = 1
dp[i][j]: means when the shortest distance when last visit j (some nodes have been visited before j)
for example: 
["catg","ctaagt","gcta","ttca","atgcatc"]
the dp:
.	.	.	.	.	
4	.	.	.	.	
.	6	.	.	.	
10	10	.	.	.	
.	.	4	.	.	
8	.	7	.	.	
.	7	10	.	.	
11	10	13	.	.	
.	.	.	4	.	
6	.	.	8	.	
.	10	.	9	.	
11	12	.	13	.	
.	.	8	8	.	
10	.	9	11	.	
.	11	13	10	.	
12	12	14	13	.	
.	.	.	.	7	
10	.	.	.	8	
.	12	.	.	13	
16	13	.	.	14	
.	.	11	.	10	
13	.	12	.	12	
.	14	16	.	14	
17	15	17	.	15	
.	.	.	11	10	
13	.	.	12	10	
.	15	.	15	15	
17	15	.	16	15	
.	.	14	14	14	
16	.	14	16	14	
.	17	19	17	16	
19	17	19	18	16	//all visited, the min is 16 (which gives the shortest length)

00: 0	0	0	0	0	
01: 0	0	0	0	0	
02: 0	0	0	0	0	
03: 1	0	0	0	0	
04: 0	0	0	0	0	
05: 2	0	0	0	0	
06: 0	2	1	0	0	
07: 1	2	0	0	0	
08: 0	0	0	0	0	
09: 3	0	0	0	0	
10: 0	3	0	1	0	
11: 3	0	0	1	0	
12: 0	0	3	2	0	
13: 3	0	0	2	0	
14: 0	2	3	1	0	
15: 3	2	0	1	0	
0: 0	0	0	0	0	
0: 4	0	0	0	0	
0: 0	4	0	0	1	
0: 1	4	0	0	0	
0: 0	0	4	0	2	
0: 4	0	4	0	0	
0: 0	2	1	0	1	
0: 4	2	1	0	0	
0: 0	0	0	4	3	
0: 3	0	0	4	0	
0: 0	4	0	1	3	
0: 3	4	0	1	0	
0: 0	0	4	4	2	
0: 3	0	4	2	0	
0: 0	2	1	1	3	
31: 3	2	1	1	0	//previous position for all visited
sequence is 4,0,3,1,2
the traceback:
last 4: 0x1f-->0 (parent is 0)
clear bit 4: [0xf][0] we get 3
clear bit 0: [0x0e][3] we get 1
clear bit 3: [0x06][1] we get 2

reconstruct the string: adding sequence 2,1,3,0,4

Then the problem becomes to: find the shortest path in this graph which visits every node exactly once. This is a Travelling Salesman Problem.
Apply TSP DP solution. Remember to record the path.

1092. Shortest common supersequence
approach 1: find the longest common subsequence and add only once of the gcd
approach 2: using edit distance to find the shortest common supersequence (the common used only once)
using lcs and backtracing to get the answer.
```cpp
    string shortestCommonSupersequence(string str1, string str2) {
        //edit distance problem, remove one of the common char
        string t=lcs(str1,str2);
        return t;
        //connect the two string 
    }
    string lcs(string& s1,string& s2){
        //using dp, and we need backtrace the longest common subsequence
        int m=s1.size(),n=s2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        dp[0][0]=0;
        for(int i=1;i<=m;i++) dp[i][0]=i;
        for(int i=1;i<=n;i++) dp[0][i]=i;
        string ans;
        int maxlen=0;
        int start=-1;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(s1[i-1]==s2[j-1]) 
                    dp[i][j]=dp[i-1][j-1]+1;
                else 
                    dp[i][j]=1+min(dp[i-1][j],dp[i][j-1]);
            }
        }
        //backtrace to get the answer string, using s2 only
        //print(dp);
        maxlen=dp[m][n];
        //int i=m,j=n;
        int i = m, j = n; 
        while (i > 0 && j > 0) 
        { 
            // If current character in X and Y are same, then 
            // current character is part of shortest supersequence 
            if (s1[i - 1] == s2[j - 1]) 
            { 
                // Put current character in result 
                ans.push_back(s1[i - 1]); 
                i--, j--, maxlen--; 
            } 

            // If current character in X and Y are different 
            else if (dp[i - 1][j] > dp[i][j - 1]) 
            { 
                // Put current character of Y in result 
                ans.push_back(s2[j - 1]); 
                j--, maxlen--; 
            } 
            else
            { 
                // Put current character of X in result 
                ans.push_back(s1[i - 1]); 
                i--, maxlen--; 
            } 
        } 

        // If Y reaches its end, put remaining characters 
        // of X in the result string 
        while (i > 0) 
        { 
            ans.push_back(s1[i - 1]); 
            i--, maxlen--; 
        } 

        // If X reaches its end, put remaining characters 
        // of Y in the result string 
        while (j > 0) 
        { 
            ans.push_back(s2[j - 1]); 
            j--, maxlen--; 
        } 

        // reverse the string and return it 
        reverse(ans.begin(), ans.end()); 
        return ans; 
    }
```
-. use dp to find the shortest common supersequence.
	s1[i]==s2[j] then choose one: dp[i][j]=dp[i-1,j-1]+1
	otherwise dp[i,j]=1+min(dp[i-1,j],dp[i,j-1])
-. traceback the dp is tricky:

lee's solution to find the lcs string without backtracing.
```cpp
    string shortestCommonSupersequence(string& A, string& B) {
        int i = 0, j = 0;
        string res = "";
        for (char c : lcs(A, B)) {
            while (A[i] != c)
                res += A[i++];
            while (B[j] != c)
                res += B[j++];
            res += c, i++, j++;//do not forget to advance i and j
        }
        return res + A.substr(i) + B.substr(j); //adding the trailing part
    }

    string lcs(string& A, string& B) {
        int n = A.size(), m = B.size();
        vector<vector<string>> dp(n + 1, vector<string>(m + 1, ""));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                if (A[i] == B[j])
                    dp[i + 1][j + 1] = dp[i][j] + A[i];
                else
                    dp[i + 1][j + 1] = dp[i + 1][j].size() > dp[i][j + 1].size() ?  dp[i + 1][j] : dp[i][j + 1];
        return dp[n][m];
    }
```
this is interesting, we just put the dp as the direct answer.
and then use a greedy to build the answer without the tricky backtracing.

we can also try to get the superstring directly using edit distance
if A[i]==B[j] then we just add 1 char
if A[i]!=B[j] we choose previous smaller one:
dp[i][j-1] for s[0...i-1] and t[0...j-2]. if it is shorter, we need append 
dp[i-1][j] for s[0..i-2] and t[0...j-1]

```cpp
    string shortestCommonSupersequence(string& A, string& B) {
        int n = A.size(), m = B.size();
        vector<vector<string>> dp(n + 1, vector<string>(m + 1));
        for(int i=1;i<=n;i++) dp[i][0]=dp[i-1][0]+A[i-1];
        for(int i=1;i<=m;i++) dp[0][i]=dp[0][i-1]+B[i-1];
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j)
                if (A[i-1] == B[j-1])
                    dp[i][j] = dp[i-1][j-1] + A[i-1];
                else //choose min length
                    dp[i][j] = dp[i][j-1].size()<dp[i-1][j].size() ?  dp[i][j-1]+B[j-1] : dp[i-1][j]+A[i-1];
        return dp[n][m];
    }
```
the problem is the memory requirement is too large. and will get MLE for a long example.	but it is a good practice for the edit distance variation.
	
97	Interleaving String    		28.1%	Hard	
check if s3 is interleaving of s1 and s2
2d path using dp. 
```cpp
    bool isInterleave(string s1, string s2, string s3) {
        int m=s1.size(),n=s2.size();
        if(s3.size()!=m+n) return 0;
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0] && s3[i-1]==s1[i-1];
        for(int i=1;i<=n;i++) dp[0][i]=dp[0][i-1] && s3[i-1]==s2[i-1];
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                dp[i][j]=(dp[i-1][j] && s3[i+j-1]==s1[i-1]) ||
                    (dp[i][j-1] && s3[i+j-1]==s2[j-1]);
            }
        }
        return dp[m][n];
    }
```	
115	Distinct Subsequences    		35.1%	Hard	
Problem Summary
return the number of distinct subsequence of S which is equal to t.

idea
this is two string compare with only deletion in S is allowed, The number of distinct subsequence is similar to climbing stairs.

if s[i-1]!=t[j-1], dp[i,j]=d[i-1,j] where we need skip this char else we have two choices use this char or not: if we use dp[i,j]=dp[i-1,j-1] if we do not use dp[i,j]=dp[i-1,j]

This is also similar to walking in a 2d matrix.

code
```cpp
    int numDistinct(string s, string t) {
        int m=s.size(),n=t.size();
        vector<vector<long>> dp(m+1,vector<long>(n+1));
        //dp[i,j] the number of sequence matches s[0..i-1] and p[0...j-1]
        for(int i=0;i<=m;i++) dp[i][0]=1; //t is empty: only empty can match
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(s[i-1]!=t[j-1]) //we need skip this char
                    dp[i][j]=dp[i-1][j];
                else dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; //use it or not use it.
            }
        }
        return dp[m][n];
    }
```	
comments
- the key is when we delete char i-1, why it is dp[i-1,j] instead of dp[i-1,j-1]. since adding this char makes the same amount of subsequence
- easily overflow

123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
two transaction, it is a special edition of K transaction.

188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
the idea is based on previous k-1 transaction, add a more transaction
dp[k][i]=max(dp[k][i-1],dp[k-1][j]+price[i]-price[j]), no operation or operation
```cpp
    int maxProfit(int k, vector<int>& prices) {
       int n=prices.size();
        if(k>=n/2)
        {
            int sum=0;
            for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) sum+=prices[i]-prices[i-1];
            return sum;
        }
        vector<vector<int>> dp(k+1,vector<int>(n));
        int maxprof=0;
        
        for(int t=1;t<=k;t++)
        {
            int tmin=INT_MAX;
            for(int i=1;i<n;i++)
            {
                tmin=min(tmin,prices[i-1]-dp[t-1][i-1]);
                dp[t][i]=max(dp[t][i-1],prices[i]-tmin);
                maxprof=max(maxprof,dp[t][i]);
            }
        }
        return maxprof;
    }
```	
note the inner side has some optimization to reduce O(N^2) to O(N)
so the complexity is O(NK).

132	Palindrome Partitioning II    		27.5%	Hard	
return min number of cuts so that each substr is a palindrome.
this is a dp. odd length and even length
cut[i] min number of cuts at i.
two subproblems: odd length and even length pal-string.
```cpp
    int minCut(string s) {
        int n = s.size();
        vector<int> cut(n+1, 0);  // number of cuts for the first k characters
        for (int i = 0; i <= n; i++) cut[i] = i-1; //boundary: cut it into single char.
        for (int i = 0; i < n; i++) {
            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome
                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);

            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome
                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);
        }
        return cut[n];
    }
```	
- implementation on this is not that simple.
- bounary condition -1,0,.....n-1
- the two inner loop is tricky.

140	Word Break II    		27.4%	Hard	
a list of words and a string, cut it into dictionary words.
return all possible combination.
Similar question 139 Word break (check if it is breakable). 
first, using dp to find all cut positions and its previous cut. and then use dfs with backtracking
dp it is convenient to add previous index and then we have to do reverse dfs.
```cpp
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        unordered_map<int,vector<string>> mp; //end position and its possible cut string
        unordered_set<string> dict(wordDict.begin(),wordDict.end());
        vector<bool> dp(s.length()+1);
        dp[0]=1;
        if(s.size()<2)
        {
            if(dict.count(s)) return vector<string>({s});
        }
        //if(dict.count(s.substr(0,1))) mp[0].push_back(s.substr(0,1));
        for(int i=1;i<=s.size();i++)
        {
            for(int j=i-1;j>=0;j--) //check all previous cut
            {
                if(dp[j])
                {
					string t;
					t=s.substr(j,i-j);//not including j, j+1 to i both inclusive
					if(dict.count(t)) {mp[i].push_back(t);dp[i]=1;}//does not include i=0 case
                }
            }
        }
        //print(mp);
        if(mp.count(s.size())==0) return vector<string>();
        //now we can use dfs to search all possible combinations
        unordered_map<int,vector<string>> mps;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            for(int i=0;i<it->second.size();i++) 
                mps[it->first-it->second[i].size()].push_back(it->second[i]);
        }
        //print(mps);
        vector<string> ans;
        string sentence;
        dfs(mps,0,s.size(),ans,sentence);
        return ans;
    }
    void dfs(unordered_map<int,vector<string>>& mp,int start,int end,vector<string>& res,string sentence)
    {
        if(start>=end) {sentence.pop_back();res.push_back(sentence);sentence+=" ";return;}
        for(int i=0;i<mp[start].size();i++) //try all cuts
        {
            sentence+=mp[start][i]+" ";
            int sz=mp[start][i].size();
            dfs(mp,start+sz,end,res,sentence);
            //cout<<sentence<<" "<<sentence.size()<<","<<sz<<endl;
            sentence.erase(sentence.size()-sz-1);//remove the last word + space
        }
    }
```
this is too complicated, and prone to bugs. using divide and conquer is a better choice
consider this also a dp problem using top down+memoization.
dp+dfs can choose the top down method to finish two at the same time.

always prefer shorter and concise code!!!!
approach:
-. we are using the prefix as the subproblem for convenience
-. we use hashset for memoization.
-. append the suffix word to all subproblem output (combine)
-. append all the strings into answer.

```cpp
    unordered_map<string, vector<string>> m;
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> ms(wordDict.begin(),wordDict.end());
        return wordBreak(s,ms);
    }
    vector<string> wordBreak(string s, unordered_set<string>& dict) {
        if(m.count(s)) return m[s]; //take from memory
        vector<string> result;
        if(dict.count(s)){ //a whole string is a word
            result.push_back(s);
        }
        for(int i=1;i<s.size();++i){
            string word=s.substr(i);
            if(dict.count(word)){
                string rem=s.substr(0,i);
                vector<string> prev=combine(word,wordBreak(rem,dict));
                result.insert(result.end(),prev.begin(), prev.end());
            }
        }
        m[s]=result; //memorize
        return result;
    }    
    vector<string> combine(string word, vector<string> prev){
        for(int i=0;i<prev.size();++i){
            prev[i]+=" "+word;
        }
        return prev;
    }
```
We shall always choose the most concise approach due to very limited time!!!!
since there could be a lot of repetions, so memoization is needed.

472. Concatenated words
first we need sort the words in dictionary from shorter length to longer length
since longer word can be combined using shorter words only
so we build the dictionary one by one.
each one is a problem of 139. 
```cpp
bool cmp1(const string& s1,const string& s2) {return s1.length()<s2.length();}
class Solution {
public:
    
    struct cmp
    {//note the 3 const are required!!!!
        bool operator()(const string& s1,const string& s2) const {return s1.length()<s2.length();}
    };
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        //sort the words using length
        vector<string> res;
        sort(words.begin(),words.end(),cmp1);
        //copy(words.begin(),words.end(),ostream_iterator<string>(cout," "));cout<<endl;
        unordered_set<string> dict;
        
        //multiset<string,cmp> dict(words.begin(),words.end()); //note if the length are the same it is not inserted!!!
        
        for(int i=0;i<words.size();i++)
        {
            if(canCombine(words[i],dict))
            {
                res.push_back(words[i]);
            }
            dict.insert(words[i]);
            //copy(dict.begin(),dict.end(),ostream_iterator<string>(cout," "));cout<<endl;
        }
        return res;
    }
    bool canCombine(string& word,unordered_set<string>& dict)
    {
        if(dict.empty()) return 0;
        vector<bool> dp(word.length()+1);//dp[i]: [0...i-1] substr can be combined
        dp[0]=1;//always can form by an empty string
        for(int i=1;i<=word.length();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(!dp[j]) continue;//previous one is not a word
                string t=word.substr(j,i-j);//note substr 2nd is the length
                //cout<<j<<","<<i<<":"<<t<<" "<<dict.count(t)<<endl;
                if(dict.count(t)) {dp[i]=1;break;} //cannot search the whole set!
            }
        }
        return dp[word.length()];
    }
};
```

174	Dungeon Game    		27.2%	Hard	
dp reverse direction
```cpp
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        //this shall be done in reverse order from bottom-right to top-left
        int m=dungeon.size(),n=dungeon[0].size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,INT_MAX));
        //add a right, bottom cell as 1 so that we can apply +1 to the min
        dp[m][n-1]=dp[m-1][n]=1;
        for(int i=m-1;i>=0;i--)
        {
            for(int j=n-1;j>=0;j--)
            {
                int t=min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];
                dp[i][j]=t<=0?1:t; //we need at least add 1 to it
            }
        }
        return dp[0][0];
        
    }
```	

312	Burst Balloons    		47.4%	Hard	
burst balloon you get nums[left]*nums[i]*nums[right]
this is a very good dp problem. Since the balloon is burst then it is gone and we need connect and if it is not a good choice we have restore back.
thus it created many choices.
But if we think it reversely, it will be much more clear. We assume ith balloon is the last one to burst, then we know its boundary is -1 and n.
and two subproblem [-1,i-1] and [i+1,n] is already solved

this hints: 
-  add a guardian to avoid boundary. add 1 to left and 1 to right
- every time we burst a balloon, it depends on the left and right index (we do not want to alter the array and it will be a big mess). It is naturally to use left and right in the dp solutions
Once we want to burst balloon i, its points will be nums[i]*nums[l]*nums[r]. And it leaves two parts l to i-1 and i+1 to r. (Between l and r there are multiple elements, we are just assuming after some bursting, l and r becomes adjacent). This is similar to a reverse process. When we solve l, i, r, the previous problem (l, i-1) and (i+1, r) have all be solved. In another word, those balloons are all bursted already.
so the recurrence dp[l, r]=max(num[i] * num[l] * num[r]+dp[l,i-1]+dp[i+1,l]), i from l to r

```cpp
    int maxCoins(vector<int>& nums) {
        nums.insert(nums.begin(),1);
        nums.push_back(1);
        int n=nums.size();
        vector<vector<int>> dp(n,vector<int>(n));
        return helper(nums,1,n-2,dp);
    }
    int helper(vector<int>& nums,int s,int e,vector<vector<int>>& dp)
    {
        if(s>e) return 0;
        if(dp[s][e]>0) return dp[s][e];
        for(int i=s;i<=e;i++)
        {
            dp[s][e]=max(dp[s][e],nums[i]*nums[s-1]*nums[e+1]+helper(nums,s,i-1,dp)+helper(nums,i+1,e,dp));
        }
        return dp[s][e];
    }
```

329	Longest Increasing Path in a Matrix    		40.1%	Hard	
dfs with memoization, dp top down
```cpp
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.size()==0) return 0;
        int m=matrix.size(),n=matrix[0].size();
        int maxlen=0;
        vector<vector<int>> dp(m,vector<int>(n));
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                maxlen=max(maxlen,dfs(matrix,i,j,INT_MIN,dp));
            }
        }
        return maxlen;
    }
    
    int dfs(vector<vector<int>>& mat,int i,int j,int prev,vector<vector<int>>& dp)
    {
        if(i<0 || j<0 || i>=mat.size() || j>=mat[0].size() || mat[i][j]<=prev) return 0;
        if(dp[i][j]) return dp[i][j];
        int d=mat[i][j];
        mat[i][j]=INT_MIN;
        int d0=1+dfs(mat,i-1,j,d,dp);
        int d1=1+dfs(mat,i+1,j,d,dp);
        int d2=1+dfs(mat,i,j-1,d,dp);
        int d3=1+dfs(mat,i,j+1,d,dp);
        mat[i][j]=d;
        return dp[i][j]=max({d0,d1,d2,d3});
    }
```

354	Russian Doll Envelopes    		34.0%	Hard	
(w,h), return the max number of envelopes you can russina doll.
only fit in if w and h > the other to be fitted.
a binary search or dp problem.
binary search: get the last true position
dp: if i can fit in j then dp[i]=dp[j]+1
same as the longest increasing subsequence problem.
```cpp
bool cmp(pair<int,int>& a,pair<int,int>& b) {return a.first<b.first || (a.first==b.first && a.second<b.second);}
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        //unordered_map<int,vector<int>> mp;
        sort(envelopes.begin(),envelopes.end(),cmp);
        //using dp
        vector<int> dp(envelopes.size(),1); //dp is the maximum length to i
        int gmax=0;
        for(int i=0;i<envelopes.size();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(canfit(envelopes[j],envelopes[i])) dp[i]=max(dp[j]+1,dp[i]);
            }
            gmax=max(gmax,dp[i]); //the global max
        }
        return gmax;
        //merge them! choose the one with max depth! longest increasing path this needs dp!
    }
    bool canfit(pair<int,int>& a,pair<int,int>& b) {return a.first<b.first && a.second<b.second;}
};
```

403	Frog Jump    		36.2%	Hard	
stones are located at different positions. frog is on the first stone, first step is 1
if last jump step is k, current step is k, K+1 or K-1. only forward jump
return if frog can jump to the last stone
approach: recursive, or dfs
- stones into a hashset
- which step can go to next stone, try it

```cpp
    bool canCross(vector<int>& stones) {
        if(stones.size()<2) return 1;
        if(stones[1]!=1) return 0;
        if(stones.size()==2) return 1;
        for(int i=1;i<stones.size();i++)
            if(stones[i] - stones[i-1] > i) return 0; //key point !!
        unordered_set<int> hs(stones.begin(),stones.end());
        return canReach(hs,1,1,stones.back());
    }
    
    bool canReach(unordered_set<int>& hs,int pos,int jmp,int last)
    {
        if(pos+jmp==last || pos+jmp-1==last || pos+jmp+1==last) return 1;
        if(hs.count(pos+jmp+1))
            if(canReach(hs,pos+jmp+1,jmp+1,last)) return 1;
        
        if(hs.count(pos+jmp))
            if(canReach(hs,pos+jmp,jmp,last)) return 1;
        
        if(jmp-1>0 && hs.count(pos+jmp-1))
            if(canReach(hs,pos+jmp-1,jmp-1,last)) return 1;
        
        return 0;
    }
```	

446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
return the number of arithmetic subsequence slices in the array
dp: when diff=A[i]-A[j] dp[i][diff]++

```cpp
    int numberOfArithmeticSlices(vector<int>& A) {
        //difference as the key
        vector<unordered_map<int,int>> dp(A.size());//difference vs length
        int res=0;
        for(int i=1;i<A.size();i++) 
        {
            for(int j=i-1;j>=0;j--) //try all previous one and build current map
            {
                if((long)A[i] - (long)A[j] > INT_MAX || (long)A[i] - (long)A[j] < INT_MIN) continue;
                int diff=A[i]-A[j];//diff is key for a(i,j)
                dp[i][diff]++;
                if(dp[j].count(diff)) {dp[i][diff]+=dp[j][diff];res+=dp[j][diff];}
            }
        }
        //print(mp);
        return res;
    }
```	
a small trick is used in the code: when have two number dp[j]=1, when have 3 numbers, dp[j]=2,....
we add dp[j][diff] is actually the array length -2

514	Freedom Trail    		40.6%	Hard	
the dial has a word,using the dial to spell a given word
return the min number of steps to rotate.
shortest distance first think of bfs then think of dp or dijkstra/bellman.
dp similar to dijkstra.

```cpp
    int findRotateSteps(string ring, string key) {
        //dfs
        int n=ring.size();
        int m=key.size();
        unordered_map<char,vector<int>> mp;
        for(int i=0;i<ring.size();i++) mp[ring[i]].push_back(i);
        //we are looking for a minimum path sum, ring initial is always 0
        //based on the memoization dfs approach, the dp approach is then simple
        vector<vector<int>> dp(n,vector<int>(m+1,INT_MAX));
        for(int i=0;i<n;i++) dp[i][m]=0;
        for(int j=m-1;j>=0;j--)
        {
            vector<int>& v=mp[key[j]];
            //for(int i=0;i<ring.size();i++)
            for(int i=n-1;i>=0;i--)
            {
                for(int k=0;k<v.size();k++) //all possible index of the current char
                {
                    int d=abs(v[k]-i); //
                    d=min(d,n-d);
                    dp[i][j]=min(dp[i][j],d+dp[v[k]][j+1]);
                }
            }
        }
        int minSteps=dp[0][0];
        return minSteps+m;
    }
```	
note we are doing it reversely. they shall be equivalent.

517	Super Washing Machines    		37.0%	Hard	
if we subtract the final target, (average), then our target is to reach all 0.
the machine with maxload shall give all out to left and right, and that is one max.
the load come through the machine is also another max.

```cpp
    int findMinMoves(vector<int>& machines) {
        //approach: total number is not changed, final number is the mean, through distribution
        //less than target: can have incoming or outcoming, +1 or -1
        //larger than target: can only have outcoming, -1
        int sum=0;
        sum=accumulate(machines.begin(),machines.end(),0);
        if(sum%machines.size()) return -1;
        int target=sum/machines.size();
        for(int i=0;i<machines.size();i++) machines[i]-=target;
        //all needs to be zero! the minimal total number of moves is max accumlated gain loss and individual gain/loss
        int cnt=0,min0=0;
        for(int i=0;i<machines.size();i++)
        {
            cnt+=machines[i];
            min0=max(min0,max(abs(cnt),machines[i]));//note loss does not account
        }
        return min0;
    }
```

546	Remove Boxes    		38.3%	Hard	
again this is similar to the google phone interview problem removing 3 or more same.
this problem k>=1, but we get k^2 points so it encourages longer.

dynamic array: when we remove a group, we need to connect to previous, assuming it is k.
dp[i][j][k] represents range [i,j] with previous added k boxes.
using dp: (divide and conquer)
for example [1, 3, 2, 2, 2, 3, 4, 3, 1] You can remove 2 first, and let the 3 connected together, 9 points 1,3,3,4,3,1, remove the 4, get 1 1,3,3,3,1 remove the 3, get 9 1,1 remove 1, get 4 total: 23

assuming dp[i,j] is the max points you can get from i to j (inclusive). And the final answer would be dp[0, n-1].

we get the group a[i] to a[i+k], assuming the k+1 elements are the same color, then we have two choices:

group them and get the score and delete them
leave them for a while and process other first and hope to have a longer sequence and higher scores.
For the first case, the score is (k+1)^2+subproblem(i+k+1,j) for the second case, assuming we find mth element==nums[i] and want to combine with a[i, i+k], then we need solve two subproblem first [i+k, m-1] with no previous same char and [m, j] with previous k+1 same char.

Thus the dp needs to add another dimension k, dp[i][j][k] defines the max score we get from the sequence i to j (inclusive) with number of same color box ahead.

dp[i][j][k]=max((k+1)^2+sub(i+k+1,j,0), sub(i+k+1,m-1,0), sub(m, j, k+1))

```cpp
    int removeBoxes(vector<int> boxes) {
        int n = boxes.size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(n,vector<int>(n)));
        return removeBoxesSub(boxes, 0, n - 1, 0, dp);
    }

    int removeBoxesSub(vector<int>& boxes, int i, int j, int k, vector<vector<vector<int>>>& dp) 
    {
        if (i > j) return 0;
        if (dp[i][j][k] > 0) return dp[i][j][k];
        for (; i + 1 <= j && boxes[i + 1] == boxes[i]; i++, k++); 
        // optimization: all boxes of the same color counted continuously from the first box should be grouped together
        int res = (k + 1) * (k + 1) + removeBoxesSub(boxes, i + 1, j, 0, dp);
        for (int m = i + 1; m <= j; m++) {
            if (boxes[i] == boxes[m]) {
                res = max(res, removeBoxesSub(boxes, i + 1, m - 1, 0, dp) + removeBoxesSub(boxes, m, j, k + 1, dp));
            }
        }
        dp[i][j][k] = res;
        return res;
    }
```
this is a very classical dp problem, it teaches us how to find the relation and how to approach a very complicated problem.
similar problem 664 strange printer

664	Strange Printer    		36.7%	Hard	
Problem summary
Printer each move prints a list of same characters. Next print will be on the previous print, covering those under. Given a string, get the min number of moves

idea
the number of same char does not matter (different from previous problem on remove boxes which is depending on k)
when same char is separated, either we connect them or print differently. That is why it is the same as removing boxes.
We don't need the k dimension in this case, since number of char does not matter. 3. this is similar to a series of overlapped segments, greedy choice will not work.

code
    int strangePrinter(string s) {
        if(s.length()<1) return 0;
        string ss;
        //reduce the string first to avoid time or space TLE
        char c=s[0];
        ss+=s[0];
        for(int i=1;i<s.length();i++) if(s[i]!=c) {c=s[i];ss+=s[i];}
        s=ss;
        int n=s.length();
        vector<vector<int>> dp(n,vector<int>(n));
        return helper(s,dp,0,n-1);
    }
    int helper(string& s,vector<vector<int>>& dp,int i,int j)
    {
        if(i>j) return 0;
        if(i==j) return 1;
        if(dp[i][j]) return dp[i][j];
        //k is the number of same char
        int res=1+helper(s,dp,i+1,j);//no char attached
        for(int m=i+1;m<=j;m++)
        {
            if(s[m]==s[i])
                res=min(res,helper(s,dp,i+1,m-1)+helper(s,dp,m,j));
        }
        dp[i][j]=res;
        return res;
    }
comments
please refer to remove boxes, which is almost the same.

552	Student Attendance Record II    		33.2%	Hard	
given n as the length, return the number of valid attendance record

dp:
it involves two or more small dp problems:
- with no A, we can add P, PL and PLL
- adding A, we can put A at any position and separate a two above dp subproblem

```cpp
    int checkRecord(int n) {
        //first we have two cases, have 1 A and 0 A
        //have 1 A divide it into two no A cases, the front and behind dp[i]*dp[n-1-i]
        //for no A case: we can add P, PL, PLL
        //dp[i]=dp[i-1]+dp[i-2]+dp[i-3]
        //boundary for no A: dp[0]=0, dp[1]=2 (P/L), dp[2]=4 (PP,PL,LL,LP)
        vector<long long> dp(n+1);
        dp[0]=1;dp[1]=2;dp[2]=4;
        int mod=1e9+7;
        for(int i=3;i<=n;i++)
        {
            dp[i]=(dp[i-1]+dp[i-2]+dp[i-3])%mod;
        }
        int res=dp[n];

        for(int i=0;i<n;i++) //A's position from 0 to n-1
        {
            res+=(dp[i]*dp[n-1-i])%mod;
            res%=mod;
        }
        return res%mod;
    }
```

600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
binary form does not contain consecutive ones <=n
convert n to binary, it will have m bits
can we solve problem when n=11111..1 with m bits case? Assuming dp[i] is the number of valid string with length i.
if previous bit is 1, then we can only add 0 dp[i][0]=dp[i-1][1]
if previous bit is 0, then we can add 1 or 0 dp[i][0]=dp[i-1][0], dp[i][1]=dp[i-1][1]
above is awkward, if we think in another way, if we define a[i] as the number of valid strings ending with 0, b[i] is the string ending with 1 we can add 0 no matter previous: a[i]=a[i-1]+b[i-1], we can add 1 only when previous is 0: b[i]=a[i-1]
subtract all over counted integers when number>n -. when binary of N appears 11, we just break, since all next smaller -. when binary of N appears 00, over count those ending with 1
dp:
```cpp
    int findIntegers(int num) {
        //32 bits max, 
        //dp[i] is the number of integers 
        string s;
        while(num) {s+=num%2+'0';num/=2;} //convert to binary
        reverse(s.begin(),s.end());//MSB is the 0th
        //dp1[i] represent number of integers where ith bit is 1
        //dp0[i] represent number of integers where ith bit is 0
        //dp1[i]=dp0[i-1], dp0[i]=dp1[i-1]+dp0[i-1] 
        int m=s.length();
        vector<int> dp0(m),dp1(m);
        dp0[0]=dp1[0]=1;
        for(int i=1;i<m;i++)
        {
            dp1[i]=dp0[i-1];
            dp0[i]=dp1[i-1]+dp0[i-1];
        }
        int res=dp0.back()+dp1.back(); //this solves the problem for num=0b101010...
        for(int i=1;i<m;i++)
        {
            if(s[i]=='1' && s[i-1]=='1') break;
            if(s[i]=='0' && s[i-1]=='0') res-=dp1[m-1-i]; //overcount  ith bit is 1
        }
        return res;
    }
```

629	K Inverse Pairs Array    		29.3%	Hard	
from 1 to n, how many different arrays have exactly k inverse pairs
this is similar counting the palindrome subsequence
recurrence relation dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-i]
assuming we solved problems for [1, i-1], adding i to exisiting condition: i can be anywhere, for example adding 5 to [1,4] 5xxxx: adding 4 inversion pairs (i-1) x5xxx: adding 3 (i-2) xx5xx: adding 2 (i-3) xxx5x: adding 1 (i-4) xxxx5: adding 0 (i-5) we have 5 ways to reach to a specific number of inverse.

dp[i,k] represents the number of permutation with k inverse pairs according to above observations if we put n as the last number then all the k inverse pair should come from the first n-1 numbers if we put n as the second last number then there's 1 inverse pair involves n so the rest k-1 comes from the first n-1 numbers ... if we put n as the first number then there's n-1 inverse pairs involve n so the rest k-(n-1) comes from the first n-1 numbers

dp[i,k]=dp[i-1,k]+dp[i-1,k-1]+dp[i-1,k-2]+dp[i-1,k-3].....+dp[i-1,k-(i-1)] using above equation: dp[i,k-1]=dp[i-1,k-1]+dp[i-1,k-2]+....dp[i-1,k-i] subtract the two: dp[i,k]=dp[i-1,k]+dp[i,k-1]-dp[i-1,k-i]

boundary condition: i=0, there is no inverse pair dp[0][k]=0; k=0, only sorted array supports dp[i][0]=1 dp[i,0]=1


```cpp
    int kInversePairs(int n, int k) {
        if(k==0 || k==(n-1)*n/2) return 1; //sorted in ascending or descending order
        if(k>n*(n-1)/2) return 0;
        vector<vector<long long>> dp(n+1,vector<long long>(k+1));
        //recurrence relation dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-i]
        const int mod=1e9+7;
        dp[2][0]=dp[2][1]=1;//two number
        for(int i=3;i<=n;i++)
        {
            dp[i][0]=1; //no inverse, sorted
            for(int j=1;j<=k;j++)
            {
                dp[i][j]=dp[i][j-1]+dp[i-1][j];//(j>=i)?dp[i-1][j-i]:0;//this one does not work, strange
                if(j>=i) dp[i][j]-=dp[i-1][j-i];
                dp[i][j]=(dp[i][j]+mod)%mod;
            }
        }
        return dp[n][k];
    }
```	

	
639	Decode Ways II    		25.2%	Hard	
* represents digit 1 to 9
dp
```cpp
    int numDecodings(string s) {
        //dp[i]=ways[i]*dp[i-1]+ways[i-1,i]*dp[i-2]
        if(s.size()==0) return 0;
        vector<long long> dp(s.size());
        const int mod=1e9+7;
        dp[0]=ways(s[0]);
        if(s.size()<2) return dp[0];
        dp[1]=ways(s[1])*dp[0]+ways(s[0],s[1]);
        for(int i=2;i<s.size();i++)
            dp[i]=(ways(s[i])*dp[i-1]+ways(s[i-1],s[i])*dp[i-2])%mod;
        return dp[s.size()-1];
    }
    int ways(char digit)
    {
        if(digit=='0') return 0;
        if(digit!='*') return 1;//note * can only be 1 to 9
        return 9;
    }
    int ways(char d1,char d2)
    {
        if(isdigit(d1)&&isdigit(d2))
        {
            if(d1>'2' || d1=='0') return 0; //does not matter d2
            if(d1=='2')
            {
                if(d2<'7') return 1;
                else return 0;
            }
            if(d1=='1') return 1;
        }
        if(d1=='*' && d2!='*')
        {
            //* can only be 1 or 2
            if(d2>'6') return 1;
            else return 2;
        }
        if(d1!='*' && d2=='*')
        {
            if(d1=='1') return 9;
            if(d1=='2') return 6;
            return 0;
        }
        if(d1=='*' && d2=='*')
        {
            return 15; //11-19 21..26
        }
    }
```


691	Stickers to Spell Word    		38.3%	Hard	
min number of stickers to be used to spell the word
dp or dfs with memoization
```cpp
    int minStickers(vector<string>& stickers, string target) {
        //target as a hashmap and stickes also a vector of hashmap
        vector<vector<int>> mp_stick(stickers.size(),vector<int>(26));
        //vector<int> mp_target(26);//use ordered_map to form string will be definite
        for(int i=0;i<stickers.size();i++)
        {
            for(int j=0;j<stickers[i].size();j++)
                mp_stick[i][stickers[i][j]-'a']++;
        }
        //for(int i=0;i<target.size();i++) mp_target[target[i]-'a']++;
        //dp is the minimum stickers used for a string, 
        unordered_map<string,int> dp;
        int res=dfs(mp_stick,target,dp); //dfs with memoization
        return res==INT_MAX?-1:res;
    }
    int dfs(vector<vector<int>>& mps,string target,unordered_map<string,int>& dp)
    {
        //dp[string]=min(1+dp[left_over])
        //string target=form_string(mpt);
        //cout<<target<<endl;
        if(dp.count(target)) return dp[target];
        if(target.size()==0) return 0;
        int min_stick=INT_MAX;
        vector<int> mpt(26);
        for(int i=0;i<target.size();i++) mpt[target[i]-'a']++;
        for(int i=0;i<mps.size();i++)
        {
            vector<int>& tmp=mps[i];//the sticker map
            //find the shared characters and greedy pick it
            //vector<int> shared=find_common(tmp,mpt);
            //int cnt=accumulate(shared.begin(),shared.end(),0);
            //if(cnt==0) continue;
            //if(shared.empty()) continue;
            //minus_map(mpt,shared);
            //string ntarget=form_string(mpt);
            string ntarget;
            for(int j=0;j<26;j++) if(mpt[j]>tmp[j]) ntarget.append(mpt[j]-tmp[j],'a'+j);
            if(ntarget==target) continue;
            //cout<<ntarget<<endl;
            int res=dfs(mps,ntarget,dp);
            if(res<INT_MAX)  min_stick=min(min_stick,1+res);//INT_MAX add 1 will overflow
            //add_map(mpt,shared);
        }
        dp[target]=min_stick;
        return min_stick;
    }

```

730	Count Different Palindromic Subsequences    		39.0%	Hard	
Problem Summary
Given a string of length n, find the number of different Palindrome subsequences, string has only a,b,c,d Attention: it asks for subsequences, not substring

ideas
it is easy to extend to 26 chars

a palindrome string can be from i to j. It is naturally use a start, end pair, or a start, length pair to indicate a palindrome string.

dp natural thinking: we start from the (i,len) subproblem and extend to see if we can solve bigger problem assuming we add a char to s[i, i+len-1] (we use xxxx to indicat the string which is palindrome):

if we define dp[i,len,x] as the number of different pal-subsequence starting at i, with length=len, with start/end char =x

if s[i]!='x', we can ignore (remove) first char, dp[i,len,x]=dp[i+1,len-1,x] else if s[j]!='x', we can ignore (remove) last char, dp[i,len,x]=dp[i,len-1,x] (the head is x but tail is not)

if both are x: dp[i,len,x]=dp[i+1,len-2,'a']+dp[i+1,len-2,'b']+dp[i+1,len-2,'c']+dp[i+1,len-2,'d']+2

why?

we are adding one x to the head and one x to the tail, which makes xa..ax, xb..bx, xc..cx, xd..dx all different pal-subsequence. Since we are making the length increased by 2, and they are all different.

+2: we can add x and xx into it since we add two x into previous solution, and we at least have length>=3

for example: we have aabaa, the subsequence start and end with a:

a,aa,aaa,aaaa,aba,aabaa

when add a to head and tail, they become:

aaa,aaaa,aaaaaa,aabaa,aaabaaa

and we add a and aa into it.

since it only involves len-2, len-1 and len, we only need 3 matrices.

The final answer is the sum of start=0, len=n, and char=a, b, c, d

Implementation
    int countPalindromicSubsequences(string S) {
       int n=S.length();
        int mod=1e9+7;
        //dp[i][len][c]: represents starting at i, with length=len start and ending with c
        vector<vector<int>> dp0(n,vector<int>(4)),dp1(n,vector<int>(4)),dp2(n,vector<int>(4));
        //dp0:len, dp1: len-1, dp2: len-2
        for(int len=1;len<=n;len++)
        {
            for(int i=0;i+len<=n;i++)
            {
                for(int j=0;j<4;j++)
                {
                    dp0[i][j]=0;
                    if(len==1) {dp0[i][j]=(S[i]=='a'+j);continue;}
                    if(S[i]!='a'+j) dp0[i][j]=dp1[i+1][j];//dp[i][len][c]=dp[i+1][len-1][c]
                    else if(S[i+len-1]!='a'+j) dp0[i][j]=dp1[i][j];//dp[i,len,c]=dp[i,len-1,c]
                    else //both ==x
                    {
                        dp0[i][j]=2;
                        if(len>2) for(int k=0;k<4;k++) {dp0[i][j]+=dp2[i+1][k];dp0[i][j]%=mod;} //dp[i+1,len-2,k]
                    }
                    dp0[i][j]%=mod;
                }
            }
            //len increase
            dp2=dp1;
            dp1=dp0;
        }
        //final answer is sum(dp[0,n,c])
        return accumulate(dp0[0].begin(),dp0[0].end(),0LL)%mod;
    }
comments
it needs subsequence, not substring, this is very important to the understanding of the algorithm
need special treat len=1 case
need special treat len==2 case when add two char (empty)
when an iteration on len is done, we need update len-1->len-2, len->len-1
every time len shall be initialized since we reuse the matrix. that is why dp2[i][x]=0 is needed. Attention shall be paid to this.

741	Cherry Pickup    		29.9%	Hard	
Problem Summary
This is a pretty hard DP problem.

matrix: 0 empty, 1 cherry -1: thorn

You need go roundtrip from top left to bottom right and back to top left and get the max cherry.

Approach:
intuitively way that maximizes the first pass and changes the optimal path and then finds the second pass optimal path will not work. Since this will only maximize the first pass and the global optimal is not guaranteed.

From top left to bottom right is equivalent to from bottom right to top left

The correct approach is to try the two passes simultaneously and make the two passes optimal. The only constraint is: the two passes cannot pick up the same cherry twice.

for a matrix n x n, one trip takes 2N-1 steps. We can try all possible locations for two passes for each step and this is the key point. i.e., the first pass goes to (i,j) and second pass goes to (p,q) and i+j=p+q=steps. The only constraint is (i, j)=(p, q). The cherry picked up at these two locations are grid[i, j]+grid[p, q].

From previous position to current (i,j) and (p,q), the previous combination could be the following: (i-1, j, p-1, q, k-1) (i-1, j, p, q-1, k-1) (i, j-1, p-1, q, k-1) (i, j-1, p, q-1, k-1). k is the number of steps.

So the recurrence relation is dp(i, j, p, q, k)=max(dp(i-1, j, p-1, q, k-1), dp(i-1, j, p, q-1, k-1), dp(i, j-1, p-1, q, k-1), dp(i, j-1, p, q-1, k-1))+grid(i, j)+grid(p,q).

Since i and j are associated, also p and q are associated, dp shall not use i and j, but we need use i and p, or j and q. (the x coordinate for two positions or y coordinates for the two passes).

dp(i-1, j, p-1, q, k-1) reduced to dp(i-1, p-1, k-1)

dp(i-1, j, p, q-1, k-1) reduced to dp(i-1, p, k-1)

dp(i, j-1, p-1, q, k-1) reduced to dp(i, p-1, k-1)

dp(i, j-1, p, q-1, k-1) reduced to dp(i, p, k-1)

Since only k-1 iteration is involved, we may not need the 3rd dimension, but extra care is needed, generally reverse iteration is required to avoid using updated values.

And finally we reached the solution:

Attention:

Since we reduce the 3d problem into 2d problem we need do reverse iteration to use n-1 values

when grid[x][y]<0, we need set dp[x1][x2]=-1 it is necessary since it is dp[x1][x2][n]! and dp[x1][x2][n-1] may be >0 but dp[x1][x2][n] may be <0. Need to keep updating.

two legs can cross the same position, but can only pick the cherry once.

code
    int cherryPickup(vector<vector<int>>& grid) {
        int n=grid.size();
        vector<vector<int>> dp(n,vector<int>(n,-1));
        dp[0][0]=grid[0][0];
        for(int nstep=1;nstep<2*n-1;nstep++)
        {
            for(int x1=n-1;x1>=0;x1--)
            {
                for(int x2=n-1;x2>=0;x2--) //can share the same position but cannot pick twice
                {
                    int y1=nstep-x1,y2=nstep-x2;
                    if(y1<0 || y2<0 ||y1>=n || y2>=n) continue;
                    if(grid[x1][y1]<0 || grid[x2][y2]<0) {dp[x1][x2]=-1;continue;}
                    int delta=grid[x1][y1];
                    if(x1!=x2) delta+=grid[x2][y2];
                    int best=-1;
                    if(x1 && x2 && dp[x1-1][x2-1]>=0) best=max(best,dp[x1-1][x2-1]+delta);
                    if(y1 && x2 && dp[x1][x2-1]>=0) best=max(best,dp[x1][x2-1]+delta);
                    if(x1 && y2 && dp[x1-1][x2]>=0) best=max(best,dp[x1-1][x2]+delta);
                    if(y1 && y2 && dp[x1][x2]>=0) best=max(best,dp[x1][x2]+delta); 
                    dp[x1][x2]=best; 
                }
            }
        }
        return dp[n-1][n-1]==-1?0:dp[n-1][n-1];
    }
Attention:
this is a 3d problem with space reduced to 2d, especial care needs attention. one is the reverse iteration, one is setting dp to be -1 when there is a thorn at either position
cannot pick the same cherry
initialize to -1 to mark. do not have to be int_min which makes things more complicated.
complexity O(N^3)

818	Race Car    		35.0%	Hard	
Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)

Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).

When you get an instruction "A", your car does the following: position += speed, speed *= 2.

When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.)

For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.

Now for some target position, say the length of the shortest sequence of instructions to get there.

```dp
    int dp[10001];
    int racecar(int t) 
    {
        if (dp[t] > 0) return dp[t];
        int n = floor(log2(t)) + 1, res;
        if (1 << n == t + 1) dp[t] = n;
        else 
        {
            dp[t] = racecar((1 << n) - 1 - t) + n + 1;
            for (int m = 0; m < n - 1; ++m)
                dp[t] = min(dp[t], racecar(t - (1 << (n - 1)) + (1 << m)) + n + m + 1);
        }
        return dp[t];
    }
```	

940	Distinct Subsequences II    		39.7%	Hard	
dp

    int distinctSubseqII(string S) {
        int endwith[26]={0};
        int mod=1e9+7;
        for(int i=0;i<S.length();i++)
        {
            int t=0;
            for(int j=0;j<26;j++)
                t+=endwith[j], t%=mod;
            endwith[S[i]-'a']=t+1;
            //endwith[S[i]-'a']=accumulate(endwith,endwith+26,1LL)%mod;
        }
            
        return accumulate(endwith,endwith+26,0LL)%mod;
    }
	
	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
dp
    int numPermsDISequence(string S) {
        int mod=1e9+7;
        int n=S.length();
        vector<vector<int>> dp(n+1,vector<int>(n+1,0));
        //dp[i][j]: the number of permutation with length=i and end at number j
        for(int i=0;i<n+1;i++) dp[0][i]=1; //boundary: length=0
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=i;j++)
            {
                if(S[i-1]=='D') //previous one shall be bigger
                {
                    for(int k=j;k<i;k++) {dp[i][j]+=dp[i-1][k];dp[i][j]%=mod;}
                }
                else //previous one shall be smaller
                {
                    for(int k=0;k<j;k++) {dp[i][j]+=dp[i-1][k];dp[i][j]%=mod;}
                }
            }
        }
        int ans=0;//length=n ending with all numbers.
        for(int i=0;i<n+1;i++) {ans+=dp[n][i];ans%=mod;}
        return ans;
    }	
	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones.

A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.

dp
```cpp
    int mergeStones(vector<int>& stones, int K) {
        int n = stones.size();
        if ((n - 1) % (K - 1)) return -1;

        vector<int> prefix(n + 1);
        for (int i = 0; i <  n; i++)
            prefix[i + 1] = prefix[i] + stones[i];

        vector<vector<int> > dp(n, vector<int>(n));
        for (int m = K; m <= n; ++m)
            for (int i = 0; i + m <= n; ++i) {
                int j = i + m - 1;
                dp[i][j] = INT_MAX;
                for (int mid = i; mid < j; mid += K - 1)
                    dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j]);
                if ((j - i) % (K - 1) == 0)
                    dp[i][j] += prefix[j + 1] - prefix[i];
            }
        return dp[0][n - 1];
    }
```
this is similar to the removing boxes. The merged pile has the sum of all piles.
using reverse thinking:
We keep merging K piles of stones until there is only one pile.

For the last step, stones[i .. j] (original) are divided into K piles, 
and we merge them into one pile, which costs sum(nums[i .. j]) + cost to make stones[i .. j] form K piles.

The problem get the minimum cost to make stones[i .. j] form 1 pile equals to

	the minimum cost to make stones[i .. j] form K piles
	+ sum(nums[i .. j])
The subproblem the minimum cost to make stones[i .. j] form K piles equals to

	the minimum cost to make stones[i .. k] form K - 1 piles
	+ the minimum cost to make stones[k + 1 .. j] form 1 pile 
	+ sum(nums[i .. j])
	
	
956	Tallest Billboard    		38.0%	Hard	
You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height.

You have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.

Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.

two legs, equal length, largest height.  so we have 3 groups, one group +x, one group -x, and one group 0 (non-used)
knapsack problem

    int tallestBillboard(vector<int>& rods) {
        int n=rods.size();
        int tsum=accumulate(rods.begin(),rods.end(),0)/2;
        vector<vector<int>> dp(n,vector<int>(10001));//dp[i,j]: -tsum to tsum
        return helper(rods,0,5000,dp);
    }
    
    int helper(vector<int>& rods,int start,int tsum,vector<vector<int>>& dp)
    {
        if(start==rods.size()) return tsum==5000?0:INT_MIN/2;
        if(dp[start][tsum]) return dp[start][tsum];
        int ans=helper(rods,start+1,tsum,dp); //do not use current
        ans=max(ans,helper(rods,start+1,tsum-rods[start],dp)); //choose rods[i] as negative
        ans=max(ans,helper(rods,start+1,tsum+rods[start],dp)+rods[start]); //choose rods[i] as positive
        //note the answer is the sum of positives
        return dp[start][tsum]=ans;
    }

960	Delete Columns to Make Sorted III    		52.8%	Hard	
longest increasing subsequence for all strings

    int minDeletionSize(vector<string>& A) {
        //longest increasing subsequence for all strings
        int m=A.size(),n=A[0].size();
        vector<int> dp(n);
        //check each column to see if it satisfy > previous
        int maxlen=0;
        for(int i=0;i<n;i++)
        {
            for(int k=0;k<i;k++) //compare to all previous
            {
                bool sorted=1;
                for(int j=0;j<m;j++) //all string
                {
                    if(A[j][i]<A[j][k]) {sorted=0;break;} //current i,k cannot be combined   
                }
                if(sorted) dp[i]=max(dp[i],dp[k]+1);
            }
            maxlen=max(maxlen,dp[i]+1);
        }
        return n-maxlen;
    }
	
	
964	Least Operators to Express Number    		40.5%	Hard	
use x and operator +-*/ to get the target number
dp using x-ary base number

    int leastOpsExpressTarget(int x, int target) {
        //dp: x-ary number to use least operations
        //n=sum(Ai*X^i) to use less operator need to compare x^(i+1) and x^i
        vector<int> digits;
        while(target) {digits.push_back(target%x);target/=x;}
        
        int n=digits.size();
        digits.push_back(0);
        vector<int> pos(n+1),neg(n+1);
        pos[0]=digits[0]*2;
        neg[0]=(x-digits[0])*2; //x^0=x/x use more operations
        for(int i=1;i<=n;i++)
        {
            //if use neg, we have a carrier flag to i
            //Aix^i: add Ai times, each with i multplication
            pos[i]=digits[i]*i+min(pos[i-1],neg[i-1]+i); 
            //AiX^i=x^(i+1)-(x-Ai)x^i
            neg[i]=min((x-digits[i])*i+pos[i-1],(x-digits[i]-1)*i+neg[i-1]);
        }
        return min(pos[n],neg[n])-1;
    }
	

968	Binary Tree Cameras    		35.2%	Hard	
greedy in tree, pretty hard to understand

```cpp
    int res = 0;
    int minCameraCover(TreeNode* root) {
        return (dfs(root) < 1 ? 1 : 0) + res;
    }

    int dfs(TreeNode* root) {
        int left = root->left ? dfs(root->left) : 2,//left null, then it is covered?
            right = root->right ? dfs(root->right) : 2;
        if (left == 0 || right == 0) { //not covered
            res++;
            return 1;
        }
        return left == 1 || right == 1 ? 2 : 0;
    }
```	

887	Super Egg Drop    		24.9%	Hard	
Problem summary
given k eggs, and floor 1 to N, there is a floor F 0<=F<<N, when you drop the egg on >F the egg will break. Get the min number of moves required to determine F

idea
Since F could be any number, this is a minmax problem, ie. get the min of all the max eggs to guarantee the finding of F.

If we drop egg at floor j, there are two options:

egg does not breaks, then F>j the problem is a smaller problem with k eggs, and N-j floors

egg breaks, the F<j, we are solving problem with k-1 eggs and j-1 floors

so dp(k, n)=min(dp[k,n],1+max(dp[k-1, j-1], dp[k, n-j]) where k is the number of eggs, n is the number of floor, and j is the floor from 1 to n.

The final answer is dp[k,N] with k eggs and N floors

bounary condition: 0 eggs we cannot determine anything, dp[0, i]=0; i eggs, 0 floor, min number of eggs is also 0. k=0, N=0 is actually not needed. 1 eggs, i floor, need i moves i eggs, 1 floor, need 1 moves

And we get the code

    int superEggDrop(int K, int N) {
        //
        vector<vector<int>> dp(K+1,vector<int>(N+1));
        for(int i=1;i<=K;i++) dp[i][1]=1;
        for(int i=1;i<=N;i++) dp[1][i]=i;
        for(int k=2;k<=K;k++)
        {
            for(int n=2;n<=N;n++)
            {
                dp[k][n]=INT_MAX;
                for(int j=1;j<=n;j++)
                    dp[k][n]=min(dp[k][n],1+max(dp[k-1][j-1],dp[k][n-j]));
            }
        }
        return dp[K][N];
    }
The complexity is O(KN^2), which needs further optimization. Possible optimization: dp[k-1][j-1] increase with j, and dp[k][N-j] decreases with j. The min of the max of the two can be found using binary search, which reduce the complexity to O(KNlogN)

Inspired @lee215, we can solve an equivalent dp problem: assuming dp[k,m] as using k eggs, m moves, what is the max number of floors we can reach:

if egg breaks: we can check max floor dp[k-1,m-1] <current floor

if egg does not break: we can check max floor dp[k, m-1] > current floor (using current floor as the base 0)

When N floors are checked, F is found. dp[k, m]=N and we find the min m.

dp[k,m]=dp[k-1,m-1]+dp[k,m-1]+1 (the combined below and above number of floors)

Why the above equation: dp[k-1, m-1] using m-1 moves and k-1 eggs, the max number of floors we can check (lower than current) dp[k, m-1] using m-1 moves and k eggs, the max number of floors we can check (higher than current) +1: the floor we currently checked.

    int superEggDrop(int K, int N) {
        //
        vector<vector<int>> dp(K+1,vector<int>(N+1));
        //dp[k,n] now is the max number of floors checked using k eggs and n moves
        for(int m=1;m<=N;m++)
        {
            for(int k=1;k<=K;k++)
                dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1;
            if(dp[K][m]>=N) return m;
        }
    }
Above solution can be reduced to 1D since it only involves with m-1. Please attention if using 1D, need to reverse iterate on k since we don't want to use the updated dp[k-1][m] to replace dp[k-1][m-1].

egg drop is considered a puzzle in geeksforgeeks.

828	Unique Letter String    		39.6%	Hard	
A character is unique in string S if it occurs exactly once in it.

For example, in string S = "LETTER", the only unique characters are "L" and "R".

Let's define UNIQ(S) as the number of unique characters in string S.

For example, UNIQ("LETTER") =  2.

Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S.

If there are two or more equal substrings at different positions in S, we consider them different.

Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.

we build a hash for all 26 chars, and record its index;
Assuming dp[i] is the number of unique letter string for S[0...i].
There is two cases:

S[i] does not appear in the front, then we add a char to all substr ending at i. that is we add 1 to 0,1,....i-1
S[i] appears in the front, assuming the last occurance is j, then we add 1 for all substr from j+1 to i-1.
from j to k (assuming k the previous position to j with the same char) we minus 1 for all substr from k+1 to j
when there are >=2 occurance of the same char, we have no changes.
dp[i]=dp[i-1]+1+(dp[i-1]-dp[i-2)+delta
when s[i] does not appear: delta=i
when s[i] appears, delta=(i-j-1)-(j-k)
So we use a hashmap to maintain the last two occurance of each character.
```cpp
    int uniqueLetterString(string S) {
        vector<vector<int>> hash(26,vector<int>());
        int n=S.size();
        vector<long long> dp(n+1,0);
        const int mod=1e9+7;
        dp[1]=1;hash[S[0]-'A'].push_back(0);
        for(int i=1;i<n;i++)
        {
            int c=S[i]-'A';
            dp[i+1]=dp[i]+1;
            int diff=dp[i]-dp[i-1];//previous addition
            if(hash[c].size()) //same char in the front
            {
                int j=hash[c].back();
                int k;
                if(hash[c].size()>1) k=hash[c][0];
                else k=-1;
                dp[i+1]+=diff+(i-j-1)-(j-k);//we add 1 to j+1 and minus 1 to k+1
            }
            else //there is no same char in the front
            {
                dp[i+1]+=i+diff;//we add one to all previous solution
            }
            hash[c].push_back(i);
            if(hash[c].size()>2)
            {
                hash[c][0]=hash[c][1];
                hash[c][1]=hash[c][2];
                hash[c].pop_back();
            }
        }
        return dp[n]%mod;
    }
```

920	Number of Music Playlists    		43.9%	Hard	
Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:

Every song is played at least once
A song can only be played again only if K other songs have been played
Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.

dp
    int numMusicPlaylists(int N, int L, int K) {
        const int mod = 1000000007;
        
        vector<vector<long long>> dp(N+1, vector<long long>(L+1));
        dp[1][1] = 1;
        for(int i = 2; i <= N; ++i) dp[i][i] = (dp[i-1][i-1] * i) % mod;
        for(int n = 1; n <= N; ++n) 
        {
            for(int l = n+1; l <= L; ++l) 
            {
                dp[n][l] = ((dp[n][l-1] * ((n-K)>0? (n-K) : 0)) % mod + (dp[n-1][l-1] * n) % mod) % mod;
            }
        }
        
        return dp[N][L];
    }
	
879	Profitable Schemes    		36.7%	Hard	
There are G people in a gang, and a list of various crimes they could commit.

The i-th crime generates a profit[i] and requires group[i] gang members to participate.

If a gang member participates in one crime, that member can't participate in another crime.

Let's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G.

How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.

dynmaic knapsack problem
```cpp
    int profitableSchemes(int G, int P, vector<int> group, vector<int> profit) {
        vector<vector<int>> dp(P + 1, vector<int>(G + 1, 0));
        dp[0][0] = 1;
        int res = 0, mod = 1e9 + 7;
        for (int k = 0; k < group.size(); k++) {
            int g = group[k], p = profit[k];
            for (int i = P; i >= 0; i--)
                for (int j = G - g; j >= 0; j--)
                    dp[min(i + p, P)][j + g] = (dp[min(i + p, P)][j + g] + dp[i][j]) % mod;
        }
        for (int x: dp[P]) res = (res + x) % mod;
        return res;
    }
```
	
## heap	
23	Merge k Sorted Lists    		34.7%	Hard	
typically using heap.
approach 1: keep merge two lists.
approach 2: pq (minheap) stores the listnode, keep popping the min, and push in min's next.

```cpp
struct compare {
    bool operator()(const ListNode* l, const ListNode* r) {
        return l->val > r->val;
    }
};
ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue
    priority_queue<ListNode *, vector<ListNode *>, compare> q;
    for(auto l : lists) {
        if(l)  q.push(l);
    }
    if(q.empty())  return NULL;

    ListNode* result = q.top();
    q.pop();
    if(result->next) q.push(result->next);
    ListNode* tail = result;            
    while(!q.empty()) {
        tail->next = q.top();
        q.pop();
        tail = tail->next;
        if(tail->next) q.push(tail->next);
    }
    return result;
}
```

407	Trapping Rain Water II    		39.3%	Hard
now 2d cell. 
Imagine the pool is surrounded by many bars. The water can only go out from the lowest bar. So we always start from the lowest boundary and keep pushing the bar from boundary towards inside. It works as if we are replacing the old bars with a bar higher than it.
See the following simple example:
4 4 4 4
4 0 1 2
4 4 4 4
it looks like we push the bar of 2 towards left and record the difference. Then you can use the same procedure with the following figure
4 4 4 4
4 0 2 2
4 4 4 4
compute the volume of water held.
```cpp
    int trapRainWater(vector<vector<int>>& heightMap) {
        typedef pair<int,int> cell; //height + 1d index
        priority_queue<cell, vector<cell>, greater<cell>> q; //minheap
        int m = heightMap.size();
        if (m == 0) return 0;
        int n = heightMap[0].size();
        vector<int> visited(m*n, 0);
        
        //the 4 boundaries
        for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) 
        {
            if (i == 0 || i == m-1 || j == 0  || j == n-1) 
            {
                if (!visited[i*n+j]) q.push(cell(heightMap[i][j], i*n+j));
                visited[i*n+j] = 1;
            }
        }
        
        int dir[4][2] = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};
        int ans = 0;
        while(!q.empty()) 
        {
            cell c = q.top();q.pop();
            int i = c.second/n, j = c.second%n;
            
            for (int r = 0; r < 4; ++r) 
            {
                int ii = i+dir[r][0], jj = j+dir[r][1];
                if (ii < 0 || ii >= m || jj < 0 || jj >= n || visited[ii*n+jj]) continue;
                ans += max(0, c.first - heightMap[ii][jj]);
                q.push(cell(max(c.first, heightMap[ii][jj]), ii*n+jj));
                visited[ii*n+jj] = true;
            }
        }
        return ans;
    }
```
630	Course Schedule III    		31.7%	Hard	
each course (t,d) t is the duration time, d is the closing day
using greedy and priority_queue to max the course
```cpp
bool cmp(vector<int>& a,vector<int>& b) {return a[1]<b[1] || (a[1]==b[1] && a[0]<b[0]);}
class Solution {
public:
    int scheduleCourse(vector<vector<int>>& courses) {
        //sort according to closing date
        sort(courses.begin(),courses.end(),cmp);
        //greedy choice: giving a closing date, several courses may satisfy the t+l<closing_date
        //since the length is determined, we shall pick shorter courses first to ensure more courses
        priority_queue<int> pq;
        int n=courses.size();
        int s=0; //s is the current time
        for(int i=0;i<n;i++)
        {
            s+=courses[i][0]; //if we select this course, advance the time
            pq.push(courses[i][0]);
            if(s>courses[i][1]) //out of closing date, try to remove the longest 
            {s-=pq.top();pq.pop();} //
        }
        return pq.size();
        
    }
};
```

632	Smallest Range    		47.5%	Hard	
smallest range which contains at least one number from each of the k-list
similar to merge sort keeping the min and max and get the smallest range
```cpp
	vector<int> smallestRange(vector<vector<int>>& nums) {
		int n=nums.size();
		vector<int> ind(n); //the index for each list
		priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq; //stores value and index i, j
		int mn=INT_MAX,mx=INT_MIN; //the range
		vector<int> ans;
		int minrange=INT_MAX;
        for(int i=0;i<n;i++)
        {
            pq.push({nums[i][ind[i]],i});
            mx=max(mx,nums[i][ind[i]]);
            mn=min(mn,nums[i][ind[i]]);
        }
        
		while(1)
		{
            if(minrange>mx-mn)
            {
                minrange=mx-mn;
                ans={mn,mx};
            }
            auto t=pq.top();
            pq.pop();
            ind[t[1]]++;
            if(ind[t[1]]<nums[t[1]].size()) 
            {
                pq.push({nums[t[1]][ind[t[1]]],t[1]});
                mn=pq.top()[0];
                mx=max(mx,nums[t[1]][ind[t[1]]]);
                //cout<<mn<<" "<<mx<<" "<<nums[t[1]][ind[t[1]]]<<endl;
            }
            else break; //used one list
		}
		return ans;
	}
```



857	Minimum Cost to Hire K Workers    		47.4%	Hard	
There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].

Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:

Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
Every worker in the paid group must be paid at least their minimum wage expectation.
Return the least amount of money needed to form a paid group satisfying the above conditions.

using priority queue
```cpp
    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int K) {
        int n=wage.size();
        vector<vector<double>> efficiency(n,vector<double>(2));
        for(int i=0;i<n;i++) 
        {
            efficiency[i][0]=wage[i]*1.0/quality[i];
            efficiency[i][1]=quality[i];
            //efficiency[i][2]=wage[i];
        }
        sort(efficiency.begin(),efficiency.end());
        double min_total=1e37;
        priority_queue<int> pq;
        int qsum=0;
        for(int i=0;i<n;i++) 
        {
            qsum+=efficiency[i][1];
            pq.push(efficiency[i][1]);
            if(pq.size()>K) {int q=pq.top();pq.pop();qsum-=q;}
            if(pq.size()==K) min_total=min(min_total,efficiency[i][0]*qsum);
        }
        return min_total;
    }
```

## linked list
25	Reverse Nodes in k-Group    		36.6%	Hard	
just reverse k
```cpp
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head || k<2) return head;
        ListNode *dummy,*pre,*post,*p;
        dummy=new ListNode(0);
        dummy->next=head;
        pre=dummy;
        p=head;
        int cnt=0;
        while(p)
        {
            post=advance(p,k,cnt);
            if(!post && cnt<k) break;
            //reverse nodes between pre and post
            pair<ListNode*,ListNode*> pn=reverse_inplace(p,k);
            pre->next=pn.first;
            pn.second->next=post;
            
            pre=pn.second; //now the node after pre becomes the new pre
            p=post;
        }
        return dummy->next;
    }
    ListNode* advance(ListNode* head,int k,int& cnt)
    {
        cnt=0;
        while(cnt<k && head) {head=head->next;cnt++;}
        return head;
    }
    pair<ListNode*,ListNode*> reverse_inplace(ListNode* p,int k)
    {
        ListNode* last=p;
        ListNode *pre=0,*next;
        while(k)//reverse its direction
        {
            next=p->next;
            p->next=pre;
            pre=p;
            p=next;
            k--;
        }
        return make_pair(pre,last);
    }
```	
295	Find Median from Data Stream    		36.8%	Hard
left: a max heap
right: a min heap
median: odd:, even: the two heap's average
when a a new data coming, check even /odd
either put left side, or right side.

```cpp
    priority_queue<int,vector<int>,less<int>> left;
    priority_queue<int,vector<int>,greater<int>> right;
    double med;
    int total;
    MedianFinder() {
        total=0;
    }
    
    void addNum(int num) {
        total++;
        if(total==1) {med=num;return;}
        
        if(total%2)//total is odd, one element is in and one element is out
        {
            if(num<left.top()) {left.push(num);med=left.top();left.pop();}
            else if(num>right.top()) {right.push(num);med=right.top();right.pop();}
            else med=num;//lmax<=num<=lmin
        }
        else //total is even, the new num and med shall be inside left or right
        {
            if(num<med) {left.push(num);right.push(med);}
            else {left.push(med);right.push(num);}
            med=(left.top()+right.top())/2.0;
        }
    }
    
    double findMedian() {
        return med;
    }
	```
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
the rectangle top left (x0,y0), bottom right (x1,y1)
S(x0,y0,x1,y1)=S4
S(x0,y0)=S1
S(x1,y0)=S1+S2
S(x0,y1)=S1+S3
S(x1,y1)=S1+S2+S3+S4
S4=S(x1,y1)-(S1+S2+S3)=S(x1,y1)-(S1+S2+S1+S3-S1)=S(x1,y1)+S(x0,y0)-S(x1,y0)-S(x0,y1)
for x1,y1 (n^2 choices) x0,y0 can be chosen from 0-x1, 0-y1, that is x1y1
if we brutal force, it will be O(N^4)

find the largest sum of subarray in a 1D array <=K
prefix sum. and we iterate from left to right, put the prefix sum in a set.
for each prefix, we can use upper_bound to find the target cum[j]-k.
O(nlogn)

/* first  consider the situation matrix is 1D
    we can save every sum of 0~i(0<=i<len) and binary search previous sum to find 
    possible result for every index, time complexity is O(NlogN).
    so in 2D matrix, we can sum up all values from row i to row j and create a 1D array 
    to use 1D array solution.
    If col number is less than row number, we can sum up all values from col i to col j 
    then use 1D array solution.
*/
public int maxSumSubmatrix(int[][] matrix, int target) {
    int row = matrix.length;
    if(row==0)return 0;
    int col = matrix[0].length;
    int m = Math.min(row,col);
    int n = Math.max(row,col);
    //indicating sum up in every row or every column
    boolean colIsBig = col>row;
    int res = Integer.MIN_VALUE;
    for(int i = 0;i<m;i++){
        int[] array = new int[n];
        // sum from row j to row i
        for(int j = i;j>=0;j--){
            int val = 0;
            TreeSet<Integer> set = new TreeSet<Integer>();
            set.add(0);
            //traverse every column/row and sum up
            for(int k = 0;k<n;k++){
                array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);
                val = val + array[k];
                //use  TreeMap to binary search previous sum to get possible result 
                Integer subres = set.ceiling(val-target);
                if(null!=subres){
                    res=Math.max(res,val-subres);
                }
                set.add(val);
            }
        }
    }
    return res;
}
	
## hash
30	Substring with Concatenation of All Words    		23.7%	Hard
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.	
subarray with all words in the dictionary, window shall be exactly the same as the total length of the dict.
approach 1: iterate on all char with a sliding window. check if the window contains all words. Note the words are the same length, which makes thing easier
approach 2: direct hash. treat each word a hash and combination of words another hash. this is a permutation of words.
approach 3: hashmap, first build a dictionary map, and sliding window to see if the window contains the map
```cpp
	vector<int> findSubstring(string s, vector<string>& words) {
        if(words.empty()) return {};
		unordered_map<string,int> mp;
		for(auto t: words) mp[t]++;
        vector<int> ans;
		int m=words.size(),n=words[0].size(),len=s.size();
		for(int i=0;i<=len-m*n;i++){
			unordered_map<string,int> tmp;
			for(int j=0;j<m;j++){
				string t=s.substr(i+j*n,n);
				if(!mp.count(t)) break;
				tmp[t]++;
			}
			if(tmp==mp) ans.push_back(i);
		}
		return ans;
	}
```	
however worst case is O(n*m*len)

149	Max Points on a Line    		15.8%	Hard	
point on a line: defined by k and d. k can be defined as dy/dx
dy,dx,d dy dx shall remove the gcd
and also need keep the sign to dx
			
391	Perfect Rectangle    		28.2%	Hard	
N rectangle, if forms an exact cover of a rectangle region
could have overlaps.
- sum of all rect area = final rect area (xmin,ymin), (xmax,ymax)
- area the same is not sufficient we can easily move a rect to other place and have an overlap.
inner side points shall be even
four side corner shall be once (no overlap)
```cpp
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        //first find the 4 points of the outer rect
        //second the area shall equal to the sum of all small rectangle
        //third the outer rect shall be the points of those sub rect (only appears once)
        //4th all inner side points must appear even times
        unordered_map<string,int> mp;
        int x0,y0,x1,y1;
        x0=y0=INT_MAX,x1=y1=INT_MIN;
        string s;
        int total_area=0;
        for(int i=0;i<rectangles.size();i++)
        {
            x0=min(x0,rectangles[i][0]);
            y0=min(y0,rectangles[i][1]);
            x1=max(x1,rectangles[i][2]);
            y1=max(y1,rectangles[i][3]);
            total_area+=(rectangles[i][0]-rectangles[i][2])*(rectangles[i][1]-rectangles[i][3]);
            s=to_string(rectangles[i][0])+":"+to_string(rectangles[i][1]);mp[s]++;
            s=to_string(rectangles[i][2])+":"+to_string(rectangles[i][3]);mp[s]++;
            s=to_string(rectangles[i][2])+":"+to_string(rectangles[i][1]);mp[s]++;
            s=to_string(rectangles[i][0])+":"+to_string(rectangles[i][3]);mp[s]++;
        }
        int area=(x0-x1)*(y0-y1);
        s=to_string(x0)+":"+to_string(y0);if(mp[s]!=1) return 0;else mp.erase(s);
        s=to_string(x1)+":"+to_string(y1);if(mp[s]!=1) return 0;else mp.erase(s);
        s=to_string(x1)+":"+to_string(y0);if(mp[s]!=1) return 0;else mp.erase(s);
        s=to_string(x0)+":"+to_string(y1);if(mp[s]!=1) return 0;else mp.erase(s);
        for(auto it=mp.begin();it!=mp.end();it++) if(it->second%2) return 0;
        return area==total_area;
    }
```
				
1044 Longest Duplicate Substring    		22.9%	Hard	
direct hash: not perfect may have collision.

```cpp
    int p = INT_MAX / 26 / 26 * 26 - 1; // = 82595499
    // order of 26 mod 82595499 is 11799354 > 50000, so this choice should result in minimum collision
    string longestDupSubstring(string S) {
        int hi = S.size(), lo = 0, idx = 0;
        while (hi - lo > 1) {
            auto mid = (hi + lo) / 2;
            int pow = 1, h = 0;
            for (int i = mid - 1; i >= 0; --i) {
                h += (S[i] - 'a') * pow, h %= p;
                pow *= 26, pow %= p;
            }
            unordered_multimap<int,int> h2i = {{h,0}}; // hash to indices
            auto i = 0;
            for ( ; i + mid < S.size(); ++i) {
                h *= 26, h %= p;
                h += (S[i+mid] - 'a') - (S[i] - 'a') * pow, h %= p;
                h += p, h %= p;
                auto its = h2i.equal_range(h);
                auto it = its.first;
                for ( ; it != its.second; ++it) {
                    auto j = i+1, k = it->second;
                    for ( ; j < i + mid; ++j, ++k) {
                        if (S[j] != S[k]) break;
                    }
                    if (j == i + mid) break;
                }
                if (it != its.second) break;
                h2i.insert({h,i+1});
            }
            if (i + mid < S.size())
                lo = mid, idx = i + 1;
            else hi = mid;
        }
        return S.substr(idx,lo);
    }
```

## stack/deque			
32	Longest Valid Parentheses    		25.6%	Hard	
using a stack to remove all valid pairs and then we leave with some intervals, then find the largest
```cpp
	int longestValidParentheses(string s) {
		stack<pair<char,int>> st;
		int maxlen=0;
		for(int i=0;i<s.size();i++){
			char c=s[i];
			if(st.size() && c==')' && st.top().first=='('){ 
				st.pop();
				if(st.size()) maxlen=max(maxlen,i-st.top().second);
				else maxlen=max(maxlen,i+1);
			}
			else st.push({c,i});
		}
		return maxlen;
	}
```	

42	Trapping Rain Water    		43.3%	Hard	
typical stack problem
stack in decreasing, once the new coming > stack it forms a container with the one before the stack top
```cpp
    int trap(vector<int>& height) {
        //using stack similar to largest rectangle in histogram
        //we maintain a stack with index, in decreasing order of height
        int n=height.size();
        stack<int> s;
        int i=0,total=0;

        while(i<n)
        {
            if(s.empty() || height[i]<=height[s.top()]) s.push(i++);
            else
            {
                int tp=s.top();s.pop();
                //min(h(l),h(r))-h(i). If there is no element in stack, the area is 0
                if(!s.empty())
                {
                    int area=(min(height[i],height[s.top()])-height[tp])*(i-s.top()-1);//current one as the minimum
                    total+=area;
                }
            }
        }
        return total;
    }
```
84	Largest Rectangle in Histogram    		31.3%	Hard	
Note it needs between to be all larger than the smaller side
approach 1: two way 
approach 2: divide and conquer
```cpp
    int largestRectangleArea(vector<int>& heights) {
        //the area=min(set)*len(set)
        /* use divide and conquer
    Find the minimum height column with index min. The max area should exist among three possible answers:
    sub-problem in index [0 ~ min]
    sub-problem in index [min + 1 ~ len - 1]
    height[min] * (len - 0)        
    */
        heights.push_back(0); //add a zero so that it won't overflow
        return getLargestArea(heights,0,heights.size()-1);
        
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }
```	
approach 3: using increasing stack
using stack
```cpp
    int largestRectangleArea(vector<int>& height) {
        height.insert(height.begin(),0); // dummy "0" added to make sure stack s will never be empty
        height.push_back(0); // dummy "0" added to clear the stack at the end
        int len = height.size();
        int i, res = 0, idx;
        stack<int> s; // stack to save "height" index
        s.push(0); // index to the first dummy "0"
        for(i=1;i<len;i++)
        {
            while(height[i]<height[idx = s.top()]) // if the current entry is out of order
            {
                s.pop();
                res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry
            }
            s.push(i);
        }
        height.erase(height.begin()); // remove two dummy "0"
        height.pop_back();
        return res;
    }
```	
85	Maximal Rectangle    		33.5%	Hard	
based on 1d histogram
```cpp
    int maximalRectangle(vector<vector<char>>& matrix) {
        //can we do it line by line and calculate the max?
        //using the algorithm from the max area in histogram
        //need calculate its height every line
        if(matrix.size()==0) return 0;
        int ncol=matrix[0].size();
        int nrow=matrix.size();
        
        vector<int> height(ncol+1);
        int max_area=0;
        for(int i=0;i<nrow;i++)
        {
            for(int j=0;j<ncol;j++) 
            {
                char c=matrix[i][j];
                if(c=='0') height[j]=0;
                else height[j]++;
            }
            int area=getLargestArea(height,0,height.size()-1)       ;
            if(area>max_area) max_area=area;
        }
        return max_area;
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }    
```

726	Number of Atoms    		44.7%	Hard	
using stack of maps
```cpp
    string countOfAtoms(string formula) {
		stack<map<string,int>> st;
		map<string,int> mp;
		int i=0,n=formula.size();
		while(i<n)
		{
			char c=formula[i++];
			if(c=='(') //( starting a stack
			{
				st.push(mp);//save previous result in stack
				mp.clear();
			}
			else if(c==')') //read the digits and perform multiply
			{
				int val=0;
				while(i<n && isdigit(formula[i])) val=val*10+formula[i++]-'0';
				if(!val) val=1;
				if(!st.empty())
				{
					map<string,int> mp0=st.top(); //t is a map
					st.pop();
                    //merge the two maps
					for(auto tt: mp) 
                        mp0[tt.first]+=tt.second*val;
                    mp=mp0;
				}
			}
			else //letters
			{
                
				int start=i-1;//since we perform i++ already
				while(i<n && islower(formula[i])) i++;
				string s=formula.substr(start,i-start);
                int val=0;
				while(i<n && isdigit(formula[i])) val=val*10+formula[i++]-'0';
				if(!val) val=1;
				mp[s]+=val;
			}
		}
		string ans;
		for(auto tt: mp)
		{
            ans+=tt.first;
            if(tt.second>1) ans+=to_string(tt.second);
		}
		return ans;
	}
```	

316	Remove Duplicate Letters    		32.6%	Hard	
brutal force: get the unique letters, sort and get all combinations, check if it is a subsequence
combined using hashmap and stack
idea: when a char is seen we first --cnt, and see if it is smaller than the stack top
for example bcabc we have b:2, c: 2, a: 1
first we see b, and there is more b behind, and smaller char behind now we have b: 1
we see c: and there is more c behind, and smaller char behind too, we have c: 1
we see a: we have no more, then we add it res=a
we see b, res=ab
we see c, res=abc;
cbacdcbc: we have c: 4, b: 2, a: 1, d: 1
c: skip, c: 3
b: skip, b: 1
a: added res=a.
c: skip c: 2
d: added res=ad.
c: skip c: 1
b: added res=adb
c: added res=adbc wrong (acdb<adbc)

cbacdcbc
c: c:3, res=c.
b: b:1, res=b. pop out c.
a: a:0, res=a. pop out b.
c: c: 2, res=ac.
d: d: 0: res=acd.
c: skip
b: res=acdb.

need a visited mechanism when added, put it true, pop it out then put it false.

```cpp
	string removeDuplicateLetters(string s){
		string ans; //using string as stack
		unordered_map<char,int> cnt;
        unordered_set<char> visited;
		for(char c: s) cnt[c]++;
		for(char c: s){
			--cnt[c];
            if(visited.count(c)) continue;
			while(ans.size() && c<ans.back() && cnt[ans.back()]){
                visited.erase(ans.back());
				ans.pop_back();
            }
			ans+=c;
            visited.insert(c);
		}
		return ans;
	}
	
```

224	Basic Calculator    		32.8%	Hard	
only involve +-()
```cpp
    int calculate(string s) {
        //+/- has lhs and rhs, can use binary tree and post-order traversal evaluation
        //also can use stack to do this. if we meet a ( we need to get the matching ) and evaluate it first
        //recursive approach: search for () first and evaluate using stack
        stack<int> brpos;
        int ind=0,start=0;//s.find_first_of('(');
        while(ind!=string::npos) //exists ()
        {
            ind=s.find_first_of("()",start);
            if(ind!=string::npos)
            {
                char c=s[ind];
                if(c=='(') brpos.push(ind);
                if(c==')')
                {
                    int ind1=brpos.top();
                    brpos.pop();
                    string res=myeval(s.substr(ind1+1,ind-ind1-1)); //evaluate it and update the string
                    s.replace(ind1,ind-ind1+1,res); //replace the string and size will be changed
					start=ind1;
                }
				else start=ind+1;
            }
			
        }
        //eval the string directly
        string res=myeval(s); 
        return stoi(res);
    }
    
    string myeval(string s) //there is no () inside, only numbers and +/- and space
    {
        int res=0,i;
        char c;
        stringstream ss(s);
        ss>>res;
        while(!ss.eof())
        {
            c=0; //to skip space
            ss>>c;
            if(c=='+') {ss>>i;res+=i;}
            if(c=='-') {ss>>i;res-=i;}
        }
        return to_string((long long)res);
    }
```	

1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
We run a preorder depth first search on the root of a binary tree.

At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  (If the depth of a node is D, the depth of its immediate child is D+1.  The depth of the root node is 0.)

If a node has only one child, that child is guaranteed to be the left child.

Given the output S of this traversal, recover the tree and return its root.

using iterative stack
    TreeNode* recoverFromPreorder(string S) {
        vector<TreeNode*> stack;
        for (int i = 0, level, val; i < S.length();) {
            for (level = 0; S[i] == '-'; i++)
                level++;
            for (val = 0; i < S.length() && S[i] != '-'; i++)
                val = val * 10 + S[i] - '0';
            TreeNode* node = new TreeNode(val);
            while (stack.size() > level) stack.pop_back();
            if (!stack.empty())
                if (!stack.back()->left) stack.back()->left = node;
                else stack.back()->right = node;
            stack.push_back(node);
        }
        return stack[0];
    }
	
	or 
    TreeNode* recoverFromPreorder(string S) {
        stack<pair<TreeNode*,int>> st;
        TreeNode* root=0;
        string w;
        int depth=0,prev_depth=0;
        S+='-';
        for(int i=0;i<S.size();i++)
        {
            char c=S[i];
            if(c=='-') 
            {
                if(w.size()) 
                {
                    int val=stoi(w);
                    TreeNode* t=new TreeNode(val);
                    if(st.empty()) root=t;
                    else
                    {
                        while(st.size() && st.top().second>depth) st.pop();
                        if(st.top().second==depth) {st.pop();st.top().first->right=t;}
                        else st.top().first->left=t;
                    }
                    st.push(make_pair(t,depth));
                    depth=0;
                    w="";
                }
                depth++;
            }
            else {w+=c;}
        }
        return root;
    }

862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
Calculate prefix sum B of list A.
B[j] - B[i] represents the sum of subarray A[i] ~ A[j-1]
Deque d will keep indexes of increasing B[i].
For every B[i], we will compare B[i] - B[d[0]] with K.

Time Complexity:
Loop on B O(N)
Every index will be pushed only once into deque. O(N)

C++:

    int shortestSubarray(vector<int> A, int K) {
        int N = A.size(), res = N + 1;
        vector<int> B(N + 1, 0);
        for (int i = 0; i < N; i++) B[i + 1] = B[i] + A[i];
        deque<int> d;
        for (int i = 0; i < N + 1; i++) {
            while (d.size() > 0 && B[i] - B[d.front()] >= K)
                res = min(res, i - d.front()), d.pop_front();
            while (d.size() > 0 && B[i] <= B[d.back()]) d.pop_back();
            d.push_back(i);
        }
        return res <= N ? res : -1;
    }
	
## backtracking
37	Sudoku Solver    		37.2%	Hard	
typical backtracking, trial & back
```cpp
    void solveSudoku(vector<vector<char>>& board) {
		if(board.size()==0) return;
		solve(board);
    }
	bool solve(vector<vector<char>>& b)
	{
		int m=b.size(),n=b[0].size();
		for(int i=0;i<m;i++)
		{
			for(int j=0;j<n;j++)
			{
				if(b[i][j]=='.')
				{
					for(char c='1';c<='9';c++)
					{
						if(isValid(b,i,j,c))
						{
							b[i][j]=c;
							if(solve(b)) return 1;
							else b[i][j]='.';
						}
					}
				}
			}
        }
		return 0;
	}
	bool isValid(vector<vector<char>>& b,int row,int col,char c)
	{
		for(int i=0;i<9;i++)
		{
			if(b[i][col]!='.' && b[i][col]==c) return 0;
			if(b[row][i]!='.' && b[row][i]==c) return 0;
			int r0=3*(row/3)+i/3,c0=3*(col/3)+i%3;
			if(b[r0][c0]!='.' && b[r0][c0]==c) return 0;
		}
		return 1;
	}
```

51	N-Queens    		39.5%	Hard	
nxn board and place n queens without attacking each other
each row shall only have one
each col shall only have one
each diag and anti-diag only have one
similar to sudoko solver using trial and back
```cpp
    vector<vector<string> > solveNQueens(int n) {
        vector<vector<string> > res;
        vector<string> nQueens(n, string(n, '.'));
        solveNQueens(res, nQueens, 0, n);
        return res;
    }
    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {
        if (row == n) 
        {
            res.push_back(nQueens);
            return;
        }
        for (int col = 0; col != n; ++col)
            if (isValid(nQueens, row, col, n)) 
            {
                nQueens[row][col] = 'Q';
                solveNQueens(res, nQueens, row + 1, n);
                nQueens[row][col] = '.';
            }
    }
    bool isValid(vector<string> &nQueens, int row, int col, int &n) 
    {
        //check if the column had a queen before.
        for (int i = 0; i != row; ++i)
            if (nQueens[i][col] == 'Q') return false;
        //check if the 45° diagonal had a queen before.
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
            if (nQueens[i][j] == 'Q') return false;
        //check if the 135° diagonal had a queen before.
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)
            if (nQueens[i][j] == 'Q') return false;
        return true;
    }
```


52	N-Queens II    		52.2%	Hard	
return the number of distinct solution.
similar to I.
```cpp
    int totalNQueens(int n) {
        //dfs, we need a matrix to store the occupied position
        vector<int> vp; //the column number
        return dfs(n,0,vp);
    }
    int dfs(int n,int row,vector<int>& vp)
    {
        if(row==n) return 1;
        int res=0;
        for(int col=0;col<n;col++) //try all columns
        {
            if(isValid(row,col,vp))
            {
                vp.push_back(col);
                res+=dfs(n,row+1,vp);
                vp.pop_back();
            }
        }
        return res;
    }
    bool isValid(int r,int c,vector<int>& vp)
    {
        //row is already ensured only one is placed
        for(int i=0;i<vp.size();i++) 
        {
            if(vp[i]==c) return 0; //vertical
            if(r+c==i+vp[i]) return 0;
            if(r-c==i-vp[i]) return 0;
        }
        return 1;
    }
```	

488	Zuma Game    		39.0%	Hard	
this is very similar to the posted google phone interview to remove 3 or more identical numbers
balls have 5 different colors, there are some balls on the table and some tables in hand.
find the min number balls to insert to remove all balls on the table.

dfs/bfs/dp
dfs approach:
- convert balls in hand as hashmap
- dfs: find all possible ways to empty the table and get the min
- dfs backtracking: 
```cpp
    int minStep;
    int findMinStep(string board, string hand) {
        unordered_map<char,int> mp;
        for (auto c:hand) mp[c]++;
    
        minStep=INT_MAX;
        dfs(board, mp, 0);
        return minStep==INT_MAX?-1:minStep;
    }
    void dfs(string& board, unordered_map<char,int>& mp, int used) {
        if (board.empty()) {
            minStep=min(minStep, used);
            return;
        }
        
        for (int i=0; i<board.size();) {
            int j=i;
            char c=board[i];
            while (j<board.size() && board[j]==c) j++;
            if (j-i<3) {
                int miss=3-(j-i);
                if (mp[c]>=miss) {
                    removeBoard(board, i, j);
                    mp[c]-=miss;
                    dfs(board, mp, used+miss);
                    mp[c]+=miss;
                    restoreBoard(board, i, j-i, c);    
                }
            } else {
                removeBoard(board, i, j);
                dfs(board, mp, used);
                restoreBoard(board, i, j-i, c);
            }
            i=j;
        }
    }
    
    void removeBoard(string& board, int start, int end) {
        board.erase(board.begin()+start, board.begin()+end);
    }
    
    void restoreBoard(string& board, int pos, int n, char c) {
        board.insert(pos, n, c);
    }
```
this is also very similar to the problem of removing boxes

753	Cracking the Safe    		46.4%	Hard	
There is a box protected by a password. The password is n digits, where each letter can be one of the first k digits 0, 1, ..., k-1.

You can keep inputting the password, the password will automatically be matched against the last n digits entered.

For example, assuming the password is "345", I can open it when I type "012345", but I enter a total of 6 digits.

Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.
the idea: everytime we change just one char. 
In order to guarantee to open the box at last, the input password ought to contain all length-n combinations on digits [0..k-1] - there should be k^n combinations in total.

To make the input password as short as possible, we'd better make each possible length-n combination on digits [0..k-1] occurs exactly once as a substring of the password. The existence of such a password is proved by De Bruijn sequence:

A de Bruijn sequence of order n on a size-k alphabet A is a cyclic sequence in which every possible length-n string on A occurs exactly once as a substring. It has length k^n, which is also the number of distinct substrings of length n on a size-k alphabet; de Bruijn sequences are therefore optimally short.

We reuse last n-1 digits of the input-so-far password as below:

e.g., n = 2, k = 2
all 2-length combinations on [0, 1]: 
00 (`00`110), 
 01 (0`01`10), 
  11 (00`11`0), 
   10 (001`10`)
   
the password is 00110
We can utilize DFS to find the password:

goal: to find the shortest input password such that each possible n-length combination of digits [0..k-1] occurs exactly once as a substring.

node: current input password

edge: if the last n - 1 digits of node1 can be transformed to node2 by appending a digit from 0..k-1, there will be an edge between node1 and node2

start node: n repeated 0's
end node: all n-length combinations among digits 0..k-1 are visited

visitedComb: all combinations that have been visited
```java
    public String crackSafe(int n, int k) {
        // Initialize pwd to n repeated 0's as the start node of DFS.
        String strPwd = String.join("", Collections.nCopies(n, "0"));
        StringBuilder sbPwd = new StringBuilder(strPwd);
        
        Set<String> visitedComb = new HashSet<>();
        visitedComb.add(strPwd);
    
        int targetNumVisited = (int) Math.pow(k, n);
        
        crackSafeAfter(sbPwd, visitedComb, targetNumVisited, n, k);
        
        return sbPwd.toString();
    }
    
    private boolean crackSafeAfter(StringBuilder pwd, Set<String> visitedComb, int targetNumVisited, int n, int k) {
        // Base case: all n-length combinations among digits 0..k-1 are visited. 
        if (visitedComb.size() == targetNumVisited) {
            return true;
        }
        
        String lastDigits = pwd.substring(pwd.length() - n + 1); // Last n-1 digits of pwd.
        for (char ch = '0'; ch < '0' + k; ch++) {
            String newComb = lastDigits + ch;
            if (!visitedComb.contains(newComb))  {
                visitedComb.add(newComb);
                pwd.append(ch);
                if (crackSafeAfter(pwd, visitedComb, targetNumVisited, n, k)) {
                    return true;
                }
                visitedComb.remove(newComb);
                pwd.deleteCharAt(pwd.length() - 1);
            }
        }
        
        return false;
    }
```	
	
## dfs/bfs
	
45	Jump Game II    		28.1%	Hard	
each number is the max jump steps
return min number of jumps
bfs like algorithm on 1d array.
```cpp
    int jump(vector<int>& nums) {
		int n=nums.size();
		 if(n<2)return 0;
		 int level=0,currentMax=0,i=0,nextMax=0;

		 while(currentMax-i+1>0)
		 {		//nodes count of current level>0
			 level++;
			 for(;i<=currentMax;i++)
			 {	//traverse current level , and update the max reach of next level
				nextMax=max(nextMax,nums[i]+i);
				if(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level 
			 }
			 currentMax=nextMax;
		 }
		 return 0;
	 }        
 ```
126	Word Ladder II    		17.8%	Hard	
find all shortest path from A to B.
similar problem 127 Word Ladder using bfs. (shortest distance from A to B)
- convert to hashset first for better retrieving.
- 
```cpp
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> dict(wordList.begin(),wordList.end()),visited;
		queue<string> q;
		q.push(beginWord);
		visited.insert(beginWord);
		int step=1;
		while(q.size()){
			int sz=q.size();
			while(sz--){
				string s=q.front();
				if(s==endWord) return step;
				q.pop();
				addWords(s,q,dict,visited);
			}
			step++;
		}
		return 0;
    }
	void addWords(string& s,queue<string>& q,unordered_set<string>& dict,unordered_set<string>& visited){
		for(int i=0;i<s.size();i++){
			char c=s[i];
			for(char t='a';t<='z';t++){
				s[i]=t;
				if(dict.count(s) && !visited.count(s)) {
					q.push(s);
					visited.insert(s);
				}
			}
			s[i]=c;
		}
	}
```	
now we need all the shortest path.
approach 1: get the shortest path length using bfs and then find path using dfs. wasted information
approach 2: bfs while keeping the route information.
when we found the path we need keep finishing the layer. also we need keep the path information. (parent)
need add a pointer to its parent. it forms a tree.
```cpp
	struct node{
		node* parent;
		string s;
		node(string ss): s(ss),parent(0){}
		node(string ss,node* p): s(ss),parent(p){}
	};
	vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList){
		vector<vector<string>> ans;
        unordered_set<string> dict(wordList.begin(),wordList.end()),visited;
		vector<node*> tree;
		queue<node*> q; //parent-child pair, do not use pointer since vector is dynamic
		tree.push_back(new node(beginWord));
		q.push(tree.back());
		visited.insert(beginWord);
		int step=1;
        bool stop=0;
		vector<string> layer;
		while(q.size() && !stop){
			layer.clear();
			int sz=q.size();
			while(sz--){
				auto nd=q.front(); //use pointer be very careful
				q.pop();
                //cout<<nd->s<<endl;
                auto parent=nd;
				if(nd->s==endWord) {
                    stop=1;
					vector<string> vt;
					while(nd){
						vt.push_back(nd->s);
                        nd=nd->parent;
					}
					ans.push_back({vt.rbegin(),vt.rend()});
				}
				addWords(parent->s,q,dict,visited,tree,parent,layer);
			}
			for(auto t: layer) visited.insert(t);
			step++;
		}
		return ans;
    }
	void addWords(string s,queue<node*>& q,unordered_set<string>& dict,
	unordered_set<string>& visited,vector<node*>& tree,node* parent,vector<string>& layer){
		for(int i=0;i<s.size();i++){
			char c=s[i];
			for(char t='a';t<='z';t++){
				s[i]=t;
				if(dict.count(s) && !visited.count(s)) {
					tree.push_back(new node(s,parent));
					q.push(tree.back());
					//if(s!=endw) visited.insert(s);
					layer.push_back(s);
				}
			}
			s[i]=c;
		}
		//for(auto t: vt) visited.insert(t);
	}
```
There is a problem: 
- the endword is not allowed to be included multiple times so only one answer would be given.
- different path may contain a common word so the visited is not proper. actually this is the key part.
bfs: the layer used canot never be visited again.
but the same layer can be used multiple times. so we can only update the visited after the layer is done!!!!!
this is another form of BFS and very good question. The node may have multiple parents to avoid dfs, it is necessary to keep multiple same nodes	in queue to maintain one to one relation

282	Expression Add Operators    		32.8%	Hard	
given a string of digits, apply +-* to get the target
divide and conquer, combined with backtracking
- loop all positions and divide left and right part. left as a number, and right as a subproblem
- apply +-* between left and right
- righ subproblem
- perform evaluation current value, previous op value, previous operator

```cpp
    vector<string> addOperators(string num, int target) {
        vector<string> res;
        if (num.empty()) return res;
        for (int i=1; i<=num.size(); i++) 
        {
            string s = num.substr(0, i);
            long cur = stol(s);
            if (to_string(cur).size() != s.size()) continue;//leading zeros
            dfs(res, num, target, s, i, cur, cur, '#');         // no operator defined.
        }

        return res;
    }

    // cur: {string} expression generated so far.
    // pos: {int}    current visiting position of num.
    // cv:  {long}   cumulative value so far.
    // pv:  {long}   previous operand value.
    // op:  {char}   previous operator used.
    void dfs(std::vector<string>& res, const string& num, int target, 
	string cur, int pos, long cv, long pv, char op) {
        if (pos == num.size() && cv == target) {res.push_back(cur);} 
        else 
        {
            for (int i=pos+1; i<=num.size(); i++) 
            {
                string t = num.substr(pos, i-pos);
                long now = stol(t);
                if (to_string(now).size() != t.size()) continue;
                dfs(res, num, target, cur+'+'+t, i, cv+now, now, '+');
                dfs(res, num, target, cur+'-'+t, i, cv-now, now, '-');
                dfs(res, num, target, cur+'*'+t, i, (op=='-')?cv+pv-pv*now:((op=='+')?cv-pv+pv*now : pv*now), pv*now, op);
            }
        }
    }    
```	
 
330	Patching Array    		33.4%	Hard	
Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.
for example [1,5,10] n=20, we need to be able to add to 20.
missing 2: add 2, we can get 2 and 3
missing 4: add 4, we can get 1,2,4 we cover 1,2,3,4,5,6,7
adding 5: 1,2,4,5, we can add up to 12
adding 10: we can add up to 22
greedy choice: 
```cpp
    int minPatches(vector<int>& nums, int n) {
        //the fastest way to go to n without leaving out any number
        //if the smaller subproblem  solves from 1 to m, then add a number m+1, it solves the problem from 1 to 2m+1
        //the greedy choice is the smaller subproblem's sum+1
         long miss = 1, added = 0, i = 0;
         while (miss <= n) 
         {
            if (i < nums.size() && nums[i] <= miss) 
            {
                miss += nums[i++];
            } 
            else 
            {
                miss += miss;
                added++;
            }
        }
        return added;
    }
```	
 
675	Cut Off Trees for Golf Event    		30.8%	Hard	
bfs
```cpp
    int cutOffTree(vector<vector<int>>& forest) {
        vector<vector<int>> trees;
        int m=forest.size(),n=forest[0].size();
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                if(forest[i][j]>1) trees.push_back({forest[i][j],i,j});
        sort(trees.begin(),trees.end());
        int curx=0,cury=0;
        int ans=0;
        
        for(int i=0;i<trees.size();i++)
        {
            int steps=bfs(forest,curx,cury,trees[i][1],trees[i][2]);
            //cout<<curx<<" "<<cury<<"->"<<trees[i][1]<<" "<<trees[i][2]<<": "<<steps<<endl;
            if(steps<0) return -1;
            ans+=steps;
            curx=trees[i][1],cury=trees[i][2];
            forest[curx][cury]=1;
        }
        return ans;
    }
    
    int bfs(vector<vector<int>>& forest,int sx,int sy,int tx,int ty)
    {
        if(sx==tx && sy==ty) return 0;
        int m=forest.size(),n=forest[0].size();
        queue<int> q;
        vector<bool> visited(m*n);
        q.push(sx*n+sy);
        visited[sx*n+sy]=1;
        int steps=0;
        int dir[][2]={{-1,0},{1,0},{0,1},{0,-1}};
        while(!q.empty())
        {
            int sz=q.size();
            for(int i=0;i<sz;i++)
            {
                int pos=q.front();q.pop();
                int x=pos/n,y=pos%n;

                for(int d=0;d<4;d++)
                {
                    int xx=x+dir[d][0],yy=y+dir[d][1];
                    int ps=xx*n+yy;
                    if(xx==tx && yy==ty) return steps+1;
                    if(xx<0 || xx>=m || yy<0 || yy>=n || visited[ps] || forest[xx][yy]==0) continue;
                    
                    q.push(ps);visited[ps]=1;
                }
            }
            steps++;
        }
        return -1;
    }
```

864	Shortest Path to Get All Keys    		36.1%	Hard	
We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks.

We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.

For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.

Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.

The idea is based on the thoughts that, usually, you won't want to visit a position where you have traversed.
However, in this problem, you may have to go back and forth to get keys for the lock.
So the keypoint is "how to relax the visited condition"?
The keypoint is that "you are only allowed to revisit a position if you get new keys".
To solve it, I use a visited map considering current carried keys, and prevent to revisit the same position if hold key is not updated.
Original visited map is two-dimension, and with keys dimension added, it extends to a three-dimension vector.
Since the problem tells us that 1<=K<=6, we know at most 64 conditions here. (only have to consider key, and no need to consider lock status)

int shortestPathAllKeys(vector<string>& grid) {
    int m=grid.size(), n=m?grid[0].size():0;
    if(!m || !n) return 0;
    int path=0, K=0;
    vector<int> dirs={0,-1,0,1,0};
    vector<vector<vector<bool>>> visited(m,vector<vector<bool>>(n,vector<bool>(64,0))); //at most 6 keys, using bitmap 111111
    queue<pair<int,int>> q; //<postion, hold keys mapping>
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(grid[i][j]=='@'){
                q.push({i*n+j,0});
                visited[i][j][0]=1;                    
            }
            if(grid[i][j]>='A' && grid[i][j]<='F') K++; //total alpha number
        }
    }
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size;i++){
            int a=q.front().first/n, b=q.front().first%n;
            int carry=q.front().second;
            q.pop();        
            if(carry==((1<<K)-1)) return path; //if all keys hold, just return 
            for(int j=0;j<4;j++){
                int x=a+dirs[j], y=b+dirs[j+1], k=carry;
                if(x<0 || x>=m || y<0 || y>=n || grid[x][y]=='#') continue;
                if(grid[x][y]>='a' && grid[x][y]<='f'){
                    k=carry|(1<<(grid[x][y]-'a')); //update hold keys
                }
                else if(grid[x][y]>='A' && grid[x][y]<='F'){
                    if(!(carry & (1<<(grid[x][y]-'A')))) continue;
                }
                if(!visited[x][y][k]){
                    visited[x][y][k]=1;
                    q.push({x*n+y,k});
               }                
            }
        }
        path++;
    }
    return -1;
}

871	Minimum Number of Refueling Stops    		28.9%	Hard	
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        //dp[t] is the largest distance after refuel t times
        //we keep updating until all stations are used
        int n=stations.size();
        vector<int> dp(n+1);
        dp[0]=startFuel; 
        for(int i=0;i<n;i++)
        {
            for(int t=i;t>=0;t--)
            {
                if(dp[t]>=stations[i][0]) dp[t+1]=max(dp[t+1],dp[t]+stations[i][1]);
            }
        }
        //find the first t with dp[t]>=target
        for(int i=0;i<=n;i++) if(dp[i]>=target) return i;
        return -1;
    }
	 
773	Sliding Puzzle    		52.6%	Hard	
bfs
```cpp
    int slidingPuzzle(vector<vector<int>>& board) {
        //convert the board to string and using bfs
        string s;
        for(int i=0;i<board.size();i++)
            for(int j=0;j<board[i].size();j++) s+=board[i][j]+'0';
        string target="123450";
        if(s==target) return 0;
        vector<vector<int>> dir{{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}};;
        //we need keep track the zero position and try all possible move, or use search
        //not sure if there are repeatable 
        queue<string> q;
        unordered_set<string> visited;
        q.push(s);visited.insert(s);
        int step=0;
        while(!q.empty())
        {
            int sz=q.size();
            for(int i=0;i<sz;i++)
            {
                string t=q.front();q.pop();
                int ind0=t.find_first_of('0');
                for(int j=0;j<dir[ind0].size();j++)
                {
                    string tt=t;
                    swap(tt[ind0],tt[dir[ind0][j]]);
                    if(tt==target) return step+1;
                    if(visited.count(tt)==0) {q.push(tt);visited.insert(tt);}
                }
            }
            step++;
        }
        return -1;
        
        
    }
```
	
815	Bus Routes    		40.1%	Hard	
We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.

We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.

Example:
Input: 
routes = [[1, 2, 7], [3, 6, 7]]
S = 1
T = 6
Output: 2
Explanation: 
The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.
this is a graph problem with bfs
```cpp
    int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {
        //this is a BFS problem
        //need convert the data structure to a data structure
        if(S==T) return 0;
        unordered_map<int,vector<int>> mp; //each node has a group number
        for(int i=0;i<routes.size();i++)
        {
            for(int j=0;j<routes[i].size();j++) mp[routes[i][j]].push_back(i);
        }
        
        //we first generate a group connection map: group number to a set of other group
        vector<set<int>> connection_mp(routes.size());
        for(auto it=mp.begin();it!=mp.end();it++) 
        {
            if(it->second.size()>1)
            {
                for(int i=0;i<it->second.size();i++)
                {
                    connection_mp[it->second[i]].insert(it->second.begin(),it->second.end());//=it->second; //include itself for simplicity
                }
            }
        }
        //print(connection_mp);
        //cout<<"S: ";copy(mp[S].begin(),mp[S].end(),ostream_iterator<int>(cout," "));cout<<endl;
        //cout<<"T: ";copy(mp[T].begin(),mp[T].end(),ostream_iterator<int>(cout," "));cout<<endl;
        //S and T could be on one or more groups!
        int min_jmp=INT_MAX;
        for(auto it=mp[S].begin();it!=mp[S].end();it++)
        {
            for(auto it1=mp[T].begin();it1!=mp[T].end();it1++)
            {
                int jmp=min_steps(*it,*it1,connection_mp);
                min_jmp=min(min_jmp,jmp);
            }
        }
        if(min_jmp==INT_MAX) return -1;
        return min_jmp;
    }
    int min_steps(int s,int t,vector<set<int>>& mp)
    {
        //using BFS to get the shortest jmp
        int ans=INT_MAX;
        set<int> visited;
        queue<int> q;
        q.push(s);//visited.insert(s);
        int steps=0;
        while(!q.empty())
        {
            int sz=q.size();
            steps++;
            for(int i=0;i<sz;i++) //the layer
            {
                int tp=q.front();q.pop();
                if(visited.count(tp)) continue;
                if(tp==t) return steps;
                visited.insert(tp);
                for(auto it=mp[tp].begin();it!=mp[tp].end();it++)
                {
                    if(*it==tp) continue; //itself
                    q.push(*it);
                    
                }
            }
            
        }
        return ans;
    }
```

1036 Escape a Large Maze    		36.8%	Hard	
    long n=1e6;
    int max_steps=20000;
    int sx,sy;
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        unordered_set<long> obs;
        int steps=0;
        for(auto t: blocked) obs.insert(t[0]*n+t[1]);
        unordered_set<long> visited;
        bool res=dfs(obs,sx=source[0],sy=source[1],target[0],target[1],steps,visited);
        steps=0;visited.clear();
        res=res&&dfs(obs,sx=target[0],sy=target[1],source[0],source[1],steps,visited);
        return res;
    }
    bool dfs(unordered_set<long>& obs,int i,int j,int x,int y,int& steps,unordered_set<long>& visited)
    {
      if(i<0 || j<0 || i>=n || j>=n) return 0;
      long t=i*n+j;
      if(obs.count(t) || visited.count(t)) return 0;
      if(i==x && j==y) return 1;
      //if(steps>=max_steps) return 1;
      if(abs(i-sx)+abs(j-sy)>obs.size()) return 1;
      visited.insert(t);
      steps++;
      
      bool res=dfs(obs,i-1,j,x,y,steps,visited);
      if(!res) res=dfs(obs,i+1,j,x,y,steps,visited);
      if(!res) res=dfs(obs,i,j-1,x,y,steps,visited);
      if(!res) res=dfs(obs,i,j+1,x,y,steps,visited);
      return res;
    }

996	Number of Squareful Arrays    		47.7%	Hard	
brutal force to find all paired
and then dfs to find the number

    unordered_map<int, int> count;
    unordered_map<int, unordered_set<int>> cand;
    int res = 0;
    int numSquarefulPerms(vector<int>& A) {
        for (int &a : A) count[a]++;
        for (auto &i : count) {
            for (auto &j : count) {
                int x = i.first, y = j.first, s = sqrt(x + y);
                if (s * s == x + y)
                    cand[x].insert(y);
            }
        }
        for (auto e : count)
            dfs(e.first, A.size() - 1);
        return res;
    }

    void dfs(int x, int left) {
        count[x]--;
        if (!left) res++;
        for (int y : cand[x])
            if (count[y] > 0)
                dfs(y, left - 1);
        count[x]++;
    }
	
980	Unique Paths III    		71.0%	Hard	
dfs the peculiar requirement: need to walk every empty cell exactly once.
```cpp
    int uniquePathsIII(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        int nsteps=0,sx=0,sy=0;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1) sx=i,sy=j;
                if(grid[i][j]!=-1) nsteps++;
            }
        }
        return dfs(grid,sx,sy,1,nsteps);
    }
    int dfs(vector<vector<int>>& grid,int sx,int sy,int step,int nsteps)
    {
        int m=grid.size(),n=grid[0].size();
        if(sx<0 || sx>=m || sy<0 || sy>=n || grid[sx][sy]==-1) return 0;
        if(grid[sx][sy]==2) return step==nsteps?1:0;
        grid[sx][sy]=-1; //mark it visited
        int ans=dfs(grid,sx+1,sy,step+1,nsteps);
        ans+=dfs(grid,sx-1,sy,step+1,nsteps);
        ans+=dfs(grid,sx,sy+1,step+1,nsteps);
        ans+=dfs(grid,sx,sy-1,step+1,nsteps);
        grid[sx][sy]=0;
        return ans;
    }	
	
854	K-Similar Strings    		33.5%	Hard	
swap exactly k-times
return the smallest k.
bfs
```cpp
    int kSimilarity(string A, string B) {
        if (A == B) return 0;
		queue<string> que;
		unordered_set<string> vis;
		que.push(A);
		int ans = 0, len = A.length();
		while (!que.empty())
		{
			ans++;
			int m = que.size(), i=0;
			while (m--)
			{
				string str = que.front(); que.pop();
				i = 0;
				while (str[i] == B[i]) i++;
				for (int j = i + 1; j < len; j++)
				{
					if (str[j] != B[j] && str[j] == B[i])
					{
						string temp = str;
						swap(temp[i], temp[j]);
						if (temp == B) return ans;
						if (vis.insert(temp).second) que.push(temp);
						
					}
				}
			}
		}
		return ans;
    }
```

847	Shortest Path Visiting All Nodes    		46.8%	Hard	
An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph.

graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected.

Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.

standard process with a state using bfs.

```cpp
    struct State{
        int mask,source;
        State(int m,int s):mask(m),source(s){}
    };
    int shortestPathLength(vector<vector<int>>& graph) {
        int m=graph.size();
        int len=1<<m;
        vector<vector<int>> dp(m,vector<int>(len,INT_MAX));
        queue<State> qs;
        for(int i=0;i<m;i++) 
        {
            dp[i][1<<i]=0; //self to self distance is 0
            qs.push(State(1<<i,i));
        }
        while(!qs.empty())
        {
            State state=qs.front();
            //cout<<state.source<<" "<<hex<<state.mask<<endl;
            qs.pop();
            for(int next:graph[state.source]) //connected nodes
            {
                int nextmask=state.mask|(1<<next);
                if(dp[next][nextmask]>dp[state.source][state.mask]+1) //passing this node is closer
                {
                    dp[next][nextmask]=dp[state.source][state.mask]+1;
                    qs.push(State(nextmask,next));
                }
            }
        }
        //shortest path 
        int ans=INT_MAX;
        for(int i=0;i<m;i++) ans=min(ans,dp[i][(1<<m)-1]);
        return ans;
    }
```			
## intervals
57	Insert Interval    		31.3%	Hard	
insert and merge
sort using the start. and then find the insert position. and merge those between.
note compare the end<the other's start. using equal range or lower_bound or upper_bound.
very smart. O(logn)
```cpp
    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
        auto compare = [] (const Interval &intv1, const Interval &intv2)
                          { return intv1.end < intv2.start; };
        auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);
        auto itr1 = range.first, itr2 = range.second;
        if (itr1 == itr2) {
            intervals.insert(itr1, newInterval);
        } else {
            itr2--;
            itr2->start = min(newInterval.start, itr1->start);
            itr2->end = max(newInterval.end, itr2->end);
            intervals.erase(itr1, itr2);
        }
        return intervals;
    }
```	
if not sorted, we can just merge each interval with the new one, and keeps updating the new one
O(n)
		
218	The Skyline Problem    		31.7%	Hard	
building are given as [x0,x1,h] and want to form the skyline
this is similar to intervals and output connected intervals with height
the output only needs the start point and height
approach:
- sort the intervals according to start. 
- overlap point is the max(h)
- we can use priority_queue to push pop the height
- min heap!!!
```cpp
	struct comp{
		bool operator()(vector<int>& a,vector<int>& b){
			return a[0]>b[0] || (a[0]==b[0] && a[2]>b[2]);
		}
	};
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        vector<vector<int>> ans;
		//sort(buildings.begin(),buildings.end());
		priority_queue<vector<int>,vector<vector<int>>,comp> pq(buildings.begin(),buildings.end());
		while(pq.size()){
			auto t=pq.top();
			ans.push_back({t[0],t[2]});
			while(pq.size() && pq.top()[0]==t[0]) pq.pop();
		}
		return ans;
	}
```

352	Data Stream as Disjoint Intervals    		43.6%	Hard	
merge the data into intervals
- sort the intervals according to start in a set
- when add a val, check if it overlaps with an interval, if yes, merge it.
for a single value it covers [val, val+1)
```cpp
    struct Cmp{
        bool operator()(Interval a, Interval b){ return a.start < b.start; }
    };
    set<Interval, Cmp> st;

    void addNum(int val) {
        auto it = st.lower_bound(Interval(val, val));
        int start = val, end = val;
        if(it != st.begin() && (--it)->end+1 < val) it++;
        while(it != st.end() && val+1 >= it->start && val-1 <= it->end)
        {
            start = min(start, it->start);
            end = max(end, it->end);
            it = st.erase(it);
        }
        st.insert(it,Interval(start, end));
    }
    
    vector<Interval> getIntervals() {
        vector<Interval> result;
        for(auto val: st) result.push_back(val);
        return result;
    }
```				

699	Falling Squares    		40.1%	Hard	
squares dropped at different position with different side length. If the square touches any other square, it is attached.
return the largest height so far.
```cpp
 vector<int> fallingSquares(vector<pair<int, int>>& positions) {
        map<int,int> mp = {{0,0}, {INT_MAX,0}};
        vector<int> res;
        int cur = 0;
        for(auto &p : positions){
            int l = p.first, r = p.first + p.second, h = p.second, maxH = 0;
            auto ptri = mp.upper_bound(l), ptrj = mp.lower_bound(r);        // find range
            int tmp = ptrj->first == r? ptrj->second : (--ptrj)++->second;  // tmp will be applied by new right bound 
            for(auto i = --ptri; i != ptrj; ++i)
                maxH = max(maxH, i->second);                                // find biggest height
            mp.erase(++ptri, ptrj);                                         // erase range
            mp[l] = h+maxH;                                                 // new left bound
            mp[r] = tmp;                                                    // new right bound
            cur = max(cur, mp[l]);
            res.push_back(cur);
        }
        return res;
    }
```

715	Range Module    		35.6%	Hard	
range [left, right). half open interval
addRange
removeRange
queryRange

```cpp
	map<int, int> invals;
    void addRange(int left, int right) {
        auto l = invals.upper_bound(left), r = invals.upper_bound(right); 
        if (l != invals.begin()) {
            l--;
            if (l->second < left) l++;
        }
        if (l != r) {
            left = min(left, l->first);
            right = max(right, (--r)->second);
            invals.erase(l,++r);
        }
        invals[left] = right;
    }
    
    bool queryRange(int left, int right) {
        auto it = invals.upper_bound(left);
        if (it == invals.begin() || (--it)->second < right) return false;
        return true;
    }
    
    void removeRange(int left, int right) {
        auto l = invals.upper_bound(left), r = invals.upper_bound(right); 
        if (l != invals.begin()) {
            l--;
            if (l->second < left) l++;
        }
        if (l == r) return;
        int l1 = min(left, l->first), r1 = max(right, (--r)->second);
        invals.erase(l, ++r);
        if (l1 < left) invals[l1] = left;
        if (r1 > right) invals[right] = r1;
    }
  
```	

757	Set Intersection Size At Least Two    		37.0%	Hard	
find the min sized interval such that it has at least two intersection with all intervals
greedy: sort the intervals using end. we only need to cover the first interval last two points and last interval first two points.
pay attention to the last, since first two points cannot guarantee previous intervals will be covered. that is why we need to sort also the starting decending

```cpp
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) 
        {
            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]); 
        });
        int n = intervals.size(), ans = 0, p1 = -1, p2 = -1;
        for (int i = 0; i < n; i++) 
        {
            if (intervals[i][0] <= p1) continue;// current p1, p2 works for intervals[i]
            if (intervals[i][0] > p2) // Neither of p1, p2 works for intervals[i]
            {
                ans += 2;
                p2 = intervals[i][1];// replace p1, p2 by ending numbers
                p1 = p2-1;
            }
            else //only p2 works
            {
                ans++;
                p1 = p2;
                p2 = intervals[i][1];
            }
        }
        return ans;
    }
```	

732	My Calendar III    		55.0%	Hard	
k-overlapping
```cpp
    map<int, int> timeline;
public:
    int book(int s, int e) {
        timeline[s]++; // 1 new event will be starting at [s]
        timeline[e]--; // 1 new event will be ending at [e];
        int ongoing = 0, k = 0;
        for (pair<int, int> t : timeline)
            k = max(k, ongoing += t.second);
        return k;
    }
```

## misc
41	First Missing Positive    		29.0%	Hard	
O(N) requirement
```cpp
Put each number in its right place.

For example:

When we find 5, then swap it with A[4].

At last, the first place where its number is not right, return the place + 1.
```cpp
class Solution
{
public:
    int firstMissingPositive(int A[], int n)
    {
        for(int i = 0; i < n; ++ i)
            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])
                swap(A[i], A[A[i] - 1]);
        
        for(int i = 0; i < n; ++ i)
            if(A[i] != i + 1)
                return i + 1;
        
        return n + 1;
    }
};
```
		
65	Valid Number    		14.0%	Hard	
trivial.
```cpp
    bool isNumber(string s) {
        string whitespace=" \t";
        int ind=s.find_last_not_of(whitespace);
        s=s.substr(0,ind+1);
        stringstream ss(s);
        double a;
        //we need remove trailing space since it is not good for processing
 
        ss>>a;
        
        if(ss.fail()) return 0;
        if(ss.eof()) return 1;
        return 0;
    }
```	
68	Text Justification    		23.4%	Hard	
```cpp
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        //each line: begin no space, last one no space!
        //if one word cannot fit the line, we shall break it into multiple lines
        //more like a greedy problem, allow take one or none
        //only exception is the line cannot fit a single word! we may break the single big words into two or three words
        //note last line shall be left adjustment!
        vector<string> line;
        vector<string> res;
        int cnt=0;
        bool line_done=0,last_line=0;
        for(int i=0;i<words.size();i++)
        {
            int len=cnt+words[i].size()+(line.empty()?0:1);
            
            if(len<=maxWidth) 
            {
                line.push_back(words[i]);cnt=len;
                if(i==words.size()-1) last_line=1;
            }
            else line_done=1;

            if(line_done && !last_line && !line.empty())    
            {
                int rem=maxWidth-cnt+line.size()-1; //cnt already included spaces
                int extra=0;
                if(line.size()>1)
                    extra=rem/(line.size()-1); //the remaining is added one from left to right!
                else extra=rem;
                rem-=extra*(line.size()-1);
                string s;
                for(int j=0;j<line.size()-1;j++) 
                {
                    s+=line[j];s.append(extra+(j<rem?1:0),' ');
                }
                s+=line.back();
				if(line.size()==1) s.append(extra,' ');
                res.push_back(s);
                line.clear();
                line_done=0;
				line.push_back(words[i]);cnt=words[i].size();
            }
        }
        //process last line
        cnt=0;
        string s;
        for(int i=0;i<line.size()-1;i++) {s+=line[i]+' ';cnt+=line[i].size()+1;}
        s+=line.back();cnt+=line.back().size();
        s.append(maxWidth-cnt,' ');
        res.push_back(s);
        
        return res;        
    }
```	


## sliding window
76	Minimum Window Substring    		30.9%	Hard
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
S has non-related chars.
sliding window: 
for simplicity we are decreasing/increasing the hashmap and length counter.
```cpp
	string minWindow(string s, string t) {
		unordered_map<char, int> mp;	// Statistic for count of char in t
		for (auto c : t) mp[c]++;
		// counter represents the number of chars of t to be found in s.
		int start = 0, end = 0, minStart = 0, minLen = INT_MAX;
		int slen = s.size(),tlen = t.size();
			
		while (end<slen) // Move end to find a valid window.
		{
			if (mp[s[end]]>0) tlen--;// If char in s exists in t, decrease counter
			mp[s[end]]--;// Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.
			end++;
			
			while (tlen == 0) // When we found a valid window, move start to find smaller window.
			{
				if(end-start<minLen) 
				{
					minStart=start;
					minLen=end-start;
				}
				mp[s[start]]++;
				
				if (mp[s[start]]>0) tlen++;// When char exists in t, increase counter.
				start++;
			}
		}
		if (minLen != INT_MAX)return s.substr(minStart, minLen);
		return "";
	}
```

239	Sliding Window Maximum    		38.3%	Hard	
classical problem using deque keeping monotonic order
also works for sliding window minimum
[1,3,-1,-3,5,3,6,7]
linear time
deque: deque=1
incoming 3: remove 1, deque=3
incoming -1: 
approach:
- save index in the deque (so we have both index and value information)
- front is always the max
- max is out of window, remove the front
- incoming > back, then remove all smaller ones 
- add incoming into back.

```cpp
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        //monotonic array using deque
        vector<int> res;
        deque<int> dq;
        for(int i=0;i<nums.size();i++)
        {
            if(!dq.empty() && dq.front()==i-k) dq.pop_front();
            while(!dq.empty() && nums[dq.back()]<nums[i]) dq.pop_back(); //remove all elements less than it
            dq.push_back(i);
            if(i>=k-1) res.push_back(nums[dq.front()]);
        }
        return res;
    }
```	

480	Sliding Window Median    		32.6%	Hard	
we have done sliding window max/min using deque
now is the median
we can use two pq, one for the max, one for the min?
this is similar to the median in a data stream.

```cpp
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> medians;
        unordered_map<int, int> hash;                          // count numbers to be deleted
        priority_queue<int, vector<int>> left;                // heap on the bottom
        priority_queue<int, vector<int>, greater<int>> right;  // heap on the top
        
        int i = 0;
        
        // Initialize the heaps
        while (i < k)  { left.push(nums[i++]); }
        for (int count = k/2; count > 0; --count) {
            right.push(left.top()); left.pop();
        }
        
        while (true) {
            // Get median
            if (k % 2) medians.push_back(left.top());
            else medians.push_back( ((double)left.top() + right.top()) / 2 );
            
            if (i == nums.size()) break;
            int m = nums[i-k], n = nums[i++], balance = 0;
            
            // What happens to the number m that is moving out of the window
            if (m <= left.top())  { --balance;  if (m == left.top()) left.pop(); else ++hash[m]; }
            else                   { ++balance;  if (m == right.top()) right.pop(); else ++hash[m]; }
            
            // Insert the new number n that enters the window
            if (!left.empty() && n <= left.top())  { ++balance; left.push(n); }
            else                                     { --balance; right.push(n); }
            
            // Rebalance the bottom and top heaps
            if      (balance < 0)  { left.push(right.top()); right.pop(); }
            else if (balance > 0)  { right.push(left.top()); left.pop(); }
            
            // Remove numbers that should be discarded at the top of the two heaps
            while (!left.empty() && hash[left.top()])  { --hash[left.top()]; left.pop(); }
            while (!right.empty() && hash[right.top()])  { --hash[right.top()]; right.pop(); }
        }
        
        return medians;
    }
```	

992	Subarrays with K Different Integers    		44.6%	Hard	
Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.

(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)

Return the number of good subarrays of A.

sliding window with hashmap
```cpp
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int ans=0;
        int i=0,j=0,k=0;//use 3 pointers, i, j for the two left i<j
        unordered_map<int,int> mp;
        while(k<A.size())
        {
            mp[A[k]]++;
            /*while(mp.size()>K)
            {
                mp[A[i]]--;
                if(mp[A[i]]==0) mp.erase(A[i]);
                i++;
            }*/
            if(mp.size()>K) {i=j+1;mp.erase(A[j]);}
            if(j<i) j=i;
            if(mp.size()==K) 
            {
                while(mp[A[j]]>1) {mp[A[j]]--;if(mp[A[j]]==0) mp.erase(A[j]);j++;}
                ans+=j-i+1;
            }
            //cout<<i<<" "<<j<<" "<<k<<endl;
            k++;
        }
        return ans;
    }
```	

## tree	
99	Recover Binary Search Tree    		34.8%	Hard	
two elements of a binary search tree are swapped. recover it
inorder traversal and keep prev and compare with current. if prev>curr it is one of it
```cpp
    TreeNode* prev;
    void recoverTree(TreeNode* root) {
        vector<TreeNode*> res;
        prev=0;
        inorder(root,res);
        //for(int i=0;i<res.size();i++) cout<<res[i]->val<<" ";
        if(res.size()==2) {swap(res[0]->val,res[1]->val);}
        else {swap(res[0]->val,res[3]->val);}
    
    }
    void inorder(TreeNode* root,vector<TreeNode*>& res) //inorder traverse to find the swapped ind
    {
        if(!root) return;
        //compare to previous 
        inorder(root->left,res);
        if(!prev) {prev=root;}
        else
        {
            if(root->val<prev->val) {res.push_back(prev);res.push_back(root);}
            prev=root;
        }
        //cout<<prev->val<<" "<<root->val<<",";
        inorder(root->right,res);
    }
```
	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
path sum: can cross the root or not cross.
cross the root: root+left+right 
not cross the root: left or right (subproblem)
combined with the dp problem: the max sum of subarray if previous sum<0 then we start a new segement.
```cpp
    int maxPathSum(TreeNode* root) {
        //any negative nodes shall not be included
        //each node shall be the largest path sum
        //nodemaxsum=node+max_left_pathsum+max_right_pathsum which needs postorder traversal
        int maxsum=INT_MIN;
        node_maxsum(root,maxsum);
        return maxsum;
    }
    int node_maxsum(TreeNode* root,int& maxpathsum)
    {
        if(!root) return 0;
        int l=node_maxsum(root->left,maxpathsum);
        int r=node_maxsum(root->right,maxpathsum);
        l=l>0?l:0; //shall we include left?
        r=r>0?r:0;//shall we include right?
        if(maxpathsum<l+r+root->val) maxpathsum=l+r+root->val;
        root->val+=max(l,r); //postorder is bottom up, update the node value to the max path sum (including the paths under its subtree
        return root->val;
    }
```	
update the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time.


145	Binary Tree Postorder Traversal    		48.7%	Hard	
iterative. postorder: left right root sequence
using stack, we first push the root, and the right and the do the left
another approach: do it in reverse way, reverse(root, right, left)
always push left, and then right, output root
```cpp
    vector<int> postorderTraversal(TreeNode* root) {
        //left, right, node. use a stack to store 
        //stack： first node, then right, then left, pop in reverse
        stack<TreeNode*> sl;
        vector<int> s;
        if(!root) return s;
        //starting from root, push all right nodes into stack, until dead end, and then pop a left node
        //save all left nodes in another stack
        TreeNode* p=root;
        while(1)
        {
            while(p) 
            {
                s.push_back(p->val);
                if(p->left) sl.push(p->left);
                p=p->right;
            }
            if(sl.size()) //try the left, note when the node is the leaf
            {
                p=sl.top();sl.pop();
                //s.push_back(p->val);//this will push twice
            }
            else break;
        }
        reverse(s.begin(),s.end());
        return s;
        
    }
```
this is the most smartest way in this problem.
	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
using stringstream
```cpp
    string serialize(TreeNode* root) {
        ostringstream os;
        serialize(root,os);
        return os.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return deserialize(is);
    }
    
    void serialize(TreeNode* root, ostringstream& os)
    {
        if(root)
        {
            os<<root->val<<" ";
            serialize(root->left,os);
            serialize(root->right,os);
        }
        else os<<"# ";
    }
    TreeNode* deserialize(istringstream& is)
    {
        string s;
        is>>s;
        if(s=="#") return 0;
        TreeNode* p=new TreeNode(stoi(s));
        p->left=deserialize(is);
        p->right=deserialize(is);
        return p;
    }
```	

440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
compare using string
since k and n could be very large, using sort would be overwhelming.
can just fill until k.
Actually this is a denary tree (each node has 10 children). Find the kth element is to do a k steps preorder traverse of the tree.
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don't really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.

```java
public int findKthNumber(int n, int k) {
    int curr = 1;
    k = k - 1;
    while (k > 0) {
        int steps = calSteps(n, curr, curr + 1);
        if (steps <= k) {
            curr += 1;
            k -= steps;
        } else {
            curr *= 10;
            k -= 1;
        }
    }
    return curr;
}
//use long in case of overflow
public int calSteps(int n, long n1, long n2) {
    int steps = 0;
    while (n1 <= n) {
        steps += Math.min(n + 1, n2) - n1;
        n1 *= 10;
        n2 *= 10;
    }
    return steps;
}
```

834	Sum of Distances in Tree    		39.6%	Hard	
An undirected, connected tree with N nodes labelled 0...N-1 and N-1 edges are given.

The ith edge connects nodes edges[i][0] and edges[i][1] together.

Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes.

```cpp
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) 
    {
        vector<unordered_set<int>> tree(N);//adjacent matrix
        vector<int> res(N, 0);
        vector<int> count(N, 0);
        if (N == 1) return res;
        for (auto e : edges) 
        {
            tree[e[0]].insert(e[1]);
            tree[e[1]].insert(e[0]);
        }
        unordered_set<int> seen1, seen2;
        dfs(0, seen1, tree, res, count);
        dfs2(0, seen2, tree, res, count, N);
        return res;
    }

    void dfs(int root, unordered_set<int>& seen, vector<unordered_set<int>>& tree, vector<int>& res, vector<int>& count) 
    {
        seen.insert(root);
        for (auto i : tree[root])//root as a root tree
        {
            if (!seen.count(i)) //not visited
            {
                dfs(i, seen, tree, res, count); //child first
                count[root] += count[i];
                res[root] += res[i] + count[i]; //later the root
            }
        }
        count[root]++;
    }

    void dfs2(int root, unordered_set<int>& seen, vector<unordered_set<int>>& tree, vector<int>& res, vector<int>& count, int N) 
    {
        seen.insert(root);
        for (auto i : tree[root])
        {
            if (!seen.count(i)) 
            {
                res[i] = res[root] - count[i] + N - count[i];
                dfs2(i, seen, tree, res, count, N);
            }
        }
    }
```	
## union find/disjoint set
128	Longest Consecutive Sequence    		41.8%	Hard	
need O(n)
for example [100,4,200,1,3,2]
when we see 4, we know we need 5 and 3
when we see 1, we know we need 2 and 0
when we see 3, it is in need list, and also it needs 4 and 2
when we see 2, it is in need list, and also it needs 3 and 1
connect them using union-find
```cpp
    int longestConsecutive(vector<int>& nums) {
        //they don't need to keep order, disjoint set
        int n=nums.size();
        if(n<2) return n;
        vector<int> parent(n),size(n,1);
        unordered_map<int,int> mp;
        for(int i=0;i<n;i++) parent[i]=i;
        for(int i=0;i<n;i++)
        {
            if(mp.count(nums[i])) continue;//ignore duplicates
            mp[nums[i]]=i;
            if(mp.count(nums[i]-1)) merge(i,mp[nums[i]-1],parent,size);
            if(mp.count(nums[i]+1)) merge(i,mp[nums[i]+1],parent,size);
        }
        return *max_element(size.begin(),size.end());
    }
    
    int getparent(int i,vector<int>& parent)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(int i,int j,vector<int>& parent,vector<int>& size)
    {
        int pi=getparent(i,parent),pj=getparent(j,parent);
        if(pi==pj) return;
        if(pi<pj) {parent[pj]=pi;size[pi]+=size[pj];size[pj]=0;}
        else {parent[pi]=pj;size[pj]+=size[pi];size[pi]=0;}
    }
```	

685	Redundant Connection II    		30.8%	Hard	
direct graph
to find the cycle
similar to union find (tree)

```cpp
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<int> parent(n+1, 0), candA, candB;
        // step 1, check whether there is a node with two parents
        for (auto &edge:edges) {
            if (parent[edge[1]] == 0)
                parent[edge[1]] = edge[0]; 
            else {
                candA = {parent[edge[1]], edge[1]};
                candB = edge;
                edge[1] = 0;
            }
        } 
        // step 2, union find
        for (int i = 1; i <= n; i++) parent[i] = i;
        for (auto &edge:edges) {
            if (edge[1] == 0) continue;
            int u = edge[0], v = edge[1], pu = root(parent, u);
            // Now every node only has 1 parent, so root of v is implicitly v
            if (pu == v) {
                if (candA.empty()) return edge;
                return candA;
            }
            parent[v] = pu;
        }
        return candB;
    }
private:
    int root(vector<int>& parent, int k) {
        if (parent[k] != k) 
            parent[k] = root(parent, parent[k]);
        return parent[k];
    }
```	

803	Bricks Falling When Hit    		28.7%	Hard	
We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.

We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.

Return an array representing the number of bricks that will drop after each erasure in sequence.

union find
```cpp
/*understand the problem is the key
only those bricks (set) which are connected to the top will not drop.
So we just change those unit to be hit to zero
then we form the disjoint set only the first row!
we add the bricks reversely back, the total size of the disjoint set difference is the number of bricks dropping.*/
class union_find
{
    int m,n;
    int count;
    vector<int> parent;
    vector<int> size;
    int max_size;
public:
    union_find(vector<vector<int>>& grid)
    {
        count=0;
        max_size=0;
        m=grid.size(),n=grid[0].size();
        parent.resize(m*n+1);//the first row will connect to a virtual node n*m
        size.resize(m*n+1);
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                //if(grid[i][j]>0) //we don't need this since every node needs to be a set
                {parent[i*n+j]=i*n+j;size[i*n+j]=1;count++;}
            }
        }
        parent[n*m]=n*m;size[n*m]=1;//dummy node
        //for(int j=0;j<n;j++) if(grid[0][j]>0) {parent[j]=n*m;size[n*m]++;}
        if(count) max_size=1;//not used
        
    }
    int find(int node)
    {
        while(parent[node]!=node) node=parent[node];
        return node;
    }
    void merge(int ni,int nj)
    {
        int i_id=find(ni);
        int j_id=find(nj);
        if(i_id==j_id) {return;}
        if(i_id>j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;max_size=max(max_size,size[i_id]);}
        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;max_size=max(max_size,size[j_id]);}
        count--;
    }
    bool connected(int ni,int nj) {return find(ni)==find(nj);}
    int get_numset() {return count;}
    int get_size(int p) {return size[p];}
    int get_maxsize() {return max_size;}
    void print_size() {copy(size.begin(),size.end(),ostream_iterator<int>(cout," "));cout<<endl;}
};

class Solution {
public:
    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
        //mark all those hits, need to differentiate previous 0 or 1
        int m=grid.size(),n=grid[0].size();
        for(int i=0;i<hits.size();i++) 
            if(grid[hits[i][0]][hits[i][1]]) grid[hits[i][0]][hits[i][1]]=-1;
       
        //form the disjoint set using the first row
        union_find uf(grid);
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        for(int j=0;j<n;j++) if(grid[0][j]>0) uf.merge(j,m*n);
        for(int i=1;i<m;i++)
            for(int j=0;j<n;j++)
                if(grid[i][j]>0)
                {
                    for(int k=0;k<4;k++)
                    {
                        int x=i+dir[k][0],y=j+dir[k][1];
                        if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]>0) uf.merge(x*n+y,i*n+j);
                    }
                 }
        //uf.print_size();
        
        //add the hits back
        vector<int> ans(hits.size());
        for(int i=hits.size()-1;i>=0;i--)
        {
            int x0=hits[i][0],y0=hits[i][1];
            if(grid[x0][y0]<0)
            {
                int prev=uf.get_size(m*n);
                grid[x0][y0]=1;//restore it
                //cout<<i<<":"<<prev<<endl;
                //check if its connected to any
                for(int k=0;k<4;k++)
                {
                    int x=x0+dir[k][0],y=y0+dir[k][1];
                    if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]>0)
                    {
                        //cout<<"merge: "<<x<<" "<<y<<"; "<<x0<<" "<<y0<<endl;
                        uf.merge(x*n+y,x0*n+y0);
                        //if(x && x0) uf.merge(x*n+y,x0*n+y0);
                        //else {uf.merge(x*n+y,m*n);uf.merge(x0*n+y0,m*n);} //if itself has no neigboring but it connects to top, this will miss.
                        //uf.print_size();
                    }
                }
                if(!x0) uf.merge(x0*n+y0,m*n);//this is very important: since the node itself shall be attached to the n*m                
                
                //uf.print_size();
                int diff;
                if(uf.connected(x0*n+y0,m*n)) diff=uf.get_size(n*m)-prev-1;
                else diff=uf.get_size(n*m)-prev;
                
                ans[i]=diff;
            }
        }
        return ans;        
    }
};
```


928	Minimize Malware Spread II    		39.3%	Hard	
union find
```cpp
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        //the idea: build the disjoint set by removing all infected nodes
        //add the infected nodes except the removed one one by one and find the one with most infected
        //union-find is fast to do union but not good for splitting and that is why we use the above approach
        int n=graph.size();
        vector<int> parents(n),size(n,1);
        //set<int> infected(initials.begin(),initials.end());
        
        sort(initial.begin(),initial.end());
        int minsize=INT_MAX,ans=INT_MAX;        
        for(int k=0;k<initial.size();k++)
        {
            int remove=initial[k];
            int infected_size=0;
            //build the union by disable the remove node
            for(int i=0;i<n;i++) {parents[i]=i;size[i]=1;}
            int num_set=n;
            for(int i=0;i<n;i++)
            {
                for(int j=i;j<n;j++)
                {
                    if(i==remove || j==remove) continue;
                    if(graph[i][j]) merge(parents,i,j,num_set,size);
                }
            }
            //get the number of infected nodes
            unordered_set<int> myset;
            for(int t=0;t<initial.size();t++)
            {
                if(initial[t]==remove) continue;
                myset.insert(get_id(parents,initial[t]));
            }
            
            for(auto it=myset.begin();it!=myset.end();it++)
                infected_size+=size[*it];
            if(minsize>infected_size) minsize=infected_size,ans=remove;
        }
        return ans;
    }
    int get_id(vector<int>& parent,int i)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(vector<int>& parent,int i,int j,int& num_set,vector<int>& size)
    {
        int i_id=get_id(parent,i);
        int j_id=get_id(parent,j);
        if(i_id==j_id) return;
        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;}
        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;}
        num_set--;
    }    
```

924	Minimize Malware Spread    		39.9%	Hard	
union find

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        vector<int> parents(n),size(n,1);
        
        for(int i=0;i<n;i++) parents[i]=i;
        int num_set=n;
        for(int i=0;i<n;i++)
        {
            for(int j=i;j<n;j++)
            if(graph[i][j]) merge(parents,i,j,num_set,size);
        }
        //sort(initial.begin(),initial.end());
        //copy(size.begin(),size.end(),ostream_iterator<int>(cout," "));
        unordered_map<int,set<int>> mp;
        for(int i=0;i<initial.size();i++)
            mp[get_id(parents,initial[i])].insert(initial[i]);
        //if there are more than one, then it is 0
        int max0=0,ans=INT_MAX;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            if(it->second.size()>1) 
            {
                if(max0==0) ans=min(ans,*(it->second.begin()));
            }
            else
            {
                if(max0<size[it->first])
                {
                    max0=size[it->first];
                    ans=*(it->second.begin());
                }
                else if(max0==size[it->first])
                    ans=min(ans,*(it->second.begin()));
            }
        }
        return ans;
        
    }
    int get_id(vector<int>& parent,int i)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(vector<int>& parent,int i,int j,int& num_set,vector<int>& size)
    {
        int i_id=get_id(parent,i);
        int j_id=get_id(parent,j);
        if(i_id==j_id) return;
        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;}
        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;}
        num_set--;
    }    
		
827	Making A Large Island    		43.3%	Hard	
union find, change at most one cell from 0 to 1.

```cpp
class union_find
{
    int m,n;
    int count;
    vector<int> parent;
    vector<int> size;
    int max_size;
public:
    union_find(vector<vector<int>>& grid)
    {
        count=0;
        max_size=0;
        m=grid.size(),n=grid[0].size();
        parent.resize(m*n+1);
        size.resize(m*n+1);
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]) {parent[i*n+j]=i*n+j;size[i*n+j]=1;count++;}
            }
        }
        if(count) max_size=1;
        parent[n*m]=n*m;//dummy node
    }
    int find(int node)
    {
        while(parent[node]!=node) node=parent[node];
        return node;
    }
    void merge(int ni,int nj)
    {
        int i_id=find(ni);
        int j_id=find(nj);
        if(i_id==j_id) return;
        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;max_size=max(max_size,size[i_id]);}
        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;max_size=max(max_size,size[j_id]);}
        count--;
    }
    bool connected(int ni,int nj) {return find(ni)==find(nj);}
    int get_numset() {return count;}
    int get_size(int p) {return size[p];}
    int get_maxsize() {return max_size;}
};
class Solution {
public:
    int largestIsland(vector<vector<int>>& grid) {
        //disjoint set and see which one flip will add the largest
        //using the i*n+j as the root
        //bfs search to merge 
        union_find uf(grid);
        int m=grid.size(),n=grid[0].size();
        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j])
                {
                    for(int k=0;k<4;k++)
                    {
                        int x=i+dir[k][0],y=j+dir[k][1];
                        if(x>=0 && x<m && y>=0 && y<n && grid[x][y])
                        {
                            uf.merge(i*n+j,x*n+y);
                        }
                    }
                }
            }
        }
        //now we get all the adjoint set, we will check the 0 to see which connect two or three or 4
        int maxlen=INT_MIN;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(!grid[i][j])
                {
                    unordered_set<int> us;
                    for(int k=0;k<4;k++)
                    {
                        int x=i+dir[k][0],y=j+dir[k][1];

                        if(x>=0 && x<m && y>=0 && y<n && grid[x][y])
                        {
                            int p=uf.find(x*n+y);//same region cannot be added multiple times
                            us.insert(p);
                        }
                    }
                    int cnt=0;
                    for(auto it=us.begin();it!=us.end();it++) cnt+=uf.get_size(*it);
                    maxlen=max(maxlen,cnt);
                }
            }
        }
        return maxlen==INT_MIN?uf.get_maxsize():maxlen+1;
    }
};
```
839	Similar String Groups    		34.5%	Hard	
god, I saw this myself in interveiw
how many groups, union find
```cpp
class disjoint_set {
    vector<int> v;
    int sz;
public:
    disjoint_set(int n) {
        makeset(n);
    }

    void makeset(int n) {
        v.resize(n);
        iota(v.begin(), v.end(), 0);
        sz = n;
    }

    int find(int i) {
        if (i != v[i])
            v[i] = find(v[i]);
        return v[i];
    }
    
    void join(int i, int j) {
        int ri = find(i), rj = find(j);
        if (ri != rj) {
            v[ri] = rj;
            sz--;
        }
    }
    
    int size() {
        return sz;
    }
};
class Solution {
public:
    bool similar(string &a, string &b) {
        int n = 0;
        for (int i = 0; i < a.size(); i++)
            if (a[i] != b[i] && ++n > 2)
                return false;
        return true;
    }

    int numSimilarGroups(vector<string>& A) {
        disjoint_set ds(A.size());
        for (int i = 0; i < A.size(); i++)
            for (int j = i + 1; j < A.size(); j++)
                if (similar(A[i], A[j]))
                    ds.join(i, j);
        return ds.size();
    }

};
```

1032 Stream of Characters    		41.0%	Hard	
trie
    struct TrieNode
    {
        bool is_end;
        vector<TrieNode*> child;
        TrieNode(){is_end=0;child=vector<TrieNode*>(26);}
    };
    TrieNode *root;
    string qstr;
    int maxlen=0;
    TrieNode* get_root() {return root;}
    void add_word(string w)
    {
        TrieNode* p=root;
        maxlen=max(maxlen,(int)w.size());
        for(int i=w.size()-1;i>=0;i--) //reverse add
        {
            char c=w[i];
            int ind=c-'a';
            if(!p->child[ind]) p->child[ind]=new TrieNode();
            p=p->child[ind];
        }
        p->is_end=1;
    }
    bool startWith(string word)
    {
        //cout<<"search: "<<word;
   		TrieNode* p=root;
        int match=0;
		for(char c: word)
		{
			if(p->child[c-'a']==0) break;
			p=p->child[c-'a'];
            if(p->is_end) return 1;
		}
		return 0;//p->is_end;//must ending with a leaf
    }        
    StreamChecker(vector<string>& words) {
        root=new TrieNode();
        for(string w: words) add_word(w);
    }
    
    bool query(char letter) {
        qstr=letter+qstr;
        if(qstr.size()>maxlen) qstr.pop_back();//qstr=qstr.substr(0,2000);
        return startWith(qstr);
    }

952	Largest Component Size by Common Factor    		26.3%	Hard	
union find

    int largestComponentSize(vector<int>& A) {
        int n=A.size();
        sort(A.begin(),A.end());
        vector<int> parent(n),size(n,1);
        for(int i=0;i<n;i++) parent[i]=i;
        //vector<unordered_set<int>> factors(n);
        unordered_map<int,set<int>> factors;
        unordered_set<int> tset;
        //build the prime factors for each number
        for(int i=0;i<n;i++)
        {
            tset=factorize(A[i]);
            for(auto tt:tset) factors[tt].insert(i);
        }
        for(auto t:factors)
        {
            auto t0=t.second;
            if(t0.size()>=2)
            {
                int node=*t0.begin();
                for(auto it=++t0.begin();it!=t0.end();it++) merge(node,*it,parent,size);
            }
        }
        return *max_element(size.begin(),size.end());
    }
    int get_parent(int i,vector<int>&parent)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    int merge(int i,int j,vector<int>& parent,vector<int>& size)
    {
        int pi=get_parent(i,parent);
        int pj=get_parent(j,parent);
        if(pi<pj) {parent[pj]=pi,size[pi]+=size[pj],size[pj]=0;}
        if(pi>pj) {parent[pi]=pj,size[pj]+=size[pi],size[pi]=0;}
        return min(pi,pj);
    }
    unordered_set<int> factorize(int x)
    {
        unordered_set<int> prime;
        int d=2;
        while(d*d<=x)
        {
            if(x%d==0) 
            {
                while(x%d==0) x/=d; //remove all its multiples
                prime.insert(d);
            }
            d++;
        }
        if(x>1 || prime.empty()) prime.insert(x); //if there is no factor, itself is a prime number
        return prime;
    }
	
778	Swim in Rising Water    		47.8%	Hard	
return the min time so that start and end connected.
binary search or union find
```cpp
    int swimInWater(vector<vector<int>>& grid) {
        const int DIRECTIONS[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
        int n = grid.size();
        
        if (grid[n - 1][n - 1] >= n * n - 2) return grid[n - 1][n - 1];
        
        vector<int> connection(n * n); // position: group
        vector<int> elevations(n * n); // elevation: position
        
        // bucket sort and init connection
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                elevations[grid[i][j]] = i * n + j;
                connection[i * n + j] = i * n + j;
            }
        }
        
        // union find, e is elevation
        for (int e = 0; e < n * n; e++) {
            // find 4 directions of the point
            for (int i = 0; i < 4; i++) {
                int x = elevations[e] / n + DIRECTIONS[i][0],
                    y = elevations[e] % n + DIRECTIONS[i][1];
                
                if (x < 0 || y < 0 || x == n || y == n) continue;
								
                // find the adjust block which elevation is lower than the current one
                // means we can connect them
                if (grid[x][y] < e) {
                    connection[find(elevations[e], connection)] = find(x * n + y, connection);
                }
            }
            
            // check if the graph connected
            if (find(0, connection) == find(n * n - 1, connection)) {
                return e;
            }
        }
        
        return n * n - 1;
    }
    
    int find(int i, vector<int>& data) {
        while (data[i] != data[data[i]]) {
            data[i] = data[data[i]];
        }
        return data[i];
    }
```
	
## greedy
135	Candy    		28.5%	Hard	
each child need have >=1 candies
children with higher rating get more candies than their neighbors
for example [1,0,2]: 
assume we give 1 one candie, but it shall be more than its neighbors, so need get at least 2 and we get 2,1,2
since it has two neighbors, we can do it two pass, one from left to right, and one from right to left.
one direction: we need take care of the left only (or right).
```cpp
    int candy(vector<int>& ratings) {
        int ans=0;
        //at least give one candy
        //simple example gives the following approach
        //find the smallest one, and assign 1
        int n=ratings.size();
        vector<int> can(n,1);
        //from left to right
        for(int i=1;i<n;i++) if(ratings[i]>ratings[i-1]) can[i]=can[i-1]+1;
        for(int i=n-2;i>=0;i--) if(ratings[i]>ratings[i+1]) can[i]=max(can[i],can[i+1]+1);
        
        //copy(can.begin(),can.end(),ostream_iterator<int>(cout," "));cout<<endl;
        return accumulate(can.begin(),can.end(),0);
    }
```
this is a good problem. two direction problem can be solved using two separate one direction problem.
	
458	Poor Pigs    		45.4%	Hard	
there are 1000 buckets, only one of them is poisonous. 
if drink the poison, it dies within 15 mins
to figure out which one is poisonous, what is the min number of pigs to be used in our hour.
a pig can drink as many simultaneously.

greedy solution:
With 2 pigs, poison killing in 15 minutes, and having 60 minutes, we can find the poison in up to 25 buckets in the following way. Arrange the buckets in a 5×5 square:

 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
Now use one pig to find the row (make it drink from buckets 1, 2, 3, 4, 5, wait 15 minutes, make it drink from buckets 6, 7, 8, 9, 10, wait 15 minutes, etc). Use the second pig to find the column (make it drink 1, 6, 11, 16, 21, then 2, 7, 12, 17, 22, etc).

Having 60 minutes and tests taking 15 minutes means we can run four tests. If the row pig dies in the third test, the poison is in the third row. If the column pig doesn't die at all, the poison is in the fifth column (this is why we can cover five rows/columns even though we can only run four tests).

With 3 pigs, we can similarly use a 5×5×5 cube instead of a 5×5 square and again use one pig to determine the coordinate of one dimension (one pig drinks layers from top to bottom, one drinks layers from left to right, one drinks layers from front to back). So 3 pigs can solve up to 125 buckets.

In general, we can solve up to (⌊minutesToTest / minutesToDie⌋ + 1)pigs buckets this way, so just find the smallest sufficient number of pigs for example like this:

def poorPigs(self, buckets, minutesToDie, minutesToTest):
    pigs = 0
    while (minutesToTest / minutesToDie + 1) ** pigs < buckets:
        pigs += 1
    return pigs
so the answer is logx+1(N)=log(N)/log(x+1)

also we can consider it a (x+1) base problem.
similar questions: 1 test, to find 1 out of 1000.
We need to figure out in hour. We need 10 rats to figure out the poisoned bottle. The result is based on binary number system. We get 10 using ⌈ Log21000 ⌉.

The idea is to number bottles from 1 to 1000 and write their corresponding binary numbers on the bottle. Each rat is assigned a position in the binary numbers written on bottles. Let us take an example. Rat 1 represents first bit in every bottle, rat 2 represents second bit and so on. If rat numbers 5, 7 and 9 die, then bottle number 42 (Binary 0000101010) is poisoned.

502	IPO    		37.7%	Hard	
<=k distinct project
each project has profit Pi, capital Ci
you have capital W.
maximize the capital (or profit)
approach:
-. remove those non-profit projects
-. make a map capital vs profit sorted from smallest capital to largest
-. upper_bound find those projects using current capital
-. among those projects, find the most profitable project
-. pick the project and remove it, add the profit
-. iterate until we have k projects.
-. to save time, (capital is getting larger), those less profit can be discarded.


```cpp
    int findMaximizedCapital(int k, int W, vector<int>& Profits, vector<int>& Capital) {
        //use priority queue to store the pairs so that searching for max is easier
        //priority_queue only ensure the max so it saves time
        //first binary search to remove all those bad 
        multimap<int,int> mp; //needs multimap since more project more profit
        //priority_queue<int> mq;
        for(int i=0;i<Profits.size();i++) //vs[i]=make_pair(Capital[i],Profits[i]);
        {
            if(Profits[i]) mp.insert(make_pair(Capital[i],Profits[i])); //no profit discard
        }
        int nproj=0,w=W;
        auto it=mp.begin(),prev_it=mp.begin();
        
        while(nproj<k)
        {
            it=mp.upper_bound(w); //binary search
            if(it==mp.begin()) break;
            auto itmax=mp.begin();
            int maxprof=itmax->second;
            for(auto it1=prev_it;it1!=it;it1++) 
            {
                if(it1->second>maxprof)
                {
                    maxprof=it1->second;
                    itmax=it1;
                }
            }
            w+=maxprof;
            //need erase the one from the map
            mp.erase(itmax);
            prev_it=it; //in front are those projects with less capital and less profits.
            nproj++;
        }
        return w;
    }
```	

761	Special Binary String    		51.5%	Hard	
number of 1s = number of 0s
prefix 1s>=0s
a move: choose two consective special substring and swap. return the largest string possible
Split S into several special strings (as many as possible).
Special string starts with 1 and ends with 0. Recursion on the middle part.
Sort all special strings in lexicographically largest order.
Join and output all strings.

string makeLargestSpecial(string S) {
    int count = 0, i = 0;
    vector<string> res;
    for (int j = 0; j < S.size(); ++j) {
      if (S[j] == '1') count++;
      else count--;
      if (count == 0) {
        res.push_back('1' + makeLargestSpecial(S.substr(i + 1, j - i - 1)) + '0');
        i = j + 1;
      }
    }
    sort(res.begin(), res.end(), greater<string>());
    string res2 = "";
    for (int i = 0; i < res.size(); ++i) res2 += res[i];
    return res2;
  }
  
765	Couples Holding Hands    		51.6%	Hard	
greedy: swap to its right place, probably fix more.
```cpp
    int minSwapsCouples(vector<int>& row) {
        for(int i=0;i<row.size();i++) row[i]/=2; //making couple the same number
        int cnt=0;
        for(int i=0;i<row.size();i+=2)
        {
            if(row[i]!=row[i+1]) 
            {
                auto it=find(row.begin()+i+2,row.end(),row[i]);
                swap(*it,row[i+1]);
                cnt++;
            }
        }
        return cnt;
    }
```	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
including duplicates
return the most number of chunks

sorted and compare with multiset
```cpp
    int maxChunksToSorted(vector<int>& arr) {
        //a segment shall be smaller than all its elements behind.
        vector<int> va=arr;
        sort(va.begin(),va.end());
        //compare the two array. if the element is the same then it is a segment
        int nseg=0;
        multiset<int> ms0,ms1;
        for(int i=0;i<arr.size();i++)
        {
            ms0.insert(arr[i]);ms1.insert(va[i]);
            if(ms0==ms1) {nseg++;ms0.clear();ms1.clear();}
        }
        return nseg;
    }
```

782	Transform to Chessboard    		39.8%	Hard	
each move, swap two rows or two columns.
what is the min number of moves to transform it to a chessboard

```cpp
    int movesToChessboard(vector<vector<int>>& board) {
        //check all rows against row 0, check all columns against col 0
        //save them in a vector in 1 0 format, 1: the same, 0: reverse, other invalid
        int n=board.size();
        vector<int> row(n,1),col(n,1);
        for(int i=1;i<n;i++)
        {
            int t=0;
            for(int j=0;j<n;j++) t+=board[i][j]^board[0][j];
            if(t!=n && t!=0) return -1;
            row[i]=t==0;
        }
        //copy(row.begin(),row.end(),ostream_iterator<int>(cout," "));cout<<endl;
        for(int j=1;j<n;j++)
        {
            int t=0;
            for(int i=0;i<n;i++) t+=board[i][j]^board[i][0];
            if(t!=n && t!=0) return -1;
            col[j]=t==0;
        }
        //copy(col.begin(),col.end(),ostream_iterator<int>(cout," "));cout<<endl;
        //check minimum swap for row and col to make it in chess order
        int m1=num_swap(row),m2=num_swap(col);
        return m1>=0 && m2>=0?m1+m2:-1;
    }
    int num_swap(vector<int>& row)
    {
        int n=row.size();
        int num1s=accumulate(row.begin(),row.end(),0); //1 and 0 shall same amount or differ by 1
        //n: even, must be the same, odd: differ by 1
        bool keep_1st=1;
        int ns=0;
        if(n%2==0) //for even, 1 or 0 can be both first
        {
            if(num1s*2!=n) return -1;
            int ns1=0;
            for(int i=0;i<n;i+=2) 
            {
                ns+=row[i]; //if the element is not 1, then need switch, they coul
                ns1+=!row[i];
            }
            ns=min(ns,ns1);
        }
        else
        {
            if(abs(num1s*2-n)!=1) return -1;
            if(num1s*2<n) keep_1st=0;//first row must be switched

            for(int i=0;i<n;i+=2) 
            {
                ns+=row[i]!=keep_1st; //if the element is not 1, then need switch, they coul
            }
          
        }
        return ns;
    }
```

995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.

greedy: from left to right flip each 0 to 1

    int minKBitFlips(vector<int>& A, int K) {
        //the leading bit shall be flipped and reduce to sub problem
        int minflips=0;
        
        for(int i=0;i<A.size()-K+1;i++)
        {
            if(A[i]==0) {if(minkflip(A,K,i)) minflips++;else return -1;}
        }
        int sum=accumulate(A.begin(),A.end(),0);
        if(sum!=A.size()) return -1;
        return minflips;
    }
    int minkflip(vector<int>& A,int K,int ind)
    {
        int m=A.size();
        for(int i=ind;i<ind+K;i++) A[i]^=1;
        if(m-ind==K) //last flip
        {
            int sum=accumulate(A.begin()+ind,A.end(),0);
            return sum==K;
        }
        
        return 1;
    }
	
936	Stamping The Sequence    		36.0%	Hard	
greedy

    vector<int> movesToStamp(string stamp, string target) {
        //reverse operation: matched then change it to ***
        //until we change the target string into *****
        //note we can only match one end if it is covered
        int n=target.length();
        string final(n,'*');
        vector<int> ans;
        while(target!=final)
        {
            int ind=match_change(target,stamp);
            if(ind==-1) return vector<int>();
            ans.push_back(ind);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
    int match_change(string& target,string stamp)
    {
        //find the first matching and return
        //at least has one non * char inside, * matches any char
        bool matched=0;
        for(int i=0;i<target.size();i++)
        {
            int cnt_match=0;
            int j=0;
            for(j=0;j<stamp.size();j++)
            {
                if(target[i+j]=='*') continue;
                if(target[i+j]==stamp[j]) cnt_match++;
                else break;
            }
            if(j==stamp.size()&& cnt_match) 
            {
                for(j=0;j<stamp.size();j++) target[i+j]='*';
                return i;
            }
        }
        return -1; //no matching
    }
	
	
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	

## sort
164	Maximum Gap    		32.6%	Hard	
unsorted array, given the max gap in its sorted form (neighboring)
O(N) complexity
arrange the elements into n-1 bins
each bin only save the min and max
and then loop over the bins (bucket sort)
this is often seen in matlab.
```cpp
    int maximumGap(vector<int>& nums) {
        //using bucket sort to put all these numbers into slots
        //the longest 0 
        int n=nums.size();
        if(n<2) return 0;
        int min0=*min_element(nums.begin(),nums.end());
        int max0=*max_element(nums.begin(),nums.end());
        double dx=double(max0-min0)/(n-1); //to cover all use ceil, have to use double!
        if(dx<1e-7) return 0;
        //cout<<dx<<endl;
        //in each bucket we only need to know the min/max
        pair<int,int> init=make_pair(INT_MAX,INT_MIN);
        vector<pair<int,int>> vs(n,init);
        for(int i=0;i<nums.size();i++)
        {
            int ind=(nums[i]-min0)/dx;
            vs[ind].first=min(vs[ind].first,nums[i]);
            vs[ind].second=max(vs[ind].second,nums[i]);
        }
        //for(int i=0;i<n;i++) cout<<vs[i].first<<" "<<vs[i].second<<endl;
        int maxgap=0;
        int prev=-1;
        for(int i=0;i<n;i++)
        {
            if(vs[i].first==INT_MAX) continue;
            if(prev<0) prev=i;
            else
            {
                maxgap=max(max(maxgap,vs[i].first-vs[prev].second),max(vs[prev].second-vs[prev].first,vs[i].second-vs[i].first));
                prev=i;
            }
        }
        //another case: only one group
        return maxgap;
    }
```	

315	Count of Smaller Numbers After Self    		38.2%	Hard	
count array is the number of smaller elements in its right.
brutal force O(N^2)
merge sort
BST
this problem is too hard. 
merge sort idea:
the elements shall bind with its index and do a merge sort
after sorted the rightcount then is all previous element with index > i

The basic idea is to do merge sort to nums[]. To record the result, we need to keep the index of each number in the original array. So instead of sort the number in nums, we sort the indexes of each number.
Example: nums = [5,2,6,1], indexes = [0,1,2,3]
After sort: indexes = [3,1,0,2]

While doing the merge part, say that we are merging left[] and right[], left[] and right[] are already sorted.

We keep a rightcount to record how many numbers from right[] we have added and keep an array count[] to record the result.

When we move a number from right[] into the new sorted array, we increase rightcount by 1.

When we move a number from left[] into the new sorted array, we increase count[ index of the number ] by rightcount.

```cpp
	typedef vector<int> vi;
	vi count;
	vi countSmaller(vi& nums) {
		int n=nums.size();
		vi ans(n),index(n);
		count.resize(n);
		for(int i=0;i<n;i++) index[i]=i;
		merge_sort(nums,index,0,n-1);
		return count;
	}
	
	void merge_sort(vi& nums,vi& index,int start,int end){
		if(end<=start) return;
		int mid=(start+end)/2;
		merge_sort(nums,index,start,mid);
		merge_sort(nums,index,mid+1,end);
		merge(nums,index,start,end);
	}
	
	void merge(vi& nums,vi& index,int start,int end){
		int mid=(start+end)/2;
		int left_ind=start,right_ind=mid+1;
		int rightcnt=0;
		vi newind(end-start+1);
		int sort_ind=0;
		while(left_ind<=mid && right_ind<=end){
			if(nums[index[right_ind]]<nums[index[left_ind]]){
				newind[sort_ind]=index[right_ind];
				rightcnt++;
				right_ind++;
			}else{
				newind[sort_ind]=index[left_ind];
				count[index[left_ind]]+=rightcnt;
				left_ind++;
			}
			sort_ind++;
		}
		while(left_ind<=mid){
			newind[sort_ind]=index[left_ind];
			count[index[left_ind]]+=rightcnt;
			left_ind++;
			sort_ind++;
		}
		while(right_ind<=end)
			newind[sort_ind++]=index[right_ind++];
		for(int i=start;i<=end;i++)
			index[i]=newind[i-start];
	}
```
guarantee O(nlogn)
			
321	Create Maximum Number    		25.4%	Hard	
from two lists and give k to form k-digit number
merge sort choose from all combinations
-. get max number from one list using i digits
- get max number from other list using k-i digits
- merge the two lists

```cpp
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        int m=nums1.size(),n=nums2.size();
        if(k>=m+n)  //just merge the two arrays
            return merge(nums1,nums2);
        //try all possible combinations, i from array 1, k-i from array 2
        //i range is [max(m-k,0),min(k,m)], other array range is [max(n-k,0),min(k,n)]
        vector<int> ans;
        for(int i=0;i<=min(m,k);i++)
        {
            if(k-i>nums2.size()) continue;
            vector<int> a=maxNumber(nums1,i);
            vector<int> b=maxNumber(nums2,k-i);
            vector<int> c=merge(a,b);
            if(lexicographical_compare(ans.begin(),ans.end(),c.begin(),c.end())) ans=c;
			//if(ans.empty()) ans=c;
			//else ans=min(ans,c);
        }
        return ans;
    }
    
    vector<int> maxNumber(vector<int>& v,int k) //get k digits from 1 array
    {
        int n=v.size();
        if(k>=n) return v;
        if(k==0) return vector<int>();
        vector<int> ans(k);
        //greedy choice, the leftmost digit is the max from i+[0,n-(k-1))
        int i=0;
        for(int j=1;j<=k;j++) //repeat k times
        {
            auto it=max_element(v.begin()+i,v.begin()+n-(k-j));
            i=int(it-v.begin())+1; //now the new pointer
            ans[j-1]=*it;
        }
        return ans;
    }
    vector<int> merge(vector<int>& v1,vector<int>& v2)
    {
        int i=0,j=0,k=0;
        vector<int> ans(v1.size()+v2.size());
        while(i<v1.size() && j<v2.size())
        {
            if(v1[i]>v2[j]) {ans[k++]=v1[i++];}
            else if(v1[i]<v2[j]) {ans[k++]=v2[j++];}
            else //two number is equal, choose the one behind is larger
            {
                if(lexicographical_compare(v1.begin()+i,v1.end(),v2.begin()+j,v2.end())) //v1<v2
                {ans[k++]=v2[j++];}
                else {ans[k++]=v1[i++];}
            }
        }
        if(i<v1.size()) copy(v1.begin()+i,v1.end(),ans.begin()+k);
        if(j<v2.size()) copy(v2.begin()+j,v2.end(),ans.begin()+k);
        return ans;
    }
```	

327	Count of Range Sum    		32.8%	Hard	
S(i,j) is the sum in the range [i,j].
return the number of range sum in [lower, upper] range.
need better than O(N^2)
divide and conquer using merge sort:
-. get the prefix sum
-. break into two half problem
-. 

```cpp
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        int len = nums.size();
        vector<long> sum(len + 1, 0);
        for(int i =0; i< len; i++) sum[i+1] = sum[i]+nums[i];
        return mergeSort(sum, lower, upper, 0, len+1);
    }
    int mergeSort(vector<long>& sum, int lower, int upper, int low, int high)
    {
        if(high-low <= 1) return 0;
        int mid = (low+high)/2, m = mid, n = mid, count =0;
        count =mergeSort(sum,lower,upper,low,mid) +mergeSort(sum,lower,upper,mid,high);
        for(int i =low; i< mid; i++)
        {
            while(m < high && sum[m] - sum[i] < lower) m++;
            while(n < high && sum[n] - sum[i] <= upper) n++;
            count += n - m;
        }
        inplace_merge(sum.begin()+low, sum.begin()+mid, sum.begin()+high);
        return count;
    }    
```
- inplace_merge: Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). 
- after call merge sort, the array is sorted.
- after the merge sort the left and right parts are sorted, so for each left sum a, what we should do is to search for range that the prefix-sums in the right b can meet the condition lower <= b-a <= higher and then that range is the possible choice we have in the right part for that single index.

## Trie
212	Word Search II    		28.8%	Hard	
multiple pattern matching using trie
```cpp
struct Node
{
    Node* next[26]; //use pointer is much convenient than using array!
    bool is_leaf;
    Node(bool b=0) {fill(next,next+26,(Node*)0);is_leaf=b;}
};
class Trie {
public:
    /** Initialize your data structure here. */
    Node* root;
    Trie() {
        root=new Node();
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Node* p=root;
        for(int i=0;i<word.size();i++)        
        {
            int ind=word[i]-'a';
            if(!p->next[ind]) p->next[ind]=new Node();
            p=p->next[ind];
        }
        p->is_leaf=1;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Node* p=find(word);
        return p && p->is_leaf; //has to end with a leaf node
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Node* p=find(prefix);
        return p; //does not have to end with a leaf node
    }
    
    Node* find(string word)
    {
        Node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int ind=word[i]-'a';
            if(p->next[ind]==0) return 0;
            p=p->next[ind];
        }
        return p;
    }
    Node* get_root() {return root;}
};

class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        Trie t;
        for(int i=0;i<words.size();i++) t.insert(words[i]);
        Node* root=t.get_root();
        //use a set to store all the possible words found from the board.
        set<string> all_words;
        for(int i=0;i<board.size();i++)
        {
            for(int j=0;j<board[0].size();j++)
                findWords(board,i,j,"",all_words,root);//to save time, some paths shall be skipped if they first do not match
        }
        vector<string> ans(all_words.size());
        copy(all_words.begin(),all_words.end(),ans.begin());
        return ans;
    }
    void findWords(vector<vector<char>>& board,int x,int y,string word,set<string>& result,Node* root)
    {
        //using backtracking
        if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;
        char c=board[x][y];
        int ind=c-'a';
        if(root->next[ind])
        {
            word+=c;
            root=root->next[ind]; 
            if(root->is_leaf) result.insert(word);
            board[x][y]=' ';
            findWords(board, x+1, y, word, result, root);
            findWords(board, x-1, y,  word, result, root);
            findWords(board, x, y+1,  word, result, root);
            findWords(board, x, y-1,  word, result, root);
            board[x][y]=c;        
        }        
    }
};
```

336	Palindrome Pairs    		31.0%	Hard	
given a list of words, find the pair of palindrome (i.e connected as pal)
O(N^2) is trivial
A+B or B+A
each word can act as prefix or suffix.
using trie.

```cpp
class Node
{
public:
    int id ;
    Node** child;
    vector<int> list;
    Node()
    {
        id = -1;
        child = new Node* [26];
        for(int i=0; i<26; i++) child[i] = 0;
    }
public:
    ~Node() {delete[] child;list.clear();}
};


class Solution {
public:
    vector<vector<int>> palindromePairs(vector<string>& words) {
        vector<vector<int>> res;
        vector< Node* > de;
        int sz = words.size();
       
        Node * root = new Node();
        string str ;
        for(int i=0; i<sz; i++)
        {
           str = words[i];
           addword(str,i,root,de);
        }
        for(int i=0; i<sz; i++)
        {
            str = words[i];
            searchword(res,str,i,root);
        }
        for(int i=0; i<de.size(); i++)
            delete (de[i]);
        de.clear();
        return res;
        
    }
    void addword( string& str , int pos , Node* root , vector<Node*>& de)
    {
        int sz = str.size();
        reverse(str.begin(),str.end());
        for(int i=0; i<sz; i++)
        {
            if( isValid(str,i,sz-1) )
            {
                (root->list).push_back(pos);
            }
            if(root->child[str[i]-'a']==NULL)
            {
                root->child[str[i]-'a'] = new Node();
                de.push_back(root->child[str[i]-'a']);
            }
            root = root->child[str[i]-'a'];
        }
        
        root->id = pos;
        (root->list).push_back(pos);
    }
    
    
    void searchword(vector<vector<int>> & res,string& str,int pos,Node* root)
    {
        int sz = str.size();
        for(int i=0; i<sz; i++)
        {
            if( root->id!=-1 && root->id!=pos && isValid(str,i,sz-1) )
            {
                res.push_back({pos ,root->id});
            }
            root = root->child[str[i]-'a'];
            if(root == NULL) return;
        }
        
        for(int i=0; i<(root->list).size() ; i++)
        {
            if( pos == root->list[i] )continue;
            res.push_back({pos,root->list[i]});
        }
    }
    
    
    bool isValid(string& t, int left, int right) 
    {
        while (left < right) if(t[left++] != t[right--]) return 0;
        return 1;
    }
};
```

745	Prefix and Suffix Search    		30.7%	Hard	
Given many words, words[i] has weight i.

Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.
trie. 
prefix trie and suffix trie? shall be able to combine together. it shall also contain the weight
For 'ape', revert suffix and insert 'epa', 'aepa', 'apepa', 'apeepa'.
```cpp
struct Trie {
    unordered_map<char,Trie*> nxt;
    int mx;//stores the current max weight
    
    Trie() {
        mx = -1;
    }
    
    void add(string w, int x) {
        Trie *cur = this;
        for (char c:w) {
            if (!cur->nxt.count(c)) cur->nxt[c] = new Trie();
            cur= cur->nxt[c];
            cur->mx = max(cur->mx,x);
        }
    }
    
    int f(string w) {
        Trie *cur = this;
        for (char c:w) {
            if (!cur->nxt.count(c)) return -1;
            cur= cur->nxt[c];
        }
        return cur->mx;
    }
};

class WordFilter {
public:
    Trie* root;
    
    WordFilter(vector<string> words) {
        root = new Trie();
        for (int i = 0; i < words.size(); ++i) {
            int m = min(10,(int)words[i].size());
            string r = words[i].substr(words[i].size()-m) + "*";
            reverse(r.begin(),r.end());
            string t;
            for (int j = 0; j < m; ++j) {
                root->add(t + r,i);
                t+= words[i][j];
            }
            root->add(t+r,i);
        }
    }
    
    int f(string prefix, string suffix) {
        reverse(suffix.begin(), suffix.end());
        return root->f(prefix + "*" + suffix);
    }
};

```


214	Shortest Palindrome    		27.6%	Hard	
only add chars in the front.
brutal force: from right to left, we judge if it is a palindrome
```cpp
	string shortestPalindrome(string s) {
		int n=s.size();
		for(int i=n-1;i>=0;i--)
			if(ispal(s,i)) {
				string pre=s.substr(i+1);
				reverse(pre.begin(),pre.end());
				return pre+s;
			}
		return s;
	}
	bool ispal(string& s,int end)
	{
		int i=0,j=end;
		while(i<j) if(s[i++]!=s[j--]) return 0;
		return 1;
	}
```
This got TLE for a long string of a (len=40002). The time for substr and construct takes more time than expected

KMP is too sophisticated.



233	Number of Digit One    		30.2%	Hard	
math problem
number counting.
for the ith digit, makes it 1, and divide to left and right<br/>
if the ith digit >1, then (left+1)*10^i (since the right can be any digit 0 to 9)<br/>
==1: then right can be from 0 to right (right+1) and left can be 1 to left (left)*10^i.<br/>
<1, then we need borrow 1 from left, left*10^i<br/>

```cpp
    int countDigitOne(int n) {
        int ans=0;
        int left=0,right=0;
        int i=0;
        while(n)
        {
            int d=n%10;
            left=n/10;
            if(d>1) ans+=(left+1)*pow(10,i);
            else if(d==1) ans+=left*pow(10,i)+right+1;
            else ans+=left*pow(10,i);
            right+=d*pow(10,i);
            n/=10;
            i++;
        }
        return ans;
    }
```	



248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
english: every thousand changes
```cpp
    string s1[]={"One", "Two", "Three", "Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"};
    string s2[]={"Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
class Solution {
public:
    string numberToWords(int num) {
        //1,10,100,1000,10^6,10^9
        if(!num) return string("Zero");
        int billion,million,thousand,hundred,twenty;
        billion=num/1000000000;
        num-=billion*1000000000;
        million=num/1000000;
        num-=million*1000000;
        thousand=num/1000;
        num-=thousand*1000;
        //now we need convert all numbers into <100
        string res;
        if(billion) res+=int2words(billion)+"Billion ";
        if(million) res+=int2words(million)+"Million ";
        if(thousand) res+=int2words(thousand)+"Thousand ";
        if(num) res+=int2words(num);
        //remove the last space
        res.pop_back();
        return res;
        
    }
    
    string int2words(int num) //number is <999
    {
        int hundred=num/100;
        num-=hundred*100;
        int ten=num/10;
        num-=ten*10;
        int one=num;
        string s;
        if(hundred) s+=s1[hundred-1]+" Hundred ";
        if(ten>1) 
        {
            s+=s2[ten-2]+" ";
            if(one) s+=s1[one-1]+" ";
            
        }
        else
        {
            if(ten*10+one>0) s+=s1[ten*10+one-1]+" ";
        }
        return s;
    }
};
```

291	Word Pattern II    		41.0%	Hard	
296	Best Meeting Point    		54.9%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	

335	Self Crossing    		27.0%	Hard	
counter clockwise travel
check if it cross itself
only need check previous i-3, i-4, i-5
```cpp
    bool isSelfCrossing(vector<int>& x) {
        //seems that the array shall be in decreasing or increasing order (the same direction array)
        //it will form a circle and if cross it will first cross the nearest circle. each circle has 4 sides
        //so we only need to compare the previous circle i, neec check i-3, i-4, i-5
        bool bcross=0;
        for(int i=3;i<x.size();i++)
        {
            int x0=x[i-2]-x[i-4];
            int y0=x[i-1]-x[i-3]+x[i-5];
            int x1=x0-x[i];
            int max_x01=max(x0,x1);
            int min_x01=min(x0,x1);
            //check crossing with i-3
            int x03=-x[i-4];
            int y03=x[i-5];
            int y13=-x[i-3]+x[i-5];
            int max_y01=max(y03,y13);
            int min_y01=min(y03,y13);
            bcross=x03<=max_x01 && x03>=min_x01 && y0<=max_y01 && y0>=min_y01;
            if(bcross) return 1;
            //check crossing with i-4 same direction
            int x04=0;
            int x14=-x[i-4];
            int y04=x[i-5]; //same direction must have overlap!
            int max_x014=max(x04,x14);
            int min_x014=min(x04,x14);
            bcross=(y0==y04) && ( (max_x01<max_x014 && max_x01>=min_x014) || (min_x01<max_x014 && min_x01>=min_x014));
            if(bcross) return 1;
            
            //check with i-5 cross-vertical
            int y05=0,y15=x[i-5],x05=0;
            int max_y015=max(y05,y15);
            int min_y015=min(y05,y15);
            bcross=x05<=max_x01 && x05>=min_x01 && y0<=max_y015 && y0>=min_y015;
            if(bcross) return 1;
        }
        return 0;        
    }
```	


358	Rearrange String k Distance Apart    		32.9%	Hard	

## random
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
insert, remove, getrandom, duplicate allowed.
insert/remove for list with iterator is O(1)
- need some storage to store the data
- need some index or iterator mechanism to access the element in O(1)

Like in the previous problem, Insert Delete GetRandom O(1), the solution is to maintain a vector with all elements to get the random number in O(1).
With duplicates allowed, instead of just one index, we now need to store indexes of all elements of the same value in our vector. The remove method becomes a bit more complicated therefore, as we need to:

Remove any index of the element being removed
Swap the last element in the vector with the element being removed (same as in the previous problem)
Remove old and add new index for the swapped (last) element
```cpp
  vector<int> v;
  unordered_map<int, unordered_set<int>> m;
  bool insert(int val) {
    v.push_back(val);
    m[val].insert(v.size() - 1);
    return m[val].size() == 1;
  }
  bool remove(int val) {
    auto it = m.find(val);
    if (it != end(m)) {
      auto free_pos = *it->second.begin();
      it->second.erase(it->second.begin());
      v[free_pos] = v.back();
      m[v.back()].insert(free_pos);
      m[v.back()].erase(v.size() - 1);
      v.pop_back();
      if (it->second.size() == 0) m.erase(it);
      return true;
    }
    return false;
  }
  int getRandom() { return v[rand() % v.size()]; }
```  
  
710	Random Pick with Blacklist    		31.3%	Hard	
```cpp
    vector<int> v;
    std::mt19937 gen;
    std::uniform_int_distribution<> dis;
    Solution(int N, vector<int> blacklist) {
        v = blacklist;
        sort(v.begin(), v.end());
        v.push_back(N);
        for (int i = 0; i < v.size(); i++) v[i] -= i;
        
        std::random_device rd;  //Will be used to obtain a seed for the random number engine
        gen = std::mt19937(rd()); //Standard mersenne_twister_engine seeded with rd()
        dis = std::uniform_int_distribution<>(0, N - v.size());
    }
    
    int pick() {
        int rnd = dis(gen);
        auto it = upper_bound(v.begin(), v.end(), rnd) - 1;
        int idx = it - v.begin();
        return idx + rnd + 1;
    }
```


	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
A password is considered strong if below conditions are all met:

It has at least 6 characters and at most 20 characters.
It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.
It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).
Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.

Insertion, deletion or replace of any one character are all considered as one change.

approach:
length check: delete or add some chars
upper/lower/digit check: need to replace
repeating: need to add/remove/replace
greedy: each move shall fix most problems

The basic principle is straightforward: if we want to make MINIMUM changes to turn s into a strong password, each change made should fix as many problems as possible.

So to start, let's first identify all the problems in the input string s and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the type of operation it takes and the position in the string where the operation is applied (Note: Ideally we should also include the characters involved in the operation and the "power" of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate).

Length problem: if the total length is less than 6, the change that should be made is (insert, any position), which reads as "the operation is insertion and it can be applied to anywhere in the string". If the total length is greater than 20, then the change should be (delete, any position).

Missing letter or digit: if any of the lowercase/uppercase letters or digits is missing, we can do either (insert, any position) or (replace, any position) to correct it. (Note here the characters for insertion or replacement can only be those missing.)

Repeating characters: for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix "aaaaa", we can do one replacement (replace the middle 'a') or two insertions (one after the second 'a' and one after the fourth 'a') or three deletions (delete any of the three 'a's). So the possible changes are (replace, repeating characters), (insert, repeating characters), (delete, repeating characters). (Note however the "power" of each operation for fixing the problem are different -- replacement is the strongest while deletion is the weakest.)

All right, what's next? If we want a change to eliminate as many problems as it can, it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem.

Since there are most (three) changes allowed for the third problem, we may start from combinations first problem & third problem and second problem & third problem. It's not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination first problem & second problem, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20.

From the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long.

For the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (insert, any position). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one.

For the latter case, there is overlapping between the first & third and second & third problems, so those overlapping changes will be taken, i.e., first problem => (delete, any position), second problem => (replace, any position). The reason not to use (insert, any position) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one?

Now the "power" of each operation for eliminating problems comes into play. For the third problem, the "power" of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most 5 repeating characters while insertion and deletion can do at most 4 and 3, respectively. In this case, we say replacement has more "power" than insertion or deletion. Intuitively the more "powerful" the operation is, the less number of changes is needed for correcting the problem. Therefore (replace, repeating characters) triumphs in terms of fixing the third problem.

Furthermore, another very interesting point shows up when the "power" of operation is taken into consideration (And thank yicui for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (replace, any position), we have no problem adapting it so that it coincides with the optimal change (replace, repeating characters) made for the third problem. However, there is no way to do the same for the first problem with change (delete, any position). We have a conflict now!

How do we reconcile it? The trick is that for a sequence of repeating characters of length k (k >= 3), instead of turning it all the way into a sequence of length 2 (so as to fix the repeating character problem) by the change (delete, any position), we will first reduce its length to (3m + 2), where (3m + 2) is the largest integer of the form yet no more than k. That is to say, if k is a multiple of 3, we apply once such change so its length will become (k - 1); else if k is a multiple of 3 plus 1, we apply twice such change to cut its length down to (k - 2), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: 2 or the remaining available changes). The reason is that the optimal change (replace, repeating characters) for the third problem will be most "powerful" when the total length of the repeating characters is of this form. Of course, if we still have more changes (delete, any position) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length 2.

Here is the java program based on the above analyses. Both time and space complexity is O(n). Not sure if we can reduce the space down to O(1) by computing the arr array on the fly. A quick explanation is given at the end.

public int strongPasswordChecker(String s) {
    int res = 0, a = 1, A = 1, d = 1;
    char[] carr = s.toCharArray();
    int[] arr = new int[carr.length];
        
    for (int i = 0; i < arr.length;) {
        if (Character.isLowerCase(carr[i])) a = 0;
        if (Character.isUpperCase(carr[i])) A = 0;
        if (Character.isDigit(carr[i])) d = 0;
            
        int j = i;
        while (i < carr.length && carr[i] == carr[j]) i++;
        arr[j] = i - j;
    }
        
    int total_missing = (a + A + d);

    if (arr.length < 6) {
        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));
            
    } else {
        int over_len = Math.max(arr.length - 20, 0), left_over = 0;
        res += over_len;
            
        for (int k = 1; k < 3; k++) {
            for (int i = 0; i < arr.length && over_len > 0; i++) {
                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;
                arr[i] -= Math.min(over_len, k);
                over_len -= k;
            }
        }
            
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= 3 && over_len > 0) {
                int need = arr[i] - 2;
                arr[i] -= over_len;
                over_len -= need;
            }
                
            if (arr[i] >= 3) left_over += arr[i] / 3;
        }
            
        res += Math.max(total_missing, left_over);
    }
        
    return res;
}
A quick explanation of the program:

res denotes the minimum changes; a, A and d are the number of missing lowercase letters, uppercase letters and digits, respectively; arr is an integer array whose element will be the number of repeating characters starting at the corresponding position in the string.

In the following loop we fill in the values for a, A, d and arr to identify the problems for each condition. The total number of missing characters total_missing will be the summation of a, A, d and fixing this problem takes at least total_missing changes.

We then distinguish the two cases when the string is too short or too long. If it is too short, we pad its length to at least 6 (note in this case we've already inserted total_missing characters so the new length is the summation of the original length and total_missing).

Otherwise, to fix the first condition, we need to delete over_len (number of surplus characters) characters. Since fixing the first problem also corrects the third one, we need to get rid of those parts from the arr array. And as I mentioned, we need to first turn all numbers in the arr array greater than 2 into the form of (3m + 2) and then reduce them all the way to 2 if over_len is still greater than 0. After that, we need to replace total_missing characters to fix the second problem, which also fixes part (or all) of the third problem. Therefore we only need to take the larger number of changes needed for fixing the second problem (which is total_missing) and for the third one (which is left_over, since it is the number of changes still needed after fixing the first problem).

425	Word Squares    		44.4%	Hard	

428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
inc(key) inc the key
dec(key) dec the key
getmaxkey()
getminkey()

approach:
store the relation as a matrix:
each row: the same value with a list of key strings.
first row: the max value
last row: the min value

getmin/max: just return the first key of the first/last row
iterator: to ensure O(1) access to any nodes in the matrix
inc: move to higher layer or create a new layer
dec: move to lower layer or create a new layer

```cpp
    struct Row 
    {
        list<string> strs;
        int val;
        Row(const string &s, int x) : strs({s}), val(x) {}
    };

    unordered_map<string, pair<list<Row>::iterator, list<string>::iterator>> strmap;//key to its index or iterators
    list<Row> matrix;

    /** Initialize your data structure here. */
    AllOne() {
        
    }
    
    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */
    void inc(string key) {
        if (strmap.count(key) == 0) 
        {
            if (matrix.empty() || matrix.back().val != 1) //does not have the row with value 1
            {
                auto newrow = matrix.emplace(matrix.end(), key, 1); //construct a new row
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
            else //has the row with value 1
            {
                auto newrow = --matrix.end();
                newrow->strs.push_front(key);
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
        }
        else  //key exists
        {
            auto row = strmap[key].first;
            auto col = strmap[key].second;
            auto lastrow = row;
            --lastrow;//need bring this node up a layer
            if (lastrow == matrix.end() || lastrow->val != row->val + 1) 
            {
                auto newrow = matrix.emplace(row, key, row->val + 1);//add a new row
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
            else //exist the new row
            {
                auto newrow = lastrow;
                newrow->strs.push_front(key);
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
            row->strs.erase(col);//remove the node
            if (row->strs.empty()) matrix.erase(row); //remove the row
        }
    }
    
    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */
    void dec(string key) {
        if (strmap.count(key) ==0) return;
        auto row = strmap[key].first;
        auto col = strmap[key].second;
        if (row->val == 1) 
        {
            row->strs.erase(col);
            if (row->strs.empty()) matrix.erase(row);
            strmap.erase(key);
            return;
        }
        auto nextrow = row;
        ++nextrow;
        if (nextrow == matrix.end() || nextrow->val != row->val - 1) 
        {
            auto newrow = matrix.emplace(nextrow, key, row->val - 1);
            strmap[key] = make_pair(newrow, newrow->strs.begin());
        }
        else 
        {
            auto newrow = nextrow;
            newrow->strs.push_front(key);
            strmap[key] = make_pair(newrow, newrow->strs.begin());
        }
        row->strs.erase(col);
        if (row->strs.empty()) matrix.erase(row);
    }
    
    /** Returns one of the keys with maximal value. */
    string getMaxKey() {
        return matrix.empty() ?  "" : matrix.front().strs.front();
    }
    
    /** Returns one of the keys with Minimal value. */
    string getMinKey() {
        return matrix.empty() ?  "" : matrix.back().strs.front();
    }
```



460	LFU Cache    		28.9%	Hard	
least frequently used cache.
list- to easy move, insert, remove.
iterator- to easy locate nodes
hashmap- key to iterator
one hashmap key to find the value and frequency
one hashmap key to find the list iterator
one hashmap freq vs the list of nodes

we are basically building a matrix:
each row is a list with same frequency


```cpp
class LFUCache {
    int cap;
    int size;
    int minFreq;
    unordered_map<int, pair<int, int>> m; //key to {value,freq};
    unordered_map<int, list<int>::iterator> mIter; //key to list iterator;
    unordered_map<int, list<int>>  fm;  //freq to key list;
public:
    LFUCache(int capacity) {
        cap=capacity;
        size=0;
    }
    
    int get(int key) {
        if(m.count(key)==0) return -1;
        
        fm[m[key].second].erase(mIter[key]);
        m[key].second++;
        fm[m[key].second].push_back(key);
        mIter[key]=--fm[m[key].second].end();
        
        if(fm[minFreq].size()==0 ) 
              minFreq++;
        
        return m[key].first;
    }
    
   void put(int key, int value) {
        if(cap<=0) return;
        
        int storedValue=get(key);
        if(storedValue!=-1)
        {
            m[key].first=value;
            return;
        }
        
        if(size>=cap )
        {
            m.erase( fm[minFreq].front() );
            mIter.erase( fm[minFreq].front() );
            fm[minFreq].pop_front();
            size--;
        }
        
        m[key]={value, 1};
        fm[1].push_back(key);
        mIter[key]=--fm[1].end();
        minFreq=1;
        size++;
    }
};
```

465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
S=[s,n] repeat s with n times
S1=[s1,n1]
S2=[s2,n2]
find the max M so that [S2,M] is a subsequence of S1

It's easy to come up with a brute force solution and to find that there will be a repetitive pattern when matching S2 through S1. The only problem is how to use the repetitive pattern to save computation.

Fact:
If s2 repeats in S1 R times, then S2 must repeats in S1 R / n2 times.
Conclusion:
We can simply count the repetition of s2 and then divide the count by n2.

How to denote repetition:
We need to scan s1 n1 times. Denote each scanning of s1 as an s1 segment.
After each scanning of i-th s1 segment, we will have

The accumulative count of s2 repeated in this s1 segment.
A nextIndex that s2[nextIndex] is the first letter you'll be looking for in the next s1 segment.
Suppose s1="abc", s2="bac", nextIndex will be 1; s1="abca", s2="bac", nextIndex will be 2

It is the nextIndex that is the denotation of the repetitive pattern.

```cpp
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        unordered_map<int, pair<int, int>> r;
        int k = 0;
        for(int i = 0; i < s1.length()*n1;) 
        {
            int rr = i % s1.length();
            if(r.find(rr) == r.end()) //record the position in the string
            {
                r[rr] = make_pair(i, k);
            }
            else //already recorded
            {
                // cout << rr << ',' << i << ',' << k << endl;
                auto i0 = r[rr].first;
                auto k0 = r[rr].second; // now, i - i0 == (k - k0) * s2.length()
                
                int n = (s1.length()*n1 - i0) / (i - i0); // we have n*(k - k0) complete s2 left
                
                // skip repeated patterns
                i = i0 + n*(i - i0);
                k = k0 + n*(k - k0);
            }
            
            //two pointer to find the matched string
            int j;
            for(j = 0; i < s1.length()*n1 && j < s2.length(); ++ i, ++ j) 
            {
                while(i < s1.length()*n1 && s1[i%s1.length()] != s2[j]) ++ i;
            }
            
            if(i >= s1.length()*n1) //in case it just matches
            {
                if(j>=s2.length()) k++;
                break;
            }
            ++ k;
        }
        
        // cout << k << endl;
        return k / n2;
    }
    
    inline string repeat(string &s, int n) {
        string S;
        S.reserve(s.size()*n);
        while(n -- > 0) {
            S += s;
        }
        return S;
    }
```
	
471	Encode String with Shortest Length    		45.2%	Hard	

479	Largest Palindrome Product    		27.4%	Hard	
```cpp
    int largestPalindrome(int n) {
        if (n == 1) return 9;
        int upper = pow(10, n) - 1;
        int lower = pow(10, n-1);
        for (int i = upper; i >= lower; i--) {
            long cand = buildPalindrome(i);
            for (long j = upper; j*j >= cand; j--) {
                if (cand % j == 0 && cand / j <= upper) {
                    return cand % 1337;
                }
            }
        }
        return -1;
    }
    
    long buildPalindrome(int n) {
        string s = to_string(n);
        reverse(s.begin(), s.end());
        return stol(to_string(n) + s);
    }
```
	

489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
important reverse: i<j and num[i]>2*num[j]
return the number of important reverse pairs.
brutal force: from right to left we insert in a multiset (allows duplicates)

```cpp
    int reversePairs(vector<int>& nums) {
		int n=nums.size();
		multiset<int> ms;
		int ans=0;
        vector<int> t;
		for(int i=n-1;i>=0;i--){
			while(ms.size() && (long)nums[i]>(long)2*(*ms.begin())) {
                ans++;
                t.push_back(*ms.begin());
                ms.erase(ms.begin());
            }
			ms.insert(nums[i]);
            for(auto tt: t) ms.insert(tt);
            t.clear();
		}
		return ans;
    }
```
It TLEs.
again it is merge sort, bst, divide and conquer problem.

499	The Maze III    		37.2%	Hard	




564	Find the Closest Palindrome    		18.8%	Hard	
given a n, find the closest palindrome number
```cpp
    string nearestPalindromic(string n) {
        //approach: the candidates are: same length: each digits +1 0 -1
        //with different length +1 or -1: it would be 9xxxx99 or 10....01
        //same length compare can use string compare which is the same.
        //total number of digits 60, can fit into a long long
        int len=n.size();
        long long num=stoll(n);
        vector<long long> vs;
        if(len>1)
        {
            string s(len-1,'9');

            long long c1=stoll(s)-num;
            long long c2=stoll(s)+2-num;
            if(c1) vs.push_back(c1);
            if(c2) vs.push_back(c2);
        }
        string s=n;//only need add 1 or keep the same or -1
        long long num1=stoll(n.substr(0,(len+1)/2));
        for(int i=-1;i<=1;i++)
        {
            long long num2=num1+i;
            n=s=to_string(num2);
            //reverse(n.begin(),n.end());//this will add an extra digit!!!wrong!
            //s+=n;
            for(int j=(len+1)/2;j<len;j++) s+=s[len-j-1];
            long long t=stoll(s)-num;
            if(t) vs.push_back(t);
        }
        sort(vs.begin(),vs.end());
        vector<long long> vs1=vs;
        transform(vs1.begin(),vs1.end(),vs1.begin(),static_cast<long long (*)(long long)>(abs));
        int ind=(int)(min_element(vs1.begin(),vs1.end())-vs1.begin());
        return to_string(num+vs[ind]);
    }
```	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
convex hull algorithm
```cpp
    int orientation(Point &p, Point &q, Point &r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    
    vector<Point> outerTrees(vector<Point>& points) {
        if (points.size() < 4)
            return points;
        
        sort(points.begin(), points.end(), [](Point &p, Point &q) {
            return p.x < q.x || (p.x == q.x && p.y < q.y);
        });
        
        vector<Point> ans;
        for (int i = 0; i < points.size(); ++i) {
            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)
                ans.pop_back();
            ans.push_back(points[i]);
        }
        ans.pop_back();
        for (int i = points.size() - 1; i >= 0; --i) {
            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)
                ans.pop_back();
            ans.push_back(points[i]);
        }
        ans.pop_back();
        return ans;
    }
```	

588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
```cpp
    bool isValid(string code) {
        int i = 0;
        return validTag(code, i) && i == code.size();
    }

private:
    bool validTag(string s, int& i) {
        int j = i;
        string tag = parseTagName(s, j);
        if (tag.empty()) return false;
        if (!validContent(s, j)) return false;
        int k = j + tag.size() + 2; // expecting j = pos of "</" , k = pos of '>'
        if (k >= s.size() || s.substr(j, k + 1 - j) != "</" + tag + ">") return false;
        i = k + 1;
        return true;
    }

    string parseTagName(string s, int& i) {
        if (s[i] != '<') return "";
        int j = s.find('>', i);
        if (j == string::npos || j - 1 - i < 1 || 9 < j - 1 - i) return "";
        string tag = s.substr(i + 1, j - 1 - i);
        for (char ch : tag) {
            if (ch < 'A' || 'Z' < ch) return "";
        }
        i = j + 1;
        return tag;
    }

    bool validContent(string s, int& i) {
        int j = i;
        while (j < s.size()) {
            if (!validText(s, j) && !validCData(s, j) && !validTag(s, j)) break;
        }
        i = j;
        return true;
    }

    bool validText(string s, int& i) {
        int j = i;
        while (i < s.size() && s[i] != '<') { i++; }
        return i != j;
    }

    bool validCData(string s, int& i) {
        if (s.find("<![CDATA[", i) != i) return false;
        int j = s.find("]]>", i);
        if (j == string::npos) return false;
        i = j + 3;
        return true;
    }
```
	


631	Design Excel Sum Formula    		29.3%	Hard	


642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	

	



	

683	K Empty Slots    		34.1%	Hard	


689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
left to right max and right to left max
```cpp
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        //get the partial sum first
        int n=nums.size();
        vector<int> psum(n-k+1);
        psum[0]=accumulate(nums.begin(),nums.begin()+k,0);
        for(int i=1;i<n-k+1;i++) psum[i]=psum[i-1]+nums[i+k-1]-nums[i-1];
        
        vector<int> leftmax(n-k+1),rightmax(n-k+1);
        int tmax=INT_MIN; for(int i=0;i<n-k+1;i++) tmax=leftmax[i]=max(tmax,psum[i]);
        tmax=INT_MIN; for(int i=n-k;i>=0;i--) tmax=rightmax[i]=max(tmax,psum[i]);
  
        int globalmax=INT_MIN;
        int mid=0,left=0,right=0;
        for(int i=k;i<psum.size()-k;i++) //mid can from k to n-k
        {
            int l=i-k,r=i+k; 
            int localmax=leftmax[i-k]+psum[i]+rightmax[i+k];
            if(globalmax<localmax) //use < so equal max will not be counted in
            {
                globalmax=localmax;
                mid=i;left=i-k;right=i+k;
            }
        }
        
        for(int i=left-1;i>=0;i--) if(leftmax[i]==leftmax[left]) left--;else break;
        for(int i=right+1;i<n-k+1;i++) if(rightmax[i]==rightmax[right]) right++;else break;
        return vector<int>({left,mid,right});
    }
```
	

711	Number of Distinct Islands II    		46.2%	Hard	








727	Minimum Window Subsequence    		37.3%	Hard	
	
	
736	Parse Lisp Expression    		44.4%	Hard	
string
```cpp
    int evaluate(string expression) {
        unordered_map<string,int> myMap;
        return help(expression,myMap);
    }
    
    int help(string expression,unordered_map<string,int> myMap) {
        if ((expression[0] == '-') || (expression[0] >= '0' && expression[0] <= '9'))
            return stoi(expression);
        else if (expression[0] != '(')
            return myMap[expression];
        //to get rid of the first '(' and the last ')'
        string s = expression.substr(1,expression.size()-2);
        int start = 0;
        string word = parse(s,start);
        if (word == "let") {
            while (true) {
                string variable = parse(s,start);
                //if there is no more expression, simply evaluate the variable
                if (start > s.size())
                    return help(variable,myMap);
                string temp = parse(s,start);
                myMap[variable] = help(temp,myMap);                    
            }
        }
        else if (word == "add") 
            return help(parse(s,start),myMap) + help(parse(s,start),myMap);
        else if (word == "mult") 
            return help(parse(s,start),myMap) * help(parse(s,start),myMap);
    }
    
    //function to seperate each expression
    string parse(string &s,int &start) {
        int end = start+1, temp = start, count = 1;
        if (s[start] == '(') {
            while (count != 0) {
                if (s[end] == '(')
                    count++;
                else if (s[end] == ')')
                    count--;
                end++;
            }
        }
        else {
            while (end < s.size() && s[end] != ' ')
                end++;
        }
        start = end+1;
        return s.substr(temp,end-temp);
    }
```	
	

749	Contain Virus    		41.3%	Hard	
virus spread in 4 directions.
build walls to qurantine the virus.
each day you can just quarantine one region. return the number of walls required.
Algorithm

Though the implementation is long, the algorithm is straightforward. We perform the following steps:

Find all viral regions (connected components), additionally for each region keeping track of the frontier (neighboring uncontaminated cells), and the perimeter of the region.

Disinfect the most viral region, adding it's perimeter to the answer.

Spread the virus in the remaining regions outward by 1 square.


759	Employee Free Time    		61.3%	Hard	

770	Basic Calculator IV    		45.6%	Hard	
hashmap + stack

772	Basic Calculator III    		44.2%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	

	
780	Reaching Points    		27.5%	Hard	
 a move (x,y)->either (x,x+y) or (x+y,y)
 check if we can move from (sx,sy) to (tx,ty)
 
 ```cpp
 Basic idea:
If we start from sx,sy, it will be hard to find tx, ty.
If we start from tx,ty, we can find only one path to go back to sx, sy.
I cut down one by one at first and I got TLE. So I came up with remainder.

First line:
if 2 target points are still bigger than 2 starting point, we reduce target points.
Second line:
check if we reduce target points to (x, y+kx) or (x+ky, y)

Time complexity
I will say O(logN) where N = max(tx,ty).

C++:

    bool reachingPoints(int sx, int sy, int tx, int ty) {
        while (sx < tx && sy < ty)
            if (tx < ty) ty %= tx;
            else tx %= ty;
        return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||
               sy == ty && sx <= tx && (tx - sx) % sy == 0;
    }
```
	
	

	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
f(x) is the number of zeros at the end of x!
find the number of x so that f(x)=K
class Solution {
public:
    int preimageSizeFZF(int K) {
        int sum[13]={1};
        for (int i=1; i<13; i++) sum[i]=sum[i-1]*5+1;
        for (int i=12; i>=0; i--) {
            if (K/sum[i]==5) return 0;
            K=K%sum[i];
        }
        return 5;
    }
};
Let g(x)=f(x)-f(x-1), so f(x)=sum{g(x)}.
We can find that
g(x)=0 if x%5!=0,
g(x)>=1 if x%5==0,
g(x)>=2 if x%25==0,
...
List g(x) as follows:
x: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ...
g(x): 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 ...
x: 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 ...
g(x): 1 1 1 1 2 1 1 1 1 2 1 1 1 1 2 1 1 1 1 2 1 1 1 1 3 ...
so g(x) will always repeat a sequnce for 5 times and +1 at the last number of the sequence.
Some K is/are skipped if g(x)>1.
For example, when x=25, g(x)=2, K=5 is skipped(there is no x that f(x)=5), and when x=125, g(x)=3, K=29, 30 are skipped.
We can find that 5(=1*5), 11(=6*1+5), 17(=6*2+5), 23(=6*3+5), 29(=6*4+5), 30(=6*5), 36(=31+5), 42(=31+6+5), 48(=31+6*2+5), ... are skipped.
Let me know if there are ambiguities.

798	Smallest Rotation with Highest Score    		40.3%	Hard	
rotate the array, if the value>=its index, get one point.
Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.
A[i] is in the range [0, A.length]
Key point
Don't calculate the score for K=0, we don't need it at all.
(I see almost all other solutions did)
The key point is to find out how score changes when K++

Time complexity:
“A will have length at most 20000.”
I think it means you should find a O(N) solution.

How dosen score change when K++ ?

Get point
Each time when we rotate, we make index 0 to index N-1, then we get one more point.
We know that for sure, so I don't need to record it.

Lose point
(i - A[i] + N) % N is the value of K making A[i]'s index just equal to A[i].
For example, If A[6] = 1, then K = (6 - A[6]) % 6 = 5 making A[6] to index 1 of new array.
So when K=5, we get this point for A[6]
Then if K is bigger when K = (i - A[i] + 1) % N, we start to lose this point, making our score -= 1
All I have done is record the value of K for all A[i] where we will lose points.

A[i]=0
Rotation makes no change for it, becasue we alwars have 0 <= index.
However, it is covered in "get point" and "lose point".

Explanation of codes

Search the index where score decrease and record this changement to a list change.
A simple for loop to calculate the score for every K value.
score[K] = score[K-1] + change[K]
In my codes I accumulated changes so I get the changed score for every K value compared to K=0
Find the index of best score.
C++:

    int bestRotation(vector<int>& A) {
        int N = A.size();
        int change[N] = {0};
        for (int i = 0; i < N; ++i) change[(i - A[i] + 1 + N) % N] -= 1;
        for (int i = 1; i < N; ++i) change[i] += change[i - 1] + 1;
        return distance(change, max_element(change, change + N));
    }






810	Chalkboard XOR Game    		45.0%	Hard	
We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)

Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.

Return True if and only if Alice wins the game, assuming both players play optimally.
Why [1, 2, 3] expect true
If xor == 0 at first for Alice, it is considered as Bob lose already!
I find this stupid idea just after contest and I think it doesn't make any sense.
It should complete this condition in the description.

Let's discuss it if we add this condition.
If xor == 0, Alice win directly.
If xor != 0 and length of numbers is even, Alice will win.

Beacause:
All numbers won't be the same. Otherwise xor will be equal to 0
If all numbers are not the same, It means there are at least 2 different numbers.
Alice can always erase a number different from current xor.
So Alice won't never lose this turn at this situation.

If we don't have the condition
Just return nums are not all 0 and length of nums is even

C++:

    bool xorGame(vector<int>& nums) {
        int xo = 0;
        for (int i: nums) xo ^= i;
        return xo == 0 || nums.size() % 2 == 0;
    }
	
	


	


	
829	Consecutive Numbers Sum    		33.4%	Hard	
math.

```cpp
    int consecutiveNumbersSum(int N) {
        //it can have 1,2,3,4,5,...
        //M consecuative sum: m*(m+1)/2+m*x=N
        int cnt=1;
        for(int i=2;i<sqrt(2*N);i++)
        {
            if((N-i*(i-1)/2)%i==0) cnt++;
        }
        return cnt;
        
    }
```	



843	Guess the Word    		43.6%	Hard	
This problem is an interactive problem new to the LeetCode platform.

We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret.

You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters.

This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead.

a lot of words compare with one pattern.
 
 minmax problem.  hard to understand.
 


850	Rectangle Area II    		45.0%	Hard	
axis aligned, rect represented using bottom left and top right coordinate
observation: rect overlaps. better do it along x axis one by one, just count the squares along the y axis
similar to the problem find the min/max rectangle area. but this find the total area.
the problem is like:
in the x-axis we have overlapping intervals, and we need to calculate each coordinate in these intervals
on y-axis, we have overlapping intervals too.
and the two are bounded.
similar question: 223 rectangle area: two rectangle.
brutal force: try to use two rectangle area. now we have n rectangles.



	



	
	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
so hard to understand


	
891	Sum of Subsequence Widths    		28.9%	Hard	
Given an array of integers A, consider all non-empty subsequences of A.

For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A. 

As the answer may be very large, return the answer modulo 10^9 + 7.

    int sumSubseqWidths(vector<int> A) {
        sort(A.begin(), A.end());
        long c = 1, res = 0, mod = 1e9 + 7;
        for (int i = 0; i < A.size(); ++i, c = (c << 1) % mod)
            res = (res + A[i] * c - A[A.size() - i - 1] * c) % mod;
        return (res + mod) % mod;
    }
	
895	Maximum Frequency Stack    		56.1%	Hard	

    unordered_map<int, int> freq;
    unordered_map<int, stack<int>> m;
    int maxfreq = 0;
public:
    void push(int x) {
        maxfreq = max(maxfreq, ++freq[x]);
        m[freq[x]].push(x);
    }

    int pop() {
        int x = m[maxfreq].top();
        m[maxfreq].pop();
        if (!m[freq[x]--].size()) maxfreq--;
        return x;
    }
	
	
899	Orderly Queue    		47.3%	Hard	
    string orderlyQueue(string S, int K) {
        if (K > 1) {
            sort(S.begin(), S.end());
            return S;
        }
        string res = S;
        for (int i = 1; i < S.length(); i++)
            res = min(res, S.substr(i) + S.substr(0, i));
        return res;
    }
	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.)

Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'.

Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N

this is similar to the confusing number II which can be solved using backtracking

    int atMostNGivenDigitSet(vector<string>& D, int N) {
        string NS = to_string(N);
        int digit = NS.size(), dsize = D.size(), rtn = 0;
        
        for (int i = 1 ; i < digit ; ++i)
            rtn += pow(dsize, i);
        
        for (int i = 0 ; i < digit ; ++i) {
            bool hasSameNum = false;
            for (string &d : D) {
                if (d[0] < NS[i]) 
                    rtn += pow(dsize, digit - i - 1);
                else if (d[0] == NS[i]) 
                    hasSameNum = true;
            }
            if (!hasSameNum) return rtn;
        }               
        return rtn+1;
    }
	
	

	
906	Super Palindromes    		30.4%	Hard	
Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.

Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].

    int superpalindromesInRange(string L, string R) {
     //R up to 10^5 since P<10^18  
        long l=stol(L);
        long r=stol(R);
        int limit=1e5;
        int ans=0;
        for(int i=1;i<limit;i++)
        {
            //odd and even arrange
            string s=to_string(i);
            string s_even=s+string(s.rbegin(),s.rend());
            //cout<<s_even<<" ";
            string s_odd=s+string(s.rbegin()+1,s.rend());
            
            long p=stol(s_even);
            p*=p;
            if(p>=l && p<=r)
            if(isPalindrome(p)) ans++;
            //cout<<s_odd<<endl;
            p=stol(s_odd);p*=p;
            if(p>=l && p<=r)
            if(isPalindrome(p)) ans++;
        }
        return ans;
    }
    bool isPalindrome(long x)
    {
        string s=to_string(x);
        int i=0,j=s.length()-1;
        while(i<j)
        {
            if(s[i]!=s[j]) return 0;
            i++,j--;
        }
        return 1;
    }
	
913	Cat and Mouse    		28.9%	Hard	
so hard to understand



	
927	Three Equal Parts    		30.4%	Hard	
binary strings
same number of 1s

    vector<int> threeEqualParts(vector<int>& A) {
      vector<int> ones;
        for(int i=0;i<A.size();i++) if(A[i]) ones.push_back(i);
        if(ones.size()%3) return vector<int>({-1,-1});
        if(ones.size()==0) return vector<int>({1,A.size()-1});
        int len=ones.size()/3;
        //check if the three parts has the same pattern
        for(int i=0;i<len;i++)
        {
            if(ones[i]-ones[0]!=ones[i+len]-ones[len] || ones[i]-ones[0]!=ones[i+2*len]-ones[2*len])
                return vector<int>({-1,-1});
        }
        //the pattern is the same, we need check number of zeros
        int nzeros3=A.size()-1-ones.back();
        int nzeros2=ones[2*len]-ones[2*len-1]-1;
        int nzeros1=ones[len]-ones[len-1]-1;
        //cout<<nzeros1<<" "<<nzeros2<<" "<<nzeros3;
        if(nzeros1>=nzeros3 && nzeros2>=nzeros3)
        {
            return vector<int>({ones[len-1]+nzeros3,ones[2*len-1]+nzeros3+1});
        }
        return vector<int>({-1,-1});
    }
	
	

	
	


	
972	Equal Rational Numbers    		40.2%	Hard

    bool isRationalEqual(string S, string T) {
        return f(S) == f(T);
    }

    double f(string S) {
        auto i = S.find("(");
        if (i != string::npos) {
            string base = S.substr(0, i);
            string rep = S.substr(i + 1, S.length() - i - 2);
            for (int j = 0; j < 20; ++j) base += rep;
            return stod(base);
        }
        return stod(S);
    }
	
975	Odd Even Jump    		47.8%	Hard	
You are given an integer array A.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.

You may from index i jump forward to index j (with i < j) in the following way:

During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j.
During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value.  If there are multiple such indexes j, you can only jump to the smallest such index j.
(It may be the case that for some index i, there are no legal jumps.)
A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.)

Return the number of good starting indexes.
Take [5,1,3,4,2] as example.

If we start at 2,
we can jump either higher first or lower first to the end,
because we are already at the end.
higher(2) = true
lower(2) = true

If we start at 4,
we can't jump higher, higher(4) = false
we can jump lower to 2, lower(4) = higher(2) = true

If we start at 3,
we can jump higher to 4, higher(3) = lower(4) = true
we can jump lower to 2, lower(3) = higher(2) = true

If we start at 1,
we can jump higher to 2, higher(1) = lower(2) = true
we can't jump lower, lower(1) = false

If we start at 5,
we can't jump higher, higher(5) = false
we can jump lower to 4, lower(5) = higher(4) = false

    int oddEvenJumps(vector<int>& A) {
        int n  = A.size(), res = 1;
        vector<int> higher(n), lower(n);
        higher[n - 1] = lower[n - 1] = 1;
        map<int, int> map;
        map[A[n - 1]] = n - 1;
        for (int i = n - 2; i >= 0; --i) {
            auto hi = map.lower_bound(A[i]), lo = map.upper_bound(A[i]);
            if (hi != map.end()) higher[i] = lower[hi->second];
            if (lo != map.begin()) lower[i] = higher[(--lo)->second];
            if (higher[i]) res++;
            map[A[i]] = i;
        }
        return res;
    }
	
	

	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
O(N^2)
```cpp
    int countTriplets(vector<int>& A) {
        unordered_map<int,int> mp;
        int n=A.size();
        int ans=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++) mp[A[i]&A[j]]++;
        }
        for(int i=0;i<n;i++)
        {
            for(auto it=mp.begin();it!=mp.end();it++)
                if((it->first&A[i])==0) ans+=it->second;
        }
        return ans;
    }
```
	
	

1001 Grid Illumination    		34.4%	Hard	
On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 0 <= y < N has a lamp.

Initially, some number of lamps are on.  lamps[i] tells us the location of the i-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).

For the i-th query queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0.

After each query (x, y) [in the order given by queries], we turn off any lamps that are at cell (x, y) or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).)

Return an array of answers.  Each value answer[i] should be equal to the answer of the i-th query queries[i].

 
     vector<int> gridIllumination(int N, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        unordered_map<int,int> rset,cset,diagset1,diagset2;
        unordered_set<string> lset;
        for(int i=0;i<lamps.size();i++)
        {
            int r=lamps[i][0],c=lamps[i][1];
            rset[r]++;cset[c]++;diagset1[r-c]++;diagset2[r+c]++;
            lset.insert(to_string(r)+","+to_string(c));
        }
        vector<int> ans;
        for(int i=0;i<queries.size();i++)
        {
            ans.push_back(query(N,queries[i][0],queries[i][1],rset,cset,diagset1,diagset2,lset));
        }
        return ans;
    }
  int query(int n,int r,int c,unordered_map<int,int>& rset,
            unordered_map<int,int>& cset,
            unordered_map<int,int>& dset1,
            unordered_map<int,int>& dset2,
            unordered_set<string>& lset)
  {
  //for i,j, row i and col j, diag1 r-c=i-j, diag2: r+c=i+j     
      int ans=rset.count(r) || cset.count(c) || dset1.count(r-c) || dset2.count(r+c);
      for(int i=-1;i<=1;i++)
      {
          for(int j=-1;j<=1;j++)
          {
              if(r+i<0 || r+i>=n || c+j<0 || c+j>=n) continue;
              int rr=r+i,cc=c+j;
              string s=to_string(r+i)+","+to_string(c+j);
              if(lset.count(s))
              {
                  lset.erase(s);
                  rset[rr]--;if(rset[rr]==0) rset.erase(rr);
                  cset[cc]--;if(cset[cc]==0) cset.erase(cc);
                  dset1[rr-cc]--;if(dset1[rr-cc]==0) dset1.erase(rr-cc);
                  dset2[rr+cc]--;if(dset2[rr+cc]==0) dset2.erase(rr+cc);
              }
          }
      }
      return ans;      
  }
  
  
1012 Numbers With Repeated Digits    		34.4%	Hard	
convert to equivalent: numbers without repeating digits
```cpp
    int numDupDigitsAtMostN(int N) {
        //equivalent: N-number of digits without repeative
        if(N<10) return 0;
        string s=to_string(N+1);
        int ndigits=s.length();
        int ans=0;
        for(int i=1;i<ndigits;i++) ans+=num_norepeat(i);
        //cout<<ans<<endl;
        //now we need add from 10xxxx0 to N
        //to solve this, for example 321: we first calculate 100-299, then 10-20, and then 1
        ans+=(s[0]-'1')*helper(9,s.length()-1);
        //cout<<ans<<endl;
        unordered_set<int> appeared;
        appeared.insert(s[0]-'0');
        for(int i=1;i<s.length();i++)
        {
            int t=s[i]-'0';
            int nused=appeared.size();
            for(int j=0;j<t;j++)
            {
                if(appeared.count(j)==0)
                    ans+=helper(9-nused,s.length()-i-1);//
            }
                
            if(appeared.count(t)) break;
            appeared.insert(t);
            //cout<<t<<" "<<nused<<endl;
        }
        return N-ans;
        
    }
    int num_norepeat(int ndigits)
    {
        if(ndigits>10 || ndigits<1) return 0;
        int ans=9;
        for(int i=1;i<ndigits;i++) ans*=(10-i);
        return ans;
    }
    int helper(int n,int len)
    {
        //if(len==0) return n;
        int ans=1;
        for(int i=0;i<len;i++) ans*=(n-i);
        return ans;
    }
```	


	

	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	

1074 Number of Submatrices That Sum to Target    		59.4%	Hard		
Intuition
For each row, calculate the prefix sum.
For each pair of columns,
calculate the accumulated sum of rows.
Now this problem is same to, "Find the Subarray with Target Sum".

Complexity
Time O(N^3), Space O(N)

    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {
        int m = A.size(), n = A[0].size();
        for (int i = 0; i < m; i++)
            for (int j = 1; j < n; j++)
                A[i][j] += A[i][j - 1];
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                unordered_map<int, int> counter;
                counter[0] = 1;
                int cur = 0;
                for (int k = 0; k < m; k++) {
                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);
                    res += counter[cur - target];
                    counter[cur]++;
                }
            }
        }
        return res;
    }
