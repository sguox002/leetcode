hard review

4	Median of Two Sorted Arrays    		26.5%	Hard	
10	Regular Expression Matching    		25.3%	Hard	
23	Merge k Sorted Lists    		34.7%	Hard	
25	Reverse Nodes in k-Group    		36.6%	Hard	
30	Substring with Concatenation of All Words    		23.7%	Hard	
32	Longest Valid Parentheses    		25.6%	Hard	
37	Sudoku Solver    		37.2%	Hard	
41	First Missing Positive    		29.0%	Hard	
42	Trapping Rain Water    		43.3%	Hard	
44	Wildcard Matching    		22.9%	Hard	
45	Jump Game II    		28.1%	Hard	
51	N-Queens    		39.5%	Hard	
52	N-Queens II    		52.2%	Hard	
57	Insert Interval    		31.3%	Hard	
65	Valid Number    		14.0%	Hard	
68	Text Justification    		23.4%	Hard	
72	Edit Distance    		37.9%	Hard	
76	Minimum Window Substring    		30.9%	Hard	
84	Largest Rectangle in Histogram    		31.3%	Hard	
85	Maximal Rectangle    		33.5%	Hard	
87	Scramble String    		31.7%	Hard	
97	Interleaving String    		28.1%	Hard	
99	Recover Binary Search Tree    		34.8%	Hard	
115	Distinct Subsequences    		35.1%	Hard	
123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
126	Word Ladder II    		17.8%	Hard	
128	Longest Consecutive Sequence    		41.8%	Hard	
132	Palindrome Partitioning II    		27.5%	Hard	
135	Candy    		28.5%	Hard	
140	Word Break II    		27.4%	Hard	
145	Binary Tree Postorder Traversal    		48.7%	Hard	
149	Max Points on a Line    		15.8%	Hard	
154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
174	Dungeon Game    		27.2%	Hard	
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
212	Word Search II    		28.8%	Hard	
214	Shortest Palindrome    		27.6%	Hard	
218	The Skyline Problem    		31.7%	Hard	
224	Basic Calculator    		32.8%	Hard	
233	Number of Digit One    		30.2%	Hard	
239	Sliding Window Maximum    		38.3%	Hard	
248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
282	Expression Add Operators    		32.8%	Hard	
291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard	
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
354	Russian Doll Envelopes    		34.0%	Hard	
358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
391	Perfect Rectangle    		28.2%	Hard	
403	Frog Jump    		36.2%	Hard	
407	Trapping Rain Water II    		39.3%	Hard	
410	Split Array Largest Sum    		42.4%	Hard	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
425	Word Squares    		44.4%	Hard	
428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
458	Poor Pigs    		45.4%	Hard	
460	LFU Cache    		28.9%	Hard	
465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
471	Encode String with Shortest Length    		45.2%	Hard	
472	Concatenated Words    		34.8%	Hard	
479	Largest Palindrome Product    		27.4%	Hard	
480	Sliding Window Median    		32.6%	Hard	
483	Smallest Good Base    		34.2%	Hard	
488	Zuma Game    		39.0%	Hard	
489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
514	Freedom Trail    		40.6%	Hard	
517	Super Washing Machines    		37.0%	Hard	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
552	Student Attendance Record II    		33.2%	Hard	
564	Find the Closest Palindrome    		18.8%	Hard	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard


4	Median of Two Sorted Arrays    		26.5%	Hard	
one array m, one n, for odd, it is (m+n+1)/2
for even it is two mid value average.
Approach 1: merge sort and it is O(m+n)
Approach 2: use binary search
two sorted array. two problem find the (m+n+1)/2 and (m+n+1)/2+1 element
or find kth element.
using la, ra for array a, and lb, rb for array b.
then the mid for a and mid for b divide the two array into 4 parts
a: [la,ma], [ma,ra]
b: [lb,mb], [mb,rb]
a[ma]<=b[mb]: 
```cpp
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //binary search shall be the best strategy for this problem
        //to find kth number recursively. 
        int m=nums1.size(),n=nums2.size();
        double v=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2);
        double v1;
        if((m+n)%2==0) {v1=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2+1);v=(v+v1)*0.5;}
        return v; 
          
    }
    int findkth(vector<int>& va,vector<int>& vb,int la,int ra,int lb,int rb,int k)
    {
        if(la>ra) return vb[lb+k-1];
        if(lb>rb) return va[la+k-1];
        
        int ma=(la+ra)/2,mb=(lb+rb)/2;
        if(va[ma]<=vb[mb])
        {
            if(k<=(ma-la)+(mb-lb)+1) return findkth(va,vb,la,ra,lb,mb-1,k);
            else return findkth(va,vb,ma+1,ra,lb,rb,k-(ma-la)-1);
        }
        else //va[ma]>vb[mb]
        {
            if(k<=ma-la+mb-lb+1) return findkth(va,vb,la,ma-1,lb,rb,k);
            else return findkth(va,vb,la,ra,mb+1,rb,k-(mb-lb)-1);
        }
    }
```	


10	Regular Expression Matching    		25.3%	Hard	
dp, two string matching problem
'.' matches any single char
'*' matches zero or more of the preceding char
```cpp
    bool isMatch(string s, string p) {
        /**
         * f[i][j]: if s[0..i-1] matches p[0..j-1]
         * if p[j - 1] != '*'
         *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]
         * if p[j - 1] == '*', denote p[j - 2] with x
         *      f[i][j] is true iff any of the following is true
         *      1) "x*" repeats 0 time and matches empty: f[i][j - 2]
         *      2) "x*" repeats >= 1 times and matches "x*x": s[i - 1] == x && f[i - 1][j]
         * '.' matches any single character
         */
        int m = s.size(), n = p.size();
        vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));
        
        f[0][0] = true;
        for (int i = 1; i <= m; i++)
            f[i][0] = false;
        // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty
        for (int j = 1; j <= n; j++)
            f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];
        
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (p[j - 1] != '*')
                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);
                else
                    // p[0] cannot be '*' so no need to check "j > 1" here
                    f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];
        
        return f[m][n];
    }
```
	
23	Merge k Sorted Lists    		34.7%	Hard	
typically using heap.
approach 1: keep merge two lists.
approach 2: pq (minheap) stores the listnode, keep popping the min, and push in min's next.

```cpp
struct compare {
    bool operator()(const ListNode* l, const ListNode* r) {
        return l->val > r->val;
    }
};
ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue
    priority_queue<ListNode *, vector<ListNode *>, compare> q;
    for(auto l : lists) {
        if(l)  q.push(l);
    }
    if(q.empty())  return NULL;

    ListNode* result = q.top();
    q.pop();
    if(result->next) q.push(result->next);
    ListNode* tail = result;            
    while(!q.empty()) {
        tail->next = q.top();
        q.pop();
        tail = tail->next;
        if(tail->next) q.push(tail->next);
    }
    return result;
}
```

25	Reverse Nodes in k-Group    		36.6%	Hard	
just reverse k
```cpp
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head || k<2) return head;
        ListNode *dummy,*pre,*post,*p;
        dummy=new ListNode(0);
        dummy->next=head;
        pre=dummy;
        p=head;
        int cnt=0;
        while(p)
        {
            post=advance(p,k,cnt);
            if(!post && cnt<k) break;
            //reverse nodes between pre and post
            pair<ListNode*,ListNode*> pn=reverse_inplace(p,k);
            pre->next=pn.first;
            pn.second->next=post;
            
            pre=pn.second; //now the node after pre becomes the new pre
            p=post;
        }
        return dummy->next;
    }
    ListNode* advance(ListNode* head,int k,int& cnt)
    {
        cnt=0;
        while(cnt<k && head) {head=head->next;cnt++;}
        return head;
    }
    pair<ListNode*,ListNode*> reverse_inplace(ListNode* p,int k)
    {
        ListNode* last=p;
        ListNode *pre=0,*next;
        while(k)//reverse its direction
        {
            next=p->next;
            p->next=pre;
            pre=p;
            p=next;
            k--;
        }
        return make_pair(pre,last);
    }
```	
30	Substring with Concatenation of All Words    		23.7%	Hard	
subarray with all words in the dictionary, window shall be exactly the same as the total length of the dict.
approach 1: iterate on all char with a sliding window. check if the window contains all words. Note the words are the same length, which makes thing easier
approach 2: direct hash. treat each word a hash and combination of words another hash. this is a permutation of words.
approach 3: hashmap, first build a dictionary map, and sliding window to see if the window contains the map
```cpp
	vector<int> findSubstring(string s, vector<string>& words) {
        if(words.empty()) return {};
		unordered_map<string,int> mp;
		for(auto t: words) mp[t]++;
        vector<int> ans;
		int m=words.size(),n=words[0].size(),len=s.size();
		for(int i=0;i<=len-m*n;i++){
			unordered_map<string,int> tmp;
			for(int j=0;j<m;j++){
				string t=s.substr(i+j*n,n);
				if(!mp.count(t)) break;
				tmp[t]++;
			}
			if(tmp==mp) ans.push_back(i);
		}
		return ans;
	}
```	
however worst case is O(n*m*len)
			
32	Longest Valid Parentheses    		25.6%	Hard	
using a stack to remove all valid pairs and then we leave with some intervals, then find the largest
```cpp
	int longestValidParentheses(string s) {
		stack<pair<char,int>> st;
		int maxlen=0;
		for(int i=0;i<s.size();i++){
			char c=s[i];
			if(st.size() && c==')' && st.top().first=='('){ 
				st.pop();
				if(st.size()) maxlen=max(maxlen,i-st.top().second);
				else maxlen=max(maxlen,i+1);
			}
			else st.push({c,i});
		}
		return maxlen;
	}
```	

37	Sudoku Solver    		37.2%	Hard	
typical backtracking, trial & back
```cpp
    void solveSudoku(vector<vector<char>>& board) {
		if(board.size()==0) return;
		solve(board);
    }
	bool solve(vector<vector<char>>& b)
	{
		int m=b.size(),n=b[0].size();
		for(int i=0;i<m;i++)
		{
			for(int j=0;j<n;j++)
			{
				if(b[i][j]=='.')
				{
					for(char c='1';c<='9';c++)
					{
						if(isValid(b,i,j,c))
						{
							b[i][j]=c;
							if(solve(b)) return 1;
							else b[i][j]='.';
						}
					}
				}
			}
        }
		return 0;
	}
	bool isValid(vector<vector<char>>& b,int row,int col,char c)
	{
		for(int i=0;i<9;i++)
		{
			if(b[i][col]!='.' && b[i][col]==c) return 0;
			if(b[row][i]!='.' && b[row][i]==c) return 0;
			int r0=3*(row/3)+i/3,c0=3*(col/3)+i%3;
			if(b[r0][c0]!='.' && b[r0][c0]==c) return 0;
		}
		return 1;
	}
```
	
41	First Missing Positive    		29.0%	Hard	
O(N) requirement
```cpp
Put each number in its right place.

For example:

When we find 5, then swap it with A[4].

At last, the first place where its number is not right, return the place + 1.
```cpp
class Solution
{
public:
    int firstMissingPositive(int A[], int n)
    {
        for(int i = 0; i < n; ++ i)
            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])
                swap(A[i], A[A[i] - 1]);
        
        for(int i = 0; i < n; ++ i)
            if(A[i] != i + 1)
                return i + 1;
        
        return n + 1;
    }
};
```

42	Trapping Rain Water    		43.3%	Hard	
typical stack problem
stack in decreasing, once the new coming > stack it forms a container with the one before the stack top
```cpp
    int trap(vector<int>& height) {
        //using stack similar to largest rectangle in histogram
        //we maintain a stack with index, in decreasing order of height
        int n=height.size();
        stack<int> s;
        int i=0,total=0;

        while(i<n)
        {
            if(s.empty() || height[i]<=height[s.top()]) s.push(i++);
            else
            {
                int tp=s.top();s.pop();
                //min(h(l),h(r))-h(i). If there is no element in stack, the area is 0
                if(!s.empty())
                {
                    int area=(min(height[i],height[s.top()])-height[tp])*(i-s.top()-1);//current one as the minimum
                    total+=area;
                }
            }
        }
        return total;
    }
```
	
44	Wildcard Matching    		22.9%	Hard	
typical two string compare dp problem
? matches any single char
* matches any sequence of char (including empty)
```cpp
    bool isMatch(string s, string p) {
        int m=s.length(),n=p.length();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        for(int i=1;i<=n;i++) //pattern string is not empty, but s1 is empty
        {
            if(p[i-1]!='*') break;else dp[0][i]=1;
        }
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(p[j-1]!='*') dp[i][j]=dp[i-1][j-1] &&(s[i-1]==p[j-1] || p[j-1]=='?');
                else dp[i][j]=dp[i-1][j]||dp[i][j-1];
            }
        }
        return dp[m][n];
    }
```
	
45	Jump Game II    		28.1%	Hard	
each number is the max jump steps
return min number of jumps
bfs like algorithm on 1d array.
```cpp
    int jump(vector<int>& nums) {
		int n=nums.size();
		 if(n<2)return 0;
		 int level=0,currentMax=0,i=0,nextMax=0;

		 while(currentMax-i+1>0)
		 {		//nodes count of current level>0
			 level++;
			 for(;i<=currentMax;i++)
			 {	//traverse current level , and update the max reach of next level
				nextMax=max(nextMax,nums[i]+i);
				if(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level 
			 }
			 currentMax=nextMax;
		 }
		 return 0;
	 }        
 ```

51	N-Queens    		39.5%	Hard	
nxn board and place n queens without attacking each other
each row shall only have one
each col shall only have one
each diag and anti-diag only have one
similar to sudoko solver using trial and back
```cpp
    vector<vector<string> > solveNQueens(int n) {
        vector<vector<string> > res;
        vector<string> nQueens(n, string(n, '.'));
        solveNQueens(res, nQueens, 0, n);
        return res;
    }
    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {
        if (row == n) 
        {
            res.push_back(nQueens);
            return;
        }
        for (int col = 0; col != n; ++col)
            if (isValid(nQueens, row, col, n)) 
            {
                nQueens[row][col] = 'Q';
                solveNQueens(res, nQueens, row + 1, n);
                nQueens[row][col] = '.';
            }
    }
    bool isValid(vector<string> &nQueens, int row, int col, int &n) 
    {
        //check if the column had a queen before.
        for (int i = 0; i != row; ++i)
            if (nQueens[i][col] == 'Q') return false;
        //check if the 45° diagonal had a queen before.
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
            if (nQueens[i][j] == 'Q') return false;
        //check if the 135° diagonal had a queen before.
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)
            if (nQueens[i][j] == 'Q') return false;
        return true;
    }
```


52	N-Queens II    		52.2%	Hard	
return the number of distinct solution.
similar to I.
```cpp
    int totalNQueens(int n) {
        //dfs, we need a matrix to store the occupied position
        vector<int> vp; //the column number
        return dfs(n,0,vp);
    }
    int dfs(int n,int row,vector<int>& vp)
    {
        if(row==n) return 1;
        int res=0;
        for(int col=0;col<n;col++) //try all columns
        {
            if(isValid(row,col,vp))
            {
                vp.push_back(col);
                res+=dfs(n,row+1,vp);
                vp.pop_back();
            }
        }
        return res;
    }
    bool isValid(int r,int c,vector<int>& vp)
    {
        //row is already ensured only one is placed
        for(int i=0;i<vp.size();i++) 
        {
            if(vp[i]==c) return 0; //vertical
            if(r+c==i+vp[i]) return 0;
            if(r-c==i-vp[i]) return 0;
        }
        return 1;
    }
```	

57	Insert Interval    		31.3%	Hard	
insert and merge
sort using the start. and then find the insert position. and merge those between.
note compare the end<the other's start. using equal range or lower_bound or upper_bound.
very smart. O(logn)
```cpp
    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
        auto compare = [] (const Interval &intv1, const Interval &intv2)
                          { return intv1.end < intv2.start; };
        auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);
        auto itr1 = range.first, itr2 = range.second;
        if (itr1 == itr2) {
            intervals.insert(itr1, newInterval);
        } else {
            itr2--;
            itr2->start = min(newInterval.start, itr1->start);
            itr2->end = max(newInterval.end, itr2->end);
            intervals.erase(itr1, itr2);
        }
        return intervals;
    }
```	
if not sorted, we can just merge each interval with the new one, and keeps updating the new one
O(n)
		
65	Valid Number    		14.0%	Hard	
trivial.
```cpp
    bool isNumber(string s) {
        string whitespace=" \t";
        int ind=s.find_last_not_of(whitespace);
        s=s.substr(0,ind+1);
        stringstream ss(s);
        double a;
        //we need remove trailing space since it is not good for processing
 
        ss>>a;
        
        if(ss.fail()) return 0;
        if(ss.eof()) return 1;
        return 0;
    }
```	
68	Text Justification    		23.4%	Hard	
```cpp
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        //each line: begin no space, last one no space!
        //if one word cannot fit the line, we shall break it into multiple lines
        //more like a greedy problem, allow take one or none
        //only exception is the line cannot fit a single word! we may break the single big words into two or three words
        //note last line shall be left adjustment!
        vector<string> line;
        vector<string> res;
        int cnt=0;
        bool line_done=0,last_line=0;
        for(int i=0;i<words.size();i++)
        {
            int len=cnt+words[i].size()+(line.empty()?0:1);
            
            if(len<=maxWidth) 
            {
                line.push_back(words[i]);cnt=len;
                if(i==words.size()-1) last_line=1;
            }
            else line_done=1;

            if(line_done && !last_line && !line.empty())    
            {
                int rem=maxWidth-cnt+line.size()-1; //cnt already included spaces
                int extra=0;
                if(line.size()>1)
                    extra=rem/(line.size()-1); //the remaining is added one from left to right!
                else extra=rem;
                rem-=extra*(line.size()-1);
                string s;
                for(int j=0;j<line.size()-1;j++) 
                {
                    s+=line[j];s.append(extra+(j<rem?1:0),' ');
                }
                s+=line.back();
				if(line.size()==1) s.append(extra,' ');
                res.push_back(s);
                line.clear();
                line_done=0;
				line.push_back(words[i]);cnt=words[i].size();
            }
        }
        //process last line
        cnt=0;
        string s;
        for(int i=0;i<line.size()-1;i++) {s+=line[i]+' ';cnt+=line[i].size()+1;}
        s+=line.back();cnt+=line.back().size();
        s.append(maxWidth-cnt,' ');
        res.push_back(s);
        
        return res;        
    }
```	

72	Edit Distance    		37.9%	Hard	
insert/delete/replace
typical dp problem

```cpp
    int minDistance(string s1, string s2) {
        //note it has three operations!
		int n=s1.size();
		int m=s2.size();
		vector<vector<char>> d(n+1,vector<char>(m+1));
		for(int i=0;i<=n;i++) d[i][0]=i;
		for(int j=0;j<=m;j++) d[0][j]=j;
		short ins,del,match,mismatch;
		for(int j=1;j<=m;j++)
		{
			for(int i=1;i<=n;i++)
			{
				ins=d[i][j-1]+1;
				del=d[i-1][j]+1;
				match=d[i-1][j-1];
				mismatch=d[i-1][j-1]+1;//replace
				if(s1[i-1]==s2[j-1]) //note string start from 0
					//d[i][j]=min(ins,min(del,match));
					d[i][j]=match;
				else
					d[i][j]=min(ins,min(del,mismatch));
			}
		}
		return d[n][m];   
    }
```	
76	Minimum Window Substring    		30.9%	Hard
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
S has non-related chars.
sliding window: 
for simplicity we are decreasing/increasing the hashmap and length counter.
```cpp
	string minWindow(string s, string t) {
		unordered_map<char, int> mp;	// Statistic for count of char in t
		for (auto c : t) mp[c]++;
		// counter represents the number of chars of t to be found in s.
		int start = 0, end = 0, minStart = 0, minLen = INT_MAX;
		int slen = s.size(),tlen = t.size();
			
		while (end<slen) // Move end to find a valid window.
		{
			if (mp[s[end]]>0) tlen--;// If char in s exists in t, decrease counter
			mp[s[end]]--;// Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.
			end++;
			
			while (tlen == 0) // When we found a valid window, move start to find smaller window.
			{
				if(end-start<minLen) 
				{
					minStart=start;
					minLen=end-start;
				}
				mp[s[start]]++;
				
				if (mp[s[start]]>0) tlen++;// When char exists in t, increase counter.
				start++;
			}
		}
		if (minLen != INT_MAX)return s.substr(minStart, minLen);
		return "";
	}
```
84	Largest Rectangle in Histogram    		31.3%	Hard	
Note it needs between to be all larger than the smaller side
approach 1: two way 
approach 2: divide and conquer
```cpp
    int largestRectangleArea(vector<int>& heights) {
        //the area=min(set)*len(set)
        /* use divide and conquer
    Find the minimum height column with index min. The max area should exist among three possible answers:
    sub-problem in index [0 ~ min]
    sub-problem in index [min + 1 ~ len - 1]
    height[min] * (len - 0)        
    */
        heights.push_back(0); //add a zero so that it won't overflow
        return getLargestArea(heights,0,heights.size()-1);
        
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }
```	
approach 3: using increasing stack
using stack
```cpp
    int largestRectangleArea(vector<int>& height) {
        height.insert(height.begin(),0); // dummy "0" added to make sure stack s will never be empty
        height.push_back(0); // dummy "0" added to clear the stack at the end
        int len = height.size();
        int i, res = 0, idx;
        stack<int> s; // stack to save "height" index
        s.push(0); // index to the first dummy "0"
        for(i=1;i<len;i++)
        {
            while(height[i]<height[idx = s.top()]) // if the current entry is out of order
            {
                s.pop();
                res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry
            }
            s.push(i);
        }
        height.erase(height.begin()); // remove two dummy "0"
        height.pop_back();
        return res;
    }
```	
85	Maximal Rectangle    		33.5%	Hard	
based on 1d histogram
```cpp
    int maximalRectangle(vector<vector<char>>& matrix) {
        //can we do it line by line and calculate the max?
        //using the algorithm from the max area in histogram
        //need calculate its height every line
        if(matrix.size()==0) return 0;
        int ncol=matrix[0].size();
        int nrow=matrix.size();
        
        vector<int> height(ncol+1);
        int max_area=0;
        for(int i=0;i<nrow;i++)
        {
            for(int j=0;j<ncol;j++) 
            {
                char c=matrix[i][j];
                if(c=='0') height[j]=0;
                else height[j]++;
            }
            int area=getLargestArea(height,0,height.size()-1)       ;
            if(area>max_area) max_area=area;
        }
        return max_area;
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }    
```
	
87	Scramble String    		31.7%	Hard	
similar to flip left right tree
recursive:
```cpp
    bool isScramble(string s1, string s2) {
        if(s1==s2)
            return true;
            
        int len = s1.length();
        int count[26] = {0};
        for(int i=0; i<len; i++)
        {
            count[s1[i]-'a']++;
            count[s2[i]-'a']--;
        }
        
        for(int i=0; i<26; i++)
        {
            if(count[i]!=0)
                return false;
        }
        
        for(int i=1; i<=len-1; i++)
        {
            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))
                return true;
            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))
                return true;
        }
        return false;
    }
```	

97	Interleaving String    		28.1%	Hard	
check if s3 is interleaving of s1 and s2
2d path using dp
```cpp
    bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.size(),n2=s2.size();
        if(s3.length() != n1+n2) return 0;
        if(n1==0) return s3==s2;
        if(n2==0) return s3==s1;
        vector<vector<bool>> dp(n1+1,vector<bool>(n2+1));
        dp[0][0]=1; //empty vs empty
        //boundary condition
        for(int i=1;i<n1+1;i++) dp[i][0]=dp[i-1][0] && (s1[i-1]==s3[i-1]); //j=0, s1 compare with s3
        for(int j=1;j<n2+1;j++) dp[0][j]=dp[0][j-1] && (s2[j-1]==s3[j-1]); //i=0: s2 compare with s3
        for(int i=1; i<n1+1; i++)
        {
            for(int j=1; j< n2+1; j++)
            {
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1] ) || (dp[i][j-1] && s2[j-1] == s3[i+j-1] );
            }
        }   
        return dp[n1][n2];
    }
```	

99	Recover Binary Search Tree    		34.8%	Hard	
115	Distinct Subsequences    		35.1%	Hard	
123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
126	Word Ladder II    		17.8%	Hard	
128	Longest Consecutive Sequence    		41.8%	Hard	
132	Palindrome Partitioning II    		27.5%	Hard	
135	Candy    		28.5%	Hard	
140	Word Break II    		27.4%	Hard	
145	Binary Tree Postorder Traversal    		48.7%	Hard	
149	Max Points on a Line    		15.8%	Hard	
154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
174	Dungeon Game    		27.2%	Hard	
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
212	Word Search II    		28.8%	Hard	
214	Shortest Palindrome    		27.6%	Hard	
218	The Skyline Problem    		31.7%	Hard	
224	Basic Calculator    		32.8%	Hard	
233	Number of Digit One    		30.2%	Hard	
239	Sliding Window Maximum    		38.3%	Hard	
248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
282	Expression Add Operators    		32.8%	Hard	
291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard	
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
354	Russian Doll Envelopes    		34.0%	Hard	
358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
391	Perfect Rectangle    		28.2%	Hard	
403	Frog Jump    		36.2%	Hard	
407	Trapping Rain Water II    		39.3%	Hard	
410	Split Array Largest Sum    		42.4%	Hard	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
425	Word Squares    		44.4%	Hard	
428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
458	Poor Pigs    		45.4%	Hard	
460	LFU Cache    		28.9%	Hard	
465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
471	Encode String with Shortest Length    		45.2%	Hard	
472	Concatenated Words    		34.8%	Hard	
479	Largest Palindrome Product    		27.4%	Hard	
480	Sliding Window Median    		32.6%	Hard	
483	Smallest Good Base    		34.2%	Hard	
488	Zuma Game    		39.0%	Hard	
489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
514	Freedom Trail    		40.6%	Hard	
517	Super Washing Machines    		37.0%	Hard	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
552	Student Attendance Record II    		33.2%	Hard	
564	Find the Closest Palindrome    		18.8%	Hard	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard		
