hard review

4	Median of Two Sorted Arrays    		26.5%	Hard	
10	Regular Expression Matching    		25.3%	Hard	
23	Merge k Sorted Lists    		34.7%	Hard	
25	Reverse Nodes in k-Group    		36.6%	Hard	
30	Substring with Concatenation of All Words    		23.7%	Hard	
32	Longest Valid Parentheses    		25.6%	Hard	
37	Sudoku Solver    		37.2%	Hard	
41	First Missing Positive    		29.0%	Hard	
42	Trapping Rain Water    		43.3%	Hard	
44	Wildcard Matching    		22.9%	Hard	
45	Jump Game II    		28.1%	Hard	
51	N-Queens    		39.5%	Hard	
52	N-Queens II    		52.2%	Hard	
57	Insert Interval    		31.3%	Hard	
65	Valid Number    		14.0%	Hard	
68	Text Justification    		23.4%	Hard	
72	Edit Distance    		37.9%	Hard	
76	Minimum Window Substring    		30.9%	Hard	
84	Largest Rectangle in Histogram    		31.3%	Hard	
85	Maximal Rectangle    		33.5%	Hard	
87	Scramble String    		31.7%	Hard	
97	Interleaving String    		28.1%	Hard	
99	Recover Binary Search Tree    		34.8%	Hard	
115	Distinct Subsequences    		35.1%	Hard	
123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
126	Word Ladder II    		17.8%	Hard	
128	Longest Consecutive Sequence    		41.8%	Hard	
132	Palindrome Partitioning II    		27.5%	Hard	
135	Candy    		28.5%	Hard	
140	Word Break II    		27.4%	Hard	
145	Binary Tree Postorder Traversal    		48.7%	Hard	
149	Max Points on a Line    		15.8%	Hard	
154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
174	Dungeon Game    		27.2%	Hard	
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
212	Word Search II    		28.8%	Hard	
214	Shortest Palindrome    		27.6%	Hard	
218	The Skyline Problem    		31.7%	Hard	
224	Basic Calculator    		32.8%	Hard	
233	Number of Digit One    		30.2%	Hard	
239	Sliding Window Maximum    		38.3%	Hard	
248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
282	Expression Add Operators    		32.8%	Hard	
291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard	
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
354	Russian Doll Envelopes    		34.0%	Hard	
358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
391	Perfect Rectangle    		28.2%	Hard	
403	Frog Jump    		36.2%	Hard	
407	Trapping Rain Water II    		39.3%	Hard	
410	Split Array Largest Sum    		42.4%	Hard	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
425	Word Squares    		44.4%	Hard	
428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
458	Poor Pigs    		45.4%	Hard	
460	LFU Cache    		28.9%	Hard	
465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
471	Encode String with Shortest Length    		45.2%	Hard	
472	Concatenated Words    		34.8%	Hard	
479	Largest Palindrome Product    		27.4%	Hard	
480	Sliding Window Median    		32.6%	Hard	
483	Smallest Good Base    		34.2%	Hard	
488	Zuma Game    		39.0%	Hard	
489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
514	Freedom Trail    		40.6%	Hard	
517	Super Washing Machines    		37.0%	Hard	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
552	Student Attendance Record II    		33.2%	Hard	
564	Find the Closest Palindrome    		18.8%	Hard	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard


4	Median of Two Sorted Arrays    		26.5%	Hard	
one array m, one n, for odd, it is (m+n+1)/2
for even it is two mid value average.
Approach 1: merge sort and it is O(m+n)
Approach 2: use binary search
two sorted array. two problem find the (m+n+1)/2 and (m+n+1)/2+1 element
or find kth element.
using la, ra for array a, and lb, rb for array b.
then the mid for a and mid for b divide the two array into 4 parts
a: [la,ma], [ma,ra]
b: [lb,mb], [mb,rb]
a[ma]<=b[mb]: 
```cpp
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //binary search shall be the best strategy for this problem
        //to find kth number recursively. 
        int m=nums1.size(),n=nums2.size();
        double v=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2);
        double v1;
        if((m+n)%2==0) {v1=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2+1);v=(v+v1)*0.5;}
        return v; 
          
    }
    int findkth(vector<int>& va,vector<int>& vb,int la,int ra,int lb,int rb,int k)
    {
        if(la>ra) return vb[lb+k-1];
        if(lb>rb) return va[la+k-1];
        
        int ma=(la+ra)/2,mb=(lb+rb)/2;
        if(va[ma]<=vb[mb])
        {
            if(k<=(ma-la)+(mb-lb)+1) return findkth(va,vb,la,ra,lb,mb-1,k);
            else return findkth(va,vb,ma+1,ra,lb,rb,k-(ma-la)-1);
        }
        else //va[ma]>vb[mb]
        {
            if(k<=ma-la+mb-lb+1) return findkth(va,vb,la,ma-1,lb,rb,k);
            else return findkth(va,vb,la,ra,mb+1,rb,k-(mb-lb)-1);
        }
    }
```	


10	Regular Expression Matching    		25.3%	Hard	
dp, two string matching problem
'.' matches any single char
'*' matches zero or more of the preceding char
```cpp
    bool isMatch(string s, string p) {
        /**
         * f[i][j]: if s[0..i-1] matches p[0..j-1]
         * if p[j - 1] != '*'
         *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]
         * if p[j - 1] == '*', denote p[j - 2] with x
         *      f[i][j] is true iff any of the following is true
         *      1) "x*" repeats 0 time and matches empty: f[i][j - 2]
         *      2) "x*" repeats >= 1 times and matches "x*x": s[i - 1] == x && f[i - 1][j]
         * '.' matches any single character
         */
        int m = s.size(), n = p.size();
        vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));
        
        f[0][0] = true;
        for (int i = 1; i <= m; i++)
            f[i][0] = false;
        // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty
        for (int j = 1; j <= n; j++)
            f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];
        
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (p[j - 1] != '*')
                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);
                else
                    // p[0] cannot be '*' so no need to check "j > 1" here
                    f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];
        
        return f[m][n];
    }
```
	
23	Merge k Sorted Lists    		34.7%	Hard	
typically using heap.
approach 1: keep merge two lists.
approach 2: pq (minheap) stores the listnode, keep popping the min, and push in min's next.

```cpp
struct compare {
    bool operator()(const ListNode* l, const ListNode* r) {
        return l->val > r->val;
    }
};
ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue
    priority_queue<ListNode *, vector<ListNode *>, compare> q;
    for(auto l : lists) {
        if(l)  q.push(l);
    }
    if(q.empty())  return NULL;

    ListNode* result = q.top();
    q.pop();
    if(result->next) q.push(result->next);
    ListNode* tail = result;            
    while(!q.empty()) {
        tail->next = q.top();
        q.pop();
        tail = tail->next;
        if(tail->next) q.push(tail->next);
    }
    return result;
}
```

25	Reverse Nodes in k-Group    		36.6%	Hard	
just reverse k
```cpp
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head || k<2) return head;
        ListNode *dummy,*pre,*post,*p;
        dummy=new ListNode(0);
        dummy->next=head;
        pre=dummy;
        p=head;
        int cnt=0;
        while(p)
        {
            post=advance(p,k,cnt);
            if(!post && cnt<k) break;
            //reverse nodes between pre and post
            pair<ListNode*,ListNode*> pn=reverse_inplace(p,k);
            pre->next=pn.first;
            pn.second->next=post;
            
            pre=pn.second; //now the node after pre becomes the new pre
            p=post;
        }
        return dummy->next;
    }
    ListNode* advance(ListNode* head,int k,int& cnt)
    {
        cnt=0;
        while(cnt<k && head) {head=head->next;cnt++;}
        return head;
    }
    pair<ListNode*,ListNode*> reverse_inplace(ListNode* p,int k)
    {
        ListNode* last=p;
        ListNode *pre=0,*next;
        while(k)//reverse its direction
        {
            next=p->next;
            p->next=pre;
            pre=p;
            p=next;
            k--;
        }
        return make_pair(pre,last);
    }
```	
30	Substring with Concatenation of All Words    		23.7%	Hard	
subarray with all words in the dictionary, window shall be exactly the same as the total length of the dict.
approach 1: iterate on all char with a sliding window. check if the window contains all words. Note the words are the same length, which makes thing easier
approach 2: direct hash. treat each word a hash and combination of words another hash. this is a permutation of words.
approach 3: hashmap, first build a dictionary map, and sliding window to see if the window contains the map
```cpp
	vector<int> findSubstring(string s, vector<string>& words) {
        if(words.empty()) return {};
		unordered_map<string,int> mp;
		for(auto t: words) mp[t]++;
        vector<int> ans;
		int m=words.size(),n=words[0].size(),len=s.size();
		for(int i=0;i<=len-m*n;i++){
			unordered_map<string,int> tmp;
			for(int j=0;j<m;j++){
				string t=s.substr(i+j*n,n);
				if(!mp.count(t)) break;
				tmp[t]++;
			}
			if(tmp==mp) ans.push_back(i);
		}
		return ans;
	}
```	
however worst case is O(n*m*len)
			
32	Longest Valid Parentheses    		25.6%	Hard	
using a stack to remove all valid pairs and then we leave with some intervals, then find the largest
```cpp
	int longestValidParentheses(string s) {
		stack<pair<char,int>> st;
		int maxlen=0;
		for(int i=0;i<s.size();i++){
			char c=s[i];
			if(st.size() && c==')' && st.top().first=='('){ 
				st.pop();
				if(st.size()) maxlen=max(maxlen,i-st.top().second);
				else maxlen=max(maxlen,i+1);
			}
			else st.push({c,i});
		}
		return maxlen;
	}
```	

37	Sudoku Solver    		37.2%	Hard	
typical backtracking, trial & back
```cpp
    void solveSudoku(vector<vector<char>>& board) {
		if(board.size()==0) return;
		solve(board);
    }
	bool solve(vector<vector<char>>& b)
	{
		int m=b.size(),n=b[0].size();
		for(int i=0;i<m;i++)
		{
			for(int j=0;j<n;j++)
			{
				if(b[i][j]=='.')
				{
					for(char c='1';c<='9';c++)
					{
						if(isValid(b,i,j,c))
						{
							b[i][j]=c;
							if(solve(b)) return 1;
							else b[i][j]='.';
						}
					}
				}
			}
        }
		return 0;
	}
	bool isValid(vector<vector<char>>& b,int row,int col,char c)
	{
		for(int i=0;i<9;i++)
		{
			if(b[i][col]!='.' && b[i][col]==c) return 0;
			if(b[row][i]!='.' && b[row][i]==c) return 0;
			int r0=3*(row/3)+i/3,c0=3*(col/3)+i%3;
			if(b[r0][c0]!='.' && b[r0][c0]==c) return 0;
		}
		return 1;
	}
```
	
41	First Missing Positive    		29.0%	Hard	
O(N) requirement
```cpp
Put each number in its right place.

For example:

When we find 5, then swap it with A[4].

At last, the first place where its number is not right, return the place + 1.
```cpp
class Solution
{
public:
    int firstMissingPositive(int A[], int n)
    {
        for(int i = 0; i < n; ++ i)
            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])
                swap(A[i], A[A[i] - 1]);
        
        for(int i = 0; i < n; ++ i)
            if(A[i] != i + 1)
                return i + 1;
        
        return n + 1;
    }
};
```

42	Trapping Rain Water    		43.3%	Hard	
typical stack problem
stack in decreasing, once the new coming > stack it forms a container with the one before the stack top
```cpp
    int trap(vector<int>& height) {
        //using stack similar to largest rectangle in histogram
        //we maintain a stack with index, in decreasing order of height
        int n=height.size();
        stack<int> s;
        int i=0,total=0;

        while(i<n)
        {
            if(s.empty() || height[i]<=height[s.top()]) s.push(i++);
            else
            {
                int tp=s.top();s.pop();
                //min(h(l),h(r))-h(i). If there is no element in stack, the area is 0
                if(!s.empty())
                {
                    int area=(min(height[i],height[s.top()])-height[tp])*(i-s.top()-1);//current one as the minimum
                    total+=area;
                }
            }
        }
        return total;
    }
```
	
44	Wildcard Matching    		22.9%	Hard	
typical two string compare dp problem
? matches any single char
* matches any sequence of char (including empty)
```cpp
    bool isMatch(string s, string p) {
        int m=s.length(),n=p.length();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        for(int i=1;i<=n;i++) //pattern string is not empty, but s1 is empty
        {
            if(p[i-1]!='*') break;else dp[0][i]=1;
        }
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(p[j-1]!='*') dp[i][j]=dp[i-1][j-1] &&(s[i-1]==p[j-1] || p[j-1]=='?');
                else dp[i][j]=dp[i-1][j]||dp[i][j-1];
            }
        }
        return dp[m][n];
    }
```
	
45	Jump Game II    		28.1%	Hard	
each number is the max jump steps
return min number of jumps
bfs like algorithm on 1d array.
```cpp
    int jump(vector<int>& nums) {
		int n=nums.size();
		 if(n<2)return 0;
		 int level=0,currentMax=0,i=0,nextMax=0;

		 while(currentMax-i+1>0)
		 {		//nodes count of current level>0
			 level++;
			 for(;i<=currentMax;i++)
			 {	//traverse current level , and update the max reach of next level
				nextMax=max(nextMax,nums[i]+i);
				if(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level 
			 }
			 currentMax=nextMax;
		 }
		 return 0;
	 }        
 ```

51	N-Queens    		39.5%	Hard	
nxn board and place n queens without attacking each other
each row shall only have one
each col shall only have one
each diag and anti-diag only have one
similar to sudoko solver using trial and back
```cpp
    vector<vector<string> > solveNQueens(int n) {
        vector<vector<string> > res;
        vector<string> nQueens(n, string(n, '.'));
        solveNQueens(res, nQueens, 0, n);
        return res;
    }
    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {
        if (row == n) 
        {
            res.push_back(nQueens);
            return;
        }
        for (int col = 0; col != n; ++col)
            if (isValid(nQueens, row, col, n)) 
            {
                nQueens[row][col] = 'Q';
                solveNQueens(res, nQueens, row + 1, n);
                nQueens[row][col] = '.';
            }
    }
    bool isValid(vector<string> &nQueens, int row, int col, int &n) 
    {
        //check if the column had a queen before.
        for (int i = 0; i != row; ++i)
            if (nQueens[i][col] == 'Q') return false;
        //check if the 45° diagonal had a queen before.
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
            if (nQueens[i][j] == 'Q') return false;
        //check if the 135° diagonal had a queen before.
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)
            if (nQueens[i][j] == 'Q') return false;
        return true;
    }
```


52	N-Queens II    		52.2%	Hard	
return the number of distinct solution.
similar to I.
```cpp
    int totalNQueens(int n) {
        //dfs, we need a matrix to store the occupied position
        vector<int> vp; //the column number
        return dfs(n,0,vp);
    }
    int dfs(int n,int row,vector<int>& vp)
    {
        if(row==n) return 1;
        int res=0;
        for(int col=0;col<n;col++) //try all columns
        {
            if(isValid(row,col,vp))
            {
                vp.push_back(col);
                res+=dfs(n,row+1,vp);
                vp.pop_back();
            }
        }
        return res;
    }
    bool isValid(int r,int c,vector<int>& vp)
    {
        //row is already ensured only one is placed
        for(int i=0;i<vp.size();i++) 
        {
            if(vp[i]==c) return 0; //vertical
            if(r+c==i+vp[i]) return 0;
            if(r-c==i-vp[i]) return 0;
        }
        return 1;
    }
```	

57	Insert Interval    		31.3%	Hard	
insert and merge
sort using the start. and then find the insert position. and merge those between.
note compare the end<the other's start. using equal range or lower_bound or upper_bound.
very smart. O(logn)
```cpp
    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
        auto compare = [] (const Interval &intv1, const Interval &intv2)
                          { return intv1.end < intv2.start; };
        auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);
        auto itr1 = range.first, itr2 = range.second;
        if (itr1 == itr2) {
            intervals.insert(itr1, newInterval);
        } else {
            itr2--;
            itr2->start = min(newInterval.start, itr1->start);
            itr2->end = max(newInterval.end, itr2->end);
            intervals.erase(itr1, itr2);
        }
        return intervals;
    }
```	
if not sorted, we can just merge each interval with the new one, and keeps updating the new one
O(n)
		
65	Valid Number    		14.0%	Hard	
trivial.
```cpp
    bool isNumber(string s) {
        string whitespace=" \t";
        int ind=s.find_last_not_of(whitespace);
        s=s.substr(0,ind+1);
        stringstream ss(s);
        double a;
        //we need remove trailing space since it is not good for processing
 
        ss>>a;
        
        if(ss.fail()) return 0;
        if(ss.eof()) return 1;
        return 0;
    }
```	
68	Text Justification    		23.4%	Hard	
```cpp
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        //each line: begin no space, last one no space!
        //if one word cannot fit the line, we shall break it into multiple lines
        //more like a greedy problem, allow take one or none
        //only exception is the line cannot fit a single word! we may break the single big words into two or three words
        //note last line shall be left adjustment!
        vector<string> line;
        vector<string> res;
        int cnt=0;
        bool line_done=0,last_line=0;
        for(int i=0;i<words.size();i++)
        {
            int len=cnt+words[i].size()+(line.empty()?0:1);
            
            if(len<=maxWidth) 
            {
                line.push_back(words[i]);cnt=len;
                if(i==words.size()-1) last_line=1;
            }
            else line_done=1;

            if(line_done && !last_line && !line.empty())    
            {
                int rem=maxWidth-cnt+line.size()-1; //cnt already included spaces
                int extra=0;
                if(line.size()>1)
                    extra=rem/(line.size()-1); //the remaining is added one from left to right!
                else extra=rem;
                rem-=extra*(line.size()-1);
                string s;
                for(int j=0;j<line.size()-1;j++) 
                {
                    s+=line[j];s.append(extra+(j<rem?1:0),' ');
                }
                s+=line.back();
				if(line.size()==1) s.append(extra,' ');
                res.push_back(s);
                line.clear();
                line_done=0;
				line.push_back(words[i]);cnt=words[i].size();
            }
        }
        //process last line
        cnt=0;
        string s;
        for(int i=0;i<line.size()-1;i++) {s+=line[i]+' ';cnt+=line[i].size()+1;}
        s+=line.back();cnt+=line.back().size();
        s.append(maxWidth-cnt,' ');
        res.push_back(s);
        
        return res;        
    }
```	

72	Edit Distance    		37.9%	Hard	
insert/delete/replace
typical dp problem

```cpp
    int minDistance(string s1, string s2) {
        //note it has three operations!
		int n=s1.size();
		int m=s2.size();
		vector<vector<char>> d(n+1,vector<char>(m+1));
		for(int i=0;i<=n;i++) d[i][0]=i;
		for(int j=0;j<=m;j++) d[0][j]=j;
		short ins,del,match,mismatch;
		for(int j=1;j<=m;j++)
		{
			for(int i=1;i<=n;i++)
			{
				ins=d[i][j-1]+1;
				del=d[i-1][j]+1;
				match=d[i-1][j-1];
				mismatch=d[i-1][j-1]+1;//replace
				if(s1[i-1]==s2[j-1]) //note string start from 0
					//d[i][j]=min(ins,min(del,match));
					d[i][j]=match;
				else
					d[i][j]=min(ins,min(del,mismatch));
			}
		}
		return d[n][m];   
    }
```	
76	Minimum Window Substring    		30.9%	Hard
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
S has non-related chars.
sliding window: 
for simplicity we are decreasing/increasing the hashmap and length counter.
```cpp
	string minWindow(string s, string t) {
		unordered_map<char, int> mp;	// Statistic for count of char in t
		for (auto c : t) mp[c]++;
		// counter represents the number of chars of t to be found in s.
		int start = 0, end = 0, minStart = 0, minLen = INT_MAX;
		int slen = s.size(),tlen = t.size();
			
		while (end<slen) // Move end to find a valid window.
		{
			if (mp[s[end]]>0) tlen--;// If char in s exists in t, decrease counter
			mp[s[end]]--;// Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.
			end++;
			
			while (tlen == 0) // When we found a valid window, move start to find smaller window.
			{
				if(end-start<minLen) 
				{
					minStart=start;
					minLen=end-start;
				}
				mp[s[start]]++;
				
				if (mp[s[start]]>0) tlen++;// When char exists in t, increase counter.
				start++;
			}
		}
		if (minLen != INT_MAX)return s.substr(minStart, minLen);
		return "";
	}
```
84	Largest Rectangle in Histogram    		31.3%	Hard	
Note it needs between to be all larger than the smaller side
approach 1: two way 
approach 2: divide and conquer
```cpp
    int largestRectangleArea(vector<int>& heights) {
        //the area=min(set)*len(set)
        /* use divide and conquer
    Find the minimum height column with index min. The max area should exist among three possible answers:
    sub-problem in index [0 ~ min]
    sub-problem in index [min + 1 ~ len - 1]
    height[min] * (len - 0)        
    */
        heights.push_back(0); //add a zero so that it won't overflow
        return getLargestArea(heights,0,heights.size()-1);
        
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }
```	
approach 3: using increasing stack
using stack
```cpp
    int largestRectangleArea(vector<int>& height) {
        height.insert(height.begin(),0); // dummy "0" added to make sure stack s will never be empty
        height.push_back(0); // dummy "0" added to clear the stack at the end
        int len = height.size();
        int i, res = 0, idx;
        stack<int> s; // stack to save "height" index
        s.push(0); // index to the first dummy "0"
        for(i=1;i<len;i++)
        {
            while(height[i]<height[idx = s.top()]) // if the current entry is out of order
            {
                s.pop();
                res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry
            }
            s.push(i);
        }
        height.erase(height.begin()); // remove two dummy "0"
        height.pop_back();
        return res;
    }
```	
85	Maximal Rectangle    		33.5%	Hard	
based on 1d histogram
```cpp
    int maximalRectangle(vector<vector<char>>& matrix) {
        //can we do it line by line and calculate the max?
        //using the algorithm from the max area in histogram
        //need calculate its height every line
        if(matrix.size()==0) return 0;
        int ncol=matrix[0].size();
        int nrow=matrix.size();
        
        vector<int> height(ncol+1);
        int max_area=0;
        for(int i=0;i<nrow;i++)
        {
            for(int j=0;j<ncol;j++) 
            {
                char c=matrix[i][j];
                if(c=='0') height[j]=0;
                else height[j]++;
            }
            int area=getLargestArea(height,0,height.size()-1)       ;
            if(area>max_area) max_area=area;
        }
        return max_area;
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }    
```
	
87	Scramble String    		31.7%	Hard	
similar to flip left right tree
recursive:
```cpp
    bool isScramble(string s1, string s2) {
        if(s1==s2)
            return true;
            
        int len = s1.length();
        int count[26] = {0};
        for(int i=0; i<len; i++)
        {
            count[s1[i]-'a']++;
            count[s2[i]-'a']--;
        }
        
        for(int i=0; i<26; i++)
        {
            if(count[i]!=0)
                return false;
        }
        
        for(int i=1; i<=len-1; i++)
        {
            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))
                return true;
            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))
                return true;
        }
        return false;
    }
```	

97	Interleaving String    		28.1%	Hard	
check if s3 is interleaving of s1 and s2
2d path using dp
```cpp
    bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.size(),n2=s2.size();
        if(s3.length() != n1+n2) return 0;
        if(n1==0) return s3==s2;
        if(n2==0) return s3==s1;
        vector<vector<bool>> dp(n1+1,vector<bool>(n2+1));
        dp[0][0]=1; //empty vs empty
        //boundary condition
        for(int i=1;i<n1+1;i++) dp[i][0]=dp[i-1][0] && (s1[i-1]==s3[i-1]); //j=0, s1 compare with s3
        for(int j=1;j<n2+1;j++) dp[0][j]=dp[0][j-1] && (s2[j-1]==s3[j-1]); //i=0: s2 compare with s3
        for(int i=1; i<n1+1; i++)
        {
            for(int j=1; j< n2+1; j++)
            {
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1] ) || (dp[i][j-1] && s2[j-1] == s3[i+j-1] );
            }
        }   
        return dp[n1][n2];
    }
```	

99	Recover Binary Search Tree    		34.8%	Hard	
two elements of a binary search tree are swapped. recover it
inorder traversal and keep prev and compare with current. if prev>curr it is one of it
```cpp
    TreeNode* prev;
    void recoverTree(TreeNode* root) {
        vector<TreeNode*> res;
        prev=0;
        inorder(root,res);
        //for(int i=0;i<res.size();i++) cout<<res[i]->val<<" ";
        if(res.size()==2) {swap(res[0]->val,res[1]->val);}
        else {swap(res[0]->val,res[3]->val);}
    
    }
    void inorder(TreeNode* root,vector<TreeNode*>& res) //inorder traverse to find the swapped ind
    {
        if(!root) return;
        //compare to previous 
        inorder(root->left,res);
        if(!prev) {prev=root;}
        else
        {
            if(root->val<prev->val) {res.push_back(prev);res.push_back(root);}
            prev=root;
        }
        //cout<<prev->val<<" "<<root->val<<",";
        inorder(root->right,res);
    }
```
	
115	Distinct Subsequences    		35.1%	Hard	
number of distinct subsequence in S equals T
that is number of ways from S to T. (similar to climbing stairs)
```cpp
    int numDistinct(string s, string t) {
        //dp edit distance
        int m=s.size(),n=t.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        //dp[i,j] represent number of subsequence for s(0...i) vs t[0..j]
        //allowing only deletion from s
        //boundary: dp[0,0]=1
        for(int i=0;i<=m;i++) dp[i][0]=1; //when t is empty, need delete all s
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(s[i-1]!=t[j-1]) dp[i][j]=dp[i-1][j]; //need delete this char, i proceed one
                else dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; //delete: i proceed one, keep: dp[i-1][j-1]
            }
        }
        return dp[m][n];
    }
```

123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
two transaction, it is a special edition of K transaction
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
the idea is based on previous k-1 transaction, add a more transaction
dp[k][i]=max(dp[k][i-1],dp[k-1][j]+price[i]-price[j]), no operation or operation
```cpp
    int maxProfit(int k, vector<int>& prices) {
       int n=prices.size();
        if(k>=n/2)
        {
            int sum=0;
            for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) sum+=prices[i]-prices[i-1];
            return sum;
        }
        vector<vector<int>> dp(k+1,vector<int>(n));
        int maxprof=0;
        
        for(int t=1;t<=k;t++)
        {
            int tmin=INT_MAX;
            for(int i=1;i<n;i++)
            {
                tmin=min(tmin,prices[i-1]-dp[t-1][i-1]);
                dp[t][i]=max(dp[t][i-1],prices[i]-tmin);
                maxprof=max(maxprof,dp[t][i]);
            }
        }
        return maxprof;
    }
```	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
path sum: can cross the root or not cross.
cross the root: root+left+right 
not cross the root: left or right (subproblem)
combined with the dp problem: the max sum of subarray if previous sum<0 then we start a new segement.
```cpp
    int maxPathSum(TreeNode* root) {
        //any negative nodes shall not be included
        //each node shall be the largest path sum
        //nodemaxsum=node+max_left_pathsum+max_right_pathsum which needs postorder traversal
        int maxsum=INT_MIN;
        node_maxsum(root,maxsum);
        return maxsum;
    }
    int node_maxsum(TreeNode* root,int& maxpathsum)
    {
        if(!root) return 0;
        int l=node_maxsum(root->left,maxpathsum);
        int r=node_maxsum(root->right,maxpathsum);
        l=l>0?l:0; //shall we include left?
        r=r>0?r:0;//shall we include right?
        if(maxpathsum<l+r+root->val) maxpathsum=l+r+root->val;
        root->val+=max(l,r); //postorder is bottom up, update the node value to the max path sum (including the paths under its subtree
        return root->val;
    }
```	
update the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time.

126	Word Ladder II    		17.8%	Hard	
find all shortest path from A to B.
similar problem 127 Word Ladder using bfs. (shortest distance from A to B)
- convert to hashset first for better retrieving.
- 
```cpp
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> dict(wordList.begin(),wordList.end()),visited;
		queue<string> q;
		q.push(beginWord);
		visited.insert(beginWord);
		int step=1;
		while(q.size()){
			int sz=q.size();
			while(sz--){
				string s=q.front();
				if(s==endWord) return step;
				q.pop();
				addWords(s,q,dict,visited);
			}
			step++;
		}
		return 0;
    }
	void addWords(string& s,queue<string>& q,unordered_set<string>& dict,unordered_set<string>& visited){
		for(int i=0;i<s.size();i++){
			char c=s[i];
			for(char t='a';t<='z';t++){
				s[i]=t;
				if(dict.count(s) && !visited.count(s)) {
					q.push(s);
					visited.insert(s);
				}
			}
			s[i]=c;
		}
	}
```	
now we need all the shortest path.
approach 1: get the shortest path length using bfs and then find path using dfs. wasted information
approach 2: bfs while keeping the route information.
when we found the path we need keep finishing the layer. also we need keep the path information. (parent)
need add a pointer to its parent. it forms a tree.
```cpp
	struct node{
		node* parent;
		string s;
		node(string ss): s(ss),parent(0){}
		node(string ss,node* p): s(ss),parent(p){}
	};
	vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList){
		vector<vector<string>> ans;
        unordered_set<string> dict(wordList.begin(),wordList.end()),visited;
		vector<node*> tree;
		queue<node*> q; //parent-child pair, do not use pointer since vector is dynamic
		tree.push_back(new node(beginWord));
		q.push(tree.back());
		visited.insert(beginWord);
		int step=1;
        bool stop=0;
		vector<string> layer;
		while(q.size() && !stop){
			layer.clear();
			int sz=q.size();
			while(sz--){
				auto nd=q.front(); //use pointer be very careful
				q.pop();
                //cout<<nd->s<<endl;
                auto parent=nd;
				if(nd->s==endWord) {
                    stop=1;
					vector<string> vt;
					while(nd){
						vt.push_back(nd->s);
                        nd=nd->parent;
					}
					ans.push_back({vt.rbegin(),vt.rend()});
				}
				addWords(parent->s,q,dict,visited,tree,parent,layer);
			}
			for(auto t: layer) visited.insert(t);
			step++;
		}
		return ans;
    }
	void addWords(string s,queue<node*>& q,unordered_set<string>& dict,
	unordered_set<string>& visited,vector<node*>& tree,node* parent,vector<string>& layer){
		for(int i=0;i<s.size();i++){
			char c=s[i];
			for(char t='a';t<='z';t++){
				s[i]=t;
				if(dict.count(s) && !visited.count(s)) {
					tree.push_back(new node(s,parent));
					q.push(tree.back());
					//if(s!=endw) visited.insert(s);
					layer.push_back(s);
				}
			}
			s[i]=c;
		}
		//for(auto t: vt) visited.insert(t);
	}
```
There is a problem: 
- the endword is not allowed to be included multiple times so only one answer would be given.
- different path may contain a common word so the visited is not proper. actually this is the key part.
bfs: the layer used canot never be visited again.
but the same layer can be used multiple times. so we can only update the visited after the layer is done!!!!!
this is another form of BFS and very good question. The node may have multiple parents to avoid dfs, it is necessary to keep multiple same nodes	in queue to maintain one to one relation

128	Longest Consecutive Sequence    		41.8%	Hard	
need O(n)
for example [100,4,200,1,3,2]
when we see 4, we know we need 5 and 3
when we see 1, we know we need 2 and 0
when we see 3, it is in need list, and also it needs 4 and 2
when we see 2, it is in need list, and also it needs 3 and 1
connect them using union-find
```cpp
    int longestConsecutive(vector<int>& nums) {
        //they don't need to keep order, disjoint set
        int n=nums.size();
        if(n<2) return n;
        vector<int> parent(n),size(n,1);
        unordered_map<int,int> mp;
        for(int i=0;i<n;i++) parent[i]=i;
        for(int i=0;i<n;i++)
        {
            if(mp.count(nums[i])) continue;//ignore duplicates
            mp[nums[i]]=i;
            if(mp.count(nums[i]-1)) merge(i,mp[nums[i]-1],parent,size);
            if(mp.count(nums[i]+1)) merge(i,mp[nums[i]+1],parent,size);
        }
        return *max_element(size.begin(),size.end());
    }
    
    int getparent(int i,vector<int>& parent)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(int i,int j,vector<int>& parent,vector<int>& size)
    {
        int pi=getparent(i,parent),pj=getparent(j,parent);
        if(pi==pj) return;
        if(pi<pj) {parent[pj]=pi;size[pi]+=size[pj];size[pj]=0;}
        else {parent[pi]=pj;size[pj]+=size[pi];size[pi]=0;}
    }
```	


132	Palindrome Partitioning II    		27.5%	Hard	
return min number of cuts so that each substr is a palindrome.
this is a dp. odd length and even length
cut[i] min number of cuts at i.

```cpp
    int minCut(string s) {
        int n = s.size();
        vector<int> cut(n+1, 0);  // number of cuts for the first k characters
        for (int i = 0; i <= n; i++) cut[i] = i-1; //boundary: cut it into single char.
        for (int i = 0; i < n; i++) {
            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome
                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);

            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome
                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);
        }
        return cut[n];
    }
```	
135	Candy    		28.5%	Hard	
each child need have >=1 candies
children with higher rating get more candies than their neighbors
for example [1,0,2]: 
assume we give 1 one candie, but it shall be more than its neighbors, so need get at least 2 and we get 2,1,2
since it has two neighbors, we can do it two pass, one from left to right, and one from right to left.
one direction: we need take care of the left only (or right).
```cpp
    int candy(vector<int>& ratings) {
        int ans=0;
        //at least give one candy
        //simple example gives the following approach
        //find the smallest one, and assign 1
        int n=ratings.size();
        vector<int> can(n,1);
        //from left to right
        for(int i=1;i<n;i++) if(ratings[i]>ratings[i-1]) can[i]=can[i-1]+1;
        for(int i=n-2;i>=0;i--) if(ratings[i]>ratings[i+1]) can[i]=max(can[i],can[i+1]+1);
        
        //copy(can.begin(),can.end(),ostream_iterator<int>(cout," "));cout<<endl;
        return accumulate(can.begin(),can.end(),0);
    }
```
this is a good problem. two direction problem can be solved using two separate one direction problem.
	

140	Word Break II    		27.4%	Hard	
a list of words and a string, cut it into dictionary words.
return all possible combination.
Similar question 139 Word break (check if it is breakable). 
first, using dp to find all cut positions and its previous cut. and then use dfs with backtracking
dp it is convenient to add previous index and then we have to do reverse dfs.
```cpp
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        unordered_map<int,vector<string>> mp; //end position and its possible cut string
        unordered_set<string> dict(wordDict.begin(),wordDict.end());
        vector<bool> dp(s.length()+1);
        dp[0]=1;
        if(s.size()<2)
        {
            if(dict.count(s)) return vector<string>({s});
        }
        //if(dict.count(s.substr(0,1))) mp[0].push_back(s.substr(0,1));
        for(int i=1;i<=s.size();i++)
        {
            for(int j=i-1;j>=0;j--) //check all previous cut
            {
                if(dp[j])
                {
                string t;
                t=s.substr(j,i-j);//not including j, j+1 to i both inclusive
                if(dict.count(t)) {mp[i].push_back(t);dp[i]=1;}//does not include i=0 case
                }
            }
        }
        //print(mp);
        if(mp.count(s.size())==0) return vector<string>();
        //now we can use dfs to search all possible combinations
        unordered_map<int,vector<string>> mps;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            for(int i=0;i<it->second.size();i++) 
                mps[it->first-it->second[i].size()].push_back(it->second[i]);
        }
        //print(mps);
        vector<string> ans;
        string sentence;
        dfs(mps,0,s.size(),ans,sentence);
        return ans;
    }
    void dfs(unordered_map<int,vector<string>>& mp,int start,int end,vector<string>& res,string sentence)
    {
        if(start>=end) {sentence.pop_back();res.push_back(sentence);sentence+=" ";return;}
        for(int i=0;i<mp[start].size();i++) //try all cuts
        {
            sentence+=mp[start][i]+" ";
            int sz=mp[start][i].size();
            dfs(mp,start+sz,end,res,sentence);
            //cout<<sentence<<" "<<sentence.size()<<","<<sz<<endl;
            sentence.erase(sentence.size()-sz-1);//remove the last word + space
        }
    }
```
this is too complicated, and prone to bugs. using divide and conquer is a better choice
```cpp
    unordered_map<string, vector<string>> m;

    vector<string> combine(string word, vector<string> prev){
        for(int i=0;i<prev.size();++i){
            prev[i]+=" "+word;
        }
        return prev;
    }

public:
    vector<string> wordBreak(string s, unordered_set<string>& dict) {
        if(m.count(s)) return m[s]; //take from memory
        vector<string> result;
        if(dict.count(s)){ //a whole string is a word
            result.push_back(s);
        }
        for(int i=1;i<s.size();++i){
            string word=s.substr(i);
            if(dict.count(word)){
                string rem=s.substr(0,i);
                vector<string> prev=combine(word,wordBreak(rem,dict));
                result.insert(result.end(),prev.begin(), prev.end());
            }
        }
        m[s]=result; //memorize
        return result;
    }
```

We shall always choose the most concise approach due to very limited time!!!!
since there could be a lot of repetions, so memoization is needed.

472. Concatenated words
first we need sort the words in dictionary from shorter length to longer length
since longer word can be combined using shorter words only
so we build the dictionary one by one.
each one is a problem of 139. 
```cpp
bool cmp1(const string& s1,const string& s2) {return s1.length()<s2.length();}
class Solution {
public:
    
    struct cmp
    {//note the 3 const are required!!!!
        bool operator()(const string& s1,const string& s2) const {return s1.length()<s2.length();}
    };
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        //sort the words using length
        vector<string> res;
        sort(words.begin(),words.end(),cmp1);
        //copy(words.begin(),words.end(),ostream_iterator<string>(cout," "));cout<<endl;
        unordered_set<string> dict;
        
        //multiset<string,cmp> dict(words.begin(),words.end()); //note if the length are the same it is not inserted!!!
        
        for(int i=0;i<words.size();i++)
        {
            if(canCombine(words[i],dict))
            {
                res.push_back(words[i]);
            }
            dict.insert(words[i]);
            //copy(dict.begin(),dict.end(),ostream_iterator<string>(cout," "));cout<<endl;
        }
        return res;
    }
    bool canCombine(string& word,unordered_set<string>& dict)
    {
        //set<string,cmp>::iterator it=dict.find(word);
        //auto it=dict.find(word);
        //int nelem=distance(dict.begin(),it);
        //if(nelem==0) return 0;
        if(dict.empty()) return 0;
        vector<bool> dp(word.length()+1);//dp[i]: [0...i-1] substr can be combined
        dp[0]=1;//always can form by an empty string
        for(int i=1;i<=word.length();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(!dp[j]) continue;//previous one is not a word
                string t=word.substr(j,i-j);//note substr 2nd is the length
                //cout<<j<<","<<i<<":"<<t<<" "<<dict.count(t)<<endl;
                if(dict.count(t)) {dp[i]=1;break;} //cannot search the whole set!
            }
        }
        return dp[word.length()];
        
    }
};
```

145	Binary Tree Postorder Traversal    		48.7%	Hard	
iterative. postorder: left right root sequence
using stack, we first push the root, and the right and the do the left
another approach: do it in reverse way, reverse(root, right, left)
always push left, and then right, output root
```cpp
    vector<int> postorderTraversal(TreeNode* root) {
        //left, right, node. use a stack to store 
        //stack： first node, then right, then left, pop in reverse
        stack<TreeNode*> sl;
        vector<int> s;
        if(!root) return s;
        //starting from root, push all right nodes into stack, until dead end, and then pop a left node
        //save all left nodes in another stack
        TreeNode* p=root;
        while(1)
        {
            while(p) 
            {
                s.push_back(p->val);
                if(p->left) sl.push(p->left);
                p=p->right;
            }
            if(sl.size()) //try the left, note when the node is the leaf
            {
                p=sl.top();sl.pop();
                //s.push_back(p->val);//this will push twice
            }
            else break;
        }
        reverse(s.begin(),s.end());
        return s;
        
    }
```
this is the most smartest way in this problem.
	
149	Max Points on a Line    		15.8%	Hard	
point on a line: defined by k and d. k can be defined as dy/dx
dy,dx,d dy dx shall remove the gcd
and also need keep the sign to dx

154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
contain duplicates using binary search
```cpp
	int findMin(vector<int>& nums) {
		int l=0,r=nums.size()-1;
		while(l<r)
		{
			int m=l+(r-l)/2;
			if(nums[m]<nums[r]) r=m;
			else if(nums[m]>nums[r]) l=m+1;
			else r--;//nums[m]==nums[r], this same thing cannot be the solution
		}
		return nums[l];
	}
```
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
unsorted array, given the max gap in its sorted form (neighboring)
O(N) complexity
arrange the elements into n-1 bins
each bin only save the min and max
and then loop over the bins (bucket sort)
this is often seen in matlab.
```cpp
    int maximumGap(vector<int>& nums) {
        //using bucket sort to put all these numbers into slots
        //the longest 0 
        int n=nums.size();
        if(n<2) return 0;
        int min0=*min_element(nums.begin(),nums.end());
        int max0=*max_element(nums.begin(),nums.end());
        double dx=double(max0-min0)/(n-1); //to cover all use ceil, have to use double!
        if(dx<1e-7) return 0;
        //cout<<dx<<endl;
        //in each bucket we only need to know the min/max
        pair<int,int> init=make_pair(INT_MAX,INT_MIN);
        vector<pair<int,int>> vs(n,init);
        for(int i=0;i<nums.size();i++)
        {
            int ind=(nums[i]-min0)/dx;
            vs[ind].first=min(vs[ind].first,nums[i]);
            vs[ind].second=max(vs[ind].second,nums[i]);
        }
        //for(int i=0;i<n;i++) cout<<vs[i].first<<" "<<vs[i].second<<endl;
        int maxgap=0;
        int prev=-1;
        for(int i=0;i<n;i++)
        {
            if(vs[i].first==INT_MAX) continue;
            if(prev<0) prev=i;
            else
            {
                maxgap=max(max(maxgap,vs[i].first-vs[prev].second),max(vs[prev].second-vs[prev].first,vs[i].second-vs[i].first));
                prev=i;
            }
        }
        //another case: only one group
        return maxgap;
    }
```	

174	Dungeon Game    		27.2%	Hard	
dp reverse direction
```cpp
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        //this shall be done in reverse order from bottom-right to top-left
        int m=dungeon.size(),n=dungeon[0].size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,INT_MAX));
        //add a right, bottom cell as 1 so that we can apply +1 to the min
        dp[m][n-1]=dp[m-1][n]=1;
        for(int i=m-1;i>=0;i--)
        {
            for(int j=n-1;j>=0;j--)
            {
                int t=min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];
                dp[i][j]=t<=0?1:t; //we need at least add 1 to it
            }
        }
        return dp[0][0];
        
    }
```	
212	Word Search II    		28.8%	Hard	
multiple pattern matching using trie
```cpp
struct Node
{
    Node* next[26]; //use pointer is much convenient than using array!
    bool is_leaf;
    Node(bool b=0) {fill(next,next+26,(Node*)0);is_leaf=b;}
};
class Trie {
public:
    /** Initialize your data structure here. */
    Node* root;
    Trie() {
        root=new Node();
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Node* p=root;
        for(int i=0;i<word.size();i++)        
        {
            int ind=word[i]-'a';
            if(!p->next[ind]) p->next[ind]=new Node();
            p=p->next[ind];
        }
        p->is_leaf=1;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Node* p=find(word);
        return p && p->is_leaf; //has to end with a leaf node
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Node* p=find(prefix);
        return p; //does not have to end with a leaf node
    }
    
    Node* find(string word)
    {
        Node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int ind=word[i]-'a';
            if(p->next[ind]==0) return 0;
            p=p->next[ind];
        }
        return p;
    }
    Node* get_root() {return root;}
};

class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        Trie t;
        for(int i=0;i<words.size();i++) t.insert(words[i]);
        Node* root=t.get_root();
        //use a set to store all the possible words found from the board.
        set<string> all_words;
        for(int i=0;i<board.size();i++)
        {
            for(int j=0;j<board[0].size();j++)
                findWords(board,i,j,"",all_words,root);//to save time, some paths shall be skipped if they first do not match
        }
        vector<string> ans(all_words.size());
        copy(all_words.begin(),all_words.end(),ans.begin());
        return ans;
    }
    void findWords(vector<vector<char>>& board,int x,int y,string word,set<string>& result,Node* root)
    {
        //using backtracking
        if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;
        char c=board[x][y];
        int ind=c-'a';
        if(root->next[ind])
        {
            word+=c;
            root=root->next[ind]; 
            if(root->is_leaf) result.insert(word);
            board[x][y]=' ';
            findWords(board, x+1, y, word, result, root);
            findWords(board, x-1, y,  word, result, root);
            findWords(board, x, y+1,  word, result, root);
            findWords(board, x, y-1,  word, result, root);
            board[x][y]=c;        
        }        
    }
};
```

214	Shortest Palindrome    		27.6%	Hard	
only add chars in the front.
brutal force: from right to left, we judge if it is a palindrome
```cpp
	string shortestPalindrome(string s) {
		int n=s.size();
		for(int i=n-1;i>=0;i--)
			if(ispal(s,i)) {
				string pre=s.substr(i+1);
				reverse(pre.begin(),pre.end());
				return pre+s;
			}
		return s;
	}
	bool ispal(string& s,int end)
	{
		int i=0,j=end;
		while(i<j) if(s[i++]!=s[j--]) return 0;
		return 1;
	}
```
This got TLE for a long string of a (len=40002). The time for substr and construct takes more time than expected

KMP is too sophisticated.

218	The Skyline Problem    		31.7%	Hard	
building are given as [x0,x1,h] and want to form the skyline
this is similar to intervals and output connected intervals with height
the output only needs the start point and height
approach:
- sort the intervals according to start. 
- overlap point is the max(h)
- we can use priority_queue to push pop the height
- min heap!!!
```cpp
	struct comp{
		bool operator()(vector<int>& a,vector<int>& b){
			return a[0]>b[0] || (a[0]==b[0] && a[2]>b[2]);
		}
	};
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        vector<vector<int>> ans;
		//sort(buildings.begin(),buildings.end());
		priority_queue<vector<int>,vector<vector<int>>,comp> pq(buildings.begin(),buildings.end());
		while(pq.size()){
			auto t=pq.top();
			ans.push_back({t[0],t[2]});
			while(pq.size() && pq.top()[0]==t[0]) pq.pop();
		}
		return ans;
	}
			

224	Basic Calculator    		32.8%	Hard	
only involve +-()
```cpp
    int calculate(string s) {
        //+/- has lhs and rhs, can use binary tree and post-order traversal evaluation
        //also can use stack to do this. if we meet a ( we need to get the matching ) and evaluate it first
        //recursive approach: search for () first and evaluate using stack
        stack<int> brpos;
        int ind=0,start=0;//s.find_first_of('(');
        while(ind!=string::npos) //exists ()
        {
            ind=s.find_first_of("()",start);
            if(ind!=string::npos)
            {
                char c=s[ind];
                if(c=='(') brpos.push(ind);
                if(c==')')
                {
                    int ind1=brpos.top();
                    brpos.pop();
                    string res=myeval(s.substr(ind1+1,ind-ind1-1)); //evaluate it and update the string
                    s.replace(ind1,ind-ind1+1,res); //replace the string and size will be changed
					start=ind1;
                }
				else start=ind+1;
            }
			
        }
        //eval the string directly
        string res=myeval(s); 
        return stoi(res);
    }
    
    string myeval(string s) //there is no () inside, only numbers and +/- and space
    {
        int res=0,i;
        char c;
        stringstream ss(s);
        ss>>res;
        while(!ss.eof())
        {
            c=0; //to skip space
            ss>>c;
            if(c=='+') {ss>>i;res+=i;}
            if(c=='-') {ss>>i;res-=i;}
        }
        return to_string((long long)res);
    }
```	

233	Number of Digit One    		30.2%	Hard	
math problem
number counting.
for the ith digit, makes it 1, and divide to left and right<br/>
if the ith digit >1, then (left+1)*10^i (since the right can be any digit 0 to 9)<br/>
==1: then right can be from 0 to right (right+1) and left can be 1 to left (left)*10^i.<br/>
<1, then we need borrow 1 from left, left*10^i<br/>

```cpp
    int countDigitOne(int n) {
        int ans=0;
        int left=0,right=0;
        int i=0;
        while(n)
        {
            int d=n%10;
            left=n/10;
            if(d>1) ans+=(left+1)*pow(10,i);
            else if(d==1) ans+=left*pow(10,i)+right+1;
            else ans+=left*pow(10,i);
            right+=d*pow(10,i);
            n/=10;
            i++;
        }
        return ans;
    }
```	

239	Sliding Window Maximum    		38.3%	Hard	
classical problem using deque keeping monotonic order
also works for sliding window minimum
[1,3,-1,-3,5,3,6,7]
linear time
deque: deque=1
incoming 3: remove 1, deque=3
incoming -1: 
approach:
- save index in the deque (so we have both index and value information)
- front is always the max
- max is out of window, remove the front
- incoming > back, then remove all smaller ones 
- add incoming into back.

```cpp
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        //monotonic array using deque
        vector<int> res;
        deque<int> dq;
        for(int i=0;i<nums.size();i++)
        {
            if(!dq.empty() && dq.front()==i-k) dq.pop_front();
            while(!dq.empty() && nums[dq.back()]<nums[i]) dq.pop_back(); //remove all elements less than it
            dq.push_back(i);
            if(i>=k-1) res.push_back(nums[dq.front()]);
        }
        return res;
    }
```	


248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
english: every thousand changes
```cpp
    string s1[]={"One", "Two", "Three", "Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"};
    string s2[]={"Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
class Solution {
public:
    string numberToWords(int num) {
        //1,10,100,1000,10^6,10^9
        if(!num) return string("Zero");
        int billion,million,thousand,hundred,twenty;
        billion=num/1000000000;
        num-=billion*1000000000;
        million=num/1000000;
        num-=million*1000000;
        thousand=num/1000;
        num-=thousand*1000;
        //now we need convert all numbers into <100
        string res;
        if(billion) res+=int2words(billion)+"Billion ";
        if(million) res+=int2words(million)+"Million ";
        if(thousand) res+=int2words(thousand)+"Thousand ";
        if(num) res+=int2words(num);
        //remove the last space
        res.pop_back();
        return res;
        
    }
    
    string int2words(int num) //number is <999
    {
        int hundred=num/100;
        num-=hundred*100;
        int ten=num/10;
        num-=ten*10;
        int one=num;
        string s;
        if(hundred) s+=s1[hundred-1]+" Hundred ";
        if(ten>1) 
        {
            s+=s2[ten-2]+" ";
            if(one) s+=s1[one-1]+" ";
            
        }
        else
        {
            if(ten*10+one>0) s+=s1[ten*10+one-1]+" ";
        }
        return s;
    }
};
```

282	Expression Add Operators    		32.8%	Hard	
given a string of digits, apply +-* to get the target
divide and conquer, combined with backtracking
- loop all positions and divide left and right part. left as a number, and right as a subproblem
- apply +-* between left and right
- righ subproblem
- perform evaluation current value, previous op value, previous operator

```cpp
    vector<string> addOperators(string num, int target) {
        vector<string> res;
        if (num.empty()) return res;
        for (int i=1; i<=num.size(); i++) 
        {
            string s = num.substr(0, i);
            long cur = stol(s);
            if (to_string(cur).size() != s.size()) continue;//leading zeros
            dfs(res, num, target, s, i, cur, cur, '#');         // no operator defined.
        }

        return res;
    }

    // cur: {string} expression generated so far.
    // pos: {int}    current visiting position of num.
    // cv:  {long}   cumulative value so far.
    // pv:  {long}   previous operand value.
    // op:  {char}   previous operator used.
    void dfs(std::vector<string>& res, const string& num, int target, 
	string cur, int pos, long cv, long pv, char op) {
        if (pos == num.size() && cv == target) {res.push_back(cur);} 
        else 
        {
            for (int i=pos+1; i<=num.size(); i++) 
            {
                string t = num.substr(pos, i-pos);
                long now = stol(t);
                if (to_string(now).size() != t.size()) continue;
                dfs(res, num, target, cur+'+'+t, i, cv+now, now, '+');
                dfs(res, num, target, cur+'-'+t, i, cv-now, now, '-');
                dfs(res, num, target, cur+'*'+t, i, (op=='-')?cv+pv-pv*now:((op=='+')?cv-pv+pv*now : pv*now), pv*now, op);
            }
        }
    }    
```	


291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard
left: a max heap
right: a min heap
median: odd:, even: the two heap's average
when a a new data coming, check even /odd
either put left side, or right side.

```cpp
    priority_queue<int,vector<int>,less<int>> left;
    priority_queue<int,vector<int>,greater<int>> right;
    double med;
    int total;
    MedianFinder() {
        total=0;
    }
    
    void addNum(int num) {
        total++;
        if(total==1) {med=num;return;}
        
        if(total%2)//total is odd, one element is in and one element is out
        {
            if(num<left.top()) {left.push(num);med=left.top();left.pop();}
            else if(num>right.top()) {right.push(num);med=right.top();right.pop();}
            else med=num;//lmax<=num<=lmin
        }
        else //total is even, the new num and med shall be inside left or right
        {
            if(num<med) {left.push(num);right.push(med);}
            else {left.push(med);right.push(num);}
            med=(left.top()+right.top())/2.0;
        }
    }
    
    double findMedian() {
        return med;
    }
	```
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
using stringstream
```cpp
    string serialize(TreeNode* root) {
        ostringstream os;
        serialize(root,os);
        return os.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return deserialize(is);
    }
    
    void serialize(TreeNode* root, ostringstream& os)
    {
        if(root)
        {
            os<<root->val<<" ";
            serialize(root->left,os);
            serialize(root->right,os);
        }
        else os<<"# ";
    }
    TreeNode* deserialize(istringstream& is)
    {
        string s;
        is>>s;
        if(s=="#") return 0;
        TreeNode* p=new TreeNode(stoi(s));
        p->left=deserialize(is);
        p->right=deserialize(is);
        return p;
    }
```	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
merge the data into intervals
- sort the intervals according to start in a set
- when add a val, check if it overlaps with an interval, if yes, merge it.
for a single value it covers [val, val+1)
```cpp
    struct Cmp{
        bool operator()(Interval a, Interval b){ return a.start < b.start; }
    };
    set<Interval, Cmp> st;

    void addNum(int val) {
        auto it = st.lower_bound(Interval(val, val));
        int start = val, end = val;
        if(it != st.begin() && (--it)->end+1 < val) it++;
        while(it != st.end() && val+1 >= it->start && val-1 <= it->end)
        {
            start = min(start, it->start);
            end = max(end, it->end);
            it = st.erase(it);
        }
        st.insert(it,Interval(start, end));
    }
    
    vector<Interval> getIntervals() {
        vector<Interval> result;
        for(auto val: st) result.push_back(val);
        return result;
    }
```	


354	Russian Doll Envelopes    		34.0%	Hard	
(w,h), return the max number of envelopes you can russina doll.
only fit in if w and h > the other to be fitted.
a binary search or dp problem.
binary search: get the last true position
dp: if i can fit in j then dp[i]=dp[j]+1
same as the longest increasing subsequence problem.
```cpp
bool cmp(pair<int,int>& a,pair<int,int>& b) {return a.first<b.first || (a.first==b.first && a.second<b.second);}
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        //unordered_map<int,vector<int>> mp;
        sort(envelopes.begin(),envelopes.end(),cmp);
        //using dp
        vector<int> dp(envelopes.size(),1); //dp is the maximum length to i
        int gmax=0;
        for(int i=0;i<envelopes.size();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(canfit(envelopes[j],envelopes[i])) dp[i]=max(dp[j]+1,dp[i]);
            }
            gmax=max(gmax,dp[i]); //the global max
        }
        return gmax;
        //merge them! choose the one with max depth! longest increasing path this needs dp!
    }
    bool canfit(pair<int,int>& a,pair<int,int>& b) {return a.first<b.first && a.second<b.second;}
};
```

358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
the rectangle top left (x0,y0), bottom right (x1,y1)
S(x0,y0,x1,y1)=S4
S(x0,y0)=S1
S(x1,y0)=S1+S2
S(x0,y1)=S1+S3
S(x1,y1)=S1+S2+S3+S4
S4=S(x1,y1)-(S1+S2+S3)=S(x1,y1)-(S1+S2+S1+S3-S1)=S(x1,y1)+S(x0,y0)-S(x1,y0)-S(x0,y1)
for x1,y1 (n^2 choices) x0,y0 can be chosen from 0-x1, 0-y1, that is x1y1
if we brutal force, it will be O(N^4)

find the largest sum of subarray in a 1D array <=K
prefix sum. and we iterate from left to right, put the prefix sum in a set.
for each prefix, we can use upper_bound to find the target cum[j]-k.
O(nlogn)

/* first  consider the situation matrix is 1D
    we can save every sum of 0~i(0<=i<len) and binary search previous sum to find 
    possible result for every index, time complexity is O(NlogN).
    so in 2D matrix, we can sum up all values from row i to row j and create a 1D array 
    to use 1D array solution.
    If col number is less than row number, we can sum up all values from col i to col j 
    then use 1D array solution.
*/
public int maxSumSubmatrix(int[][] matrix, int target) {
    int row = matrix.length;
    if(row==0)return 0;
    int col = matrix[0].length;
    int m = Math.min(row,col);
    int n = Math.max(row,col);
    //indicating sum up in every row or every column
    boolean colIsBig = col>row;
    int res = Integer.MIN_VALUE;
    for(int i = 0;i<m;i++){
        int[] array = new int[n];
        // sum from row j to row i
        for(int j = i;j>=0;j--){
            int val = 0;
            TreeSet<Integer> set = new TreeSet<Integer>();
            set.add(0);
            //traverse every column/row and sum up
            for(int k = 0;k<n;k++){
                array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);
                val = val + array[k];
                //use  TreeMap to binary search previous sum to get possible result 
                Integer subres = set.ceiling(val-target);
                if(null!=subres){
                    res=Math.max(res,val-subres);
                }
                set.add(val);
            }
        }
    }
    return res;
}

381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
insert, remove, getrandom, duplicate allowed.
insert/remove for list with iterator is O(1)
- need some storage to store the data
- need some index or iterator mechanism to access the element in O(1)

Like in the previous problem, Insert Delete GetRandom O(1), the solution is to maintain a vector with all elements to get the random number in O(1).
With duplicates allowed, instead of just one index, we now need to store indexes of all elements of the same value in our vector. The remove method becomes a bit more complicated therefore, as we need to:

Remove any index of the element being removed
Swap the last element in the vector with the element being removed (same as in the previous problem)
Remove old and add new index for the swapped (last) element
```cpp
  vector<int> v;
  unordered_map<int, unordered_set<int>> m;
  bool insert(int val) {
    v.push_back(val);
    m[val].insert(v.size() - 1);
    return m[val].size() == 1;
  }
  bool remove(int val) {
    auto it = m.find(val);
    if (it != end(m)) {
      auto free_pos = *it->second.begin();
      it->second.erase(it->second.begin());
      v[free_pos] = v.back();
      m[v.back()].insert(free_pos);
      m[v.back()].erase(v.size() - 1);
      v.pop_back();
      if (it->second.size() == 0) m.erase(it);
      return true;
    }
    return false;
  }
  int getRandom() { return v[rand() % v.size()]; }
```  
  
391	Perfect Rectangle    		28.2%	Hard	
N rectangle, if forms an exact cover of a rectangle region
could have overlaps.
- sum of all rect area = final rect area (xmin,ymin), (xmax,ymax)
- area the same is not sufficient we can easily move a rect to other place and have an overlap.
inner side points shall be even
four side corner shall be once (no overlap)
```cpp
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        //first find the 4 points of the outer rect
        //second the area shall equal to the sum of all small rectangle
        //third the outer rect shall be the points of those sub rect (only appears once)
        //4th all inner side points must appear even times
        unordered_map<string,int> mp;
        int x0,y0,x1,y1;
        x0=y0=INT_MAX,x1=y1=INT_MIN;
        string s;
        int total_area=0;
        for(int i=0;i<rectangles.size();i++)
        {
            x0=min(x0,rectangles[i][0]);
            y0=min(y0,rectangles[i][1]);
            x1=max(x1,rectangles[i][2]);
            y1=max(y1,rectangles[i][3]);
            total_area+=(rectangles[i][0]-rectangles[i][2])*(rectangles[i][1]-rectangles[i][3]);
            s=to_string(rectangles[i][0])+":"+to_string(rectangles[i][1]);mp[s]++;
            s=to_string(rectangles[i][2])+":"+to_string(rectangles[i][3]);mp[s]++;
            s=to_string(rectangles[i][2])+":"+to_string(rectangles[i][1]);mp[s]++;
            s=to_string(rectangles[i][0])+":"+to_string(rectangles[i][3]);mp[s]++;
        }
        int area=(x0-x1)*(y0-y1);
        s=to_string(x0)+":"+to_string(y0);if(mp[s]!=1) return 0;else mp.erase(s);
        s=to_string(x1)+":"+to_string(y1);if(mp[s]!=1) return 0;else mp.erase(s);
        s=to_string(x1)+":"+to_string(y0);if(mp[s]!=1) return 0;else mp.erase(s);
        s=to_string(x0)+":"+to_string(y1);if(mp[s]!=1) return 0;else mp.erase(s);
        for(auto it=mp.begin();it!=mp.end();it++) if(it->second%2) return 0;
        return area==total_area;
    }
```
	


403	Frog Jump    		36.2%	Hard	
stones are located at different positions. frog is on the first stone, first step is 1
if last jump step is k, current step is k, K+1 or K-1. only forward jump
return if frog can jump to the last stone
approach: recursive, or dfs
- stones into a hashset
- which step can go to next stone, try it

```cpp
    bool canCross(vector<int>& stones) {
        if(stones.size()<2) return 1;
        if(stones[1]!=1) return 0;
        if(stones.size()==2) return 1;
        for(int i=1;i<stones.size();i++)
            if(stones[i] - stones[i-1] > i) return 0; //key point !!
        unordered_set<int> hs(stones.begin(),stones.end());
        return canReach(hs,1,1,stones.back());
    }
    
    bool canReach(unordered_set<int>& hs,int pos,int jmp,int last)
    {
        if(pos+jmp==last || pos+jmp-1==last || pos+jmp+1==last) return 1;
        if(hs.count(pos+jmp+1))
            if(canReach(hs,pos+jmp+1,jmp+1,last)) return 1;
        
        if(hs.count(pos+jmp))
            if(canReach(hs,pos+jmp,jmp,last)) return 1;
        
        if(jmp-1>0 && hs.count(pos+jmp-1))
            if(canReach(hs,pos+jmp-1,jmp-1,last)) return 1;
        
        return 0;
    }
```	

407	Trapping Rain Water II    		39.3%	Hard
now 2d cell. 
Imagine the pool is surrounded by many bars. The water can only go out from the lowest bar. So we always start from the lowest boundary and keep pushing the bar from boundary towards inside. It works as if we are replacing the old bars with a bar higher than it.
See the following simple example:
4 4 4 4
4 0 1 2
4 4 4 4
it looks like we push the bar of 2 towards left and record the difference. Then you can use the same procedure with the following figure
4 4 4 4
4 0 2 2
4 4 4 4
compute the volume of water held.
```cpp
    int trapRainWater(vector<vector<int>>& heightMap) {
        typedef pair<int,int> cell; //height + 1d index
        priority_queue<cell, vector<cell>, greater<cell>> q; //minheap
        int m = heightMap.size();
        if (m == 0) return 0;
        int n = heightMap[0].size();
        vector<int> visited(m*n, 0);
        
        //the 4 boundaries
        for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) 
        {
            if (i == 0 || i == m-1 || j == 0  || j == n-1) 
            {
                if (!visited[i*n+j]) q.push(cell(heightMap[i][j], i*n+j));
                visited[i*n+j] = 1;
            }
        }
        
        int dir[4][2] = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};
        int ans = 0;
        while(!q.empty()) 
        {
            cell c = q.top();q.pop();
            int i = c.second/n, j = c.second%n;
            
            for (int r = 0; r < 4; ++r) 
            {
                int ii = i+dir[r][0], jj = j+dir[r][1];
                if (ii < 0 || ii >= m || jj < 0 || jj >= n || visited[ii*n+jj]) continue;
                ans += max(0, c.first - heightMap[ii][jj]);
                q.push(cell(max(c.first, heightMap[ii][jj]), ii*n+jj));
                visited[ii*n+jj] = true;
            }
        }
        return ans;
    }
```
410	Split Array Largest Sum    		42.4%	Hard	
Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
typical binary search problem
```cpp
    int splitArray(vector<int>& nums, int m) {
        //the sum is between the max and the sum of all elements
        //use the mid value to split and use the greedy algorithm to form split arrays
        //if more than m can be obtained, the mid value is smaller, 
        //if less than m can be obtained, the mid value is larger
        
        int lbound=*max_element(nums.begin(),nums.end());
        int ubound=accumulate(nums.begin(),nums.end(),0);
        if(m<=1) return ubound;
        if(m>=nums.size()) return lbound;
        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];//accumulate sum, and they are sorted
        //copy(nums.begin(),nums.end(),ostream_iterator<int>(cout," "));cout<<endl;
        int mid,maxsum;
        int numseg=0;
        while(lbound<=ubound)
        {
            //cout<<mid<<endl;
            mid=(lbound+ubound)/2;
            numseg=calcNumSeg(nums,mid,maxsum);
            //cout<<mid<<" "<<numseg<<endl;
            if(numseg>m) {lbound=mid+1;}
            else {ubound=mid-1;}
        }
        return lbound;//maxsum;
    }
    int calcNumSeg(vector<int>& nums,int midval,int& maxsum)
    {
        int cnt=0,i=0,prevsum=0;
        maxsum=0;
        while(i<nums.size())
        {
            int ind=int(upper_bound(nums.begin()+i,nums.end(),midval+prevsum)-nums.begin());
            if(ind!=nums.size()) 
            {
                /*if(nums[ind]==midval+prevsum) {maxsum=max(maxsum,nums[ind]-prevsum);i=ind+1;prevsum=nums[ind];}
                else */{maxsum=max(maxsum,nums[ind-1]-prevsum);i=ind;prevsum=nums[ind-1];}
            }
            else {maxsum=max(maxsum,nums[ind-1]-prevsum);i=ind;}
            cnt++;
        }
        return cnt;
    }
```
	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
A password is considered strong if below conditions are all met:

It has at least 6 characters and at most 20 characters.
It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.
It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).
Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.

Insertion, deletion or replace of any one character are all considered as one change.

approach:
length check: delete or add some chars
upper/lower/digit check: need to replace
repeating: need to add/remove/replace
greedy: each move shall fix most problems

The basic principle is straightforward: if we want to make MINIMUM changes to turn s into a strong password, each change made should fix as many problems as possible.

So to start, let's first identify all the problems in the input string s and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the type of operation it takes and the position in the string where the operation is applied (Note: Ideally we should also include the characters involved in the operation and the "power" of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate).

Length problem: if the total length is less than 6, the change that should be made is (insert, any position), which reads as "the operation is insertion and it can be applied to anywhere in the string". If the total length is greater than 20, then the change should be (delete, any position).

Missing letter or digit: if any of the lowercase/uppercase letters or digits is missing, we can do either (insert, any position) or (replace, any position) to correct it. (Note here the characters for insertion or replacement can only be those missing.)

Repeating characters: for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix "aaaaa", we can do one replacement (replace the middle 'a') or two insertions (one after the second 'a' and one after the fourth 'a') or three deletions (delete any of the three 'a's). So the possible changes are (replace, repeating characters), (insert, repeating characters), (delete, repeating characters). (Note however the "power" of each operation for fixing the problem are different -- replacement is the strongest while deletion is the weakest.)

All right, what's next? If we want a change to eliminate as many problems as it can, it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem.

Since there are most (three) changes allowed for the third problem, we may start from combinations first problem & third problem and second problem & third problem. It's not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination first problem & second problem, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20.

From the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long.

For the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (insert, any position). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one.

For the latter case, there is overlapping between the first & third and second & third problems, so those overlapping changes will be taken, i.e., first problem => (delete, any position), second problem => (replace, any position). The reason not to use (insert, any position) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one?

Now the "power" of each operation for eliminating problems comes into play. For the third problem, the "power" of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most 5 repeating characters while insertion and deletion can do at most 4 and 3, respectively. In this case, we say replacement has more "power" than insertion or deletion. Intuitively the more "powerful" the operation is, the less number of changes is needed for correcting the problem. Therefore (replace, repeating characters) triumphs in terms of fixing the third problem.

Furthermore, another very interesting point shows up when the "power" of operation is taken into consideration (And thank yicui for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (replace, any position), we have no problem adapting it so that it coincides with the optimal change (replace, repeating characters) made for the third problem. However, there is no way to do the same for the first problem with change (delete, any position). We have a conflict now!

How do we reconcile it? The trick is that for a sequence of repeating characters of length k (k >= 3), instead of turning it all the way into a sequence of length 2 (so as to fix the repeating character problem) by the change (delete, any position), we will first reduce its length to (3m + 2), where (3m + 2) is the largest integer of the form yet no more than k. That is to say, if k is a multiple of 3, we apply once such change so its length will become (k - 1); else if k is a multiple of 3 plus 1, we apply twice such change to cut its length down to (k - 2), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: 2 or the remaining available changes). The reason is that the optimal change (replace, repeating characters) for the third problem will be most "powerful" when the total length of the repeating characters is of this form. Of course, if we still have more changes (delete, any position) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length 2.

Here is the java program based on the above analyses. Both time and space complexity is O(n). Not sure if we can reduce the space down to O(1) by computing the arr array on the fly. A quick explanation is given at the end.

public int strongPasswordChecker(String s) {
    int res = 0, a = 1, A = 1, d = 1;
    char[] carr = s.toCharArray();
    int[] arr = new int[carr.length];
        
    for (int i = 0; i < arr.length;) {
        if (Character.isLowerCase(carr[i])) a = 0;
        if (Character.isUpperCase(carr[i])) A = 0;
        if (Character.isDigit(carr[i])) d = 0;
            
        int j = i;
        while (i < carr.length && carr[i] == carr[j]) i++;
        arr[j] = i - j;
    }
        
    int total_missing = (a + A + d);

    if (arr.length < 6) {
        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));
            
    } else {
        int over_len = Math.max(arr.length - 20, 0), left_over = 0;
        res += over_len;
            
        for (int k = 1; k < 3; k++) {
            for (int i = 0; i < arr.length && over_len > 0; i++) {
                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;
                arr[i] -= Math.min(over_len, k);
                over_len -= k;
            }
        }
            
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= 3 && over_len > 0) {
                int need = arr[i] - 2;
                arr[i] -= over_len;
                over_len -= need;
            }
                
            if (arr[i] >= 3) left_over += arr[i] / 3;
        }
            
        res += Math.max(total_missing, left_over);
    }
        
    return res;
}
A quick explanation of the program:

res denotes the minimum changes; a, A and d are the number of missing lowercase letters, uppercase letters and digits, respectively; arr is an integer array whose element will be the number of repeating characters starting at the corresponding position in the string.

In the following loop we fill in the values for a, A, d and arr to identify the problems for each condition. The total number of missing characters total_missing will be the summation of a, A, d and fixing this problem takes at least total_missing changes.

We then distinguish the two cases when the string is too short or too long. If it is too short, we pad its length to at least 6 (note in this case we've already inserted total_missing characters so the new length is the summation of the original length and total_missing).

Otherwise, to fix the first condition, we need to delete over_len (number of surplus characters) characters. Since fixing the first problem also corrects the third one, we need to get rid of those parts from the arr array. And as I mentioned, we need to first turn all numbers in the arr array greater than 2 into the form of (3m + 2) and then reduce them all the way to 2 if over_len is still greater than 0. After that, we need to replace total_missing characters to fix the second problem, which also fixes part (or all) of the third problem. Therefore we only need to take the larger number of changes needed for fixing the second problem (which is total_missing) and for the third one (which is left_over, since it is the number of changes still needed after fixing the first problem).

425	Word Squares    		44.4%	Hard	

428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
inc(key) inc the key
dec(key) dec the key
getmaxkey()
getminkey()

approach:
store the relation as a matrix:
each row: the same value with a list of key strings.
first row: the max value
last row: the min value

getmin/max: just return the first key of the first/last row
iterator: to ensure O(1) access to any nodes in the matrix
inc: move to higher layer or create a new layer
dec: move to lower layer or create a new layer

```cpp
    struct Row 
    {
        list<string> strs;
        int val;
        Row(const string &s, int x) : strs({s}), val(x) {}
    };

    unordered_map<string, pair<list<Row>::iterator, list<string>::iterator>> strmap;//key to its index or iterators
    list<Row> matrix;

    /** Initialize your data structure here. */
    AllOne() {
        
    }
    
    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */
    void inc(string key) {
        if (strmap.count(key) == 0) 
        {
            if (matrix.empty() || matrix.back().val != 1) //does not have the row with value 1
            {
                auto newrow = matrix.emplace(matrix.end(), key, 1); //construct a new row
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
            else //has the row with value 1
            {
                auto newrow = --matrix.end();
                newrow->strs.push_front(key);
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
        }
        else  //key exists
        {
            auto row = strmap[key].first;
            auto col = strmap[key].second;
            auto lastrow = row;
            --lastrow;//need bring this node up a layer
            if (lastrow == matrix.end() || lastrow->val != row->val + 1) 
            {
                auto newrow = matrix.emplace(row, key, row->val + 1);//add a new row
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
            else //exist the new row
            {
                auto newrow = lastrow;
                newrow->strs.push_front(key);
                strmap[key] = make_pair(newrow, newrow->strs.begin());
            }
            row->strs.erase(col);//remove the node
            if (row->strs.empty()) matrix.erase(row); //remove the row
        }
    }
    
    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */
    void dec(string key) {
        if (strmap.count(key) ==0) return;
        auto row = strmap[key].first;
        auto col = strmap[key].second;
        if (row->val == 1) 
        {
            row->strs.erase(col);
            if (row->strs.empty()) matrix.erase(row);
            strmap.erase(key);
            return;
        }
        auto nextrow = row;
        ++nextrow;
        if (nextrow == matrix.end() || nextrow->val != row->val - 1) 
        {
            auto newrow = matrix.emplace(nextrow, key, row->val - 1);
            strmap[key] = make_pair(newrow, newrow->strs.begin());
        }
        else 
        {
            auto newrow = nextrow;
            newrow->strs.push_front(key);
            strmap[key] = make_pair(newrow, newrow->strs.begin());
        }
        row->strs.erase(col);
        if (row->strs.empty()) matrix.erase(row);
    }
    
    /** Returns one of the keys with maximal value. */
    string getMaxKey() {
        return matrix.empty() ?  "" : matrix.front().strs.front();
    }
    
    /** Returns one of the keys with Minimal value. */
    string getMinKey() {
        return matrix.empty() ?  "" : matrix.back().strs.front();
    }
```


440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
compare using string
since k and n could be very large, using sort would be overwhelming.
can just fill until k.
Actually this is a denary tree (each node has 10 children). Find the kth element is to do a k steps preorder traverse of the tree.
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don't really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.

```java
public int findKthNumber(int n, int k) {
    int curr = 1;
    k = k - 1;
    while (k > 0) {
        int steps = calSteps(n, curr, curr + 1);
        if (steps <= k) {
            curr += 1;
            k -= steps;
        } else {
            curr *= 10;
            k -= 1;
        }
    }
    return curr;
}
//use long in case of overflow
public int calSteps(int n, long n1, long n2) {
    int steps = 0;
    while (n1 <= n) {
        steps += Math.min(n + 1, n2) - n1;
        n1 *= 10;
        n2 *= 10;
    }
    return steps;
}
```

446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
return the number of arithmetic subsequence slices in the array
dp: when diff=A[i]-A[j] dp[i][diff]++

```cpp
    int numberOfArithmeticSlices(vector<int>& A) {
        //difference as the key
        vector<unordered_map<int,int>> dp(A.size());//difference vs length
        int res=0;
        for(int i=1;i<A.size();i++) 
        {
            for(int j=i-1;j>=0;j--) //try all previous one and build current map
            {
                if((long)A[i] - (long)A[j] > INT_MAX || (long)A[i] - (long)A[j] < INT_MIN) continue;
                int diff=A[i]-A[j];//diff is key for a(i,j)
                dp[i][diff]++;
                if(dp[j].count(diff)) {dp[i][diff]+=dp[j][diff];res+=dp[j][diff];}
            }
        }
        //print(mp);
        return res;
    }
```	
458	Poor Pigs    		45.4%	Hard	
there are 1000 buckets, only one of them is poisonous. 
if drink the poison, it dies within 15 mins
to figure out which one is poisonous, what is the min number of pigs to be used in our hour.
a pig can drink as many simultaneously.

greedy solution:

With 2 pigs, poison killing in 15 minutes, and having 60 minutes, we can find the poison in up to 25 buckets in the following way. Arrange the buckets in a 5×5 square:

 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
Now use one pig to find the row (make it drink from buckets 1, 2, 3, 4, 5, wait 15 minutes, make it drink from buckets 6, 7, 8, 9, 10, wait 15 minutes, etc). Use the second pig to find the column (make it drink 1, 6, 11, 16, 21, then 2, 7, 12, 17, 22, etc).

Having 60 minutes and tests taking 15 minutes means we can run four tests. If the row pig dies in the third test, the poison is in the third row. If the column pig doesn't die at all, the poison is in the fifth column (this is why we can cover five rows/columns even though we can only run four tests).

With 3 pigs, we can similarly use a 5×5×5 cube instead of a 5×5 square and again use one pig to determine the coordinate of one dimension (one pig drinks layers from top to bottom, one drinks layers from left to right, one drinks layers from front to back). So 3 pigs can solve up to 125 buckets.

In general, we can solve up to (⌊minutesToTest / minutesToDie⌋ + 1)pigs buckets this way, so just find the smallest sufficient number of pigs for example like this:

def poorPigs(self, buckets, minutesToDie, minutesToTest):
    pigs = 0
    while (minutesToTest / minutesToDie + 1) ** pigs < buckets:
        pigs += 1
    return pigs


460	LFU Cache    		28.9%	Hard	
least frequently used cache.
list- to easy move, insert, remove.
iterator- to easy locate nodes
hashmap- key to iterator
one hashmap key to find the value and frequency
one hashmap key to find the list iterator
one hashmap freq vs the list of nodes

we are basically building a matrix:
each row is a list with same frequency


```cpp
class LFUCache {
    int cap;
    int size;
    int minFreq;
    unordered_map<int, pair<int, int>> m; //key to {value,freq};
    unordered_map<int, list<int>::iterator> mIter; //key to list iterator;
    unordered_map<int, list<int>>  fm;  //freq to key list;
public:
    LFUCache(int capacity) {
        cap=capacity;
        size=0;
    }
    
    int get(int key) {
        if(m.count(key)==0) return -1;
        
        fm[m[key].second].erase(mIter[key]);
        m[key].second++;
        fm[m[key].second].push_back(key);
        mIter[key]=--fm[m[key].second].end();
        
        if(fm[minFreq].size()==0 ) 
              minFreq++;
        
        return m[key].first;
    }
    
   void put(int key, int value) {
        if(cap<=0) return;
        
        int storedValue=get(key);
        if(storedValue!=-1)
        {
            m[key].first=value;
            return;
        }
        
        if(size>=cap )
        {
            m.erase( fm[minFreq].front() );
            mIter.erase( fm[minFreq].front() );
            fm[minFreq].pop_front();
            size--;
        }
        
        m[key]={value, 1};
        fm[1].push_back(key);
        mIter[key]=--fm[1].end();
        minFreq=1;
        size++;
    }
};
```

465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
S=[s,n] repeat s with n times
S1=[s1,n1]
S2=[s2,n2]
find the max M so that [S2,M] is a subsequence of S1

It's easy to come up with a brute force solution and to find that there will be a repetitive pattern when matching S2 through S1. The only problem is how to use the repetitive pattern to save computation.

Fact:
If s2 repeats in S1 R times, then S2 must repeats in S1 R / n2 times.
Conclusion:
We can simply count the repetition of s2 and then divide the count by n2.

How to denote repetition:
We need to scan s1 n1 times. Denote each scanning of s1 as an s1 segment.
After each scanning of i-th s1 segment, we will have

The accumulative count of s2 repeated in this s1 segment.
A nextIndex that s2[nextIndex] is the first letter you'll be looking for in the next s1 segment.
Suppose s1="abc", s2="bac", nextIndex will be 1; s1="abca", s2="bac", nextIndex will be 2

It is the nextIndex that is the denotation of the repetitive pattern.

```cpp
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        unordered_map<int, pair<int, int>> r;
        int k = 0;
        for(int i = 0; i < s1.length()*n1;) 
        {
            int rr = i % s1.length();
            if(r.find(rr) == r.end()) //record the position in the string
            {
                r[rr] = make_pair(i, k);
            }
            else //already recorded
            {
                // cout << rr << ',' << i << ',' << k << endl;
                auto i0 = r[rr].first;
                auto k0 = r[rr].second; // now, i - i0 == (k - k0) * s2.length()
                
                int n = (s1.length()*n1 - i0) / (i - i0); // we have n*(k - k0) complete s2 left
                
                // skip repeated patterns
                i = i0 + n*(i - i0);
                k = k0 + n*(k - k0);
            }
            
            //two pointer to find the matched string
            int j;
            for(j = 0; i < s1.length()*n1 && j < s2.length(); ++ i, ++ j) 
            {
                while(i < s1.length()*n1 && s1[i%s1.length()] != s2[j]) ++ i;
            }
            
            if(i >= s1.length()*n1) //in case it just matches
            {
                if(j>=s2.length()) k++;
                break;
            }
            ++ k;
        }
        
        // cout << k << endl;
        return k / n2;
    }
    
    inline string repeat(string &s, int n) {
        string S;
        S.reserve(s.size()*n);
        while(n -- > 0) {
            S += s;
        }
        return S;
    }
```
	
471	Encode String with Shortest Length    		45.2%	Hard	

479	Largest Palindrome Product    		27.4%	Hard	
```cpp
    int largestPalindrome(int n) {
        if (n == 1) return 9;
        int upper = pow(10, n) - 1;
        int lower = pow(10, n-1);
        for (int i = upper; i >= lower; i--) {
            long cand = buildPalindrome(i);
            for (long j = upper; j*j >= cand; j--) {
                if (cand % j == 0 && cand / j <= upper) {
                    return cand % 1337;
                }
            }
        }
        return -1;
    }
    
    long buildPalindrome(int n) {
        string s = to_string(n);
        reverse(s.begin(), s.end());
        return stol(to_string(n) + s);
    }
```
	
480	Sliding Window Median    		32.6%	Hard	
we have done sliding window max/min using deque
now is the median
we can use two pq, one for the max, one for the min?
this is similar to the median in a data stream.

```cpp
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        vector<double> medians;
        unordered_map<int, int> hash;                          // count numbers to be deleted
        priority_queue<int, vector<int>> left;                // heap on the bottom
        priority_queue<int, vector<int>, greater<int>> right;  // heap on the top
        
        int i = 0;
        
        // Initialize the heaps
        while (i < k)  { left.push(nums[i++]); }
        for (int count = k/2; count > 0; --count) {
            right.push(left.top()); left.pop();
        }
        
        while (true) {
            // Get median
            if (k % 2) medians.push_back(left.top());
            else medians.push_back( ((double)left.top() + right.top()) / 2 );
            
            if (i == nums.size()) break;
            int m = nums[i-k], n = nums[i++], balance = 0;
            
            // What happens to the number m that is moving out of the window
            if (m <= left.top())  { --balance;  if (m == left.top()) left.pop(); else ++hash[m]; }
            else                   { ++balance;  if (m == right.top()) right.pop(); else ++hash[m]; }
            
            // Insert the new number n that enters the window
            if (!left.empty() && n <= left.top())  { ++balance; left.push(n); }
            else                                     { --balance; right.push(n); }
            
            // Rebalance the bottom and top heaps
            if      (balance < 0)  { left.push(right.top()); right.pop(); }
            else if (balance > 0)  { right.push(left.top()); left.pop(); }
            
            // Remove numbers that should be discarded at the top of the two heaps
            while (!left.empty() && hash[left.top()])  { --hash[left.top()]; left.pop(); }
            while (!right.empty() && hash[right.top()])  { --hash[right.top()]; right.pop(); }
        }
        
        return medians;
    }
```	
483	Smallest Good Base    		34.2%	Hard	
binary search
or brutal force search

```cpp
    string smallestGoodBase(string n) {
       //approach n=sum(k^i) =(k^(m+1)-1)/(k-1), k<n^(1/m)<k+1
       //so only need to consider n^(1/m) m from 2 to log2(n)
        long long nn=stoll(n);
        int max_m=log2(nn);
        //cout<<nn<<":"<<max_m;
        for(int m=max_m;m>1;m--)
        {
            int k=pow(nn,1.0/m);
            //long long t=(mypow(k,m+1)-1)/(k-1); //will overflow!
            if((nn-1)%k) continue;
            else
            {
                long long t=(mypow(k,m)-1)/(k-1); //will overflow!
                //cout<<m<<" "<<k<<" "<<t<<endl;
                if((nn-1)/k==t) return to_string(k);//note power cannot be used since it does not have the precision
            }
        }
        return to_string(nn-1);
    }
    
    long long mypow(int k,int m)
    {
        long long res=1;
        for(int i=0;i<m;i++) res*=k;
        return res;
    }
```	
488	Zuma Game    		39.0%	Hard	
this is very similar to the posted google phone interview to remove 3 or more identical numbers
balls have 5 different colors, there are some balls on the table and some tables in hand.
find the min number balls to insert to remove all balls on the table.

dfs/bfs/dp
dfs approach:
- convert balls in hand as hashmap
- dfs: find all possible ways to empty the table and get the min
- dfs backtracking: 
```cpp
    int minStep;
    int findMinStep(string board, string hand) {
        unordered_map<char,int> mp;
        for (auto c:hand) mp[c]++;
    
        minStep=INT_MAX;
        dfs(board, mp, 0);
        return minStep==INT_MAX?-1:minStep;
    }
    void dfs(string& board, unordered_map<char,int>& mp, int used) {
        if (board.empty()) {
            minStep=min(minStep, used);
            return;
        }
        
        for (int i=0; i<board.size();) {
            int j=i;
            char c=board[i];
            while (j<board.size() && board[j]==c) j++;
            if (j-i<3) {
                int miss=3-(j-i);
                if (mp[c]>=miss) {
                    removeBoard(board, i, j);
                    mp[c]-=miss;
                    dfs(board, mp, used+miss);
                    mp[c]+=miss;
                    restoreBoard(board, i, j-i, c);    
                }
            } else {
                removeBoard(board, i, j);
                dfs(board, mp, used);
                restoreBoard(board, i, j-i, c);
            }
            i=j;
        }
    }
    
    void removeBoard(string& board, int start, int end) {
        board.erase(board.begin()+start, board.begin()+end);
    }
    
    void restoreBoard(string& board, int pos, int n, char c) {
        board.insert(pos, n, c);
    }
```

489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
important reverse: i<j and num[i]>2*num[j]
return the number of important reverse pairs.
brutal force: from right to left we insert in a multiset (allows duplicates)

```cpp
    int reversePairs(vector<int>& nums) {
		int n=nums.size();
		multiset<int> ms;
		int ans=0;
        vector<int> t;
		for(int i=n-1;i>=0;i--){
			while(ms.size() && (long)nums[i]>(long)2*(*ms.begin())) {
                ans++;
                t.push_back(*ms.begin());
                ms.erase(ms.begin());
            }
			ms.insert(nums[i]);
            for(auto tt: t) ms.insert(tt);
            t.clear();
		}
		return ans;
    }
```
It TLEs.
again it is merge sort, bst, divide and conquer problem.

499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
<=k distinct project
each project has profit Pi, capital Ci
you have capital W.
maximize the capital (or profit)
approach:
-. remove those non-profit projects
-. make a map capital vs profit sorted from smallest capital to largest
-. upper_bound find those projects using current capital
-. among those projects, find the most profitable project
-. pick the project and remove it, add the profit
-. iterate until we have k projects.
-. to save time, (capital is getting larger), those less profit can be discarded.


```cpp
    int findMaximizedCapital(int k, int W, vector<int>& Profits, vector<int>& Capital) {
        //use priority queue to store the pairs so that searching for max is easier
        //priority_queue only ensure the max so it saves time
        //first binary search to remove all those bad 
        multimap<int,int> mp; //needs multimap since more project more profit
        //priority_queue<int> mq;
        for(int i=0;i<Profits.size();i++) //vs[i]=make_pair(Capital[i],Profits[i]);
        {
            if(Profits[i]) mp.insert(make_pair(Capital[i],Profits[i])); //no profit discard
        }
        int nproj=0,w=W;
        auto it=mp.begin(),prev_it=mp.begin();
        
        while(nproj<k)
        {
            it=mp.upper_bound(w); //binary search
            if(it==mp.begin()) break;
            auto itmax=mp.begin();
            int maxprof=itmax->second;
            for(auto it1=prev_it;it1!=it;it1++) 
            {
                if(it1->second>maxprof)
                {
                    maxprof=it1->second;
                    itmax=it1;
                }
            }
            w+=maxprof;
            //need erase the one from the map
            mp.erase(itmax);
            prev_it=it; //in front are those projects with less capital and less profits.
            nproj++;
        }
        return w;
    }
```	

514	Freedom Trail    		40.6%	Hard	
the dial has a word,using the dial to spell a given word
return the min number of steps to rotate.

dp similar to dijkstra.
```cpp
    int findRotateSteps(string ring, string key) {
        //dfs
        int n=ring.size();
        int m=key.size();
        unordered_map<char,vector<int>> mp;
        for(int i=0;i<ring.size();i++) mp[ring[i]].push_back(i);
        //we are looking for a minimum path sum, ring initial is always 0
        //based on the memoization dfs approach, the dp approach is then simple
        vector<vector<int>> dp(n,vector<int>(m+1,INT_MAX));
        for(int i=0;i<n;i++) dp[i][m]=0;
        for(int j=m-1;j>=0;j--)
        {
            vector<int>& v=mp[key[j]];
            //for(int i=0;i<ring.size();i++)
            for(int i=n-1;i>=0;i--)
            {
                for(int k=0;k<v.size();k++) //all possible index of the current char
                {
                    int d=abs(v[k]-i); //
                    d=min(d,n-d);
                    dp[i][j]=min(dp[i][j],d+dp[v[k]][j+1]);
                }
            }
        }
        int minSteps=dp[0][0];
        return minSteps+m;
    }
```	


517	Super Washing Machines    		37.0%	Hard	
if we subtract the final target, (average), then our target is to reach all 0
```cpp
    int findMinMoves(vector<int>& machines) {
        //approach: total number is not changed, final number is the mean, through distribution
        //less than target: can have incoming or outcoming, +1 or -1
        //larger than target: can only have outcoming, -1
        int sum=0;
        sum=accumulate(machines.begin(),machines.end(),0);
        if(sum%machines.size()) return -1;
        int target=sum/machines.size();
        //transform(machines.begin(),machines.end(),machines.begin(),)
        for(int i=0;i<machines.size();i++) machines[i]-=target;
        //all needs to be zero! the minimal total number of moves is max accumlated gain loss and individual gain/loss
        int cnt=0,min0=0;
        for(int i=0;i<machines.size();i++)
        {
            cnt+=machines[i];
            min0=max(min0,max(abs(cnt),machines[i]));//note loss does not account
        }
        return min0;
    }
```
	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
again this is similar to the google phone interview problem removing 3 or more same
using dp: (divide and conquer)
```cpp
    int removeBoxes(vector<int> boxes) {
        int n = boxes.size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(n,vector<int>(n)));
        return removeBoxesSub(boxes, 0, n - 1, 0, dp);
    }

    int removeBoxesSub(vector<int>& boxes, int i, int j, int k, vector<vector<vector<int>>>& dp) 
    {
        if (i > j) return 0;
        if (dp[i][j][k] > 0) return dp[i][j][k];
        for (; i + 1 <= j && boxes[i + 1] == boxes[i]; i++, k++); 
        // optimization: all boxes of the same color counted continuously from the first box should be grouped together
        int res = (k + 1) * (k + 1) + removeBoxesSub(boxes, i + 1, j, 0, dp);
        for (int m = i + 1; m <= j; m++) {
            if (boxes[i] == boxes[m]) {
                res = max(res, removeBoxesSub(boxes, i + 1, m - 1, 0, dp) + removeBoxesSub(boxes, m, j, k + 1, dp));
            }
        }
        dp[i][j][k] = res;
        return res;
    }
```

552	Student Attendance Record II    		33.2%	Hard	
given n as the length, return the number of valid attendance record
dp:
```cpp
    int checkRecord(int n) {
        //first we have two cases, have 1 A and 0 A
        //have 1 A divide it into two no A cases, the front and behind dp[i]*dp[n-1-i]
        //for no A case: we can add P, PL, PLL
        //dp[i]=dp[i-1]+dp[i-2]+dp[i-3]
        //boundary for no A: dp[0]=0, dp[1]=2 (P/L), dp[2]=4 (PP,PL,LL,LP)
        vector<long long> dp(n+1);
        dp[0]=1;dp[1]=2;dp[2]=4;
        int mod=1e9+7;
        for(int i=3;i<=n;i++)
        {
            dp[i]=(dp[i-1]+dp[i-2]+dp[i-3])%mod;
        }
        int res=dp[n];

        for(int i=0;i<n;i++) //A's position from 0 to n-1
        {
            res+=(dp[i]*dp[n-1-i])%mod;
            res%=mod;
        }
        return res%mod;
    }
```


564	Find the Closest Palindrome    		18.8%	Hard	
given a n, find the closest palindrome number
```cpp
    string nearestPalindromic(string n) {
        //approach: the candidates are: same length: each digits +1 0 -1
        //with different length +1 or -1: it would be 9xxxx99 or 10....01
        //same length compare can use string compare which is the same.
        //total number of digits 60, can fit into a long long
        int len=n.size();
        long long num=stoll(n);
        vector<long long> vs;
        if(len>1)
        {
            string s(len-1,'9');

            long long c1=stoll(s)-num;
            long long c2=stoll(s)+2-num;
            if(c1) vs.push_back(c1);
            if(c2) vs.push_back(c2);
        }
        string s=n;//only need add 1 or keep the same or -1
        long long num1=stoll(n.substr(0,(len+1)/2));
        for(int i=-1;i<=1;i++)
        {
            long long num2=num1+i;
            n=s=to_string(num2);
            //reverse(n.begin(),n.end());//this will add an extra digit!!!wrong!
            //s+=n;
            for(int j=(len+1)/2;j<len;j++) s+=s[len-j-1];
            long long t=stoll(s)-num;
            if(t) vs.push_back(t);
        }
        sort(vs.begin(),vs.end());
        vector<long long> vs1=vs;
        transform(vs1.begin(),vs1.end(),vs1.begin(),static_cast<long long (*)(long long)>(abs));
        int ind=(int)(min_element(vs1.begin(),vs1.end())-vs1.begin());
        return to_string(num+vs[ind]);
    }
```	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard		
