hard review

4	Median of Two Sorted Arrays    		26.5%	Hard	
10	Regular Expression Matching    		25.3%	Hard	
23	Merge k Sorted Lists    		34.7%	Hard	
25	Reverse Nodes in k-Group    		36.6%	Hard	
30	Substring with Concatenation of All Words    		23.7%	Hard	
32	Longest Valid Parentheses    		25.6%	Hard	
37	Sudoku Solver    		37.2%	Hard	
41	First Missing Positive    		29.0%	Hard	
42	Trapping Rain Water    		43.3%	Hard	
44	Wildcard Matching    		22.9%	Hard	
45	Jump Game II    		28.1%	Hard	
51	N-Queens    		39.5%	Hard	
52	N-Queens II    		52.2%	Hard	
57	Insert Interval    		31.3%	Hard	
65	Valid Number    		14.0%	Hard	
68	Text Justification    		23.4%	Hard	
72	Edit Distance    		37.9%	Hard	
76	Minimum Window Substring    		30.9%	Hard	
84	Largest Rectangle in Histogram    		31.3%	Hard	
85	Maximal Rectangle    		33.5%	Hard	
87	Scramble String    		31.7%	Hard	
97	Interleaving String    		28.1%	Hard	
99	Recover Binary Search Tree    		34.8%	Hard	
115	Distinct Subsequences    		35.1%	Hard	
123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
126	Word Ladder II    		17.8%	Hard	
128	Longest Consecutive Sequence    		41.8%	Hard	
132	Palindrome Partitioning II    		27.5%	Hard	
135	Candy    		28.5%	Hard	
140	Word Break II    		27.4%	Hard	
145	Binary Tree Postorder Traversal    		48.7%	Hard	
149	Max Points on a Line    		15.8%	Hard	
154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
174	Dungeon Game    		27.2%	Hard	
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
212	Word Search II    		28.8%	Hard	
214	Shortest Palindrome    		27.6%	Hard	
218	The Skyline Problem    		31.7%	Hard	
224	Basic Calculator    		32.8%	Hard	
233	Number of Digit One    		30.2%	Hard	
239	Sliding Window Maximum    		38.3%	Hard	
248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
282	Expression Add Operators    		32.8%	Hard	
291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard	
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
354	Russian Doll Envelopes    		34.0%	Hard	
358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
391	Perfect Rectangle    		28.2%	Hard	
403	Frog Jump    		36.2%	Hard	
407	Trapping Rain Water II    		39.3%	Hard	
410	Split Array Largest Sum    		42.4%	Hard	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
425	Word Squares    		44.4%	Hard	
428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
458	Poor Pigs    		45.4%	Hard	
460	LFU Cache    		28.9%	Hard	
465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
471	Encode String with Shortest Length    		45.2%	Hard	
472	Concatenated Words    		34.8%	Hard	
479	Largest Palindrome Product    		27.4%	Hard	
480	Sliding Window Median    		32.6%	Hard	
483	Smallest Good Base    		34.2%	Hard	
488	Zuma Game    		39.0%	Hard	
489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
514	Freedom Trail    		40.6%	Hard	
517	Super Washing Machines    		37.0%	Hard	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
552	Student Attendance Record II    		33.2%	Hard	
564	Find the Closest Palindrome    		18.8%	Hard	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard


4	Median of Two Sorted Arrays    		26.5%	Hard	
one array m, one n, for odd, it is (m+n+1)/2
for even it is two mid value average.
Approach 1: merge sort and it is O(m+n)
Approach 2: use binary search
two sorted array. two problem find the (m+n+1)/2 and (m+n+1)/2+1 element
or find kth element.
using la, ra for array a, and lb, rb for array b.
then the mid for a and mid for b divide the two array into 4 parts
a: [la,ma], [ma,ra]
b: [lb,mb], [mb,rb]
a[ma]<=b[mb]: 
```cpp
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //binary search shall be the best strategy for this problem
        //to find kth number recursively. 
        int m=nums1.size(),n=nums2.size();
        double v=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2);
        double v1;
        if((m+n)%2==0) {v1=findkth(nums1,nums2,0,m-1,0,n-1,(m+n+1)/2+1);v=(v+v1)*0.5;}
        return v; 
          
    }
    int findkth(vector<int>& va,vector<int>& vb,int la,int ra,int lb,int rb,int k)
    {
        if(la>ra) return vb[lb+k-1];
        if(lb>rb) return va[la+k-1];
        
        int ma=(la+ra)/2,mb=(lb+rb)/2;
        if(va[ma]<=vb[mb])
        {
            if(k<=(ma-la)+(mb-lb)+1) return findkth(va,vb,la,ra,lb,mb-1,k);
            else return findkth(va,vb,ma+1,ra,lb,rb,k-(ma-la)-1);
        }
        else //va[ma]>vb[mb]
        {
            if(k<=ma-la+mb-lb+1) return findkth(va,vb,la,ma-1,lb,rb,k);
            else return findkth(va,vb,la,ra,mb+1,rb,k-(mb-lb)-1);
        }
    }
```	


10	Regular Expression Matching    		25.3%	Hard	
dp, two string matching problem
'.' matches any single char
'*' matches zero or more of the preceding char
```cpp
    bool isMatch(string s, string p) {
        /**
         * f[i][j]: if s[0..i-1] matches p[0..j-1]
         * if p[j - 1] != '*'
         *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]
         * if p[j - 1] == '*', denote p[j - 2] with x
         *      f[i][j] is true iff any of the following is true
         *      1) "x*" repeats 0 time and matches empty: f[i][j - 2]
         *      2) "x*" repeats >= 1 times and matches "x*x": s[i - 1] == x && f[i - 1][j]
         * '.' matches any single character
         */
        int m = s.size(), n = p.size();
        vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));
        
        f[0][0] = true;
        for (int i = 1; i <= m; i++)
            f[i][0] = false;
        // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty
        for (int j = 1; j <= n; j++)
            f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];
        
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (p[j - 1] != '*')
                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);
                else
                    // p[0] cannot be '*' so no need to check "j > 1" here
                    f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];
        
        return f[m][n];
    }
```
	
23	Merge k Sorted Lists    		34.7%	Hard	
typically using heap.
approach 1: keep merge two lists.
approach 2: pq (minheap) stores the listnode, keep popping the min, and push in min's next.

```cpp
struct compare {
    bool operator()(const ListNode* l, const ListNode* r) {
        return l->val > r->val;
    }
};
ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue
    priority_queue<ListNode *, vector<ListNode *>, compare> q;
    for(auto l : lists) {
        if(l)  q.push(l);
    }
    if(q.empty())  return NULL;

    ListNode* result = q.top();
    q.pop();
    if(result->next) q.push(result->next);
    ListNode* tail = result;            
    while(!q.empty()) {
        tail->next = q.top();
        q.pop();
        tail = tail->next;
        if(tail->next) q.push(tail->next);
    }
    return result;
}
```

25	Reverse Nodes in k-Group    		36.6%	Hard	
just reverse k
```cpp
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head || k<2) return head;
        ListNode *dummy,*pre,*post,*p;
        dummy=new ListNode(0);
        dummy->next=head;
        pre=dummy;
        p=head;
        int cnt=0;
        while(p)
        {
            post=advance(p,k,cnt);
            if(!post && cnt<k) break;
            //reverse nodes between pre and post
            pair<ListNode*,ListNode*> pn=reverse_inplace(p,k);
            pre->next=pn.first;
            pn.second->next=post;
            
            pre=pn.second; //now the node after pre becomes the new pre
            p=post;
        }
        return dummy->next;
    }
    ListNode* advance(ListNode* head,int k,int& cnt)
    {
        cnt=0;
        while(cnt<k && head) {head=head->next;cnt++;}
        return head;
    }
    pair<ListNode*,ListNode*> reverse_inplace(ListNode* p,int k)
    {
        ListNode* last=p;
        ListNode *pre=0,*next;
        while(k)//reverse its direction
        {
            next=p->next;
            p->next=pre;
            pre=p;
            p=next;
            k--;
        }
        return make_pair(pre,last);
    }
```	
30	Substring with Concatenation of All Words    		23.7%	Hard	
subarray with all words in the dictionary, window shall be exactly the same as the total length of the dict.
approach 1: iterate on all char with a sliding window. check if the window contains all words. Note the words are the same length, which makes thing easier
approach 2: direct hash. treat each word a hash and combination of words another hash. this is a permutation of words.
approach 3: hashmap, first build a dictionary map, and sliding window to see if the window contains the map
```cpp
	vector<int> findSubstring(string s, vector<string>& words) {
        if(words.empty()) return {};
		unordered_map<string,int> mp;
		for(auto t: words) mp[t]++;
        vector<int> ans;
		int m=words.size(),n=words[0].size(),len=s.size();
		for(int i=0;i<=len-m*n;i++){
			unordered_map<string,int> tmp;
			for(int j=0;j<m;j++){
				string t=s.substr(i+j*n,n);
				if(!mp.count(t)) break;
				tmp[t]++;
			}
			if(tmp==mp) ans.push_back(i);
		}
		return ans;
	}
```	
however worst case is O(n*m*len)
			
32	Longest Valid Parentheses    		25.6%	Hard	
using a stack to remove all valid pairs and then we leave with some intervals, then find the largest
```cpp
	int longestValidParentheses(string s) {
		stack<pair<char,int>> st;
		int maxlen=0;
		for(int i=0;i<s.size();i++){
			char c=s[i];
			if(st.size() && c==')' && st.top().first=='('){ 
				st.pop();
				if(st.size()) maxlen=max(maxlen,i-st.top().second);
				else maxlen=max(maxlen,i+1);
			}
			else st.push({c,i});
		}
		return maxlen;
	}
```	

37	Sudoku Solver    		37.2%	Hard	
typical backtracking, trial & back
```cpp
    void solveSudoku(vector<vector<char>>& board) {
		if(board.size()==0) return;
		solve(board);
    }
	bool solve(vector<vector<char>>& b)
	{
		int m=b.size(),n=b[0].size();
		for(int i=0;i<m;i++)
		{
			for(int j=0;j<n;j++)
			{
				if(b[i][j]=='.')
				{
					for(char c='1';c<='9';c++)
					{
						if(isValid(b,i,j,c))
						{
							b[i][j]=c;
							if(solve(b)) return 1;
							else b[i][j]='.';
						}
					}
				}
			}
        }
		return 0;
	}
	bool isValid(vector<vector<char>>& b,int row,int col,char c)
	{
		for(int i=0;i<9;i++)
		{
			if(b[i][col]!='.' && b[i][col]==c) return 0;
			if(b[row][i]!='.' && b[row][i]==c) return 0;
			int r0=3*(row/3)+i/3,c0=3*(col/3)+i%3;
			if(b[r0][c0]!='.' && b[r0][c0]==c) return 0;
		}
		return 1;
	}
```
	
41	First Missing Positive    		29.0%	Hard	
O(N) requirement
```cpp
Put each number in its right place.

For example:

When we find 5, then swap it with A[4].

At last, the first place where its number is not right, return the place + 1.
```cpp
class Solution
{
public:
    int firstMissingPositive(int A[], int n)
    {
        for(int i = 0; i < n; ++ i)
            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])
                swap(A[i], A[A[i] - 1]);
        
        for(int i = 0; i < n; ++ i)
            if(A[i] != i + 1)
                return i + 1;
        
        return n + 1;
    }
};
```

42	Trapping Rain Water    		43.3%	Hard	
typical stack problem
stack in decreasing, once the new coming > stack it forms a container with the one before the stack top
```cpp
    int trap(vector<int>& height) {
        //using stack similar to largest rectangle in histogram
        //we maintain a stack with index, in decreasing order of height
        int n=height.size();
        stack<int> s;
        int i=0,total=0;

        while(i<n)
        {
            if(s.empty() || height[i]<=height[s.top()]) s.push(i++);
            else
            {
                int tp=s.top();s.pop();
                //min(h(l),h(r))-h(i). If there is no element in stack, the area is 0
                if(!s.empty())
                {
                    int area=(min(height[i],height[s.top()])-height[tp])*(i-s.top()-1);//current one as the minimum
                    total+=area;
                }
            }
        }
        return total;
    }
```
	
44	Wildcard Matching    		22.9%	Hard	
typical two string compare dp problem
? matches any single char
* matches any sequence of char (including empty)
```cpp
    bool isMatch(string s, string p) {
        int m=s.length(),n=p.length();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1));
        dp[0][0]=1;
        for(int i=1;i<=n;i++) //pattern string is not empty, but s1 is empty
        {
            if(p[i-1]!='*') break;else dp[0][i]=1;
        }
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(p[j-1]!='*') dp[i][j]=dp[i-1][j-1] &&(s[i-1]==p[j-1] || p[j-1]=='?');
                else dp[i][j]=dp[i-1][j]||dp[i][j-1];
            }
        }
        return dp[m][n];
    }
```
	
45	Jump Game II    		28.1%	Hard	
each number is the max jump steps
return min number of jumps
bfs like algorithm on 1d array.
```cpp
    int jump(vector<int>& nums) {
		int n=nums.size();
		 if(n<2)return 0;
		 int level=0,currentMax=0,i=0,nextMax=0;

		 while(currentMax-i+1>0)
		 {		//nodes count of current level>0
			 level++;
			 for(;i<=currentMax;i++)
			 {	//traverse current level , and update the max reach of next level
				nextMax=max(nextMax,nums[i]+i);
				if(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level 
			 }
			 currentMax=nextMax;
		 }
		 return 0;
	 }        
 ```

51	N-Queens    		39.5%	Hard	
nxn board and place n queens without attacking each other
each row shall only have one
each col shall only have one
each diag and anti-diag only have one
similar to sudoko solver using trial and back
```cpp
    vector<vector<string> > solveNQueens(int n) {
        vector<vector<string> > res;
        vector<string> nQueens(n, string(n, '.'));
        solveNQueens(res, nQueens, 0, n);
        return res;
    }
    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {
        if (row == n) 
        {
            res.push_back(nQueens);
            return;
        }
        for (int col = 0; col != n; ++col)
            if (isValid(nQueens, row, col, n)) 
            {
                nQueens[row][col] = 'Q';
                solveNQueens(res, nQueens, row + 1, n);
                nQueens[row][col] = '.';
            }
    }
    bool isValid(vector<string> &nQueens, int row, int col, int &n) 
    {
        //check if the column had a queen before.
        for (int i = 0; i != row; ++i)
            if (nQueens[i][col] == 'Q') return false;
        //check if the 45° diagonal had a queen before.
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
            if (nQueens[i][j] == 'Q') return false;
        //check if the 135° diagonal had a queen before.
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)
            if (nQueens[i][j] == 'Q') return false;
        return true;
    }
```


52	N-Queens II    		52.2%	Hard	
return the number of distinct solution.
similar to I.
```cpp
    int totalNQueens(int n) {
        //dfs, we need a matrix to store the occupied position
        vector<int> vp; //the column number
        return dfs(n,0,vp);
    }
    int dfs(int n,int row,vector<int>& vp)
    {
        if(row==n) return 1;
        int res=0;
        for(int col=0;col<n;col++) //try all columns
        {
            if(isValid(row,col,vp))
            {
                vp.push_back(col);
                res+=dfs(n,row+1,vp);
                vp.pop_back();
            }
        }
        return res;
    }
    bool isValid(int r,int c,vector<int>& vp)
    {
        //row is already ensured only one is placed
        for(int i=0;i<vp.size();i++) 
        {
            if(vp[i]==c) return 0; //vertical
            if(r+c==i+vp[i]) return 0;
            if(r-c==i-vp[i]) return 0;
        }
        return 1;
    }
```	

57	Insert Interval    		31.3%	Hard	
insert and merge
sort using the start. and then find the insert position. and merge those between.
note compare the end<the other's start. using equal range or lower_bound or upper_bound.
very smart. O(logn)
```cpp
    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
        auto compare = [] (const Interval &intv1, const Interval &intv2)
                          { return intv1.end < intv2.start; };
        auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);
        auto itr1 = range.first, itr2 = range.second;
        if (itr1 == itr2) {
            intervals.insert(itr1, newInterval);
        } else {
            itr2--;
            itr2->start = min(newInterval.start, itr1->start);
            itr2->end = max(newInterval.end, itr2->end);
            intervals.erase(itr1, itr2);
        }
        return intervals;
    }
```	
if not sorted, we can just merge each interval with the new one, and keeps updating the new one
O(n)
		
65	Valid Number    		14.0%	Hard	
trivial.
```cpp
    bool isNumber(string s) {
        string whitespace=" \t";
        int ind=s.find_last_not_of(whitespace);
        s=s.substr(0,ind+1);
        stringstream ss(s);
        double a;
        //we need remove trailing space since it is not good for processing
 
        ss>>a;
        
        if(ss.fail()) return 0;
        if(ss.eof()) return 1;
        return 0;
    }
```	
68	Text Justification    		23.4%	Hard	
```cpp
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        //each line: begin no space, last one no space!
        //if one word cannot fit the line, we shall break it into multiple lines
        //more like a greedy problem, allow take one or none
        //only exception is the line cannot fit a single word! we may break the single big words into two or three words
        //note last line shall be left adjustment!
        vector<string> line;
        vector<string> res;
        int cnt=0;
        bool line_done=0,last_line=0;
        for(int i=0;i<words.size();i++)
        {
            int len=cnt+words[i].size()+(line.empty()?0:1);
            
            if(len<=maxWidth) 
            {
                line.push_back(words[i]);cnt=len;
                if(i==words.size()-1) last_line=1;
            }
            else line_done=1;

            if(line_done && !last_line && !line.empty())    
            {
                int rem=maxWidth-cnt+line.size()-1; //cnt already included spaces
                int extra=0;
                if(line.size()>1)
                    extra=rem/(line.size()-1); //the remaining is added one from left to right!
                else extra=rem;
                rem-=extra*(line.size()-1);
                string s;
                for(int j=0;j<line.size()-1;j++) 
                {
                    s+=line[j];s.append(extra+(j<rem?1:0),' ');
                }
                s+=line.back();
				if(line.size()==1) s.append(extra,' ');
                res.push_back(s);
                line.clear();
                line_done=0;
				line.push_back(words[i]);cnt=words[i].size();
            }
        }
        //process last line
        cnt=0;
        string s;
        for(int i=0;i<line.size()-1;i++) {s+=line[i]+' ';cnt+=line[i].size()+1;}
        s+=line.back();cnt+=line.back().size();
        s.append(maxWidth-cnt,' ');
        res.push_back(s);
        
        return res;        
    }
```	

72	Edit Distance    		37.9%	Hard	
insert/delete/replace
typical dp problem

```cpp
    int minDistance(string s1, string s2) {
        //note it has three operations!
		int n=s1.size();
		int m=s2.size();
		vector<vector<char>> d(n+1,vector<char>(m+1));
		for(int i=0;i<=n;i++) d[i][0]=i;
		for(int j=0;j<=m;j++) d[0][j]=j;
		short ins,del,match,mismatch;
		for(int j=1;j<=m;j++)
		{
			for(int i=1;i<=n;i++)
			{
				ins=d[i][j-1]+1;
				del=d[i-1][j]+1;
				match=d[i-1][j-1];
				mismatch=d[i-1][j-1]+1;//replace
				if(s1[i-1]==s2[j-1]) //note string start from 0
					//d[i][j]=min(ins,min(del,match));
					d[i][j]=match;
				else
					d[i][j]=min(ins,min(del,mismatch));
			}
		}
		return d[n][m];   
    }
```	
76	Minimum Window Substring    		30.9%	Hard
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
S has non-related chars.
sliding window: 
for simplicity we are decreasing/increasing the hashmap and length counter.
```cpp
	string minWindow(string s, string t) {
		unordered_map<char, int> mp;	// Statistic for count of char in t
		for (auto c : t) mp[c]++;
		// counter represents the number of chars of t to be found in s.
		int start = 0, end = 0, minStart = 0, minLen = INT_MAX;
		int slen = s.size(),tlen = t.size();
			
		while (end<slen) // Move end to find a valid window.
		{
			if (mp[s[end]]>0) tlen--;// If char in s exists in t, decrease counter
			mp[s[end]]--;// Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.
			end++;
			
			while (tlen == 0) // When we found a valid window, move start to find smaller window.
			{
				if(end-start<minLen) 
				{
					minStart=start;
					minLen=end-start;
				}
				mp[s[start]]++;
				
				if (mp[s[start]]>0) tlen++;// When char exists in t, increase counter.
				start++;
			}
		}
		if (minLen != INT_MAX)return s.substr(minStart, minLen);
		return "";
	}
```
84	Largest Rectangle in Histogram    		31.3%	Hard	
Note it needs between to be all larger than the smaller side
approach 1: two way 
approach 2: divide and conquer
```cpp
    int largestRectangleArea(vector<int>& heights) {
        //the area=min(set)*len(set)
        /* use divide and conquer
    Find the minimum height column with index min. The max area should exist among three possible answers:
    sub-problem in index [0 ~ min]
    sub-problem in index [min + 1 ~ len - 1]
    height[min] * (len - 0)        
    */
        heights.push_back(0); //add a zero so that it won't overflow
        return getLargestArea(heights,0,heights.size()-1);
        
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }
```	
approach 3: using increasing stack
using stack
```cpp
    int largestRectangleArea(vector<int>& height) {
        height.insert(height.begin(),0); // dummy "0" added to make sure stack s will never be empty
        height.push_back(0); // dummy "0" added to clear the stack at the end
        int len = height.size();
        int i, res = 0, idx;
        stack<int> s; // stack to save "height" index
        s.push(0); // index to the first dummy "0"
        for(i=1;i<len;i++)
        {
            while(height[i]<height[idx = s.top()]) // if the current entry is out of order
            {
                s.pop();
                res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry
            }
            s.push(i);
        }
        height.erase(height.begin()); // remove two dummy "0"
        height.pop_back();
        return res;
    }
```	
85	Maximal Rectangle    		33.5%	Hard	
based on 1d histogram
```cpp
    int maximalRectangle(vector<vector<char>>& matrix) {
        //can we do it line by line and calculate the max?
        //using the algorithm from the max area in histogram
        //need calculate its height every line
        if(matrix.size()==0) return 0;
        int ncol=matrix[0].size();
        int nrow=matrix.size();
        
        vector<int> height(ncol+1);
        int max_area=0;
        for(int i=0;i<nrow;i++)
        {
            for(int j=0;j<ncol;j++) 
            {
                char c=matrix[i][j];
                if(c=='0') height[j]=0;
                else height[j]++;
            }
            int area=getLargestArea(height,0,height.size()-1)       ;
            if(area>max_area) max_area=area;
        }
        return max_area;
    }
    int getLargestArea(vector<int>& h,int l,int r)
    {
        if(l>=r) return h[l];
        //special case: the array is sorted
        if(is_sorted(h.begin()+l,h.begin()+r))
        {
            int smax=h[l]*(r-l);
            for(int i=l+1;i<r;i++)
            {
                int area=h[i]*(r-i);
                if(area>smax) smax=area;
            }
            return smax;
        }
        int min_ind=static_cast<int>(min_element(h.begin()+l,h.begin()+r)-h.begin());
        int area_left=getLargestArea(h,l,min_ind);
        int area_right=getLargestArea(h,min_ind+1,r);
        int area_min=h[min_ind]*(r-l);
        return max(area_min,max(area_left,area_right));
    }    
```
	
87	Scramble String    		31.7%	Hard	
similar to flip left right tree
recursive:
```cpp
    bool isScramble(string s1, string s2) {
        if(s1==s2)
            return true;
            
        int len = s1.length();
        int count[26] = {0};
        for(int i=0; i<len; i++)
        {
            count[s1[i]-'a']++;
            count[s2[i]-'a']--;
        }
        
        for(int i=0; i<26; i++)
        {
            if(count[i]!=0)
                return false;
        }
        
        for(int i=1; i<=len-1; i++)
        {
            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))
                return true;
            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))
                return true;
        }
        return false;
    }
```	

97	Interleaving String    		28.1%	Hard	
check if s3 is interleaving of s1 and s2
2d path using dp
```cpp
    bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.size(),n2=s2.size();
        if(s3.length() != n1+n2) return 0;
        if(n1==0) return s3==s2;
        if(n2==0) return s3==s1;
        vector<vector<bool>> dp(n1+1,vector<bool>(n2+1));
        dp[0][0]=1; //empty vs empty
        //boundary condition
        for(int i=1;i<n1+1;i++) dp[i][0]=dp[i-1][0] && (s1[i-1]==s3[i-1]); //j=0, s1 compare with s3
        for(int j=1;j<n2+1;j++) dp[0][j]=dp[0][j-1] && (s2[j-1]==s3[j-1]); //i=0: s2 compare with s3
        for(int i=1; i<n1+1; i++)
        {
            for(int j=1; j< n2+1; j++)
            {
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1] ) || (dp[i][j-1] && s2[j-1] == s3[i+j-1] );
            }
        }   
        return dp[n1][n2];
    }
```	

99	Recover Binary Search Tree    		34.8%	Hard	
two elements of a binary search tree are swapped. recover it
inorder traversal and keep prev and compare with current. if prev>curr it is one of it
```cpp
    TreeNode* prev;
    void recoverTree(TreeNode* root) {
        vector<TreeNode*> res;
        prev=0;
        inorder(root,res);
        //for(int i=0;i<res.size();i++) cout<<res[i]->val<<" ";
        if(res.size()==2) {swap(res[0]->val,res[1]->val);}
        else {swap(res[0]->val,res[3]->val);}
    
    }
    void inorder(TreeNode* root,vector<TreeNode*>& res) //inorder traverse to find the swapped ind
    {
        if(!root) return;
        //compare to previous 
        inorder(root->left,res);
        if(!prev) {prev=root;}
        else
        {
            if(root->val<prev->val) {res.push_back(prev);res.push_back(root);}
            prev=root;
        }
        //cout<<prev->val<<" "<<root->val<<",";
        inorder(root->right,res);
    }
```
	
115	Distinct Subsequences    		35.1%	Hard	
number of distinct subsequence in S equals T
that is number of ways from S to T. (similar to climbing stairs)
```cpp
    int numDistinct(string s, string t) {
        //dp edit distance
        int m=s.size(),n=t.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        //dp[i,j] represent number of subsequence for s(0...i) vs t[0..j]
        //allowing only deletion from s
        //boundary: dp[0,0]=1
        for(int i=0;i<=m;i++) dp[i][0]=1; //when t is empty, need delete all s
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(s[i-1]!=t[j-1]) dp[i][j]=dp[i-1][j]; //need delete this char, i proceed one
                else dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; //delete: i proceed one, keep: dp[i-1][j-1]
            }
        }
        return dp[m][n];
    }
```

123	Best Time to Buy and Sell Stock III    		33.8%	Hard	
two transaction, it is a special edition of K transaction
188	Best Time to Buy and Sell Stock IV    		26.4%	Hard	
the idea is based on previous k-1 transaction, add a more transaction
dp[k][i]=max(dp[k][i-1],dp[k-1][j]+price[i]-price[j]), no operation or operation
```cpp
    int maxProfit(int k, vector<int>& prices) {
       int n=prices.size();
        if(k>=n/2)
        {
            int sum=0;
            for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) sum+=prices[i]-prices[i-1];
            return sum;
        }
        vector<vector<int>> dp(k+1,vector<int>(n));
        int maxprof=0;
        
        for(int t=1;t<=k;t++)
        {
            int tmin=INT_MAX;
            for(int i=1;i<n;i++)
            {
                tmin=min(tmin,prices[i-1]-dp[t-1][i-1]);
                dp[t][i]=max(dp[t][i-1],prices[i]-tmin);
                maxprof=max(maxprof,dp[t][i]);
            }
        }
        return maxprof;
    }
```	
124	Binary Tree Maximum Path Sum    		30.1%	Hard	
path sum: can cross the root or not cross.
cross the root: root+left+right 
not cross the root: left or right (subproblem)
combined with the dp problem: the max sum of subarray if previous sum<0 then we start a new segement.
```cpp
    int maxPathSum(TreeNode* root) {
        //any negative nodes shall not be included
        //each node shall be the largest path sum
        //nodemaxsum=node+max_left_pathsum+max_right_pathsum which needs postorder traversal
        int maxsum=INT_MIN;
        node_maxsum(root,maxsum);
        return maxsum;
    }
    int node_maxsum(TreeNode* root,int& maxpathsum)
    {
        if(!root) return 0;
        int l=node_maxsum(root->left,maxpathsum);
        int r=node_maxsum(root->right,maxpathsum);
        l=l>0?l:0; //shall we include left?
        r=r>0?r:0;//shall we include right?
        if(maxpathsum<l+r+root->val) maxpathsum=l+r+root->val;
        root->val+=max(l,r); //postorder is bottom up, update the node value to the max path sum (including the paths under its subtree
        return root->val;
    }
```	
update the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time.

126	Word Ladder II    		17.8%	Hard	
find all shortest path from A to B.
similar problem 127 Word Ladder using bfs. (shortest distance from A to B)
- convert to hashset first for better retrieving.
- 
```cpp
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> dict(wordList.begin(),wordList.end()),visited;
		queue<string> q;
		q.push(beginWord);
		visited.insert(beginWord);
		int step=1;
		while(q.size()){
			int sz=q.size();
			while(sz--){
				string s=q.front();
				if(s==endWord) return step;
				q.pop();
				addWords(s,q,dict,visited);
			}
			step++;
		}
		return 0;
    }
	void addWords(string& s,queue<string>& q,unordered_set<string>& dict,unordered_set<string>& visited){
		for(int i=0;i<s.size();i++){
			char c=s[i];
			for(char t='a';t<='z';t++){
				s[i]=t;
				if(dict.count(s) && !visited.count(s)) {
					q.push(s);
					visited.insert(s);
				}
			}
			s[i]=c;
		}
	}
```	
now we need all the shortest path.
approach 1: get the shortest path length using bfs and then find path using dfs. wasted information
approach 2: bfs while keeping the route information.
when we found the path we need keep finishing the layer. also we need keep the path information. (parent)
need add a pointer to its parent. it forms a tree.
```cpp
	struct node{
		node* parent;
		string s;
		node(string ss): s(ss),parent(0){}
		node(string ss,node* p): s(ss),parent(p){}
	};
	vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList){
		vector<vector<string>> ans;
        unordered_set<string> dict(wordList.begin(),wordList.end()),visited;
		vector<node*> tree;
		queue<node*> q; //parent-child pair, do not use pointer since vector is dynamic
		tree.push_back(new node(beginWord));
		q.push(tree.back());
		visited.insert(beginWord);
		int step=1;
        bool stop=0;
		vector<string> layer;
		while(q.size() && !stop){
			layer.clear();
			int sz=q.size();
			while(sz--){
				auto nd=q.front(); //use pointer be very careful
				q.pop();
                //cout<<nd->s<<endl;
                auto parent=nd;
				if(nd->s==endWord) {
                    stop=1;
					vector<string> vt;
					while(nd){
						vt.push_back(nd->s);
                        nd=nd->parent;
					}
					ans.push_back({vt.rbegin(),vt.rend()});
				}
				addWords(parent->s,q,dict,visited,tree,parent,layer);
			}
			for(auto t: layer) visited.insert(t);
			step++;
		}
		return ans;
    }
	void addWords(string s,queue<node*>& q,unordered_set<string>& dict,
	unordered_set<string>& visited,vector<node*>& tree,node* parent,vector<string>& layer){
		for(int i=0;i<s.size();i++){
			char c=s[i];
			for(char t='a';t<='z';t++){
				s[i]=t;
				if(dict.count(s) && !visited.count(s)) {
					tree.push_back(new node(s,parent));
					q.push(tree.back());
					//if(s!=endw) visited.insert(s);
					layer.push_back(s);
				}
			}
			s[i]=c;
		}
		//for(auto t: vt) visited.insert(t);
	}
```
There is a problem: 
- the endword is not allowed to be included multiple times so only one answer would be given.
- different path may contain a common word so the visited is not proper. actually this is the key part.
bfs: the layer used canot never be visited again.
but the same layer can be used multiple times. so we can only update the visited after the layer is done!!!!!
this is another form of BFS and very good question. The node may have multiple parents to avoid dfs, it is necessary to keep multiple same nodes	in queue to maintain one to one relation

128	Longest Consecutive Sequence    		41.8%	Hard	
need O(n)
for example [100,4,200,1,3,2]
when we see 4, we know we need 5 and 3
when we see 1, we know we need 2 and 0
when we see 3, it is in need list, and also it needs 4 and 2
when we see 2, it is in need list, and also it needs 3 and 1
connect them using union-find
```cpp
    int longestConsecutive(vector<int>& nums) {
        //they don't need to keep order, disjoint set
        int n=nums.size();
        if(n<2) return n;
        vector<int> parent(n),size(n,1);
        unordered_map<int,int> mp;
        for(int i=0;i<n;i++) parent[i]=i;
        for(int i=0;i<n;i++)
        {
            if(mp.count(nums[i])) continue;//ignore duplicates
            mp[nums[i]]=i;
            if(mp.count(nums[i]-1)) merge(i,mp[nums[i]-1],parent,size);
            if(mp.count(nums[i]+1)) merge(i,mp[nums[i]+1],parent,size);
        }
        return *max_element(size.begin(),size.end());
    }
    
    int getparent(int i,vector<int>& parent)
    {
        while(i!=parent[i]) i=parent[i];
        return i;
    }
    void merge(int i,int j,vector<int>& parent,vector<int>& size)
    {
        int pi=getparent(i,parent),pj=getparent(j,parent);
        if(pi==pj) return;
        if(pi<pj) {parent[pj]=pi;size[pi]+=size[pj];size[pj]=0;}
        else {parent[pi]=pj;size[pj]+=size[pi];size[pi]=0;}
    }
```	


132	Palindrome Partitioning II    		27.5%	Hard	
return min number of cuts so that each substr is a palindrome.
this is a dp. odd length and even length
cut[i] min number of cuts at i.

```cpp
    int minCut(string s) {
        int n = s.size();
        vector<int> cut(n+1, 0);  // number of cuts for the first k characters
        for (int i = 0; i <= n; i++) cut[i] = i-1; //boundary: cut it into single char.
        for (int i = 0; i < n; i++) {
            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome
                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);

            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome
                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);
        }
        return cut[n];
    }
```	
135	Candy    		28.5%	Hard	
each child need have >=1 candies
children with higher rating get more candies than their neighbors
for example [1,0,2]: 
assume we give 1 one candie, but it shall be more than its neighbors, so need get at least 2 and we get 2,1,2
since it has two neighbors, we can do it two pass, one from left to right, and one from right to left.
one direction: we need take care of the left only (or right).
```cpp
    int candy(vector<int>& ratings) {
        int ans=0;
        //at least give one candy
        //simple example gives the following approach
        //find the smallest one, and assign 1
        int n=ratings.size();
        vector<int> can(n,1);
        //from left to right
        for(int i=1;i<n;i++) if(ratings[i]>ratings[i-1]) can[i]=can[i-1]+1;
        for(int i=n-2;i>=0;i--) if(ratings[i]>ratings[i+1]) can[i]=max(can[i],can[i+1]+1);
        
        //copy(can.begin(),can.end(),ostream_iterator<int>(cout," "));cout<<endl;
        return accumulate(can.begin(),can.end(),0);
    }
```
this is a good problem. two direction problem can be solved using two separate one direction problem.
	

140	Word Break II    		27.4%	Hard	
a list of words and a string, cut it into dictionary words.
return all possible combination.
Similar question 139 Word break (check if it is breakable). 
first, using dp to find all cut positions and its previous cut. and then use dfs with backtracking
dp it is convenient to add previous index and then we have to do reverse dfs.
```cpp
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        unordered_map<int,vector<string>> mp; //end position and its possible cut string
        unordered_set<string> dict(wordDict.begin(),wordDict.end());
        vector<bool> dp(s.length()+1);
        dp[0]=1;
        if(s.size()<2)
        {
            if(dict.count(s)) return vector<string>({s});
        }
        //if(dict.count(s.substr(0,1))) mp[0].push_back(s.substr(0,1));
        for(int i=1;i<=s.size();i++)
        {
            for(int j=i-1;j>=0;j--) //check all previous cut
            {
                if(dp[j])
                {
                string t;
                t=s.substr(j,i-j);//not including j, j+1 to i both inclusive
                if(dict.count(t)) {mp[i].push_back(t);dp[i]=1;}//does not include i=0 case
                }
            }
        }
        //print(mp);
        if(mp.count(s.size())==0) return vector<string>();
        //now we can use dfs to search all possible combinations
        unordered_map<int,vector<string>> mps;
        for(auto it=mp.begin();it!=mp.end();it++)
        {
            for(int i=0;i<it->second.size();i++) 
                mps[it->first-it->second[i].size()].push_back(it->second[i]);
        }
        //print(mps);
        vector<string> ans;
        string sentence;
        dfs(mps,0,s.size(),ans,sentence);
        return ans;
    }
    void dfs(unordered_map<int,vector<string>>& mp,int start,int end,vector<string>& res,string sentence)
    {
        if(start>=end) {sentence.pop_back();res.push_back(sentence);sentence+=" ";return;}
        for(int i=0;i<mp[start].size();i++) //try all cuts
        {
            sentence+=mp[start][i]+" ";
            int sz=mp[start][i].size();
            dfs(mp,start+sz,end,res,sentence);
            //cout<<sentence<<" "<<sentence.size()<<","<<sz<<endl;
            sentence.erase(sentence.size()-sz-1);//remove the last word + space
        }
    }
```
this is too complicated, and prone to bugs. using divide and conquer is a better choice
```cpp
    unordered_map<string, vector<string>> m;

    vector<string> combine(string word, vector<string> prev){
        for(int i=0;i<prev.size();++i){
            prev[i]+=" "+word;
        }
        return prev;
    }

public:
    vector<string> wordBreak(string s, unordered_set<string>& dict) {
        if(m.count(s)) return m[s]; //take from memory
        vector<string> result;
        if(dict.count(s)){ //a whole string is a word
            result.push_back(s);
        }
        for(int i=1;i<s.size();++i){
            string word=s.substr(i);
            if(dict.count(word)){
                string rem=s.substr(0,i);
                vector<string> prev=combine(word,wordBreak(rem,dict));
                result.insert(result.end(),prev.begin(), prev.end());
            }
        }
        m[s]=result; //memorize
        return result;
    }
```

We shall always choose the most concise approach due to very limited time!!!!
since there could be a lot of repetions, so memoization is needed.

472. Concatenated words
first we need sort the words in dictionary from shorter length to longer length
since longer word can be combined using shorter words only
so we build the dictionary one by one.
each one is a problem of 139. 
```cpp
bool cmp1(const string& s1,const string& s2) {return s1.length()<s2.length();}
class Solution {
public:
    
    struct cmp
    {//note the 3 const are required!!!!
        bool operator()(const string& s1,const string& s2) const {return s1.length()<s2.length();}
    };
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        //sort the words using length
        vector<string> res;
        sort(words.begin(),words.end(),cmp1);
        //copy(words.begin(),words.end(),ostream_iterator<string>(cout," "));cout<<endl;
        unordered_set<string> dict;
        
        //multiset<string,cmp> dict(words.begin(),words.end()); //note if the length are the same it is not inserted!!!
        
        for(int i=0;i<words.size();i++)
        {
            if(canCombine(words[i],dict))
            {
                res.push_back(words[i]);
            }
            dict.insert(words[i]);
            //copy(dict.begin(),dict.end(),ostream_iterator<string>(cout," "));cout<<endl;
        }
        return res;
    }
    bool canCombine(string& word,unordered_set<string>& dict)
    {
        //set<string,cmp>::iterator it=dict.find(word);
        //auto it=dict.find(word);
        //int nelem=distance(dict.begin(),it);
        //if(nelem==0) return 0;
        if(dict.empty()) return 0;
        vector<bool> dp(word.length()+1);//dp[i]: [0...i-1] substr can be combined
        dp[0]=1;//always can form by an empty string
        for(int i=1;i<=word.length();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(!dp[j]) continue;//previous one is not a word
                string t=word.substr(j,i-j);//note substr 2nd is the length
                //cout<<j<<","<<i<<":"<<t<<" "<<dict.count(t)<<endl;
                if(dict.count(t)) {dp[i]=1;break;} //cannot search the whole set!
            }
        }
        return dp[word.length()];
        
    }
};
```

145	Binary Tree Postorder Traversal    		48.7%	Hard	
iterative. postorder: left right root sequence
using stack, we first push the root, and the right and the do the left
another approach: do it in reverse way, reverse(root, right, left)
always push left, and then right, output root
```cpp
    vector<int> postorderTraversal(TreeNode* root) {
        //left, right, node. use a stack to store 
        //stack： first node, then right, then left, pop in reverse
        stack<TreeNode*> sl;
        vector<int> s;
        if(!root) return s;
        //starting from root, push all right nodes into stack, until dead end, and then pop a left node
        //save all left nodes in another stack
        TreeNode* p=root;
        while(1)
        {
            while(p) 
            {
                s.push_back(p->val);
                if(p->left) sl.push(p->left);
                p=p->right;
            }
            if(sl.size()) //try the left, note when the node is the leaf
            {
                p=sl.top();sl.pop();
                //s.push_back(p->val);//this will push twice
            }
            else break;
        }
        reverse(s.begin(),s.end());
        return s;
        
    }
```
this is the most smartest way in this problem.
	
149	Max Points on a Line    		15.8%	Hard	
point on a line: defined by k and d. k can be defined as dy/dx
dy,dx,d dy dx shall remove the gcd
and also need keep the sign to dx

154	Find Minimum in Rotated Sorted Array II    		39.4%	Hard	
contain duplicates using binary search
```cpp
	int findMin(vector<int>& nums) {
		int l=0,r=nums.size()-1;
		while(l<r)
		{
			int m=l+(r-l)/2;
			if(nums[m]<nums[r]) r=m;
			else if(nums[m]>nums[r]) l=m+1;
			else r--;//nums[m]==nums[r], this same thing cannot be the solution
		}
		return nums[l];
	}
```
158	Read N Characters Given Read4 II - Call multiple times    		26.5%	Hard	
159	Longest Substring with At Most Two Distinct Characters    		47.1%	Hard	
164	Maximum Gap    		32.6%	Hard	
unsorted array, given the max gap in its sorted form (neighboring)
O(N) complexity
arrange the elements into n-1 bins
each bin only save the min and max
and then loop over the bins (bucket sort)
this is often seen in matlab.
```cpp
    int maximumGap(vector<int>& nums) {
        //using bucket sort to put all these numbers into slots
        //the longest 0 
        int n=nums.size();
        if(n<2) return 0;
        int min0=*min_element(nums.begin(),nums.end());
        int max0=*max_element(nums.begin(),nums.end());
        double dx=double(max0-min0)/(n-1); //to cover all use ceil, have to use double!
        if(dx<1e-7) return 0;
        //cout<<dx<<endl;
        //in each bucket we only need to know the min/max
        pair<int,int> init=make_pair(INT_MAX,INT_MIN);
        vector<pair<int,int>> vs(n,init);
        for(int i=0;i<nums.size();i++)
        {
            int ind=(nums[i]-min0)/dx;
            vs[ind].first=min(vs[ind].first,nums[i]);
            vs[ind].second=max(vs[ind].second,nums[i]);
        }
        //for(int i=0;i<n;i++) cout<<vs[i].first<<" "<<vs[i].second<<endl;
        int maxgap=0;
        int prev=-1;
        for(int i=0;i<n;i++)
        {
            if(vs[i].first==INT_MAX) continue;
            if(prev<0) prev=i;
            else
            {
                maxgap=max(max(maxgap,vs[i].first-vs[prev].second),max(vs[prev].second-vs[prev].first,vs[i].second-vs[i].first));
                prev=i;
            }
        }
        //another case: only one group
        return maxgap;
    }
```	

174	Dungeon Game    		27.2%	Hard	
dp reverse direction
```cpp
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        //this shall be done in reverse order from bottom-right to top-left
        int m=dungeon.size(),n=dungeon[0].size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,INT_MAX));
        //add a right, bottom cell as 1 so that we can apply +1 to the min
        dp[m][n-1]=dp[m-1][n]=1;
        for(int i=m-1;i>=0;i--)
        {
            for(int j=n-1;j>=0;j--)
            {
                int t=min(dp[i+1][j],dp[i][j+1])-dungeon[i][j];
                dp[i][j]=t<=0?1:t; //we need at least add 1 to it
            }
        }
        return dp[0][0];
        
    }
```	
212	Word Search II    		28.8%	Hard	
multiple pattern matching using trie
```cpp
struct Node
{
    Node* next[26]; //use pointer is much convenient than using array!
    bool is_leaf;
    Node(bool b=0) {fill(next,next+26,(Node*)0);is_leaf=b;}
};
class Trie {
public:
    /** Initialize your data structure here. */
    Node* root;
    Trie() {
        root=new Node();
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Node* p=root;
        for(int i=0;i<word.size();i++)        
        {
            int ind=word[i]-'a';
            if(!p->next[ind]) p->next[ind]=new Node();
            p=p->next[ind];
        }
        p->is_leaf=1;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Node* p=find(word);
        return p && p->is_leaf; //has to end with a leaf node
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Node* p=find(prefix);
        return p; //does not have to end with a leaf node
    }
    
    Node* find(string word)
    {
        Node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int ind=word[i]-'a';
            if(p->next[ind]==0) return 0;
            p=p->next[ind];
        }
        return p;
    }
    Node* get_root() {return root;}
};

class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        Trie t;
        for(int i=0;i<words.size();i++) t.insert(words[i]);
        Node* root=t.get_root();
        //use a set to store all the possible words found from the board.
        set<string> all_words;
        for(int i=0;i<board.size();i++)
        {
            for(int j=0;j<board[0].size();j++)
                findWords(board,i,j,"",all_words,root);//to save time, some paths shall be skipped if they first do not match
        }
        vector<string> ans(all_words.size());
        copy(all_words.begin(),all_words.end(),ans.begin());
        return ans;
    }
    void findWords(vector<vector<char>>& board,int x,int y,string word,set<string>& result,Node* root)
    {
        //using backtracking
        if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;
        char c=board[x][y];
        int ind=c-'a';
        if(root->next[ind])
        {
            word+=c;
            root=root->next[ind]; 
            if(root->is_leaf) result.insert(word);
            board[x][y]=' ';
            findWords(board, x+1, y, word, result, root);
            findWords(board, x-1, y,  word, result, root);
            findWords(board, x, y+1,  word, result, root);
            findWords(board, x, y-1,  word, result, root);
            board[x][y]=c;        
        }        
    }
};
```

214	Shortest Palindrome    		27.6%	Hard	
only add chars in the front.
brutal force: from right to left, we judge if it is a palindrome
```cpp
	string shortestPalindrome(string s) {
		int n=s.size();
		for(int i=n-1;i>=0;i--)
			if(ispal(s,i)) {
				string pre=s.substr(i+1);
				reverse(pre.begin(),pre.end());
				return pre+s;
			}
		return s;
	}
	bool ispal(string& s,int end)
	{
		int i=0,j=end;
		while(i<j) if(s[i++]!=s[j--]) return 0;
		return 1;
	}
```
This got TLE for a long string of a (len=40002). The time for substr and construct takes more time than expected

KMP is too sophisticated.

218	The Skyline Problem    		31.7%	Hard	
building are given as [x0,x1,h] and want to form the skyline
this is similar to intervals and output connected intervals with height
the output only needs the start point and height
approach:
- sort the intervals according to start. 
- overlap point is the max(h)
- we can use priority_queue to push pop the height
- min heap!!!
```cpp
	struct comp{
		bool operator()(vector<int>& a,vector<int>& b){
			return a[0]>b[0] || (a[0]==b[0] && a[2]>b[2]);
		}
	};
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        vector<vector<int>> ans;
		//sort(buildings.begin(),buildings.end());
		priority_queue<vector<int>,vector<vector<int>>,comp> pq(buildings.begin(),buildings.end());
		while(pq.size()){
			auto t=pq.top();
			ans.push_back({t[0],t[2]});
			while(pq.size() && pq.top()[0]==t[0]) pq.pop();
		}
		return ans;
	}
			

224	Basic Calculator    		32.8%	Hard	
only involve +-()
```cpp
    int calculate(string s) {
        //+/- has lhs and rhs, can use binary tree and post-order traversal evaluation
        //also can use stack to do this. if we meet a ( we need to get the matching ) and evaluate it first
        //recursive approach: search for () first and evaluate using stack
        stack<int> brpos;
        int ind=0,start=0;//s.find_first_of('(');
        while(ind!=string::npos) //exists ()
        {
            ind=s.find_first_of("()",start);
            if(ind!=string::npos)
            {
                char c=s[ind];
                if(c=='(') brpos.push(ind);
                if(c==')')
                {
                    int ind1=brpos.top();
                    brpos.pop();
                    string res=myeval(s.substr(ind1+1,ind-ind1-1)); //evaluate it and update the string
                    s.replace(ind1,ind-ind1+1,res); //replace the string and size will be changed
					start=ind1;
                }
				else start=ind+1;
            }
			
        }
        //eval the string directly
        string res=myeval(s); 
        return stoi(res);
    }
    
    string myeval(string s) //there is no () inside, only numbers and +/- and space
    {
        int res=0,i;
        char c;
        stringstream ss(s);
        ss>>res;
        while(!ss.eof())
        {
            c=0; //to skip space
            ss>>c;
            if(c=='+') {ss>>i;res+=i;}
            if(c=='-') {ss>>i;res-=i;}
        }
        return to_string((long long)res);
    }
```	

233	Number of Digit One    		30.2%	Hard	
math problem
number counting.
for the ith digit, makes it 1, and divide to left and right<br/>
if the ith digit >1, then (left+1)*10^i (since the right can be any digit 0 to 9)<br/>
==1: then right can be from 0 to right (right+1) and left can be 1 to left (left)*10^i.<br/>
<1, then we need borrow 1 from left, left*10^i<br/>

```cpp
    int countDigitOne(int n) {
        int ans=0;
        int left=0,right=0;
        int i=0;
        while(n)
        {
            int d=n%10;
            left=n/10;
            if(d>1) ans+=(left+1)*pow(10,i);
            else if(d==1) ans+=left*pow(10,i)+right+1;
            else ans+=left*pow(10,i);
            right+=d*pow(10,i);
            n/=10;
            i++;
        }
        return ans;
    }
```	

239	Sliding Window Maximum    		38.3%	Hard	
classical problem using deque keeping monotonic order
also works for sliding window minimum
[1,3,-1,-3,5,3,6,7]
linear time
deque: deque=1
incoming 3: remove 1, deque=3
incoming -1: 
approach:
- save index in the deque (so we have both index and value information)
- front is always the max
- max is out of window, remove the front
- incoming > back, then remove all smaller ones 
- add incoming into back.

```cpp
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        //monotonic array using deque
        vector<int> res;
        deque<int> dq;
        for(int i=0;i<nums.size();i++)
        {
            if(!dq.empty() && dq.front()==i-k) dq.pop_front();
            while(!dq.empty() && nums[dq.back()]<nums[i]) dq.pop_back(); //remove all elements less than it
            dq.push_back(i);
            if(i>=k-1) res.push_back(nums[dq.front()]);
        }
        return res;
    }
```	


248	Strobogrammatic Number III    		36.6%	Hard	
265	Paint House II    		41.6%	Hard	
269	Alien Dictionary    		31.1%	Hard	
272	Closest Binary Search Tree Value II    		45.2%	Hard	
273	Integer to English Words    		24.4%	Hard	
english: every thousand changes
```cpp
    string s1[]={"One", "Two", "Three", "Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"};
    string s2[]={"Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
class Solution {
public:
    string numberToWords(int num) {
        //1,10,100,1000,10^6,10^9
        if(!num) return string("Zero");
        int billion,million,thousand,hundred,twenty;
        billion=num/1000000000;
        num-=billion*1000000000;
        million=num/1000000;
        num-=million*1000000;
        thousand=num/1000;
        num-=thousand*1000;
        //now we need convert all numbers into <100
        string res;
        if(billion) res+=int2words(billion)+"Billion ";
        if(million) res+=int2words(million)+"Million ";
        if(thousand) res+=int2words(thousand)+"Thousand ";
        if(num) res+=int2words(num);
        //remove the last space
        res.pop_back();
        return res;
        
    }
    
    string int2words(int num) //number is <999
    {
        int hundred=num/100;
        num-=hundred*100;
        int ten=num/10;
        num-=ten*10;
        int one=num;
        string s;
        if(hundred) s+=s1[hundred-1]+" Hundred ";
        if(ten>1) 
        {
            s+=s2[ten-2]+" ";
            if(one) s+=s1[one-1]+" ";
            
        }
        else
        {
            if(ten*10+one>0) s+=s1[ten*10+one-1]+" ";
        }
        return s;
    }
};
```

282	Expression Add Operators    		32.8%	Hard	
given a string of digits, apply +-* to get the target
divide and conquer, combined with backtracking
- loop all positions and divide left and right part. left as a number, and right as a subproblem
- apply +-* between left and right
- righ subproblem
- perform evaluation current value, previous op value, previous operator

```cpp
    vector<string> addOperators(string num, int target) {
        vector<string> res;
        if (num.empty()) return res;
        for (int i=1; i<=num.size(); i++) 
        {
            string s = num.substr(0, i);
            long cur = stol(s);
            if (to_string(cur).size() != s.size()) continue;//leading zeros
            dfs(res, num, target, s, i, cur, cur, '#');         // no operator defined.
        }

        return res;
    }

    // cur: {string} expression generated so far.
    // pos: {int}    current visiting position of num.
    // cv:  {long}   cumulative value so far.
    // pv:  {long}   previous operand value.
    // op:  {char}   previous operator used.
    void dfs(std::vector<string>& res, const string& num, int target, 
	string cur, int pos, long cv, long pv, char op) {
        if (pos == num.size() && cv == target) {res.push_back(cur);} 
        else 
        {
            for (int i=pos+1; i<=num.size(); i++) 
            {
                string t = num.substr(pos, i-pos);
                long now = stol(t);
                if (to_string(now).size() != t.size()) continue;
                dfs(res, num, target, cur+'+'+t, i, cv+now, now, '+');
                dfs(res, num, target, cur+'-'+t, i, cv-now, now, '-');
                dfs(res, num, target, cur+'*'+t, i, (op=='-')?cv+pv-pv*now:((op=='+')?cv-pv+pv*now : pv*now), pv*now, op);
            }
        }
    }    
```	


291	Word Pattern II    		41.0%	Hard	
295	Find Median from Data Stream    		36.8%	Hard
left: a max heap
right: a min heap
median: odd:, even: the two heap's average
when a a new data coming, check even /odd
either put left side, or right side.

```cpp
    priority_queue<int,vector<int>,less<int>> left;
    priority_queue<int,vector<int>,greater<int>> right;
    double med;
    int total;
    MedianFinder() {
        total=0;
    }
    
    void addNum(int num) {
        total++;
        if(total==1) {med=num;return;}
        
        if(total%2)//total is odd, one element is in and one element is out
        {
            if(num<left.top()) {left.push(num);med=left.top();left.pop();}
            else if(num>right.top()) {right.push(num);med=right.top();right.pop();}
            else med=num;//lmax<=num<=lmin
        }
        else //total is even, the new num and med shall be inside left or right
        {
            if(num<med) {left.push(num);right.push(med);}
            else {left.push(med);right.push(num);}
            med=(left.top()+right.top())/2.0;
        }
    }
    
    double findMedian() {
        return med;
    }
	```
296	Best Meeting Point    		54.9%	Hard	
297	Serialize and Deserialize Binary Tree    		41.1%	Hard	
using stringstream
```cpp
    string serialize(TreeNode* root) {
        ostringstream os;
        serialize(root,os);
        return os.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return deserialize(is);
    }
    
    void serialize(TreeNode* root, ostringstream& os)
    {
        if(root)
        {
            os<<root->val<<" ";
            serialize(root->left,os);
            serialize(root->right,os);
        }
        else os<<"# ";
    }
    TreeNode* deserialize(istringstream& is)
    {
        string s;
        is>>s;
        if(s=="#") return 0;
        TreeNode* p=new TreeNode(stoi(s));
        p->left=deserialize(is);
        p->right=deserialize(is);
        return p;
    }
```	
301	Remove Invalid Parentheses    		39.4%	Hard	
302	Smallest Rectangle Enclosing Black Pixels    		49.3%	Hard	
305	Number of Islands II    		41.8%	Hard	
308	Range Sum Query 2D - Mutable    		32.1%	Hard	
312	Burst Balloons    		47.4%	Hard	
315	Count of Smaller Numbers After Self    		38.2%	Hard	
316	Remove Duplicate Letters    		32.6%	Hard	
317	Shortest Distance from All Buildings    		37.9%	Hard	
321	Create Maximum Number    		25.4%	Hard	
327	Count of Range Sum    		32.8%	Hard	
329	Longest Increasing Path in a Matrix    		40.1%	Hard	
330	Patching Array    		33.4%	Hard	
335	Self Crossing    		27.0%	Hard	
336	Palindrome Pairs    		31.0%	Hard	
340	Longest Substring with At Most K Distinct Characters    		39.8%	Hard	
352	Data Stream as Disjoint Intervals    		43.6%	Hard	
354	Russian Doll Envelopes    		34.0%	Hard	
358	Rearrange String k Distance Apart    		32.9%	Hard	
363	Max Sum of Rectangle No Larger Than K    		35.2%	Hard	
381	Insert Delete GetRandom O(1) - Duplicates allowed    		32.0%	Hard	
391	Perfect Rectangle    		28.2%	Hard	
403	Frog Jump    		36.2%	Hard	
407	Trapping Rain Water II    		39.3%	Hard	
410	Split Array Largest Sum    		42.4%	Hard	
411	Minimum Unique Word Abbreviation    		35.0%	Hard	
420	Strong Password Checker    		17.3%	Hard	
425	Word Squares    		44.4%	Hard	
428	Serialize and Deserialize N-ary Tree    		53.9%	Hard	
431	Encode N-ary Tree to Binary Tree    		63.6%	Hard	
432	All O`one Data Structure    		29.6%	Hard	
440	K-th Smallest in Lexicographical Order    		26.6%	Hard	
446	Arithmetic Slices II - Subsequence    		30.2%	Hard	
458	Poor Pigs    		45.4%	Hard	
460	LFU Cache    		28.9%	Hard	
465	Optimal Account Balancing    		42.9%	Hard	
466	Count The Repetitions    		27.4%	Hard	
471	Encode String with Shortest Length    		45.2%	Hard	
472	Concatenated Words    		34.8%	Hard	
479	Largest Palindrome Product    		27.4%	Hard	
480	Sliding Window Median    		32.6%	Hard	
483	Smallest Good Base    		34.2%	Hard	
488	Zuma Game    		39.0%	Hard	
489	Robot Room Cleaner    		64.4%	Hard	
493	Reverse Pairs    		23.2%	Hard	
499	The Maze III    		37.2%	Hard	
502	IPO    		37.7%	Hard	
514	Freedom Trail    		40.6%	Hard	
517	Super Washing Machines    		37.0%	Hard	
527	Word Abbreviation    		50.0%	Hard	
546	Remove Boxes    		38.3%	Hard	
552	Student Attendance Record II    		33.2%	Hard	
564	Find the Closest Palindrome    		18.8%	Hard	
568	Maximum Vacation Days    		38.1%	Hard	
587	Erect the Fence    		34.3%	Hard	
588	Design In-Memory File System    		39.7%	Hard	
591	Tag Validator    		32.8%	Hard	
600	Non-negative Integers without Consecutive Ones    		32.8%	Hard	
629	K Inverse Pairs Array    		29.3%	Hard	
630	Course Schedule III    		31.7%	Hard	
631	Design Excel Sum Formula    		29.3%	Hard	
632	Smallest Range    		47.5%	Hard	
639	Decode Ways II    		25.2%	Hard	
642	Design Search Autocomplete System    		38.0%	Hard	
644	Maximum Average Subarray II    		28.6%	Hard	
656	Coin Path    		26.9%	Hard	
660	Remove 9    		51.5%	Hard	
664	Strange Printer    		36.7%	Hard	
668	Kth Smallest Number in Multiplication Table    		42.0%	Hard	
675	Cut Off Trees for Golf Event    		30.8%	Hard	
679	24 Game    		42.9%	Hard	
683	K Empty Slots    		34.1%	Hard	
685	Redundant Connection II    		30.8%	Hard	
689	Maximum Sum of 3 Non-Overlapping Subarrays    		44.2%	Hard	
691	Stickers to Spell Word    		38.3%	Hard	
699	Falling Squares    		40.1%	Hard	
710	Random Pick with Blacklist    		31.3%	Hard	
711	Number of Distinct Islands II    		46.2%	Hard	
715	Range Module    		35.6%	Hard	
719	Find K-th Smallest Pair Distance    		29.2%	Hard	
726	Number of Atoms    		44.7%	Hard	
727	Minimum Window Subsequence    		37.3%	Hard	
730	Count Different Palindromic Subsequences    		39.0%	Hard	
732	My Calendar III    		55.0%	Hard	
736	Parse Lisp Expression    		44.4%	Hard	
741	Cherry Pickup    		29.9%	Hard	
745	Prefix and Suffix Search    		30.7%	Hard	
749	Contain Virus    		41.3%	Hard	
753	Cracking the Safe    		46.4%	Hard	
757	Set Intersection Size At Least Two    		37.0%	Hard	
759	Employee Free Time    		61.3%	Hard	
761	Special Binary String    		51.5%	Hard	
765	Couples Holding Hands    		51.6%	Hard	
768	Max Chunks To Make Sorted II    		46.0%	Hard	
770	Basic Calculator IV    		45.6%	Hard	
772	Basic Calculator III    		44.2%	Hard	
773	Sliding Puzzle    		52.6%	Hard	
774	Minimize Max Distance to Gas Station    		41.8%	Hard	
778	Swim in Rising Water    		47.8%	Hard	
780	Reaching Points    		27.5%	Hard	
782	Transform to Chessboard    		39.8%	Hard	
786	K-th Smallest Prime Fraction    		39.8%	Hard	
793	Preimage Size of Factorial Zeroes Function    		39.0%	Hard	
798	Smallest Rotation with Highest Score    		40.3%	Hard	
803	Bricks Falling When Hit    		28.7%	Hard	
805	Split Array With Same Average    		24.4%	Hard	
810	Chalkboard XOR Game    		45.0%	Hard	
815	Bus Routes    		40.1%	Hard	
818	Race Car    		35.0%	Hard	
827	Making A Large Island    		43.3%	Hard	
828	Unique Letter String    		39.6%	Hard	
829	Consecutive Numbers Sum    		33.4%	Hard	
834	Sum of Distances in Tree    		39.6%	Hard	
839	Similar String Groups    		34.5%	Hard	
843	Guess the Word    		43.6%	Hard	
847	Shortest Path Visiting All Nodes    		46.8%	Hard	
850	Rectangle Area II    		45.0%	Hard	
854	K-Similar Strings    		33.5%	Hard	
857	Minimum Cost to Hire K Workers    		47.4%	Hard	
862	Shortest Subarray with Sum at Least K    		22.2%	Hard	
864	Shortest Path to Get All Keys    		36.1%	Hard	
871	Minimum Number of Refueling Stops    		28.9%	Hard	
878	Nth Magical Number    		25.5%	Hard	
879	Profitable Schemes    		36.7%	Hard	
882	Reachable Nodes In Subdivided Graph    		38.1%	Hard	
887	Super Egg Drop    		24.9%	Hard	
891	Sum of Subsequence Widths    		28.9%	Hard	
895	Maximum Frequency Stack    		56.1%	Hard	
899	Orderly Queue    		47.3%	Hard	
902	Numbers At Most N Given Digit Set    		28.6%	Hard	
903	Valid Permutations for DI Sequence    		44.2%	Hard	
906	Super Palindromes    		30.4%	Hard	
913	Cat and Mouse    		28.9%	Hard	
920	Number of Music Playlists    		43.9%	Hard	
924	Minimize Malware Spread    		39.9%	Hard	
927	Three Equal Parts    		30.4%	Hard	
928	Minimize Malware Spread II    		39.3%	Hard	
936	Stamping The Sequence    		36.0%	Hard	
940	Distinct Subsequences II    		39.7%	Hard	
943	Find the Shortest Superstring    		38.1%	Hard	
952	Largest Component Size by Common Factor    		26.3%	Hard	
956	Tallest Billboard    		38.0%	Hard	
960	Delete Columns to Make Sorted III    		52.8%	Hard	
964	Least Operators to Express Number    		40.5%	Hard	
968	Binary Tree Cameras    		35.2%	Hard	
972	Equal Rational Numbers    		40.2%	Hard
975	Odd Even Jump    		47.8%	Hard	
980	Unique Paths III    		71.0%	Hard	
982	Triples with Bitwise AND Equal To Zero    		53.9%	Hard	
992	Subarrays with K Different Integers    		44.6%	Hard	
995	Minimum Number of K Consecutive Bit Flips    		48.6%	Hard	
996	Number of Squareful Arrays    		47.7%	Hard	
1000 Minimum Cost to Merge Stones    		31.5%	Hard	
1001 Grid Illumination    		34.4%	Hard	
1012 Numbers With Repeated Digits    		34.4%	Hard	
1028 Recover a Tree From Preorder Traversal    		70.7%	Hard	
1032 Stream of Characters    		41.0%	Hard	
1036 Escape a Large Maze    		36.8%	Hard	
1044 Longest Duplicate Substring    		22.9%	Hard	
1063 Number of Valid Subarrays    		75.7%	Hard	
1067 Digit Count in Range    		32.2%	Hard	
1074 Number of Submatrices That Sum to Target    		59.4%	Hard		
