
shangping guo <shangpingguo@gmail.com>
6:31 PM (1 hour ago)
to me

leetcode

## expression evaluation

1106. parsing a bool expression

1096 brace expansion II

224. basic calculator
+-()and space
simpler than 772

227. basic calculator II
+-*/and space
using stack, without recursive.

772. basic calculator III
with +-*/ and ()
use long for intermediate results.
remove all blank chars in the string.

770. basic calculator IV
with variables. some variables are not assigned. return an expression
+-*(), separate by spaces.
variables: contains no digits inside.
- first replace all strings which has values into values
- stack store the results in string.
this is really complicated



## complete full tree
1104. path in zigzag labelled binary tree
parent child relation i->2*i and 2*i+1
child parent i/2

## convert to binary search problem
1102. path with max min value
dfs will TLE
bfs will need a lot of considerations

remove those small values and until there is only one path to connect
binary search: 
- need to check if two elements work or not (not proper will fall infinite loop)
- need keep the range condition satisified all the time.
- use bfs or union-find the check connectivity

the problem is for l to r: the condition is T...TF...F
and we need find the last T position
if we get T: we move left to mid
else we move r to mid. (cannot -1 since it will invalidate the TF condition)
this will cause two element infinite loop problem: use l+1<r.

778. Swim in rising water
this is exactly the same problem as 1102
searching a only path problem in a matrix.

1101 The earliest moment when everyone become friends.
this is also very similar to above, which can be solved using binary search and union-find
but binary search is not quite necessary.

1011 capacity to ship packages within D days
equivalent: FFFTTTTFFF case, to find the first T.


## more then one binary search
1095. find in mountain array
three binary search

## need some conversions to do binary search
1064. Fixed Point
i=A[i] A[i]-i is also sorted.

1060. Missing Element in Sorted Array
find kth missing number.
why can binary search be used? 
for example [4,7,9,10] the difference [0,3,5,6] the A[i]-A[0]-i indicates number of missing number


## counting and search using binary search
1093. statistics from large sample
a sample has counting, prefix on the counters and binary search to find the number index.
median.


## sliding window to find a substr satisfying some conditions
1100. Find K-Length Substrings With No Repeated Characters
fixed sliding window using hashmap: hashmap size==K.

1052. grumpy bookstore owner
equivalent to find the window with max number of customer

1040. Moving Stones Until Consecutive II
equivalent to find the window containing min number of empty slots or max number of empty slots
1033. moving stones until consective
only 3 stones.
Edge case 1: all three stones are next to each other (z - x == 2). Return {0, 0}.
Edge case 2: two stones are next to each other, or there is only one space in between. Minimum moves is 1.

Otherwise; minimum moves are 2, maximum - z - x - 2.

So the position of the middle stone (y) only matters for the minimum moves.

487. max consecutive ones II
only one zero is allowed.

1004 max consecutive ones III
change up to K 0 to 1 to have the longest ones.
equivalent: longest window which has <=k zeros
record the 0's position and jump to next 0's position.




## K sum
1099. Two Sum Less Than K
put the visited in set, and check current with previous so i>j is automatically satisfied.

923. 3sum with multiplicity
asks for number of tuples sum to target.
- counting and put in a map
- use three pointer, pick two numbers from map, and check target-i-j exist
- i=j=k, numbers in the same group. C(n,3)
- i=j!=k, two number in same group C(n,2)*C(m,1)
-i!=j!=k, m*n.




## interval overlapping problem
1094. car pooling
note when leaving and joining at the same time, leaving first (common sense)
use +1 for joining, and -1 for leaving, sort according to time.

video stitching

986. interval list intersection
max(start0,start1), min(end0,end1)
use two pointers.
- when A end < B start, keeps increasing i
- when B end <A start, keeps increasing j.
- when intersect, find the intersection
- if A end is left, increase i.
- if B end is left, increase j.





## dp
## longest common substr/subsequence.
it may have equivalent shortest superstring problems
1092. Shortest Common Supersequence
equivalent: find the longest common substr and then assemble the shortest superstring
- find the length of the common subsequence, and then do traceback, which is not straightforward
- find the largest common subsequence. s[i]==s[j] we add the char into the string, dp shall be the string instead of length.
- assemble: use lcs only once.
- directly store the longest superseq in dp will cause memory over limit.

1062. Longest Repeating Substring
using 2d dp check all s[i] vs s[j] to see equal
if not easy do it in 1d, using 2d.
this problem does not involve overlap.

1044. longest duplicate substring
this involves overlap.
using a sliding window with binary search (window length) and search for duplicates.
do not have to use dp
sliding window substring match can use direct hash for comparison.

1049 longest string chain
with some predecessor check and connect to make it longest.

1035. uncrossed lines
equivalent to the longest common subsequence problem

1027 longest arithmetic sequence

960. Delete Columns to Make Sorted III
delete column to make row sorted.
this is to find the longest commin increasing sequence for all rows. (equvalent)
the condition changes to involving two column compare

955. Delete Columns to Make Sorted II
row[0]<=row[1]<=row[2]....
just check prefix if not sorted, delete current column and replace with *.

944. Delete Columns to Make Sorted I
all columns are sorted.

1043. Partition Array for Maximum Sum
window<=K.
pq to maintain a K window.
for ith position, we need to compare: use the curmax for i, i-1, i-2....

1039. minimum score triangulation of polygon

1000. Minimum Cost to Merge Stones
hard

983. min cost for tickets
typical dp problem

dp[i] is the min cost for the 0...ith day ticket cost.
use 1 day price, 7 day price and 30 day price three options,

975 odd even jump
- odd jump is jump higher, even jump is jump lower.
- the initial condition is the last element so it is natural to do it from right to left.
- jmp higher is true is the solution
- visited form a sorted map for binary search.

964. Least Operators to Express Number
+-*/ using only x.
this is equivalent to a x-base representation. x^0 use x/x.
the key is: we can always use + to represent x-base number.
kx^n need to be expressed x*x*x...*x for k times.
it can also be expressed as x^(n+1)-k'x^n

940. Distinct Subsequences II
ending with different char is the key.
abc
a.
b, ab.
c, bc, ac, abc
basically it appends the current char to all other ending and add into current ending char.

931. min falling path
simple dp

920 number of music playlist
N songs, list length L. L>=N.
each song needs to be played at least once.
a song can be played again only if K other songs have been played.
return number of possible playlist.
dp[i][j] denotes the solution of i songs with j different songs. So the final answer should be dp[L][N]
if the new add song is new, we have choices N-(j-1)
if the new add song is odd, then we cannot choose previous K songs. we have N-K choices
boundary: diagonal: i songs and list length=i. we have i! choices





## union-find
1061. Lexicographically Smallest Equivalent String
get the relation using union-find and then replace each char using the smallest char in each group.
only trick: use the integer associate with the letter.

990. satisfiability of equality equations
use union find the put all the equal in one group

952. Largest Component Size by Common Factor
- prime factorize the numbers
- if shares a common factor, then union.

947. most stones removed with same row or column'
use dfs or union find are both ok

924. Minimize Malware Spread
initial: nodes are infected
graph: the network connection graph
remove one node from initial to minimize the malware spreading.
intuition: group the network if they are connected. 
- if more than one initial in one group, we cannot save that group.
- so choose the group with only one intial inside and the group is the largest.

928. Minimize Malware Spread II
remove the node and remove all its connections.
this will change the groups.

this will need to reverse thinking:
- build the groups without those nodes in initial list
- add the initial nodes one by one and see which one infected the most.
convert to a equivalent problem makes it much easier.



## bfs

shortest path problem
1091. Shortest Path in Binary Matrix
1 blocked, 0 empty, 8 directions

913 cat and mouse
node 0 is a hole.
cat occupies the same node as mouse, cat win.
if mouse enter the hole, mouse win.
repeated, draw.
start: mouse at node 1, cat at node 2.

909. snakes and ladders
- a position, we need to push all its next position into queue: this including 6 steps, snakes ladders.
- convert to 1d is equivalent but easier. (we don't need to worry the index calculations)
- this is a very good bfs example.









## dfs
finding all paths

1059. All Paths from Source Lead to Destination
with cycle detection

1036 escape a large maze
the dfs longest distance to the source point greater than the obstacle size, then we are out of the blocks.
number of obstacles cannot only maintain a block line that large.

1034. coloring a border
use a negative value to indicate colored.
after done, restore inner cells

1020 number of enclaves
upsample and using dfs

996 number of squareful arrays
- first try all combinations so that they add to a square, build a map. 
- the use dfs to get all paths

980. unique path III
with obstacles. from src to dst,
path needs to use all empty cells exactly once.
use the number of steps = the empty cells
regular dfs: visiting then mark it as obstacle, visited restore back to empty cell.

63. unique path II
with obstacles.
2d climbing stair problems using simple dp.

959 regions cut by slash
upsample and then simple dfs

935 knight dialer

934 shortest bridge
use dfs to get two islands and find the shortest distance

933 number of recent calls
remove old calls
add new calls
deque


## stack: using stack to pop previous 
1081. Smallest Subsequence of Distinct Characters
pop bigger one

316 remove duplicate letters

1063. Number of Valid Subarrays
leftmost element shall be the minimum.
count number of subarray.
brutal force: using current number as min and grows right. and add all the numbers
stack: it actually equivalent to find next larger.

1019 next greater node in linked list

921 min add to make parentheses valid
using stack to remove all valid pairs
note since stack only stores (, so unmatched ) shall be recorded.


## tree
1080. Insufficient Nodes in Root to Leaf Paths
O(N^2) check each node to see if its subtree sum
O(N): dfs to check if the leaf node<limit and remove it. if its left and right is removed then the root is removed.

1038. BST to greater sum tree
the problem is actually the suffix sum. so the idea is clear. using reversed in order traversal: right, root, left.

1028. Recover a Tree From Preorder Traversal
preorder traversal is a string.
this is to test the preorder and using stack to recover the tree.

1008. construct BST from preorder traversal
for example [8,5,1,7,10,12].
- 8 is the root, [5,1,7] is the left and [10,12] is the right, and build recursively


1026 max difference between node and ancestor
equivalent: find the along path max-min max values. think it in 1d array and which will be much easier

1022. sum of root to leaf binary number
dfs or preorder

998. Max binary tree II
max binary tree is not heap. heap recursively satisfies root is the max.
- val>root: replace root, and the tree becomes the left
- insert into the right subtree.
pretty straightfoward.
654, max binary tree
build the binary tree from the array.
partition and recursively build the tree.

993. cousins in binary tree
same depth, but different parents.

988. smallest string starting from leaf
dfs using preorder and then reverse the string

987. vertical order traversal of binary tree.
use any traversal and collect the information of x and y coordinate and then sort.
note some nodes will share a same coordinate.

979. distribute coins in binary tree.
coins can go up to parents, go down to children. return the number of moves.
similar to super washing machine, whatever the current amount, if we have more than 1 coins, we need pass n-1 out.
we process left and right first using post order traversal
coins=left+right+root->val-1;
steps+=abs(coins)
there are basically two recursive problem
- calculate the in/out coins to a subtree.
- the steps to move coins.

971 flip binary tree to match preorder traversal
return the list of nodes which is flipped.
preorder traversal:
if match, continue
if does not match, try right first, and then left.
if root does not match, then it is not legal. 

968. binary tree camera
combined with greedy
a camera can monitor child and itself and parents. so always try to put in upper level
if it is illuminated, mark it.
top down is apparently not good. we need to go bottom up
then we get left and right.
left: camera, right: camera, then root is monitored
left: camera, right, monitored. then root is monitored
left: monitored, right: monitored, then we need to go up to place a camera
left or right not minitored, we have to place a camera in the root
0: it is a leaf
1: it is a parent of a leaf, with a camera on it.
2: monitored without a camera.

965 univalued binary tree
traversal all equal to root value

958. check completeness of a binary tree
- bfs to check if there is a null node
- recursive: using height 
preorder traversal: when we get the height, (leftmost) we save the height, 
when we see first the height-1, we mark it the end.
make sure we see no more height after the end is marked. (all must be h-1)
this easily miss cases.

951 flip equivalent binary tree
left-left && right-right
left-right && right-left
same tree.

919. Complete Binary Tree Inserter
store the node into an array (level)
then insert a new node is equivalent to add a new element in the end.
- creating the array does not need lengthy bfs, but to use vector to simulate the bfs (tricky)
- parent child relation is simple and often used.







## combination and permutation
1079. Letter Tile Possibilities
- use dfs for combinations, and from combination to get number of permutations, too complicated
- use dfs backtracking. just pick one by one of each char until there is none left.

967. numbers with same consecutive differences
difference of neighboring digits is +/-K
backtracking
k=0 case.

918. max sum cirular subarray
use maxsum and minsum at the same time.

## all kinds of combinations and counting problems
1088 confusing number II
looks upside down, still a number but different.
a confusing number can only be 01689
brutal forice: dfs or backtracking. could take a long time

247. Strobogrammatic Number II
find all numbers with n digits
we can append 0/0 1/1, 6/9 9/6 8/8 to previous solution to get larger solution. 

248. Strobogrammatic Number III
find all numbers in range [L,R]. we only need the number of combinations.
look upside down, still a number but the same.
still use above idea: add 0/0,1/1,8/8,6/9,9/6 to grow.
when length <lower || length>upper discard 
when length=lower || length==upper lexi compare
between are all valid solutions
two 247 problems: m bit and n bits and counting.

get m digit numbers, minus those smaller than lower.
get m+1 to n-1 digits
get n digit numbers, minus those larger than upper.

since we do not need the combinations, we only need to keep the current string and that is fine.

233. Number Of Digit One
use one digit by one digit to do

1067. Digit Count in Range
for n-digit numbers, a digit can appear n+n-1+n-2+1, but 0 cannot appear in the first.
this is similar to 248. we need limit the range.
for example 123 find digit 1:
1,11,21,31,41,....91,101,111, 121 last digit is 1: 1
use simple counting using digit logn
count(upper)-count(lower-1)

1012. Numbers With Repeated Digits
find the number of integers<=N with at least 1 repeated digits
equivalent: N-number of no repeat digits.
for example N=1000
thousand: no choice
hundred: 9x9x8
ten: 9x9
one: 9
1000-9x9x8-9x9-9=262
for example: 364
one: x: 9
ten: xx: 9*9
1xx-2xx: 2*9*8
30x-35x: 5*8 (each have 8 options, 33x are not allowed.)
360-364: 4
total 364-278=86

For example,
if N = 8765, L = [8,7,6,6],
the number without repeated digit can the the following format:
XXX
XX
X
1XXX ~ 7XXX
80XX ~ 86XX
870X ~ 875X
8760 ~ 8765

992. Subarrays with K Different Integers
counting the number of subarrays.
using two pointers or sliding window 
[1,2,1,2,3] K=2
use three pointers, i, j, k, i to k is the largest window to contain K integers, j to k is the smallest window containing K integers
i=0,j=0,k=1, ending with 2: [1,2],1
i=0,j=1,k=2, ending with 1: [2,1],[1,2,1]: 2
i=0,j=2,k=3, ending with 2: [1,2],[2,1,2],[1,2,1,2]: 3
i=3,j=3,k=4: ending with 3: [2,3]
so the counting is (j-i+1)
use a hash map to update the counting.

982. triples with bitwise and equal to zero.
triples allows any ijk combinations.
O(N^2): first get all two combinations and then combine with n.
brutal force counting.
- always see if we have brutal force approach first
- then we think of optimization way.

978. longest turbulent subarray
sign flips
 just counting the flip changes.
 
974. subarray sums divisible by K.
- included negative, using %K carefully
- convert to prefixsum%K.
- using hashmap or sorting to count the same remainder.
1+2+3+... similar problem.
so if have 3 same remainder, we have 6 subarrays.

930. binary subarray with sum
count the number of subarray =K.
this is similar to 974. we can use the tight window for K 1s and expand left and right 0s.
thus we can only record the 1s position and do sliding window on that to avold complexity.

907. sum of subarry minimums.
every subarray
each number can be a min of some subarrays
[3,1,2,4]
3 as the min: [3]
1 as the min: [1],[3,1],[1,2],[3,1,2],[1,2,4],[3,1,2,4]
2 as the min: [2],[2,4]
4 as the min: [4]
(front+1)*(behined+1)*nums[i]
these are two stack problems to find previous larger and next larger.
- brutal force: check range for each element O(N^2)
- stack can reduce to O(N).

## greedy: convert to equivalent problem
1072. Flip Columns For Maximum Number of Equal Rows
this is equivalent to count max number of same or xor rows. (flip or not flip max)

1071. Greatest Common Divisor of Strings
using similar idea of gcd for numbers. gcd(a,b)->gcd(a-b,b).....

1058. Minimize Rounding Error to Meet Target
all ceil->max sum
all floor->min sum
the target shall be in between. N=m+n, 

1053. Previous Permutation With One Swap
getting next smaller number:
from right to left find the first A[i]>A[i+1] and swap with its right (leftmost) max.
for example 152234, need 142235.
Note: this is not reverse of next_permutation.

1042 Flower planting with no adjacent
each garden has <=3 paths connected. 
greedy choose one color and color different to connected.
build a graph
loop over each node: record all the color used for the neighboring cells and choose available color for ccurrent node.

1041. Robot Bounded In Circle
- infinite loop: actually 4 rounds are sufficient. 
one direction: 4 will make one loop
two directions: 4 will make two loops
three directions: 4 will make 3 loops
four directions: 4 will make 4 loops

1029 Two city scheduling
greedy: send all to city A and pay the largest savings to B.
equivalent: sort using the difference.

1025 divisor game
odd/even and factors

1024. Video Stitching
min number of video to color the whole length
- find the start time < t and the end max clip

1007. minum domino rotations for equal row
greedy: first pass count row 1 = first a, and row 2=first a, and rotation is n-max(cnta,cntb)
second pass count second row first one, and do similar

1005 max sum of array after K negations
convert as many negatives into positive and then the smaller positive into negative.

995. Min number of K consecutive bit flips
greedy to make left 0 to 1.
pretty straightfoward.

991. broken calculator
only supports *2 and -1
min number of operations from x to y.
equivalent: from y to x with only /2 and +1.
- y<x, only +1
- y>x: if y is even /2 else +1 and /2 (since * is equivalent to / only for double operations)

984 string without AAA or BBB
this is usually build from small example
A=0: out b.
B=0: out a.
A==B, out ab+sub(A-1,B-1)
A>B: out aab+sub(A-2,B-1) subproblem can only be A>B or A=B so will no problem
A<B: out bba+sub(A-1,B-2) subproblem can only be A<B or A=B, so will have no problem.
what is the difference using "aab"+sub(A-2,B-1) it needs more memory since it needs first to solve the subproblem

969 pancake sorting
bring the max to top and then to its sorted position

948 bag of tokens
greedy: lost min power to get 1 point, lose 1 point to get largest power.

945. min increment to make array unique
+1 to make it different. from smallest.

932. Beautiful Array
i<k<j there is no k: A[k]*2=A[i]+A[j]
basically A[i]+A[j] must be an odd number.
use smallest beautiful array to grow into n.
- if an array is beautiful, add something to it will not change
- multiply something will not change
- grow: A*2-1 + A*2, the left part is all odd, the right part is all even.
1
1,2
1,3,2,4
1,5,3,7,2,6,4,8...


910. Smallest Range II
add +k or -k.
- equivalent to add 0 and 2*k.
- all add 2K equivalent to original
- sort it and try to add from left to see if we can reduce the range.

908. smallest range I
you can add x in [-k,k].
when difference>2*K, then we can only reduce to max-min-2*K.
otherwise we can reduce to 0.



## two string matching
1055. Shortest Way to Form String
source abc, target abcbc, min number of subsequence of source to obtain target.
brutal force: matching the subsequence of source for multiple times.




## heap
min/max problems
1090. largest value from labels
choose N item, limit K from each label, return largest sum.
label vs a max heap
choose k from each label the k largest into a maxheap and then choose N items from the heap.

1086. High Five
top 5 score average for each student.
hashmap and heap

1057. Campus Bikes 
using heap to produce N*M distance.

1054. Distant Barcodes
identical to arrange there is no same neighborings
store in heap and assign the max 2nd max, and update heap again

973. K closest point to origin
heap, keeps the size K, pop the largest

954 array of doubled pairs
negative and positive partitioned
sort in min heap

911. online election
using a heap to record the candidates.
record the winners and time in vector
binary search.



## shortest path problem
1066. Campus Bikes II
N peopple, M bikes, manhantan distance

943. Find the Shortest Superstring
N strings and a+b b+a has different length
so build a directed graph and problem is equivalent to:
visit all nodes once and get the shortest distance: traveler's problem
- use bit to indicate visiting or not
- use other edges to reduce the distance
- keep the previous information and restore the shortest path.

## trie
1065. Index Pairs of a String
a list of search words
search all positions, typical trie

1032 stream of characters
typical trie with startWith search



## array with two directions, two pointers
1031. maximum sum of two non-overlapping subarrays
1023. Camelcase Matching
matching the uppercase and lowercase. using two pointer both from left.
1014. best sightseeing pair
similar to lmax rmax problem.

962. max with ramp
A[i]<A[j] and max of j-i.
get lmin and rmax and rmax>lmin 


926. Flip String to Monotone Increasing
left shall be all zero and right shall be all 1. 

915 partion array into disjoint intervals
into two parts: left elements all <= right
rmin and lmax.


## think in simple
sometimes easy problem if using a complicate approach, will pay a large cost.
1103. distribute candies to people
just simulate the distribution. If we treat it as a math try to get rid of the first several rounds, it is not easy to get it right.

1089. duplicate zeros
- if shift right, O(N^2)
- two pass: first pass we count number of zeros (using two pointers, we only count the number of zeros in front of i when j hit the end)
second pass: just assume it is space unlimited and do it from right to left. (only we do not write it actually when out of the scope)
this is think simple. if we do it otherway, it is more complicated and not easy to get it out

970 powerful integer
just try brutal force all possible combinations.

950. Reveal Cards In Increasing Order
input->operations->sorted
reverse simulate the process using deque.

949. largest time for given digits
just try all combinations, need to treat as a whole. don't be over smart.

946. Validate Stack Sequences
pushed always appear before popped.


## kadane algorithm
560. Subarray Sum Equals K
while calculating the prefix, searching for target-prefix, and accumulate the numbers.

1074. Number of Submatrices That Sum to Target
this is based on 1d problem
loop over all rows (i)
loop over current row to ending row (j)
adding all prefix row sum (from j)
check the prefix sum array for the target sum

## base problem
1073. adding two negabinary number
use & to get the remainder
use >> to get the divider

            ans.push_back(d&1);
            cf=-(d>>1);

poor pigs
K-based number representation
extention from binary problem

1017 conver to base -2
1009. Complement of Base 10 Integer
compliment is 2^n-1-number.


## knapsack problem
1049. Last stone weight II
equivalent: assign +, - to each of the rock and get the minimum sum >0.
pos+neg=tsum, pos-neg=minsum
so the problem is to choose some elements making its sum as large as possible <=tsum/2

956 tallest billboard
two group
each rod has three options: use in group 1, use in group 2 or discarded
to get the largest sum for group1 and group 2, group1=group2

use + for group1, - for group 2, 0 for for discarded, and this is equivalent to sum to 0
target sum is <=tsum/2 and try to get the max.
range [-tsum, tsum]


## topological sort
269 alien language

course schedule II


## misc
1015. Smallest Integer Divisible by K
integer are all 1111...
pigeon hole principle, %k the value is from 0 to K-1
so if it is divisible, K digits would be sufficient. K%2==0 K%5==0 cannot be a solution.

927 three equal parts
only with 01
direct approach: divide by 3 parts with same number of 1
- the 1 window shall be the same
- trailing zeros matters
- leading zeros does not matters


## hashmap
1001 grid illumination
although it is hard, but actually not.
diagonal: r+c=const, r-c=const we can use them as the key

## timebased key-value store
key value time
store in hash, value a map in sorted order
find the value using binary search.

972. equal rational number
expand to over double precision and they are considered equal.

966. Vowel Spellchecker
- exact match
- case match
- vowels 

963. min area rectangle II
use diagnonal length and center as the hash string.
939. Minimum Area Rectangle
use hash to sort the x and form rect with previous x.


957. prison cells after N days
store the status in hash
once a status is seen, there is a cycle, and we can get the period and then skip all those periods

953. Verifying an Alien Dictionary
convert to normal order.

## reverse thinking
936. Stamping The Sequence
abc to ababc
ababc->ab***->*****



## trivial
1085. Sum of Digits in the Minimum Number
1078. Occurrences After Bigram
previous store in vector, current to match second, found then add the followed string.
1051 Height checker
compare with sorted
1047. Remove All Adjacent Duplicates In String
stack trivial
1046. Last Stone Weight
pq: max and second max smash and put back.
1037 valid boomerang
1030. Matrix Cells in Distance Order
manhatan distance from a given cell. put into a min heap
1021. remove outermost parentheses
using counter or stack
1018. Binary Prefix Divisible By 5
1016. Binary String With Substrings Representing 1 To N
search the pattern
1013. Partition Array Into Three Parts With Equal Sum
just find the target sum and check the substr which can sum to the target.
check number of partions we get.
1003. Check If Word Is Valid After Substitutions
using dq or stack to check the 3 chars.

1002. Find Common Characters
appeared in all strings

999. available captures for rook

997. find the town judge

994. rotting oranges

989 add to array from of integer

985 sum of even numbers after queries

977. square of a sorted array
negative square may become larger, so use two pointer

976. largest perimeter triangle
triangle a+b>c why we can check in descending order?
C is current largest:

961. N repeated element in size 2N array
- sort
- hashset

942 DI string match
use two pointer to meet at the middle

941 valid mountain array
find the max and check left sorted and right descending sorted.

938. Range Sum of BST
simple traverse

937 reorder log files
simple hash

929.unique email address

925 long pressed name
two pointer and counting

922 sort array by parity

917. reveres only letters
916. word subsets
check words if containing all the letters given

914. x of a lind in a deck of cards
gcd

912. sort an array
qsort
merge sort
bubble sort



